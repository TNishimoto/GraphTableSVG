/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var GraphTableSVG;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/svg-path-parser/index.js":
/*!***********************************************!*\
  !*** ./node_modules/svg-path-parser/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// v1.0 exported just the parser function. To maintain backwards compatibility,\n// we export additional named features as properties of that function.\nvar parserFunction = (__webpack_require__(/*! ./parser.js */ \"./node_modules/svg-path-parser/parser.js\").parse);\nparserFunction.parseSVG = parserFunction;\nparserFunction.makeAbsolute = makeSVGPathCommandsAbsolute;\nmodule.exports = parserFunction;\n\nfunction makeSVGPathCommandsAbsolute(commands) {\n\tvar subpathStart, prevCmd={x:0,y:0};\n\tvar attr = {x:'x0',y:'y0',x1:'x0',y1:'y0',x2:'x0',y2:'y0'};\n\tcommands.forEach(function(cmd) {\n\t\tif (cmd.command==='moveto') subpathStart=cmd;\n\t\tcmd.x0=prevCmd.x; cmd.y0=prevCmd.y;\n\t\tfor (var a in attr) if (a in cmd) cmd[a] += cmd.relative ? cmd[attr[a]] : 0;\n\t\tif (!('x' in cmd)) cmd.x = prevCmd.x; // V\n\t\tif (!('y' in cmd)) cmd.y = prevCmd.y; // X\n\t\tcmd.relative = false;\n\t\tcmd.code = cmd.code.toUpperCase();\n\t\tif (cmd.command=='closepath') {\n\t\t\tcmd.x = subpathStart.x;\n\t\t\tcmd.y = subpathStart.y;\n\t\t}\n\t\tprevCmd = cmd;\n\t});\n\treturn commands;\n}\n\n\n//# sourceURL=webpack://GraphTableSVG/./node_modules/svg-path-parser/index.js?");

/***/ }),

/***/ "./node_modules/svg-path-parser/parser.js":
/*!************************************************!*\
  !*** ./node_modules/svg-path-parser/parser.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { svg_path: peg$parsesvg_path },\n      peg$startRuleFunction  = peg$parsesvg_path,\n\n      peg$c0 = function(data) {\n          if (!data) return [];\n          for (var cmds=[],i=0;i<data.length;i++) cmds=cmds.concat.apply(cmds,data[i]);\n          var first=cmds[0];\n          if (first && first.code=='m'){ // Per spec, first moveto is never relative\n            delete first.relative;\n            first.code = 'M';\n          }\n          return cmds;\n        },\n      peg$c1 = function(first, more) { return merge(first,more) },\n      peg$c2 = /^[Mm]/,\n      peg$c3 = peg$classExpectation([\"M\", \"m\"], false, false),\n      peg$c4 = function(c, first, more) {\n          var move = commands(c,[first]);\n          if (more) move = move.concat(commands(c=='M' ? 'L' : 'l',more[1]));\n          return move;\n        },\n      peg$c5 = /^[Zz]/,\n      peg$c6 = peg$classExpectation([\"Z\", \"z\"], false, false),\n      peg$c7 = function() { return commands('Z') },\n      peg$c8 = /^[Ll]/,\n      peg$c9 = peg$classExpectation([\"L\", \"l\"], false, false),\n      peg$c10 = function(c, args) { return commands(c,args) },\n      peg$c11 = /^[Hh]/,\n      peg$c12 = peg$classExpectation([\"H\", \"h\"], false, false),\n      peg$c13 = function(c, args) { return commands(c,args.map(function(x){ return {x:x}})) },\n      peg$c14 = /^[Vv]/,\n      peg$c15 = peg$classExpectation([\"V\", \"v\"], false, false),\n      peg$c16 = function(c, args) { return commands(c,args.map(function(y){ return {y:y}})) },\n      peg$c17 = /^[Cc]/,\n      peg$c18 = peg$classExpectation([\"C\", \"c\"], false, false),\n      peg$c19 = function(a, b, c) { return { x1:a.x, y1:a.y, x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c20 = /^[Ss]/,\n      peg$c21 = peg$classExpectation([\"S\", \"s\"], false, false),\n      peg$c22 = function(b, c) { return { x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c23 = /^[Qq]/,\n      peg$c24 = peg$classExpectation([\"Q\", \"q\"], false, false),\n      peg$c25 = function(a, b) { return { x1:a.x, y1:a.y, x:b.x, y:b.y } },\n      peg$c26 = /^[Tt]/,\n      peg$c27 = peg$classExpectation([\"T\", \"t\"], false, false),\n      peg$c28 = /^[Aa]/,\n      peg$c29 = peg$classExpectation([\"A\", \"a\"], false, false),\n      peg$c30 = function(rx, ry, xrot, large, sweep, xy) { return { rx:rx, ry:ry, xAxisRotation:xrot, largeArc:large, sweep:sweep, x:xy.x, y:xy.y } },\n      peg$c31 = function(x, y) { return { x:x, y:y } },\n      peg$c32 = function(n) { return n*1 },\n      peg$c33 = function(parts) { return parts.join('')*1 },\n      peg$c34 = /^[01]/,\n      peg$c35 = peg$classExpectation([\"0\", \"1\"], false, false),\n      peg$c36 = function(bit) { return bit=='1' },\n      peg$c37 = function() { return '' },\n      peg$c38 = \",\",\n      peg$c39 = peg$literalExpectation(\",\", false),\n      peg$c40 = function(parts) { return parts.join('') },\n      peg$c41 = \".\",\n      peg$c42 = peg$literalExpectation(\".\", false),\n      peg$c43 = /^[eE]/,\n      peg$c44 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c45 = /^[+\\-]/,\n      peg$c46 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c47 = /^[0-9]/,\n      peg$c48 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c49 = function(digits) { return digits.join('') },\n      peg$c50 = /^[ \\t\\n\\r]/,\n      peg$c51 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsesvg_path() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewsp();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsemoveTo_drawTo_commandGroups();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroups() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveTo_drawTo_commandGroup();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsemoveTo_drawTo_commandGroup();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemoveTo_drawTo_commandGroup();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroup() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveto();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsedrawto_command();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsedrawto_command();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedrawto_command() {\n    var s0;\n\n    s0 = peg$parseclosepath();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parselineto();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsehorizontal_lineto();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsevertical_lineto();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsecurveto();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsesmooth_curveto();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsequadratic_bezier_curveto();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsesmooth_quadratic_bezier_curveto();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseelliptical_arc();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveto() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    if (peg$c2.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsecomma_wsp();\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parselineto_argument_sequence();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c4(s1, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseclosepath() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c5.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c7();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parselineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c8.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parselineto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselineto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsehorizontal_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c11.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c12); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsenumber();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevertical_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c14.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c15); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c16(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c17.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c18); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecurveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecurveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecurveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecurveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecoordinate_pair();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c19(s1, s3, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c20.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsesmooth_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsesmooth_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesmooth_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c23.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c24); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsequadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsequadratic_bezier_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsequadratic_bezier_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsequadratic_bezier_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c26.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c27); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c28.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseelliptical_arc_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseelliptical_arc_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseelliptical_arc_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseelliptical_arc_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenonnegative_number();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenonnegative_number();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsenumber();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecomma_wsp();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseflag();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsecomma_wsp();\n                  if (s8 === peg$FAILED) {\n                    s8 = null;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseflag();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsecomma_wsp();\n                      if (s10 === peg$FAILED) {\n                        s10 = null;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parsecoordinate_pair();\n                        if (s11 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c30(s1, s3, s5, s7, s9, s11);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_pair() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c31(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenonnegative_number() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefloating_point_constant();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsedigit_sequence();\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsesign();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsefloating_point_constant();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedigit_sequence();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c33(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseflag() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c34.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c35); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c36(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsecomma_wsp() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewsp();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecomma();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c37();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c38;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c39); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloating_point_constant() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsefractional_constant();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseexponent();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseexponent();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsefractional_constant() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedigit_sequence();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c41;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c41;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseexponent() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c43.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsesign();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    var s0;\n\n    if (peg$c45.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c46); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit_sequence() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c47.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c49(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsewsp() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c50.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c51); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c37();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n\n    function merge(first,more){\n      if (!more) return [first];\n      for (var a=[first],i=0,l=more.length;i<l;i++) a[i+1]=more[i][1];\n      return a;\n    }\n\n    var cmds = {m:'moveto',l:'lineto',h:'horizontal lineto',v:'vertical lineto',c:'curveto',s:'smooth curveto',q:'quadratic curveto',t:'smooth quadratic curveto',a:'elliptical arc',z:'closepath'};\n    for (var code in cmds) cmds[code.toUpperCase()]=cmds[code];\n    function commands(code,args){\n      if (!args) args=[{}];\n      for (var i=args.length;i--;){\n        var cmd={code:code,command:cmds[code]};\n        if (code==code.toLowerCase()) cmd.relative=true;\n        for (var k in args[i]) cmd[k]=args[i][k];\n        args[i] = cmd;\n      }\n      return args;\n    }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n\n//# sourceURL=webpack://GraphTableSVG/./node_modules/svg-path-parser/parser.js?");

/***/ }),

/***/ "./src/common/attribute_names.ts":
/*!***************************************!*\
  !*** ./src/common/attribute_names.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.direction = exports.arrowHeadHeight = exports.arrowHeadWidth = exports.arrowNeckHeight = exports.arrowNeckWidth = exports.endVertex = exports.beginVertex = exports.columnWidth = exports.rowHeight = exports.height = exports.width = exports.h = exports.w = exports.y3 = exports.x3 = exports.y2 = exports.x2 = exports.y1 = exports.x1 = exports.cy = exports.cx = exports.y = exports.x = exports.syncYTargetPosition = exports.syncYSourcePosition = exports.syncYTarget = exports.syncXTargetPosition = exports.syncXSourcePosition = exports.syncXTarget = exports.id = exports.style = exports.className = exports.defaultCircleRadius = exports.defaultCellClass = exports.cellTemporaryBorderClass = exports.cellEmphasisBorderClass = exports.cellEmphasisCellClass = exports.customElement = exports.dataNameAttribute = exports.objectIDName = exports.GroupAttribute = exports.objectCreatedEventName = exports.vertexCreatedEventName = exports.resizeName = exports.connectPositionChangedEventName = exports.allowHoverName = exports.controlPointName = exports.isAppropriatelyReverseTextMode = exports.endNodeName = exports.beginNodeName = void 0;\nexports.speakerY = exports.speakerX = void 0;\nexports.beginNodeName = \"data-begin-node\";\nexports.endNodeName = \"data-end-node\";\nexports.isAppropriatelyReverseTextMode = \"data-appropriately-reverse-text\";\nexports.controlPointName = \"data-control-point\";\nexports.allowHoverName = \"data-allow-hover\";\nexports.connectPositionChangedEventName = \"connect_position_changed\";\nexports.resizeName = \"resized\";\nexports.vertexCreatedEventName = \"vertex_created\";\nexports.objectCreatedEventName = \"object_created\";\nexports.GroupAttribute = \"data-type\";\nexports.objectIDName = \"data-object-id\";\nexports.dataNameAttribute = \"data-name\";\nexports.customElement = \"data-custom\";\nexports.cellEmphasisCellClass = \"___cell-emphasis\";\nexports.cellEmphasisBorderClass = \"___border-emphasis\";\nexports.cellTemporaryBorderClass = \"___temporary-class\";\nexports.defaultCellClass = \"___cell-default\";\nexports.defaultCircleRadius = 15;\nexports.className = \"class\";\nexports.style = \"style\";\nexports.id = \"id\";\n//export const joint : string = \"joint\";\n//export const jointPosition : string = \"joint-position\";\nexports.syncXTarget = \"sync-x-target\";\nexports.syncXSourcePosition = \"sync-x-source-position\";\nexports.syncXTargetPosition = \"sync-x-target-position\";\nexports.syncYTarget = \"sync-y-target\";\nexports.syncYSourcePosition = \"sync-y-source-position\";\nexports.syncYTargetPosition = \"sync-y-target-position\";\n//export const beginConnectorTypeAttribute: string = \"begin-connector-type\";\n//export const endConnectorTypeAttribute: string = \"end-connector-type\";\n//export const groupClassName : string = \"group:class\";\n//export const groupStyle : string = \"group:style\";\n/*\nexport const surfaceClassName : string = \"surface:class\";\nexport const surfaceStyle : string = \"surface:style\";\n\n\nexport const backgroundClassName : string = \"background:class\";\nexport const backgroundStyle : string = \"background:style\";\n\nexport const topBorderClassName : string = \"topborder:class\";\nexport const topBorderStyle : string = \"topborder:style\";\n\nexport const leftBorderClassName : string = \"leftborder:class\";\nexport const leftBorderStyle : string = \"leftborder:style\";\n\nexport const rightBorderClassName : string = \"rightborder:class\";\nexport const rightBorderStyle : string = \"rightborder:style\";\n\nexport const bottomBorderClassName : string = \"bottomborder:class\";\nexport const bottomBorderStyle : string = \"bottomborder:style\";\n\nexport const textClass : string = \"text:class\";\nexport const textStyle : string = \"text:style\";\n*/\nexports.x = \"x\";\nexports.y = \"y\";\nexports.cx = \"cx\";\nexports.cy = \"cy\";\nexports.x1 = \"x1\";\nexports.y1 = \"y1\";\nexports.x2 = \"x2\";\nexports.y2 = \"y2\";\nexports.x3 = \"x3\";\nexports.y3 = \"y3\";\nexports.w = \"w\";\nexports.h = \"h\";\nexports.width = \"width\";\nexports.height = \"height\";\nexports.rowHeight = \"row-height\";\nexports.columnWidth = \"column-width\";\nexports.beginVertex = \"begin-vertex\";\nexports.endVertex = \"end-vertex\";\nexports.arrowNeckWidth = \"arrow-neck-width\";\nexports.arrowNeckHeight = \"arrow-neck-height\";\nexports.arrowHeadWidth = \"arrow-head-width\";\nexports.arrowHeadHeight = \"arrow-head-height\";\nexports.direction = \"direction\";\nexports.speakerX = \"speaker-x\";\nexports.speakerY = \"speaker-y\";\n//export const speakerY : string = \"speaker-y\";\n//export const elementTypeName = \"data-element-type\";\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/attribute_names.ts?");

/***/ }),

/***/ "./src/common/character.ts":
/*!*********************************!*\
  !*** ./src/common/character.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.recoverFromEscapeCharacter = void 0;\nvar characters = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    '\\'': '&#39;'\n};\nfunction recoverFromEscapeCharacter(text) {\n    text = text.replace(/&lt;/g, \"<\");\n    text = text.replace(/&gt;/g, \">\");\n    text = text.replace(/&amp;/g, \"&\");\n    text = text.replace(/&quot;/g, `\"`);\n    text = text.replace(/&#39;/g, `'`);\n    return text;\n}\nexports.recoverFromEscapeCharacter = recoverFromEscapeCharacter;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/character.ts?");

/***/ }),

/***/ "./src/common/color.ts":
/*!*****************************!*\
  !*** ./src/common/color.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRGBFromColorName = exports.createRGBCodeFromColorName = exports.createHexFromColorName = exports.createHexCodeFromColorName = void 0;\n// tslint:disable-next-line: no-namespace\n//namespace GraphTableSVG {\n/**\n * \n */\n//export namespace Color {\nconst colorNameArray = new Array(\"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\", \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\", \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\", \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\", \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\", \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\", \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\", \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\", \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\", \"gold\", \"goldenrod\", \"gray\", \"green\", \"greenyellow\", \"honeydew\", \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\", \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\", \"lightcyan\", \"lightgoldenrodyellow\", \"lightgreen\", \"lightgrey\", \"lightpink\", \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\", \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\", \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\", \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\", \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\", \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\", \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\", \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\", \"purple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\", \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\", \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\", \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\", \"whitesmoke\", \"yellow\", \"yellowgreen\");\nlet colorDic;\n// red16\nconst rValue = new Array(\"F0\", \"FA\", \"00\", \"7F\", \"F0\", \"F5\", \"FF\", \"00\", \"FF\", \"00\", \"8A\", \"A5\", \"DE\", \"5F\", \"7F\", \"D2\", \"FF\", \"64\", \"FF\", \"DC\", \"00\", \"00\", \"00\", \"B8\", \"A9\", \"00\", \"BD\", \"8B\", \"55\", \"FF\", \"99\", \"8B\", \"E9\", \"8F\", \"48\", \"2F\", \"00\", \"94\", \"FF\", \"00\", \"69\", \"1E\", \"B2\", \"FF\", \"22\", \"FF\", \"DC\", \"F8\", \"FF\", \"DA\", \"80\", \"00\", \"AD\", \"F0\", \"FF\", \"CD\", \"4B\", \"FF\", \"F0\", \"E6\", \"FF\", \"7C\", \"FF\", \"AD\", \"F0\", \"E0\", \"FA\", \"90\", \"D3\", \"FF\", \"FF\", \"20\", \"87\", \"77\", \"B0\", \"FF\", \"00\", \"32\", \"FA\", \"FF\", \"80\", \"66\", \"00\", \"BA\", \"93\", \"3C\", \"7B\", \"00\", \"48\", \"C7\", \"19\", \"F5\", \"FF\", \"FF\", \"FF\", \"00\", \"FD\", \"80\", \"6B\", \"FF\", \"FF\", \"DA\", \"EE\", \"98\", \"AF\", \"DB\", \"FF\", \"FF\", \"CD\", \"FF\", \"DD\", \"B0\", \"80\", \"FF\", \"BC\", \"41\", \"8B\", \"FA\", \"F4\", \"2E\", \"FF\", \"A0\", \"C0\", \"87\", \"6A\", \"70\", \"FF\", \"00\", \"46\", \"D2\", \"00\", \"D8\", \"FF\", \"40\", \"EE\", \"F5\", \"FF\", \"F5\", \"FF\", \"9A\");\n// green16\nconst gValue = new Array(\"F8\", \"EB\", \"FF\", \"FF\", \"FF\", \"F5\", \"E4\", \"00\", \"EB\", \"00\", \"2B\", \"2A\", \"B8\", \"9E\", \"FF\", \"69\", \"7F\", \"95\", \"F8\", \"14\", \"FF\", \"00\", \"8B\", \"86\", \"A9\", \"64\", \"B7\", \"00\", \"6B\", \"8C\", \"32\", \"00\", \"96\", \"BC\", \"3D\", \"4F\", \"CE\", \"00\", \"14\", \"BF\", \"69\", \"90\", \"22\", \"FA\", \"8B\", \"00\", \"DC\", \"F8\", \"D7\", \"A5\", \"80\", \"80\", \"FF\", \"FF\", \"69\", \"5C\", \"00\", \"FF\", \"E6\", \"E6\", \"F0\", \"FC\", \"FA\", \"D8\", \"80\", \"FF\", \"FA\", \"EE\", \"D3\", \"B6\", \"A0\", \"B2\", \"CE\", \"88\", \"C4\", \"FF\", \"FF\", \"CD\", \"F0\", \"00\", \"00\", \"CD\", \"00\", \"55\", \"70\", \"B3\", \"68\", \"FA\", \"D1\", \"15\", \"19\", \"FF\", \"E4\", \"E4\", \"DE\", \"00\", \"F5\", \"80\", \"8E\", \"A5\", \"45\", \"70\", \"E8\", \"FB\", \"EE\", \"70\", \"EF\", \"DA\", \"85\", \"C0\", \"A0\", \"E0\", \"00\", \"00\", \"8F\", \"69\", \"45\", \"80\", \"A4\", \"8B\", \"F5\", \"52\", \"C0\", \"CE\", \"5A\", \"80\", \"FA\", \"FF\", \"82\", \"B4\", \"80\", \"BF\", \"63\", \"E0\", \"82\", \"DE\", \"FF\", \"F5\", \"FF\", \"CD\");\n// blue16\nconst bValue = new Array(\"FF\", \"D7\", \"FF\", \"D4\", \"FF\", \"DC\", \"C4\", \"00\", \"CD\", \"FF\", \"E2\", \"2A\", \"87\", \"A0\", \"00\", \"1E\", \"50\", \"ED\", \"DC\", \"3C\", \"FF\", \"8B\", \"8B\", \"0B\", \"A9\", \"00\", \"6B\", \"8B\", \"2F\", \"00\", \"CC\", \"00\", \"7A\", \"8F\", \"8B\", \"4F\", \"D1\", \"D3\", \"93\", \"FF\", \"69\", \"FF\", \"22\", \"F0\", \"22\", \"FF\", \"DC\", \"FF\", \"00\", \"20\", \"80\", \"00\", \"2F\", \"F0\", \"B4\", \"5C\", \"82\", \"F0\", \"8C\", \"FA\", \"F5\", \"00\", \"CD\", \"E6\", \"80\", \"FF\", \"D2\", \"90\", \"D3\", \"C1\", \"7A\", \"AA\", \"FA\", \"99\", \"DE\", \"E0\", \"00\", \"32\", \"E6\", \"FF\", \"00\", \"AA\", \"CD\", \"D3\", \"DB\", \"71\", \"EE\", \"9A\", \"CC\", \"85\", \"70\", \"FA\", \"E1\", \"B5\", \"AD\", \"80\", \"E6\", \"00\", \"23\", \"00\", \"00\", \"D6\", \"AA\", \"98\", \"EE\", \"93\", \"D5\", \"B9\", \"3F\", \"CB\", \"DD\", \"E6\", \"80\", \"00\", \"8F\", \"E1\", \"13\", \"72\", \"60\", \"57\", \"EE\", \"2D\", \"C0\", \"EB\", \"CD\", \"90\", \"FA\", \"7F\", \"B4\", \"8C\", \"80\", \"D8\", \"47\", \"D0\", \"EE\", \"B3\", \"FF\", \"F5\", \"00\", \"32\");\n/**\n * 16\n * @param colorName\n */\nfunction createHexCodeFromColorName(colorName) {\n    if (!colorDic) {\n        colorDic = {};\n        for (let i = 0; i < colorNameArray.length; i++) {\n            colorDic[colorNameArray[i]] = i;\n        }\n    }\n    if (colorName in colorDic) {\n        const i = colorDic[colorName];\n        return rValue[i] + gValue[i] + bValue[i];\n    }\n    else {\n        return colorName;\n    }\n}\nexports.createHexCodeFromColorName = createHexCodeFromColorName;\n/**\n * 16\n * @param colorName\n */\nfunction createHexFromColorName(colorName) {\n    if (!colorDic) {\n        colorDic = {};\n        for (let i = 0; i < colorNameArray.length; i++) {\n            colorDic[colorNameArray[i]] = i;\n        }\n    }\n    if (colorName in colorDic) {\n        const i = colorDic[colorName];\n        // return r_value[i] + g_value[i] + b_value[i];\n        return { r: parseInt(rValue[i], 16), g: parseInt(gValue[i], 16), b: parseInt(bValue[i], 16) };\n    }\n    else {\n        return null;\n    }\n}\nexports.createHexFromColorName = createHexFromColorName;\n/**\n * RGB\n * @param colorName\n */\nfunction createRGBCodeFromColorName(colorName) {\n    const newColorName = createHexCodeFromColorName(colorName);\n    if (newColorName.substr(0, 3) === \"rgb\") {\n        return newColorName;\n    }\n    else {\n        if (colorName[0] == \"#\") {\n            return createRGBCodeFromColorName(colorName.substr(1));\n        }\n        else if (newColorName.length === 6) {\n            const r = newColorName.substr(0, 2);\n            const g = newColorName.substr(2, 2);\n            const b = newColorName.substr(4, 2);\n            return `rgb(${parseInt(r, 16)}, ${parseInt(g, 16)}, ${parseInt(b, 16)})`;\n        }\n        else {\n            return `rgb(${80}, ${80}, ${80})`;\n        }\n    }\n}\nexports.createRGBCodeFromColorName = createRGBCodeFromColorName;\n/**\n * RGB\n * @param str\n */\nfunction createRGBFromColorName(str) {\n    const v = createHexFromColorName(str);\n    const def = { r: 80, g: 80, b: 80 };\n    if (v != null) {\n        return v;\n    }\n    else {\n        if (str.substr(0, 3) === \"rgb\") {\n            str = str.replace(\"rgb(\", \"\");\n            str = str.replace(\")\", \"\");\n            const values = str.split(\",\");\n            if (values.length === 3) {\n                return { b: parseInt(values[2], undefined), g: parseInt(values[1], undefined),\n                    r: parseInt(values[0], undefined) };\n            }\n            else {\n                return def;\n            }\n        }\n        else if (str.length === 6) {\n            const r = str.substr(0, 2);\n            const g = str.substr(2, 2);\n            const b = str.substr(4, 2);\n            return { g: parseInt(g, undefined), b: parseInt(b, undefined), r: parseInt(r, undefined) };\n        }\n        else {\n            return def;\n        }\n    }\n}\nexports.createRGBFromColorName = createRGBFromColorName;\n//}\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/color.ts?");

/***/ }),

/***/ "./src/common/common_functions.ts":
/*!****************************************!*\
  !*** ./src/common/common_functions.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n//namespace GraphTableSVG {\n//import { Rectangle } from \"./vline\";\n//import * as CSS from \"../svghtml/css\"\n//import {GGraph} from \"../object/g_graph\"\n//import {GTable} from \"../object/g_table\"\n//import {GObject} from \"../object/z_object\"\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bezierLocation = exports.toPX = exports.parseUnit = exports.paddingLeft = exports.IsDescendantOfBody = void 0;\n//import {VBAObjectType} from \"../object/table/vba\"\n//export namespace CommonFunctions {\n/**\n * document.bodyTrue\n * @param node \n */\nfunction IsDescendantOfBody(node) {\n    const parent = node.parentNode;\n    if (parent == null) {\n        return false;\n    }\n    else if (parent == document.body) {\n        return true;\n    }\n    else {\n        return IsDescendantOfBody(parent);\n    }\n}\nexports.IsDescendantOfBody = IsDescendantOfBody;\n/**\n * \n * @param text \n * @param length text\n * @param leftChar \n */\nfunction paddingLeft(text, length, leftChar) {\n    while (text.length < length) {\n        text = leftChar + text;\n    }\n    return text;\n}\nexports.paddingLeft = paddingLeft;\n//export function setCellCSS(){\n//}\n/**\n * \n * @param text \n */\nfunction parseUnit(text) {\n    let str1 = \"\", str2 = \"\";\n    for (let i = 0; i < text.length; i++) {\n        if (isNaN(text[i]) && text[i] != \".\") {\n            str2 += text[i];\n        }\n        else {\n            str1 += text[i];\n        }\n    }\n    return [Number(str1), str2];\n}\nexports.parseUnit = parseUnit;\n/**\n * \n * @param value\n */\nfunction toPX(value) {\n    const [val, unit] = parseUnit(value);\n    if (unit == \"px\") {\n        return val;\n    }\n    else if (unit == \"em\") {\n        return val * 16;\n    }\n    else if (unit == \"pt\") {\n        return (val / 72) * 96;\n    }\n    else {\n        return val;\n    }\n}\nexports.toPX = toPX;\n/**\n * \n * @param param0 [x,y] \n * @param param1 [x,y] \n * @param param2 [x,y] \n * @param t  010.5\n * @returns \n */\nfunction bezierLocation([px1, py1], [px2, py2], [px3, py3], t) {\n    const x = px1 * (1 - t) * (1 - t) + 2 * px2 * t * (1 - t) + px3 * t * t;\n    const y = py1 * (1 - t) * (1 - t) + 2 * py2 * t * (1 - t) + py3 * t * t;\n    return [x, y];\n}\nexports.bezierLocation = bezierLocation;\n//}\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/common_functions.ts?");

/***/ }),

/***/ "./src/common/debugger.ts":
/*!********************************!*\
  !*** ./src/common/debugger.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Debugger = void 0;\nconst debugMode = \"None\";\nlet objID = null;\nlet updateObjID = null;\nlet counter = 0;\nclass Debugger {\n    static getDebugMode() {\n        return debugMode;\n    }\n    static getStopWatchFlag() {\n        return false;\n    }\n    static getStableFlagWatchFlag() {\n        return false;\n    }\n    static getNodePathFlag() {\n        return false;\n    }\n    static getObserveUpdateFlag() {\n        return false;\n    }\n    static showTime(oldTime, newTime, name, msg) {\n        const diffx = newTime.getTime() - oldTime.getTime();\n        const styles = 'color: black; background-color: lightgreen;';\n        console.log(`%c Timer: name = ${name}: UpdateTime = ${Math.abs(diffx) / 1000}s`, styles);\n    }\n    static updateUnstableFlagLog(obj, func, msg) {\n        if (this.getStableFlagWatchFlag()) {\n            const type = obj.constructor.name;\n            let id = null;\n            let name = func.name;\n            const xid = (obj.objectID);\n            if (xid != undefined) {\n                id = xid;\n            }\n            else {\n                id = null;\n            }\n            const styles = 'color: yellow; background-color: black;';\n            let s = \"\";\n            if (objID == id) {\n                for (let i = 0; i < counter; i++) {\n                    s += \"\\t\";\n                }\n                counter++;\n            }\n            else {\n                objID = id;\n                counter = 1;\n            }\n            console.log(`${s} %c (ID = ${id}) object = ${type}, function = ${name}(${msg})`, styles);\n        }\n    }\n    static updateFlagLog(obj, func, msg) {\n        if (Debugger.getObserveUpdateFlag()) {\n            const type = obj.constructor.name;\n            let id = null;\n            let name = func.name;\n            const xid = (obj.objectID);\n            if (xid != undefined) {\n                id = xid;\n            }\n            else {\n                id = null;\n            }\n            const styles = 'color: yellow; background-color: black;';\n            let s = \"\";\n            if (objID == id) {\n                for (let i = 0; i < counter; i++) {\n                    s += \"\\t\";\n                }\n                counter++;\n            }\n            else {\n                objID = id;\n                counter = 1;\n            }\n            console.log(`${s} %c (ID = ${id}) object = ${type}, function = ${name}(${msg})`, styles);\n            //console.trace(obj);\n            if (name == \"updateSVGSVGTimer\") {\n                objID = null;\n                counter = 0;\n            }\n        }\n    }\n    static updateLog(obj, func, msg) {\n        if (Debugger.getObserveUpdateFlag()) {\n            const type = obj.constructor.name;\n            let id = null;\n            let name = func.name;\n            const xid = (obj.objectID);\n            if (xid != undefined) {\n                id = xid;\n            }\n            else {\n                id = null;\n            }\n            const styles = 'color: black; background-color: aqua;';\n            let s = \"\";\n            if (updateObjID == id) {\n                for (let i = 0; i < counter; i++) {\n                    s += \"\\t\";\n                }\n                counter++;\n            }\n            else {\n                updateObjID = id;\n                counter = 1;\n            }\n            console.log(`${s} %c (ID = ${id}) object = ${type}, function = ${name}(${msg})`, styles);\n            //console.trace(obj);\n            if (name == \"updateSVGSVGTimer\") {\n                updateObjID = null;\n                counter = 0;\n            }\n        }\n    }\n}\nexports.Debugger = Debugger;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/debugger.ts?");

/***/ }),

/***/ "./src/common/default_class_names.ts":
/*!*******************************************!*\
  !*** ./src/common/default_class_names.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultConsoleColumnTitleCellBackgroundClass = exports.defaultConsoleColumnTitleCellUndefinedTextClass = exports.defaultConsoleColumnTitleCellTextClass = exports.defaultConsoleColumnTitleCellClass = exports.defaultTreeClass = exports.defaultVertexClass = exports.defaultEdgeClass = exports.defaultRectButtonClass = exports.defaultRectButtonSurfaceClass = exports.defaultCellBorderClass = exports.defaultCellBackgroungClass = exports.defaultCircleLogicTreeCircleSVGGroup = exports.defaultTextboxPathClass = exports.defaultEdgePathClass = exports.defaultPathSurfaceClass = exports.defaultSurfaceClass = exports.defaultCellClass = exports.defaultTextClass = void 0;\nexports.defaultTextClass = \"___text-default\";\nexports.defaultCellClass = \"___cell-default\";\nexports.defaultSurfaceClass = \"___surface-default\";\nexports.defaultPathSurfaceClass = \"___path-surface-default\";\nexports.defaultEdgePathClass = \"___default-edge-path\";\nexports.defaultTextboxPathClass = \"___default-textbox-path\";\nexports.defaultCircleLogicTreeCircleSVGGroup = \"___default-logic-tree-circle-svgGroup\";\nexports.defaultCellBackgroungClass = \"___cell-background-default\";\nexports.defaultCellBorderClass = \"___cell-border-default\";\nexports.defaultRectButtonSurfaceClass = \"___rect-button-surface-default\";\nexports.defaultRectButtonClass = \"___rect-button-default\";\nexports.defaultEdgeClass = \"__default-edge\";\nexports.defaultVertexClass = \"__default-vertex\";\nexports.defaultTreeClass = \"__default-tree\";\nexports.defaultConsoleColumnTitleCellClass = \"___column_title_cell\";\nexports.defaultConsoleColumnTitleCellTextClass = \"___column_title_text_cell\";\nexports.defaultConsoleColumnTitleCellUndefinedTextClass = \"___column_title_undefined_text_cell\";\nexports.defaultConsoleColumnTitleCellBackgroundClass = \"___column_title_background_cell\";\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/default_class_names.ts?");

/***/ }),

/***/ "./src/common/enums.ts":
/*!*****************************!*\
  !*** ./src/common/enums.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parsePXString = exports.HorizontalAnchor = exports.VerticalAnchor = exports.ConnectorType = exports.ShapeToFitType = exports.AutoSizeShapeToFitText = exports.DataName = exports.Direction = exports.msoDashStyle = exports.PathTextAlighnment = exports.ShapeObjectType = exports.OriginalSVGSVGAttributes = exports.MacroTagNames = exports.VBAShapeType = exports.CoodinateType = exports.VertexOrder = void 0;\nvar VertexOrder;\n(function (VertexOrder) {\n    VertexOrder.Preorder = \"preorder\";\n    VertexOrder.Postorder = \"postorder\";\n})(VertexOrder || (exports.VertexOrder = VertexOrder = {}));\nvar CoodinateType;\n(function (CoodinateType) {\n    CoodinateType.ObjectCenter = \"object-center\";\n    CoodinateType.Group00 = \"group00\";\n})(CoodinateType || (exports.CoodinateType = CoodinateType = {}));\nvar VBAShapeType;\n(function (VBAShapeType) {\n    VBAShapeType.None = \"NONE\";\n    VBAShapeType.Table = \"--table\";\n    VBAShapeType.Oval = \"msoShapeOval\";\n    VBAShapeType.Rectangle = \"msoShapeRectangle\";\n    VBAShapeType.Callout = \"msoShapeRectangularCallout\";\n    VBAShapeType.UpArrowCallout = \"msoShapeUpArrowCallout\";\n    VBAShapeType.LeftArrowCallout = \"msoShapeLeftArrowCallout\";\n    VBAShapeType.RightArrowCallout = \"msoShapeRightArrowCallout\";\n    VBAShapeType.DownArrowCallout = \"msoShapeDownArrowCallout\";\n})(VBAShapeType || (exports.VBAShapeType = VBAShapeType = {}));\nvar MacroTagNames;\n(function (MacroTagNames) {\n    MacroTagNames.Tree = \"m-tree\";\n    MacroTagNames.Ellipse = \"m-ellipse\";\n    MacroTagNames.Circle = \"m-circle\";\n    MacroTagNames.Rect = \"m-rect\";\n})(MacroTagNames || (exports.MacroTagNames = MacroTagNames = {}));\nvar OriginalSVGSVGAttributes;\n(function (OriginalSVGSVGAttributes) {\n    OriginalSVGSVGAttributes.VBAAttributeName = \"z-vba\";\n    OriginalSVGSVGAttributes.ShrinkAttributeName = \"z-shrink\";\n    OriginalSVGSVGAttributes.Edit = \"z-edit\";\n})(OriginalSVGSVGAttributes || (exports.OriginalSVGSVGAttributes = OriginalSVGSVGAttributes = {}));\nvar ShapeObjectType;\n(function (ShapeObjectType) {\n    ShapeObjectType.Callout = \"z-callout\";\n    ShapeObjectType.ArrowCallout = \"z-arrow-callout\";\n    ShapeObjectType.Ellipse = \"z-ellipse\";\n    ShapeObjectType.Circle = \"z-circle\";\n    ShapeObjectType.Rect = \"z-rect\";\n    ShapeObjectType.PathTextBox = \"z-path-textbox\";\n    ShapeObjectType.RectButton = \"z-rect-button\";\n    ShapeObjectType.Graph = \"z-graph\";\n    ShapeObjectType.Table = \"z-table\";\n    ShapeObjectType.Object = \"z-object\";\n    ShapeObjectType.Edge = \"z-edge\";\n    ShapeObjectType.ForeignObject = \"z-foreign-object\";\n    ShapeObjectType.ForeignButton = \"z-foreign-button\";\n    const typeDic = {\n        \"z-callout\": true,\n        \"z-arrow-callout\": true,\n        \"z-ellipse\": true,\n        \"z-circle\": true,\n        \"z-rect\": true,\n        \"z-edge\": true,\n        \"z-graph\": true,\n        \"z-table\": true,\n        \"z-object\": true,\n        \"z-path-textbox\": true,\n        \"z-rect-button\": true,\n        \"z-foreign-button\": true\n    };\n    const customTypeDic = {\n        \"row\": true,\n        \"cell\": true,\n        \"t\": true\n    };\n    function toShapeObjectType(value) {\n        if (value in typeDic) {\n            return value;\n        }\n        else {\n            return null;\n        }\n    }\n    ShapeObjectType.toShapeObjectType = toShapeObjectType;\n    function toShapeObjectTypeOrCustomTag(value) {\n        const lowerValue = value.toLowerCase();\n        const value1 = toShapeObjectType(lowerValue);\n        if (value1 != null) {\n            return value1;\n        }\n        else {\n            if (value in customTypeDic) {\n                return lowerValue;\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    ShapeObjectType.toShapeObjectTypeOrCustomTag = toShapeObjectTypeOrCustomTag;\n})(ShapeObjectType || (exports.ShapeObjectType = ShapeObjectType = {}));\nvar PathTextAlighnment;\n(function (PathTextAlighnment) {\n    PathTextAlighnment.regularInterval = \"regularInterval\";\n    PathTextAlighnment.begin = \"begin\";\n    PathTextAlighnment.end = \"end\";\n    PathTextAlighnment.center = \"center\";\n    const typeDic = {\n        \"none\": \"none\",\n        \"begin\": \"begin\",\n        \"end\": \"end\",\n        \"center\": \"center\",\n        \"regularInterval\": \"regularInterval\",\n    };\n    function toPathTextAlighnment(value) {\n        if (value in typeDic) {\n            return typeDic[value];\n        }\n        else {\n            return \"none\";\n        }\n    }\n    PathTextAlighnment.toPathTextAlighnment = toPathTextAlighnment;\n})(PathTextAlighnment || (exports.PathTextAlighnment = PathTextAlighnment = {}));\nvar msoDashStyle;\n(function (msoDashStyle) {\n    //export const styleName : string = \"--mso-dash-style\"\n    msoDashStyle.msoLineDash = \"msoLineDash\";\n    msoDashStyle.msoLineDashDot = \"msoLineDashDot\";\n    msoDashStyle.msoLineDashDotDot = \"msoLineDashDotDot\";\n    //export const msoLineDashStyleMixed: msoDashStyle = \"msoLineDashStyleMixed\"\n    msoDashStyle.msoLineLongDash = \"msoLineLongDash\";\n    msoDashStyle.msoLineLongDashDot = \"msoLineLongDashDot\";\n    msoDashStyle.msoLineRoundDot = \"msoLineRoundDot\";\n    msoDashStyle.msoLineSolid = \"msoLineSolid\";\n    msoDashStyle.msoLineSquareDot = \"msoLineSquareDot\";\n    msoDashStyle.dashArrayDic = {\n        \"msoLineDash\": [4, 3],\n        \"msoLineDashDot\": [4, 3, 1, 3],\n        \"msoLineDashDotDot\": [3, 1, 1, 1, 1, 1],\n        //\"msoLineDashStyleMixed\" : \"6,3\",\n        \"msoLineLongDash\": [9, 3],\n        \"msoLineLongDashDot\": [9, 3, 1, 3],\n        \"msoLineRoundDot\": [0.25, 2],\n        \"msoLineSolid\": [],\n        \"msoLineSquareDot\": [1, 1]\n    };\n    msoDashStyle.lineCapDic = {\n        \"msoLineDash\": \"butt\",\n        \"msoLineDashDot\": \"butt\",\n        \"msoLineDashDotDot\": \"butt\",\n        //\"msoLineDashStyleMixed\" : \"butt\",\n        \"msoLineLongDash\": \"butt\",\n        \"msoLineLongDashDot\": \"butt\",\n        \"msoLineRoundDot\": \"round\",\n        \"msoLineSolid\": \"butt\",\n        \"msoLineSquareDot\": \"butt\"\n    };\n    const typeDic = {\n        \"msoLineDash\": msoDashStyle.msoLineDash,\n        \"msoLineDashDot\": msoDashStyle.msoLineDashDot,\n        \"msoLineDashDotDot\": msoDashStyle.msoLineDashDotDot,\n        //\"msoLineDashStyleMixed\" : msoDashStyle.msoLineDashStyleMixed,\n        \"msoLineLongDash\": msoDashStyle.msoLineLongDash,\n        \"msoLineLongDashDot\": msoDashStyle.msoLineLongDashDot,\n        \"msoLineRoundDot\": msoDashStyle.msoLineRoundDot,\n        \"msoLineSquareDot\": msoDashStyle.msoLineSquareDot,\n        \"msoLineSolid\": msoDashStyle.msoLineSolid\n    };\n    function toMSODashStyle(value) {\n        if (value in typeDic) {\n            return typeDic[value];\n        }\n        else {\n            return msoDashStyle.msoLineSolid;\n        }\n    }\n    msoDashStyle.toMSODashStyle = toMSODashStyle;\n    /*\n    function setStyle(svgLine: SVGLineElement | SVGPathElement | SVGElement, type: string): void {\n        if (toMSODashStyle(type) != null) {\n            const width = <number>svgLine.getPropertyStyleNumberValue(\"stroke-width\", 2);\n            svgLine.setPropertyStyleValue(\"stroke-dasharray\", computeDashArray(toMSODashStyle(type), width));\n            svgLine.setPropertyStyleValue(\"stroke-linecap\", lineCapDic[type]);\n            svgLine.setPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName, type);\n        } else {\n\n        }\n    }\n    */\n    /*\n    export function getLineType(svgLine: SVGLineElement | SVGPathElement | SVGElement): msoDashStyle {\n        const typeName = svgLine.getPropertyStyleValue(StyleNames.msoDashStyleName);\n        if (typeName != null) {\n            const type = toMSODashStyle(typeName);\n            if (type != null) {\n                return type;\n            }\n        }\n        const dashArray = svgLine.getPropertyStyleValue(\"stroke-dasharray\");\n        if (dashArray != null) {\n            return msoDashStyle.msoLineDash;\n        } else {\n            return msoDashStyle.msoLineSolid;\n        }\n    }\n    */\n})(msoDashStyle || (exports.msoDashStyle = msoDashStyle = {}));\nvar Direction;\n(function (Direction) {\n    function toDirection(value) {\n        if (value == \"up\") {\n            return \"up\";\n        }\n        else if (value == \"left\") {\n            return \"left\";\n        }\n        else if (value == \"right\") {\n            return \"right\";\n        }\n        else {\n            return \"down\";\n        }\n    }\n    Direction.toDirection = toDirection;\n})(Direction || (exports.Direction = Direction = {}));\nvar DataName;\n(function (DataName) {\n    DataName.Surface = \"surface\";\n    DataName.Text = \"text\";\n    DataName.TopBorder = \"topborder\";\n    DataName.LeftBorder = \"leftborder\";\n    DataName.RightBorder = \"rightborder\";\n    DataName.BottomBorder = \"bottomborder\";\n})(DataName || (exports.DataName = DataName = {}));\nvar AutoSizeShapeToFitText;\n(function (AutoSizeShapeToFitText) {\n    AutoSizeShapeToFitText.Auto = \"auto\";\n    AutoSizeShapeToFitText.SemiAuto = \"semi-auto\";\n    AutoSizeShapeToFitText.None = \"none\";\n})(AutoSizeShapeToFitText || (exports.AutoSizeShapeToFitText = AutoSizeShapeToFitText = {}));\nvar ShapeToFitType;\n(function (ShapeToFitType) {\n    ShapeToFitType.None = \"none\";\n    ShapeToFitType.Auto = \"auto\";\n    ShapeToFitType.SemiAuto = \"semi-auto\";\n})(ShapeToFitType || (exports.ShapeToFitType = ShapeToFitType = {}));\nvar ConnectorType;\n(function (ConnectorType) {\n    ConnectorType.Top = \"top\";\n    ConnectorType.TopLeft = \"topleft\";\n    ConnectorType.Left = \"left\";\n    ConnectorType.BottomLeft = \"bottomleft\";\n    ConnectorType.Bottom = \"bottom\";\n    ConnectorType.BottomRight = \"bottomright\";\n    ConnectorType.Right = \"right\";\n    ConnectorType.TopRight = \"topright\";\n    ConnectorType.Auto = \"auto\";\n    function ToConnectorPosition(str) {\n        if (str == null) {\n            return ConnectorType.Auto;\n        }\n        else {\n            return str;\n            /*\n            switch (str) {\n                case \"top\": return ConnectorPosition.Top;\n                case \"topleft\": return ConnectorPosition.TopLeft;\n                case \"left\": return ConnectorPosition.Left;\n                case \"bottomleft\": return ConnectorPosition.BottomLeft;\n                case \"bottom\": return ConnectorPosition.Bottom;\n                case \"bottomright\": return ConnectorPosition.BottomRight;\n                case \"right\": return ConnectorPosition.Right;\n                case \"topright\": return ConnectorPosition.TopRight;\n                case \"auto\": return ConnectorPosition.Auto;\n                default: return ConnectorPosition.Auto;\n            }\n            */\n        }\n    }\n    ConnectorType.ToConnectorPosition = ToConnectorPosition;\n    function ToVBAConnectorPosition(shapeType, str) {\n        if (shapeType == \"circle\") {\n            switch (str) {\n                case \"top\": return 1;\n                case \"topleft\": return 2;\n                case \"left\": return 3;\n                case \"bottomleft\": return 4;\n                case \"bottom\": return 5;\n                case \"bottomright\": return 6;\n                case \"right\": return 7;\n                case \"topright\": return 8;\n                case \"auto\": return 9;\n                default: return 1;\n            }\n        }\n        else if (shapeType == \"rectangle\") {\n            switch (str) {\n                case \"top\": return 1;\n                case \"left\": return 2;\n                case \"bottom\": return 3;\n                case \"right\": return 4;\n                case \"auto\": return 9;\n                default: return 1;\n            }\n        }\n        else {\n            return 1;\n        }\n    }\n    ConnectorType.ToVBAConnectorPosition = ToVBAConnectorPosition;\n    function ToVBAConnectorPosition2(shapeType, str) {\n        switch (shapeType) {\n            case VBAShapeType.Oval:\n            case VBAShapeType.UpArrowCallout:\n            case VBAShapeType.LeftArrowCallout:\n            case VBAShapeType.RightArrowCallout:\n            case VBAShapeType.DownArrowCallout:\n                switch (str) {\n                    case \"top\": return 1;\n                    case \"topleft\": return 2;\n                    case \"left\": return 3;\n                    case \"bottomleft\": return 4;\n                    case \"bottom\": return 5;\n                    case \"bottomright\": return 6;\n                    case \"right\": return 7;\n                    case \"topright\": return 8;\n                    case \"auto\": return 9;\n                    default: return 1;\n                }\n            case VBAShapeType.Rectangle:\n            case VBAShapeType.Table:\n                switch (str) {\n                    case \"top\": return 1;\n                    case \"left\": return 2;\n                    case \"bottom\": return 3;\n                    case \"right\": return 4;\n                    case \"auto\": return 9;\n                    default: return 1;\n                }\n            default: return 1;\n        }\n        /*\n        if (shapeType == VBAShapeType.Oval) {\n            switch (str) {\n                case \"top\": return 1;\n                case \"topleft\": return 2;\n                case \"left\": return 3;\n                case \"bottomleft\": return 4;\n                case \"bottom\": return 5;\n                case \"bottomright\": return 6;\n                case \"right\": return 7;\n                case \"topright\": return 8;\n                case \"auto\": return 9;\n                default: return 1;\n            }\n        } else if (shapeType == VBAShapeType.Rectangle) {\n            switch (str) {\n                case \"top\": return 1;\n                case \"left\": return 2;\n                case \"bottom\": return 3;\n                case \"right\": return 4;\n                case \"auto\": return 9;\n                default: return 1;\n            }\n\n        } else if (){\n\n        }\n        else {\n            return 1;\n        }\n        */\n    }\n    ConnectorType.ToVBAConnectorPosition2 = ToVBAConnectorPosition2;\n})(ConnectorType || (exports.ConnectorType = ConnectorType = {}));\nvar VerticalAnchor;\n(function (VerticalAnchor) {\n    /**\n     * \n     */\n    VerticalAnchor.Top = \"top\";\n    /**\n     * \n     */\n    VerticalAnchor.Middle = \"middle\";\n    /**\n     * \n     */\n    VerticalAnchor.Bottom = \"bottom\";\n    function toVerticalAnchor(value) {\n        if (value == \"top\") {\n            return \"top\";\n        }\n        else if (value == \"bottom\") {\n            return \"bottom\";\n        }\n        else {\n            return \"middle\";\n        }\n    }\n    VerticalAnchor.toVerticalAnchor = toVerticalAnchor;\n})(VerticalAnchor || (exports.VerticalAnchor = VerticalAnchor = {}));\nvar HorizontalAnchor;\n(function (HorizontalAnchor) {\n    /**\n     * \n     */\n    HorizontalAnchor.Left = \"left\";\n    /**\n     * \n     */\n    HorizontalAnchor.Center = \"center\";\n    /**\n    * \n    */\n    HorizontalAnchor.Right = \"right\";\n    function toHorizontalAnchor(value) {\n        if (value == \"center\") {\n            return \"center\";\n        }\n        else if (value == \"right\") {\n            return \"right\";\n        }\n        else {\n            return \"left\";\n        }\n    }\n    HorizontalAnchor.toHorizontalAnchor = toHorizontalAnchor;\n})(HorizontalAnchor || (exports.HorizontalAnchor = HorizontalAnchor = {}));\nfunction parsePXString(item) {\n    if (item == null) {\n        return 0;\n    }\n    else {\n        if (item.length == 0) {\n            return 0;\n        }\n        else {\n            return parseInt(item);\n        }\n    }\n}\nexports.parsePXString = parsePXString;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/enums.ts?");

/***/ }),

/***/ "./src/common/exceptions.ts":
/*!**********************************!*\
  !*** ./src/common/exceptions.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NullError = exports.ArgumentOutOfRangeError = exports.NotSupportedError = exports.UndefinedError = void 0;\nclass UndefinedError extends Error {\n    constructor() {\n        super();\n        //this.message = \"Undefined Error:\";\n    }\n}\nexports.UndefinedError = UndefinedError;\nclass NotSupportedError extends Error {\n    constructor() {\n        super();\n        //this.message = \"Undefined Error:\";\n    }\n}\nexports.NotSupportedError = NotSupportedError;\nclass ArgumentOutOfRangeError extends Error {\n}\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\nclass NullError extends Error {\n}\nexports.NullError = NullError;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/exceptions.ts?");

/***/ }),

/***/ "./src/common/index.ts":
/*!*****************************!*\
  !*** ./src/common/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Exceptions = exports.StyleNames = exports.DefaultClassNames = exports.VLine = exports.VBAFunctions = exports.Enums = exports.AttributeNames = exports.CommonFunctions = exports.Color = void 0;\nconst Color = __webpack_require__(/*! ./color */ \"./src/common/color.ts\");\nexports.Color = Color;\nconst CommonFunctions = __webpack_require__(/*! ./common_functions */ \"./src/common/common_functions.ts\");\nexports.CommonFunctions = CommonFunctions;\nconst AttributeNames = __webpack_require__(/*! ./attribute_names */ \"./src/common/attribute_names.ts\");\nexports.AttributeNames = AttributeNames;\nconst DefaultClassNames = __webpack_require__(/*! ./default_class_names */ \"./src/common/default_class_names.ts\");\nexports.DefaultClassNames = DefaultClassNames;\nconst StyleNames = __webpack_require__(/*! ./style_names */ \"./src/common/style_names.ts\");\nexports.StyleNames = StyleNames;\nconst Enums = __webpack_require__(/*! ./enums */ \"./src/common/enums.ts\");\nexports.Enums = Enums;\nconst VBAFunctions = __webpack_require__(/*! ./vba_functions */ \"./src/common/vba_functions.ts\");\nexports.VBAFunctions = VBAFunctions;\nconst VLine = __webpack_require__(/*! ./vline */ \"./src/common/vline.ts\");\nexports.VLine = VLine;\nconst Exceptions = __webpack_require__(/*! ./exceptions */ \"./src/common/exceptions.ts\");\nexports.Exceptions = Exceptions;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/index.ts?");

/***/ }),

/***/ "./src/common/style_names.ts":
/*!***********************************!*\
  !*** ./src/common/style_names.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EdgeStyleNames = exports.prohibitionOutOfRange = exports.relocateName = exports.msoDashStyleName = exports.horizontalAnchor = exports.verticalAnchor = exports.marginBottom = exports.marginRight = exports.marginLeft = exports.marginTop = exports.paddingBottom = exports.paddingRight = exports.paddingLeft = exports.paddingTop = exports.defaultSurfaceType = exports.defaultHeight = exports.defaultWidth = exports.defaultRadius = exports.GraphStyleNames = exports.autoSizeShapeToFitText = void 0;\nexports.autoSizeShapeToFitText = \"--autosize-shape-to-fit-text\";\nvar GraphStyleNames;\n(function (GraphStyleNames) {\n    GraphStyleNames.vertexXInterval = \"--vertex-x-interval\";\n    GraphStyleNames.vertexYInterval = \"--vertex-y-interval\";\n    GraphStyleNames.graphDirection = \"--direction\";\n})(GraphStyleNames || (exports.GraphStyleNames = GraphStyleNames = {}));\nexports.defaultRadius = \"--default-radius\";\nexports.defaultWidth = \"--default-width\";\nexports.defaultHeight = \"--default-height\";\nexports.defaultSurfaceType = \"--default-surface-type\";\nexports.paddingTop = \"--padding-top\";\nexports.paddingLeft = \"--padding-left\";\nexports.paddingRight = \"--padding-right\";\nexports.paddingBottom = \"--padding-bottom\";\nexports.marginTop = \"--margin-top\";\nexports.marginLeft = \"--margin-left\";\nexports.marginRight = \"--margin-right\";\nexports.marginBottom = \"--margin-bottom\";\nexports.verticalAnchor = \"--vertical-anchor\";\nexports.horizontalAnchor = \"--horizontal-anchor\";\nexports.msoDashStyleName = \"--stroke-style\";\nexports.relocateName = \"--relocate\";\nexports.prohibitionOutOfRange = \"--prohibition-out-of-range\";\nvar EdgeStyleNames;\n(function (EdgeStyleNames) {\n    EdgeStyleNames.edgeType = \"--edge-type\";\n    EdgeStyleNames.readableText = \"--readable-text\";\n    EdgeStyleNames.markerStart = \"--marker-start\";\n    EdgeStyleNames.markerEnd = \"--marker-end\";\n    EdgeStyleNames.beginConnectorType = \"--begin-connector-type\";\n    EdgeStyleNames.endConnectorType = \"--end-connector-type\";\n    EdgeStyleNames.pathTextAlignment = \"--path-text-alignment\";\n})(EdgeStyleNames || (exports.EdgeStyleNames = EdgeStyleNames = {}));\n//export const defaultLineClass: string = \"--default-line-class\";\n//export const defaultVertexClass: string = \"--default-vertex-class\";\n//export const defaultEdgeClass: string = \"--default-edge-class\";\n//export const defaultTextClass: string = \"--default-text-class\";\n//export const defaultPathClass: string = \"--default-path-class\";\n//export const defaulSurfaceClass: string = \"--default-surface-class\";\n//export const defaultCellClass: string = \"--default-cell-class\";\n//export const defaultBorderClass: string = \"--default-border-class\";\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/style_names.ts?");

/***/ }),

/***/ "./src/common/vba_functions.ts":
/*!*************************************!*\
  !*** ./src/common/vba_functions.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VBATranslateFunctions = exports.sanityze = exports.styleVisible = exports.parseInteger = void 0;\n//namespace GraphTableSVG {\nconst html_1 = __webpack_require__(/*! ../html */ \"./src/html/index.ts\");\nconst Color = __webpack_require__(/*! ./color */ \"./src/common/color.ts\");\nconst CommonFunctions = __webpack_require__(/*! ./common_functions */ \"./src/common/common_functions.ts\");\nfunction parseInteger(value) {\n    if (value == \"\") {\n        return 1;\n    }\n    else {\n        return parseInt(value);\n    }\n}\nexports.parseInteger = parseInteger;\n/*\nexport function visible(value: string): number {\n    if (value == \"hidden\") {\n        return 1.0;\n    } else {\n        return 0;\n    }\n}\n*/\nfunction styleVisible(value) {\n    if (value.visibility == \"hidden\") {\n        return 1.0;\n    }\n    else if (value.stroke == \"transparent\") {\n        return 1.0;\n    }\n    else {\n        return 0;\n    }\n}\nexports.styleVisible = styleVisible;\nfunction sanityze(text) {\n    return text.replace(/\"/g, '\"\"');\n    //return text.replace(`\"`, `\"\"`);\n}\nexports.sanityze = sanityze;\nclass VBATranslateFunctions {\n    static grouping80(codes) {\n        let r = [];\n        const result = [];\n        codes.forEach(function (x, i, arr) {\n            if (r.length + x.length >= 80) {\n                result.push(VBATranslateFunctions.joinLines(r));\n                r = [];\n            }\n            x.forEach((v) => r.push(v));\n        });\n        if (r.length > 0) {\n            result.push(VBATranslateFunctions.joinLines(r));\n            r = [];\n        }\n        return result;\n    }\n    static splitCode(codes, subArg, callArg, id) {\n        const functions = [];\n        const p = VBATranslateFunctions.grouping80(codes);\n        p.forEach(function (x, i, arr) {\n            functions.push(`Call SubFunction${id}_${i}(${callArg})`);\n            const begin = `Sub SubFunction${id}_${i}(${subArg})`;\n            const end = `End Sub`;\n            p[i] = VBATranslateFunctions.joinLines([begin, x, end]);\n        });\n        return [VBATranslateFunctions.joinLines(functions), VBATranslateFunctions.joinLines(p)];\n    }\n    static ToFontBold(bold) {\n        if (bold == \"bold\") {\n            return \"msotrue\";\n        }\n        else {\n            return \"msofalse\";\n        }\n    }\n    static ToVerticalAnchor(value) {\n        switch (value) {\n            case \"top\": return \"msoAnchorTop\";\n            case \"middle\": return \"msoAnchorMiddle\";\n            case \"bottom\": return \"msoAnchorBottom\";\n            default: return \"msoAnchorTop\";\n        }\n    }\n    static ToHorizontalAnchor(value) {\n        switch (value) {\n            case \"left\": return \"ppAlignLeft\";\n            case \"center\": return \"ppAlignCenter\";\n            case \"right\": return \"ppAlignRight\";\n            default: return \"ppAlignLeft\";\n        }\n    }\n    static createStringFunction(item) {\n        return item.length == 0 ? `\"\"` : `\"` + item + `\"`;\n    }\n    static createArrayFunction(items) {\n        let s = ``;\n        for (let i = 0; i < items.length; i++) {\n            s += items[i];\n            if (i + 1 != items.length) {\n                s += `, `;\n            }\n        }\n        return `Array(${s})`;\n    }\n    static createStringArrayFunction(items) {\n        let s = ``;\n        for (let i = 0; i < items.length; i++) {\n            s += `\"${items[i]}\"`;\n            if (i + 1 != items.length) {\n                s += `, `;\n            }\n        }\n        return `Array(${s})`;\n    }\n    static createJagArrayFunction(items) {\n        let s = ``;\n        for (let i = 0; i < items.length; i++) {\n            s += VBATranslateFunctions.createArrayFunction(items[i]);\n            if (i + 1 != items.length)\n                s += `, `;\n        }\n        return `Array(${s})`;\n    }\n    static joinLines(lines) {\n        let s = ``;\n        for (let i = 0; i < lines.length; i++) {\n            s += lines[i];\n            if (i + 1 != lines.length)\n                s += `\\n`;\n        }\n        return s;\n    }\n    static colorToVBA(color) {\n        color = Color.createRGBCodeFromColorName(color);\n        if (color.indexOf(\"rgb\") != -1) {\n            return color.replace(\"rgb\", \"Array\");\n        }\n        else {\n            return \"Array(0, 0, 0)\";\n        }\n    }\n    static ToVBAFont(font) {\n        font = font.replace(/\"/g, \"\");\n        font = font.replace(/'/g, \"\");\n        return font;\n    }\n    static TranslateSVGTextElement(sub, item, range) {\n        const text = item.textContent == null ? \"\" : item.textContent;\n        sub.push([`${range}.text = \"${item.textContent}\"`]);\n        if (item.children.length > 0) {\n            let pos = 1;\n            for (let i = 0; i < item.children.length; i++) {\n                const child = item.children.item(i);\n                if (child != null && child.textContent != null && child.textContent.length > 0) {\n                    const css = getComputedStyle(child);\n                    const childColor = Color.createRGBFromColorName(css.fill == null ? \"black\" : css.fill);\n                    const fontName = this.getFont(css);\n                    const fontSize = CommonFunctions.toPX(css.fontSize == null ? \"14pt\" : css.fontSize);\n                    const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\n                    const len = child.textContent.length;\n                    let f = child.getAttribute(\"data-script\");\n                    if (f == null) {\n                        f = \"\";\n                    }\n                    sub.push([`Call EditTextRangeSub(${range},${pos}, ${len}, \"${f}\", Array(${childColor.r}, ${childColor.g}, ${childColor.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`]);\n                    pos += len;\n                }\n            }\n        }\n        else if (item.textContent != null && item.textContent.length > 0) {\n            const css = getComputedStyle(item);\n            if (css.fontSize == null)\n                throw Error(\"error\");\n            if (css.fill == null)\n                throw Error(\"error\");\n            const color = Color.createRGBFromColorName(css.fill);\n            const fontName = this.getFont(css);\n            const fontSize = CommonFunctions.toPX(css.fontSize);\n            const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\n            sub.push([`Call EditTextRangeSub(${range},${1}, ${item.textContent.length}, \"\", Array(${color.r}, ${color.g}, ${color.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`]);\n        }\n    }\n    static getFont(css) {\n        if (css.fontFamily == null)\n            throw Error(\"error\");\n        const arr = css.fontFamily.split(\",\");\n        if (arr.length > 0) {\n            let name = arr[0];\n            name = name.replace(/\\\"/g, \"\");\n            name = name.replace(/\\'/g, \"\");\n            return name;\n        }\n        else {\n            return \"\";\n        }\n    }\n    static TranslateSVGTextElement2(item, range) {\n        const lines = [];\n        //const text = item.textContent == null ? \"\" : item.textContent;\n        if (item.children.length > 0) {\n            let textCode = \"\";\n            for (let i = 0; i < item.children.length; i++) {\n                const child = item.children.item(i);\n                if (child != null && child.textContent != null && child.textContent.length > 0) {\n                    const newLine = child.getAttribute(\"newline\");\n                    if (newLine != null && newLine == \"true\") {\n                        textCode += `& vbCrLf `;\n                    }\n                    const text = sanityze(html_1.HTMLFunctions.removeInvisibleCharacters(child.textContent));\n                    if (textCode.length > 0) {\n                        textCode += `& \"${text}\"`;\n                    }\n                    else {\n                        textCode = `\"${text}\"`;\n                    }\n                }\n            }\n            lines.push(`${range}.text = ${textCode}`);\n            let pos = 1;\n            for (let i = 0; i < item.children.length; i++) {\n                const child = item.children.item(i);\n                if (child != null && child.textContent != null && child.textContent.length > 0) {\n                    const newLine = child.getAttribute(\"newline\");\n                    if (newLine != null && newLine == \"true\") {\n                        pos++;\n                    }\n                    for (let j = 0; j < child.childNodes.length; j++) {\n                        const child2 = child.childNodes.item(j);\n                        const node = child2 instanceof SVGTSpanElement ? child2 : child;\n                        const textContent = html_1.HTMLFunctions.removeInvisibleCharacters(child2.textContent);\n                        const css = getComputedStyle(node);\n                        if (css.fontSize == null)\n                            throw Error(\"error\");\n                        if (css.fill == null)\n                            throw Error(\"error\");\n                        const childColor = Color.createRGBFromColorName(css.fill);\n                        const fontName = this.getFont(css);\n                        const fontSize = CommonFunctions.toPX(css.fontSize);\n                        const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\n                        const len = textContent.length;\n                        let f = node.getAttribute(\"data-script\");\n                        if (f == null) {\n                            f = \"\";\n                        }\n                        lines.push(`Call EditTextRangeSub(${range},${pos}, ${len}, \"${f}\", Array(${childColor.r}, ${childColor.g}, ${childColor.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`);\n                        pos += len;\n                    }\n                }\n            }\n        }\n        else if (item.textContent != null && item.textContent.length > 0) {\n            const vbaText = sanityze(html_1.HTMLFunctions.removeInvisibleCharacters(item.textContent));\n            lines.push(`${range}.text = \"${vbaText}\"`);\n            const css = getComputedStyle(item);\n            if (css.fontSize == null)\n                throw Error(\"error\");\n            if (css.fill == null)\n                throw Error(\"error\");\n            const color = Color.createRGBFromColorName(css.fill);\n            const fontName = this.getFont(css);\n            const fontSize = CommonFunctions.toPX(css.fontSize);\n            const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\n            lines.push(`Call EditTextRangeSub(${range},${1}, ${vbaText.length}, \"\", Array(${color.r}, ${color.g}, ${color.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`);\n        }\n        return lines;\n    }\n}\nexports.VBATranslateFunctions = VBATranslateFunctions;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/vba_functions.ts?");

/***/ }),

/***/ "./src/common/vline.ts":
/*!*****************************!*\
  !*** ./src/common/vline.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n//namespace GraphTableSVG {\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Rectangle = exports.escapeWithRound100 = exports.nearlyEqual = exports.round100 = exports.Size = exports.Padding = exports.VLine = exports.PositionType = void 0;\nvar PositionType;\n(function (PositionType) {\n    PositionType.Center = \"center\";\n    PositionType.UpperLeft = \"upper-left\";\n})(PositionType || (exports.PositionType = PositionType = {}));\n/**\n * \n */\nclass VLine {\n    get smallPoint() {\n        if (this.x1 < this.x2) {\n            return [this.x1, this.y1];\n        }\n        else {\n            return [this.x2, this.y2];\n        }\n    }\n    get largePoint() {\n        if (this.x1 < this.x2) {\n            return [this.x2, this.y2];\n        }\n        else {\n            return [this.x1, this.y1];\n        }\n    }\n    constructor(x1, y1, x2, y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n    distance() {\n        const l = Math.abs(this.x1 - this.x2);\n        const r = Math.abs(this.y1 - this.y2);\n        return Math.sqrt(l * l) + Math.sqrt(r * r);\n    }\n    contains(x, y) {\n        const lineY = this.getY(x);\n        if (lineY == null) {\n            return x < this.x1;\n        }\n        else {\n            return y < lineY;\n        }\n    }\n    getY(x) {\n        const intercept = this.intercept;\n        if (intercept == null) {\n            return null;\n        }\n        else {\n            if (this.slope == null) {\n                return null;\n            }\n            else {\n                return (this.slope * x) + intercept;\n            }\n        }\n    }\n    get slope() {\n        const [x1, y1] = this.smallPoint;\n        const [x2, y2] = this.largePoint;\n        if (x2 - x1 == 0) {\n            return null;\n        }\n        else {\n            return (y2 - y1) / (x2 - x1);\n        }\n    }\n    get intercept() {\n        const [x1, y1] = this.smallPoint;\n        const [x2, y2] = this.largePoint;\n        if (this.slope == null) {\n            return null;\n        }\n        else {\n            return y1 - x1 * this.slope;\n        }\n    }\n    get inverseSlope() {\n        if (this.slope == 0) {\n            return null;\n        }\n        else {\n            if (this.slope == null) {\n                return null;\n            }\n            else {\n                return -1 / this.slope;\n            }\n        }\n    }\n    inverseIntercept(x, y) {\n        if (this.slope == 0) {\n            return null;\n        }\n        else {\n            if (this.inverseSlope == null) {\n                return null;\n            }\n            else {\n                return y - (this.inverseSlope * x);\n            }\n        }\n    }\n}\nexports.VLine = VLine;\nclass Padding {\n    constructor(top = 0, left = 0, right = 0, bottom = 0) {\n        this.top = top;\n        this.left = left;\n        this.right = right;\n        this.bottom = bottom;\n    }\n}\nexports.Padding = Padding;\nclass Size {\n    constructor(width = 0, height = 0) {\n        this.width = width;\n        this.height = height;\n    }\n}\nexports.Size = Size;\nfunction round100(value) {\n    return Math.round(value * 100) / 100;\n}\nexports.round100 = round100;\nfunction nearlyEqual(value1, value2) {\n    const abs = Math.abs(value1 - value2);\n    return abs < 0.1;\n}\nexports.nearlyEqual = nearlyEqual;\nfunction escapeWithRound100(literals, ...placeholders) {\n    let result = \"\";\n    // interleave the literals with the placeholders\n    for (let i = 0; i < placeholders.length; i++) {\n        result += literals[i];\n        const p = placeholders[i];\n        result += typeof (p) === \"string\" ? p : round100(p).toString();\n    }\n    // add the last literal\n    result += literals[literals.length - 1];\n    return result;\n}\nexports.escapeWithRound100 = escapeWithRound100;\n/**\n * \n */\nclass Rectangle {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    /**\n    X\n    */\n    get right() {\n        return this.x + this.width;\n    }\n    /**\n    Y\n    */\n    get bottom() {\n        return this.y + this.height;\n    }\n    /**\n     * XY\n     * @param x\n     * @param y\n     */\n    addOffset(x, y) {\n        this.x += x;\n        this.y += y;\n    }\n    /**\n     * \n     * @param rects\n     */\n    static merge(rects) {\n        if (rects.length > 0) {\n            let x1 = rects[0].x;\n            let y1 = rects[0].y;\n            let x2 = rects[0].right;\n            let y2 = rects[0].bottom;\n            rects.forEach((v) => {\n                if (x1 > v.x)\n                    x1 = v.x;\n                if (y1 > v.y)\n                    y1 = v.y;\n                if (x2 < v.right)\n                    x2 = v.right;\n                if (y2 < v.bottom)\n                    y2 = v.bottom;\n            });\n            const rect = new Rectangle();\n            rect.x = x1;\n            rect.y = y1;\n            rect.width = x2 - x1;\n            rect.height = y2 - y1;\n            return rect;\n        }\n        else {\n            return new Rectangle(0, 0, 0, 0);\n        }\n    }\n}\nexports.Rectangle = Rectangle;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/vline.ts?");

/***/ }),

/***/ "./src/debug/debug.ts":
/*!****************************!*\
  !*** ./src/debug/debug.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBinaryTrie = exports.randomLabeledTree = exports.randomTrie = exports.randomBinaryTree = exports.randomTree = void 0;\nconst logic_tree_1 = __webpack_require__(/*! ../logics/logic_tree */ \"./src/logics/logic_tree.ts\");\n//export namespace Debug {\nfunction randomTreeArray(node_num, max_degree) {\n    const nodes = new Array(0);\n    const graph = new logic_tree_1.LogicTree();\n    const root = new logic_tree_1.LogicTreeNode();\n    nodes.push(root);\n    while (nodes.length < node_num) {\n        var random = Math.floor(Math.random() * nodes.length);\n        const parent = nodes[random];\n        if (parent.children.length < max_degree) {\n            const child = new logic_tree_1.LogicTreeNode();\n            parent.children.push(child);\n            nodes.push(child);\n        }\n    }\n    graph.root = root;\n    return [graph, nodes];\n}\n/*\nfunction randomBinaryTreeArray(node_num : number) : BinaryLogicTree[] {\n    const nodes : BinaryLogicTree[] = new Array(0);\n    const root = new BinaryLogicTree();\n    nodes.push(root);\n\n    while(nodes.length < node_num){\n        var random = Math.floor( Math.random()*nodes.length );\n        var leftOrRight = Math.floor( Math.random()*2 );\n\n        const parent = nodes[random];\n\n        if(leftOrRight == 0 && parent.left == null){\n            const child = new BinaryLogicTree();\n            parent.left = child;\n            nodes.push(child);\n        }else if(leftOrRight == 1 && parent.right == null){\n            const child = new BinaryLogicTree();\n            parent.right = child;\n            nodes.push(child);\n\n        }\n    }\n    return nodes;\n}\n*/\nfunction randomTree(node_num, max_degree) {\n    return randomTreeArray(node_num, max_degree)[0];\n}\nexports.randomTree = randomTree;\nfunction randomBinaryTree(node_num) {\n    return randomTree(node_num, 2);\n}\nexports.randomBinaryTree = randomBinaryTree;\nconst labels = [\"a\", \"b\", \"c\", \"\", \"e\", \"f\", \"g\"];\nfunction randomTrie(node_num, max_degree) {\n    const [graph, nodes] = randomTreeArray(node_num, max_degree);\n    for (let i = 1; i < nodes.length; i++) {\n        var randomLabelNumber = Math.floor(Math.random() * labels.length);\n        nodes[i].edgeOption.text = labels[randomLabelNumber];\n    }\n    return graph;\n}\nexports.randomTrie = randomTrie;\nfunction randomLabeledTree(node_num, max_degree, max_string_length) {\n    const [graph, nodes] = randomTreeArray(node_num, max_degree);\n    for (let i = 1; i < nodes.length; i++) {\n        var strLen = Math.floor(Math.random() * max_string_length);\n        let s = \"\";\n        for (let x = 0; x < strLen; x++) {\n            var randomLabelNumber = Math.floor(Math.random() * labels.length);\n            if (randomLabelNumber < 4) {\n                s += labels[randomLabelNumber];\n            }\n        }\n        nodes[i].edgeOption.text = s;\n    }\n    return graph;\n}\nexports.randomLabeledTree = randomLabeledTree;\nfunction randomBinaryTrie(node_num) {\n    const node = randomTrie(node_num, 2);\n    return node;\n}\nexports.randomBinaryTrie = randomBinaryTrie;\n/*\nexport function randomTrie(node_num : number, max_degree : number) : LogicTree {\n    const nodes = randomTreeArray(node_num, max_degree);\n    for(let i=1;i<nodes.length;i++){\n        var randomLabelNumber = Math.floor( Math.random()* labels.length );\n        nodes[i].parentEdgeText = labels[randomLabelNumber];\n        \n    }\n    return nodes[0];\n}\n*/\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/debug/debug.ts?");

/***/ }),

/***/ "./src/html/css.ts":
/*!*************************!*\
  !*** ./src/html/css.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.writeDownCSSToStyleAttributes = exports.setCSSToStyle = exports.setCSSStyle = exports.setCSSClass = exports.createCSSClass = exports.createCSSString = exports.createCSS = exports.getOrCreateClassName = exports.toRuleMap = exports.getRuleContentString = exports.getGraphTableStyleSheet = exports.getGraphTableCSS = exports.setGraphTableCSS = exports.buildClassNameFromSurfaceClassCSS = void 0;\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ./html_functions */ \"./src/html/html_functions.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\n//export namespace CSS {\n/*\ninterface IPoint2D {\n    x: number;\n    y: number;\n  }\n  */\nfunction buildClassNameFromSurfaceClassCSS(rule) {\n    const _rule = toRuleMap(rule);\n    return getOrCreateClassName(_rule);\n}\nexports.buildClassNameFromSurfaceClassCSS = buildClassNameFromSurfaceClassCSS;\nconst CSSName = \"___GraphTableCSS\";\nlet createdGraphTableCSS = false;\nconst replaceMapper = new Map();\nfunction setupReplaceMapper() {\n    replaceMapper.set(\"fontSize\", \"font-size\");\n    replaceMapper.set(\"fontFamily\", \"font-family\");\n    replaceMapper.set(\"autoSizeShapeToFitText\", StyleNames.autoSizeShapeToFitText);\n    replaceMapper.set(\"verticalAnchor\", StyleNames.verticalAnchor);\n    replaceMapper.set(\"horizontalAnchor\", StyleNames.horizontalAnchor);\n    replaceMapper.set(\"beginConnectorType\", StyleNames.EdgeStyleNames.beginConnectorType);\n    replaceMapper.set(\"endConnectorType\", StyleNames.EdgeStyleNames.endConnectorType);\n    replaceMapper.set(\"startMarker\", StyleNames.EdgeStyleNames.markerStart);\n    replaceMapper.set(\"endMarker\", StyleNames.EdgeStyleNames.markerEnd);\n    replaceMapper.set(\"edgeType\", StyleNames.EdgeStyleNames.edgeType);\n    replaceMapper.set(\"pathTextAlignment\", StyleNames.EdgeStyleNames.pathTextAlignment);\n    replaceMapper.set(\"paddingTop\", StyleNames.paddingTop);\n    replaceMapper.set(\"paddingLeft\", StyleNames.paddingLeft);\n    replaceMapper.set(\"paddingRight\", StyleNames.paddingRight);\n    replaceMapper.set(\"paddingBottom\", StyleNames.paddingBottom);\n    replaceMapper.set(\"strokeWidth\", \"stroke-width\");\n}\nfunction setGraphTableCSS() {\n    if (createdGraphTableCSS)\n        return;\n    const item = document.head.getElementsByClassName(CSSName);\n    if (item.length > 0) {\n        document.head.removeChild(item[0]);\n    }\n    var blankStyle = document.createElement('style');\n    blankStyle.innerHTML = createCSS();\n    blankStyle.type = \"text/css\";\n    blankStyle.setAttribute(\"class\", CSSName);\n    blankStyle.title = CSSName;\n    const head = document.getElementsByTagName('head');\n    const fstItem = head.item(0).firstChild;\n    if (fstItem == null) {\n        head.item(0).appendChild(blankStyle);\n    }\n    else {\n        head.item(0).insertBefore(blankStyle, fstItem);\n    }\n    createdGraphTableCSS = true;\n}\nexports.setGraphTableCSS = setGraphTableCSS;\nfunction getGraphTableCSS() {\n    const item = document.getElementById(CSSName);\n    if (item instanceof HTMLStyleElement) {\n        return item;\n    }\n    else {\n        return null;\n    }\n}\nexports.getGraphTableCSS = getGraphTableCSS;\nfunction getGraphTableStyleSheet() {\n    if (!createdGraphTableCSS)\n        setGraphTableCSS();\n    for (let i = 0; i < document.styleSheets.length; i++) {\n        const css = document.styleSheets.item(i);\n        if (css.title == CSSName && css instanceof CSSStyleSheet) {\n            return css;\n        }\n    }\n    return null;\n}\nexports.getGraphTableStyleSheet = getGraphTableStyleSheet;\nfunction getRuleContentString(rule) {\n    const arr = new Array();\n    rule.forEach((value, key) => {\n        arr.push(key);\n    });\n    arr.sort();\n    const content = arr.map((key) => {\n        return `${key}: ${rule.get(key)};`;\n    }).join(\"\\n\");\n    return content;\n}\nexports.getRuleContentString = getRuleContentString;\nfunction toRuleMap(rule) {\n    if (replaceMapper.size == 0)\n        setupReplaceMapper();\n    const _rule = new Map();\n    Object.keys(rule).forEach((v) => {\n        if (replaceMapper.has(v)) {\n            _rule.set(replaceMapper.get(v), rule[v]);\n        }\n        else {\n            _rule.set(v, rule[v]);\n        }\n        /*\n        if(v == \"fontSize\"){\n            _rule.set(\"font-size\", value);\n        }else if(v == \"fontFamily\"){\n            _rule.set(\"font-family\", value);\n        }else{\n            _rule.set(v, (<any>rule)[v]);\n        }\n        */\n    });\n    return _rule;\n}\nexports.toRuleMap = toRuleMap;\nconst ruleInverseMap = new Map();\nlet createdCSSRuleCount = 0;\nconst generatedCSSRuleName = \"--g-class-\";\nfunction getOrCreateClassName(rule) {\n    if (rule instanceof Map) {\n        const ruleContentString = getRuleContentString(rule);\n        if (ruleInverseMap.has(ruleContentString)) {\n            return ruleInverseMap.get(ruleContentString);\n        }\n        else {\n            const css = getGraphTableStyleSheet();\n            const className = `${generatedCSSRuleName}${createdCSSRuleCount++}`;\n            const cssRule = `.${className}{${ruleContentString}}`;\n            css.insertRule(cssRule, css.cssRules.length);\n            ruleInverseMap.set(ruleContentString, className);\n            return className;\n        }\n    }\n    else {\n        const _rule = toRuleMap(rule);\n        return getOrCreateClassName(_rule);\n    }\n}\nexports.getOrCreateClassName = getOrCreateClassName;\nfunction createCSS() {\n    const r = `\r\n            .${AttributeNames.cellEmphasisCellClass}{\r\n            fill : yellow !important;\r\n            }\r\n            .${AttributeNames.cellEmphasisBorderClass}{\r\n            stroke : red !important;\r\n            }\r\n            .${DefaultClassNames.defaultCellClass}{\r\n                ${StyleNames.paddingTop} : 0px;\r\n                ${StyleNames.paddingLeft} : 0px;\r\n                ${StyleNames.paddingRight} : 0px;\r\n                ${StyleNames.paddingBottom} : 0px;\r\n                ${StyleNames.verticalAnchor} : ${enums_1.VerticalAnchor.Middle};\r\n                ${StyleNames.horizontalAnchor} : ${enums_1.HorizontalAnchor.Center};\r\n            }\r\n            .${DefaultClassNames.defaultTextClass}{\r\n                fill : black;\r\n                font-size: 20px;\r\n                font-family: \"Times New Roman\";\r\n            }\r\n            .${DefaultClassNames.defaultCellBackgroungClass}{\r\n                fill : white;\r\n            }\r\n            .${DefaultClassNames.defaultCellBorderClass}{\r\n                stroke : black;\r\n            }\r\n            .${DefaultClassNames.defaultVertexClass}{\r\n\r\n            }\r\n            .${DefaultClassNames.defaultEdgeClass}{\r\n                ${StyleNames.EdgeStyleNames.pathTextAlignment}: center;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultSurfaceClass}{\r\n                stroke: black;\r\n                stroke-width: 1px;\r\n                fill : white;\r\n            }\r\n            .${DefaultClassNames.defaultPathSurfaceClass}{\r\n                stroke: black;\r\n                stroke-width: 1px;\r\n                fill : transparent;\r\n            }\r\n            .${DefaultClassNames.defaultCircleLogicTreeCircleSVGGroup}{\r\n                ${StyleNames.autoSizeShapeToFitText}: false;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultEdgePathClass}{\r\n                stroke: black;\r\n                fill: none;\r\n                stroke-width: 1px;\r\n            }\r\n            .${DefaultClassNames.defaultTextboxPathClass}{\r\n                stroke: black;\r\n                fill: white;\r\n                stroke-width: 1px;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultRectButtonClass}{\r\n                --padding-top: 5;\r\n                --padding-left: 15;\r\n                --padding-right: 15;\r\n                --padding-bottom: 5;\r\n            }\r\n\r\n            .___column_title_cellaa{\r\n                --default-text-class : table-text;\r\n                --default-background-class : background;    \r\n                --horizontal-anchor: center;\r\n                --vertical-anchor: middle;\r\n                --padding-top: 0px;\r\n                --padding-left: 0px;\r\n                --padding-right: 0px;\r\n                --padding-bottom: 0px;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultConsoleColumnTitleCellTextClass} {\r\n                fill : black;\r\n                font-size: 18px;\r\n                font-weight: bold;\r\n                font-family: \"'Times New Roman'\";\r\n            }\r\n            .${DefaultClassNames.defaultConsoleColumnTitleCellUndefinedTextClass} {\r\n                fill : pink;\r\n                font-size: 18px;\r\n                font-style: italic;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultConsoleColumnTitleCellBackgroundClass}{\r\n                fill: #8EB8FF; \r\n                stroke: black;\r\n            }\r\n            .${DefaultClassNames.defaultTreeClass}{\r\n                ${StyleNames.relocateName}: standard;\r\n            }\r\n\r\n\r\n            g[data-type=\"z-rect-button\"] > rect {\r\n                fill:#69c; \r\n                stroke: #444444;\r\n                stroke-width: 3px;\r\n                transition-duration: 0.2s;\r\n            }\r\n\r\n            g[data-type=\"z-rect-button\"] > rect[disabled]{\r\n                stroke-width: 5px;\r\n            }\r\n            g[data-type=\"z-rect-button\"] > rect:not([disabled]):hover {\r\n                stroke-width: 1px;\r\n                fill: #79acdf;\r\n                stroke: white;\r\n\r\n            }\r\n            g[data-type=\"z-rect-button\"] > rect:not([disabled]):active {\r\n                stroke-width: 5px;\r\n                stroke: black;\r\n\r\n            }\r\n            g[data-type=\"z-rect-button\"] > text {\r\n                pointer-events: none;\r\n                fill: white;\r\n                font-family: \"'Arial'\";\r\n            }\r\n\r\n            g[data-allow-hover=\"true\"] > rect, g[data-allow-hover=\"true\"] > circle, g[data-allow-hover=\"true\"] > ellipse, g[data-allow-hover=\"true\"] > path {\r\n                transition-duration: 0.2s;\r\n            }\r\n            g[data-allow-hover=\"true\"] > rect:not([disabled]):hover, g[data-allow-hover=\"true\"] > circle:not([disabled]):hover, g[data-allow-hover=\"true\"] > ellipse:not([disabled]):hover, g[data-allow-hover=\"true\"] > path:not([disabled]):hover {\r\n                stroke-width: 1px;\r\n            }\r\n\r\n            .graphtablesvg_wrapper{\r\n                min-height: 100vh;\r\n                position: relative;\r\n                padding-bottom: 120px;\r\n                box-sizing: border-box;\r\n            }\r\n            \r\n            .graphtablesvg_footer{\r\n                width: 100%;\r\n                background-color: #89c7de;\r\n                color: #fff;\r\n                text-align: center;\r\n                padding: 30px 0;\r\n            \r\n             position: absolute;\r\n                bottom: 0;\r\n            }\r\n\r\n            `;\n    return r;\n}\nexports.createCSS = createCSS;\nfunction createCSSString(obj) {\n    if (typeof obj == \"string\") {\n        return obj;\n    }\n    else if (typeof obj == \"object\") {\n        const styleContent = getRuleContentString(toRuleMap(obj));\n        return styleContent;\n    }\n    else {\n        return undefined;\n    }\n}\nexports.createCSSString = createCSSString;\nfunction createCSSClass(obj) {\n    if (typeof obj == \"string\") {\n        return obj;\n    }\n    else if (typeof obj == \"object\") {\n        const styleClass = getOrCreateClassName(obj);\n        return styleClass;\n    }\n    else {\n        return undefined;\n    }\n}\nexports.createCSSClass = createCSSClass;\nfunction setCSSClass(e, style) {\n    if (style !== undefined) {\n        //SVG.resetStyle(e.style);\n        if (style == null) {\n            e.removeAttribute(\"class\");\n        }\n        else {\n            const styleClass = createCSSClass(style);\n            if (styleClass !== undefined) {\n                e.setAttribute(\"class\", styleClass);\n            }\n        }\n    }\n}\nexports.setCSSClass = setCSSClass;\nfunction setCSSStyle(e, style) {\n    if (style !== undefined) {\n        //SVG.resetStyle(e.style);\n        const styleClass = createCSSString(style);\n        if (styleClass !== undefined) {\n            e.setAttribute(\"style\", styleClass);\n        }\n    }\n}\nexports.setCSSStyle = setCSSStyle;\nconst exceptionStyleNames = [\"marker-start\", \"marker-mid\", \"marker-end\", \"width\", \"height\"];\nconst cssPropertyNames = [\"font-size\", \"fill\", \"stroke\",\n    \"font-family\", \"font-weight\", \"stroke-width\", \"background\", \"border\", \"background-color\", \"border-bottom-color\", \"border-bottom-style\", \"border-bottom-width\",\n    \"border-left-color\", \"border-left-style\", \"border-left-width\", \"border-right-color\", \"border-right-style\", \"border-right-width\", \"border-top-color\", \"border-top-style\", \"border-top-width\"];\nfunction getPropertyStyleValue(item, name) {\n    const p = item.style.getPropertyValue(name).trim();\n    if (p.length == 0) {\n        const r = item.getAttribute(\"class\");\n        if (r == null) {\n            return null;\n        }\n        else {\n            const css = getComputedStyle(item);\n            //const css = getComputedStyle(item);\n            const p2 = css.getPropertyValue(name).trim();\n            if (p2.length == 0) {\n                return null;\n            }\n            else {\n                return p2;\n            }\n        }\n    }\n    else {\n        return p;\n    }\n}\n/**\n         * SVGCSSStyleDeclaration\n         * @param svg SVG\n         */\nfunction setCSSToStyle(svg, isComplete = true) {\n    if (isComplete) {\n        const css = getComputedStyle(svg);\n        if (css != null) {\n            for (let i = 0; i < css.length; i++) {\n                const name = css.item(i);\n                const value = css.getPropertyValue(name);\n                if (value.length > 0) {\n                    if (!exceptionStyleNames.some((v) => v == name)) {\n                        svg.style.setProperty(name, value);\n                    }\n                }\n            }\n        }\n    }\n    else {\n        cssPropertyNames.forEach((v) => {\n            const value = getPropertyStyleValue(svg, v);\n            if (value != null) {\n                svg.style.setProperty(v, value);\n            }\n        });\n    }\n    /*\n    const css = getCSSStyle(svg);\n    if (css != null) {\n        let css2: CSSStyleDeclaration = css;\n        cssPropertyNames.forEach((v) => {\n            const value = css2.getPropertyValue(v).trim();\n            if (value.length > 0) {\n                svg.style.setProperty(v, value);\n            }\n        });\n    }\n    */\n}\nexports.setCSSToStyle = setCSSToStyle;\nfunction writeDownCSSToStyleAttributes(element) {\n    if (element instanceof SVGSVGElement || element instanceof SVGGElement) {\n        const elements = HTMLFunctions.getDescendantsByPostorder(element);\n        elements.forEach((v) => {\n            if (v instanceof SVGGeometryElement) {\n                setCSSToStyle(v, false);\n            }\n            else if (v instanceof SVGTextElement) {\n                setCSSToStyle(v, false);\n            }\n        });\n    }\n    else {\n        const id = element;\n        const v = document.getElementById(id);\n        if (v instanceof SVGSVGElement || v instanceof SVGGElement) {\n            writeDownCSSToStyleAttributes(v);\n        }\n        else {\n            throw new Error(\"Not found!\");\n        }\n    }\n}\nexports.writeDownCSSToStyleAttributes = writeDownCSSToStyleAttributes;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/css.ts?");

/***/ }),

/***/ "./src/html/draggable_object.ts":
/*!**************************************!*\
  !*** ./src/html/draggable_object.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DraggableObjectFunctions = void 0;\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\nvar DraggableObjectFunctions;\n(function (DraggableObjectFunctions) {\n    let drag = null;\n    function draggable(element, g) {\n        element.addEventListener('mousedown', function (e) {\n            e.preventDefault();\n            //const rect = getContainerRect(g);\n            const parent = SVG.getLeastContainer(g);\n            if (parent != null) {\n                const rect = SVG.getAbsolutePosition(g);\n                drag = {\n                    offsetX: e.clientX - rect.x,\n                    offsetY: e.clientY - rect.y,\n                    target: element,\n                    g: g,\n                    gParentG: parent\n                };\n            }\n            return false;\n        });\n    }\n    DraggableObjectFunctions.draggable = draggable;\n    /*\n    function getContainerRect(e: SVGElement) {\n        const container = SVG.getLeastContainer(e)!;\n        const containerRect = container.getBoundingClientRect();\n        return containerRect;\n    }\n    */\n    function appendDragFunctionsToDocument() {\n        document.onmouseup = function () {\n            drag = null;\n        };\n        document.onmousemove = function (e) {\n            if (drag != null) {\n                if (drag.target != null && drag.target instanceof SVGElement) {\n                    const g = drag.g;\n                    const containerRect = SVG.getAbsolutePosition(drag.gParentG);\n                    const refx = (e.clientX - containerRect.x) - drag.offsetX;\n                    const refy = (e.clientY - containerRect.y) - drag.offsetY;\n                    SVGGExtension.setX(g, refx);\n                    SVGGExtension.setY(g, refy);\n                    //drag.target.x.baseVal.value = e.clientX - drag.offsetx;\n                    //drag.target.y.baseVal.value = e.clientY - drag.offsety;\n                }\n            }\n        };\n    }\n    DraggableObjectFunctions.appendDragFunctionsToDocument = appendDragFunctionsToDocument;\n})(DraggableObjectFunctions || (exports.DraggableObjectFunctions = DraggableObjectFunctions = {}));\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/draggable_object.ts?");

/***/ }),

/***/ "./src/html/enum_extension.ts":
/*!************************************!*\
  !*** ./src/html/enum_extension.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUpdateFlagAppropriateDashArray = exports.updateAppropriateDashArray = exports.tryUpdateAppropriateDashArrayWithUpdateFlag = exports.getLineType = void 0;\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nfunction getLineType(svgLine) {\n    const typeName = ElementExtension.getPropertyStyleValue(svgLine, StyleNames.msoDashStyleName);\n    if (typeName != null) {\n        const type = enums_1.msoDashStyle.toMSODashStyle(typeName);\n        if (type != null) {\n            return type;\n        }\n    }\n    const dashArray = ElementExtension.getPropertyStyleValue(svgLine, \"stroke-dasharray\");\n    if (dashArray != null && dashArray != \"none\") {\n        return enums_1.msoDashStyle.msoLineDash;\n    }\n    else {\n        return enums_1.msoDashStyle.msoLineSolid;\n    }\n}\nexports.getLineType = getLineType;\nfunction computeDashArray(type, width) {\n    const r = [];\n    for (let i = 0; i < enums_1.msoDashStyle.dashArrayDic[type].length; i++) {\n        r.push(`${enums_1.msoDashStyle.dashArrayDic[type][i] * width}px`);\n    }\n    if (r.length == 0) {\n        return \"none\";\n    }\n    else {\n        return r.join(\", \");\n    }\n}\nfunction tryUpdateAppropriateDashArrayWithUpdateFlag(svgLine, updateFlag) {\n    const type = ElementExtension.getPropertyStyleValue(svgLine, StyleNames.msoDashStyleName);\n    if (type == null) {\n        return false;\n    }\n    else if (enums_1.msoDashStyle.toMSODashStyle(type) != null) {\n        const width = ElementExtension.getPropertyStyleNumberValue(svgLine, \"stroke-width\", 2);\n        const newDashArray = computeDashArray(enums_1.msoDashStyle.toMSODashStyle(type), width);\n        const newLineCap = enums_1.msoDashStyle.lineCapDic[type];\n        const oldDashArray = ElementExtension.getPropertyStyleValue(svgLine, \"stroke-dasharray\");\n        const b1 = !(newDashArray == oldDashArray);\n        if (b1) {\n            if (updateFlag) {\n                ElementExtension.setPropertyStyleValue2(svgLine, \"stroke-dasharray\", newDashArray);\n            }\n            else {\n                debugger_1.Debugger.updateFlagLog(svgLine, tryUpdateAppropriateDashArrayWithUpdateFlag, \"!(newDashArray == oldDashArray)\");\n                return true;\n            }\n        }\n        const oldLineCap = ElementExtension.getPropertyStyleValue(svgLine, \"stroke-linecap\");\n        const b2 = !(newLineCap == oldLineCap);\n        if (b2) {\n            if (updateFlag) {\n                ElementExtension.setPropertyStyleValue2(svgLine, \"stroke-linecap\", newLineCap);\n            }\n            else {\n                debugger_1.Debugger.updateFlagLog(svgLine, tryUpdateAppropriateDashArrayWithUpdateFlag, \"!(newLineCap == oldLineCap)\");\n                return true;\n            }\n        }\n        return b1 || b2;\n    }\n    else {\n        return false;\n    }\n}\nexports.tryUpdateAppropriateDashArrayWithUpdateFlag = tryUpdateAppropriateDashArrayWithUpdateFlag;\nfunction updateAppropriateDashArray(svgLine) {\n    return tryUpdateAppropriateDashArrayWithUpdateFlag(svgLine, true);\n}\nexports.updateAppropriateDashArray = updateAppropriateDashArray;\nfunction getUpdateFlagAppropriateDashArray(svgLine) {\n    return tryUpdateAppropriateDashArrayWithUpdateFlag(svgLine, false);\n}\nexports.getUpdateFlagAppropriateDashArray = getUpdateFlagAppropriateDashArray;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/enum_extension.ts?");

/***/ }),

/***/ "./src/html/gui.ts":
/*!*************************!*\
  !*** ./src/html/gui.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getClientRectangle = exports.getNonNullElementById = exports.getInputText = exports.setURLParametersToHTMLElements = exports.getURLParameters = exports.setSVGBoxSize = void 0;\n//namespace GraphTableSVG {\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nfunction setSVGBoxSize(box, item1, item2) {\n    if (item1 instanceof vline_1.Rectangle) {\n        if (item2 instanceof vline_1.Padding) {\n            const w = item1.right + item2.left + item2.right;\n            const h = item1.bottom + item2.top + item2.bottom;\n            setSVGBoxSize(box, w, h);\n        }\n        else {\n            throw new Error();\n        }\n    }\n    else {\n        if (item2 instanceof vline_1.Padding) {\n            throw new Error();\n        }\n        else {\n            const width = `${item1}px`;\n            const height = `${item2}px`;\n            if (box.style.width != width || box.style.height != height) {\n                box.style.width = width;\n                box.style.height = height;\n                box.setAttribute(\"width\", width);\n                box.setAttribute(\"height\", height);\n                box.setAttribute(`viewBox`, `0 0 ${item1} ${item2}`);\n            }\n        }\n    }\n}\nexports.setSVGBoxSize = setSVGBoxSize;\n/**\n * URL\n */\nfunction getURLParameters() {\n    const arg = {};\n    const pair = location.search.substring(1).split('&');\n    for (let i = 0; pair[i]; i++) {\n        const kv = pair[i].split('=');\n        arg[kv[0]] = kv[1];\n    }\n    return arg;\n}\nexports.getURLParameters = getURLParameters;\n/**\n * URLHTML\n */\nfunction setURLParametersToHTMLElements() {\n    const parameters = getURLParameters();\n    Object.keys(parameters).forEach((key) => {\n        const val = parameters[key]; // this  obj\n        const element = document.getElementById(key);\n        if (element != null) {\n            if (element instanceof HTMLTextAreaElement) {\n                element.value = val;\n            }\n        }\n    }, parameters);\n}\nexports.setURLParametersToHTMLElements = setURLParametersToHTMLElements;\n/**\n * HTMLTextAreaElement\n * @param elementID HTMLTextAreaElementID\n */\nfunction getInputText(elementID) {\n    const textbox = document.getElementById(elementID);\n    return textbox.value;\n}\nexports.getInputText = getInputText;\n/**\n * HTMLTextAreaElement\n * @param id HTMLTextAreaElementID\n */\nfunction getNonNullElementById(id) {\n    const tmp = document.getElementById(id);\n    if (tmp == null) {\n        throw Error(\"Null Error\");\n    }\n    else {\n        return tmp;\n    }\n}\nexports.getNonNullElementById = getNonNullElementById;\nfunction getClientRectangle() {\n    const x = window.pageXOffset;\n    const y = window.pageYOffset;\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    return new vline_1.Rectangle(x, y, width, height);\n}\nexports.getClientRectangle = getClientRectangle;\n//}\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/gui.ts?");

/***/ }),

/***/ "./src/html/gui_observer.ts":
/*!**********************************!*\
  !*** ./src/html/gui_observer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.observeSVGSVG = exports.isObserved = exports.observeChangeElement = exports.observeSVGBox = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst GUI = __webpack_require__(/*! ./gui */ \"./src/html/gui.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ./html_functions */ \"./src/html/html_functions.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\n/**\n *\n * @param svgBox\n * @param sizeFunc\n * @param padding\n */\nfunction observeSVGBox(svgBox, sizeFunc, padding = new vline_1.Padding(5, 5, 5, 5)) {\n    let _observer;\n    let observeFunction = (x) => {\n        let b = false;\n        for (let i = 0; i < x.length; i++) {\n            const item = x[i];\n            if (svgBox != item.target) {\n                b = true;\n            }\n        }\n        if (b)\n            GUI.setSVGBoxSize(svgBox, sizeFunc(), padding);\n    };\n    _observer = new MutationObserver(observeFunction);\n    const option = {\n        subtree: true, attributes: true\n    };\n    _observer.observe(svgBox, option);\n}\nexports.observeSVGBox = observeSVGBox;\nfunction dispatchResizeEvent(e) {\n    const children = HTMLFunctions.getChildren(e);\n    children.forEach((v) => {\n        dispatchResizeEvent(v);\n    });\n    if (e instanceof SVGGElement) {\n        var event = document.createEvent(\"HTMLEvents\");\n        event.initEvent(AttributeNames.resizeName, false, true);\n        e.dispatchEvent(event);\n    }\n}\nlet changeElementDic = [];\nlet timerInterval = 100;\nfunction observeChangeElement() {\n    var result = document.evaluate(\"//iframe[@g-src]\", document, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);\n    for (var i = 0; i < result.snapshotLength; i++) {\n        var node = result.snapshotItem(i);\n        changeElementDic.push(node);\n    }\n    if (changeElementDic.length > 0)\n        setTimeout(observeChangeElementTimer, timerInterval);\n}\nexports.observeChangeElement = observeChangeElement;\nfunction observeChangeElementTimer() {\n    for (let i = 0; i < changeElementDic.length; i++) {\n        const element = changeElementDic[i];\n        if (HTMLFunctions.isInsideElement(element)) {\n            const url = element.getAttribute(\"g-src\");\n            element.setAttribute(\"src\", url);\n            element.removeAttribute(\"g-src\");\n            changeElementDic.splice(i, 1);\n            i = -1;\n        }\n    }\n    if (changeElementDic.length > 0)\n        setTimeout(observeChangeElementTimer, timerInterval);\n}\nlet dic = [];\nlet createdObserveSVGSVGTimer = false;\nfunction resizeSVGSVG(svgBox, padding) {\n    //GraphTableSVG.GUI.setSVGBoxSize(svgBox, new Rectangle(0,0,1000,1000), padding);\n    const rect = SVG.getRegion2(svgBox);\n    if (rect.width == 0)\n        rect.width = 1;\n    if (rect.height == 0)\n        rect.height = 1;\n    GUI.setSVGBoxSize(svgBox, rect, padding);\n}\nfunction isObserved(svgBox) {\n    for (let i = 0; i < dic.length; i++) {\n        if (dic[i].svgsvg === svgBox) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.isObserved = isObserved;\nfunction observeSVGSVG(svgBox, padding = new vline_1.Padding(0, 0, 0, 0)) {\n    if (isObserved(svgBox)) {\n        return;\n    }\n    let _observer;\n    let observeFunction = (x) => {\n        const gShrink = ElementExtension.gtGetAttributeBooleanWithUndefined(svgBox, enums_1.OriginalSVGSVGAttributes.ShrinkAttributeName);\n        let b = false;\n        for (let i = 0; i < x.length; i++) {\n            const item = x[i];\n            if (svgBox != item.target) {\n                b = true;\n            }\n        }\n        if (gShrink === true && b) {\n            resizeSVGSVG(svgBox, padding);\n        }\n    };\n    _observer = new MutationObserver(observeFunction);\n    const option = {\n        subtree: true, attributes: true\n    };\n    _observer.observe(svgBox, option);\n    dic.push({ svgsvg: svgBox, visible: false, padding: padding });\n    if (!createdObserveSVGSVGTimer) {\n        createdObserveSVGSVGTimer = true;\n        setTimeout(observeSVGSVGTimer, timerInterval);\n    }\n}\nexports.observeSVGSVG = observeSVGSVG;\n/**\n * SVGSVGElemen\n */\nfunction observeSVGSVGTimer() {\n    dic.forEach((v, i) => {\n        const nowVisible = !SVG.isSVGSVGHidden(v.svgsvg);\n        if (v.visible) {\n            if (!nowVisible) {\n                v.visible = false;\n            }\n        }\n        else {\n            if (nowVisible) {\n                dispatchResizeEvent(v.svgsvg);\n                const b = ElementExtension.gtGetAttributeBooleanWithUndefined(v.svgsvg, enums_1.OriginalSVGSVGAttributes.ShrinkAttributeName);\n                if (b !== undefined && b === true)\n                    resizeSVGSVG(v.svgsvg, v.padding);\n                v.visible = true;\n            }\n        }\n    });\n    setTimeout(observeSVGSVGTimer, timerInterval);\n}\n//}\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/gui_observer.ts?");

/***/ }),

/***/ "./src/html/html_functions.ts":
/*!************************************!*\
  !*** ./src/html/html_functions.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAttributeFromAncestors = exports.getSubAttributeFromAncestors = exports.getSVGSVGAncestor = exports.removeInvisibleCharacters = exports.isInsideElement = exports.getChildByNodeName = exports.getChildren = exports.getDescendants = exports.getDescendantsByPostorder = exports.getDescendantsByPreorder = exports.isShow = exports.copyAttributes = exports.getAncestorAttribute = exports.getTNodes = exports.NodeOrder = void 0;\nconst GUI = __webpack_require__(/*! ./gui */ \"./src/html/gui.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\n//export namespace HTMLFunctions {\nvar NodeOrder;\n(function (NodeOrder) {\n    NodeOrder[NodeOrder[\"Preorder\"] = 0] = \"Preorder\";\n    NodeOrder[NodeOrder[\"Postorder\"] = 1] = \"Postorder\";\n})(NodeOrder || (exports.NodeOrder = NodeOrder = {}));\nfunction getTNodes(e) {\n    const tNodes = getChildren(e).filter((v) => v.getAttribute(AttributeNames.customElement) == \"t\");\n    if (tNodes.length > 0) {\n        tNodes.forEach((v, i) => {\n            v.removeAttribute(AttributeNames.customElement);\n            if (i > 0 && !v.hasAttribute(\"newline\"))\n                v.setAttribute(\"newline\", \"true\");\n        });\n        return tNodes;\n    }\n    else {\n        return null;\n    }\n}\nexports.getTNodes = getTNodes;\nfunction getAncestorAttribute(e, attr) {\n    if (e.hasAttribute(attr)) {\n        return e.getAttribute(attr);\n    }\n    else {\n        if (e.parentElement == null) {\n            return null;\n        }\n        else {\n            return getAncestorAttribute(e.parentElement, attr);\n        }\n    }\n}\nexports.getAncestorAttribute = getAncestorAttribute;\nfunction copyAttributes(from, to) {\n    for (let i = 0; i < from.attributes.length; i++) {\n        const attr = from.attributes.item(i);\n        to.setAttribute(attr.name, attr.value);\n    }\n}\nexports.copyAttributes = copyAttributes;\n/*\nfunction isShow2(e: HTMLElement | SVGElement, isParentWindow : boolean = false): boolean {\n    \n    const p = isParentWindow ? window.parent.getComputedStyle(e) : window.getComputedStyle(e);\n    const disp = p.display;\n    const vis = p.visibility;\n    if (disp == \"none\" || vis == \"hidden\") {\n        return false;\n    } else {\n        const parent = e.parentElement;\n        if (parent == null) {\n            if(isParentWindow){\n                return true;\n            }else{\n                if(window == window.parent){\n                    return true;\n                }else{\n                    return isShow2(<HTMLElement>window.frameElement, true);\n                }\n            }\n        } else {\n            return isShow2(parent, isParentWindow);\n        }\n    }\n\n}\n*/\nfunction isShow(e) {\n    const p = e.getBoundingClientRect();\n    return !(p.top == 0 && p.left == 0 && p.width == 0 && p.height == 0);\n    //return isShow2(e);\n}\nexports.isShow = isShow;\nfunction getDescendantsByPreorder(e) {\n    const r = [];\n    r.push(e);\n    for (let i = 0; i < e.children.length; i++) {\n        const p = e.children.item(i);\n        if (p instanceof Element) {\n            getDescendantsByPreorder(p).forEach((v) => r.push(v));\n        }\n    }\n    return r;\n}\nexports.getDescendantsByPreorder = getDescendantsByPreorder;\nfunction getDescendantsByPostorder(e) {\n    const r = [];\n    for (let i = 0; i < e.children.length; i++) {\n        const p = e.children.item(i);\n        if (p instanceof Element) {\n            getDescendantsByPostorder(p).forEach((v) => r.push(v));\n        }\n    }\n    r.push(e);\n    return r;\n}\nexports.getDescendantsByPostorder = getDescendantsByPostorder;\nfunction getDescendants(e, order = NodeOrder.Preorder) {\n    if (order == NodeOrder.Preorder) {\n        return getDescendantsByPreorder(e);\n    }\n    else {\n        return getDescendantsByPostorder(e);\n    }\n}\nexports.getDescendants = getDescendants;\nfunction getChildren(e) {\n    const r = [];\n    for (let i = 0; i < e.children.length; i++) {\n        const p = e.children.item(i);\n        if (p instanceof Element) {\n            r.push(p);\n        }\n    }\n    return r;\n}\nexports.getChildren = getChildren;\nfunction getChildByNodeName(e, name) {\n    const p = getChildren(e).filter((v) => v.nodeName.toLowerCase() == name.toLowerCase());\n    if (p.length > 0) {\n        return p[0];\n    }\n    else {\n        return null;\n    }\n}\nexports.getChildByNodeName = getChildByNodeName;\nfunction isInsideElement(element) {\n    const win = GUI.getClientRectangle();\n    const ele = element.getBoundingClientRect();\n    const b1 = ele.left <= win.width && ele.top <= win.height;\n    const b2 = ele.right <= win.width && ele.top <= win.height;\n    const b3 = ele.left <= win.width && ele.bottom <= win.height;\n    const b4 = ele.right <= win.width && ele.bottom <= win.height;\n    return b1 || b2 || b3 || b4;\n}\nexports.isInsideElement = isInsideElement;\nfunction removeInvisibleCharacters(text) {\n    let prevSpace = true;\n    var l = text.split(\"\\n\");\n    var newContent = l.join('');\n    let s = \"\";\n    for (let j = 0; j < newContent.length; j++) {\n        const character = newContent[j];\n        const value = character.charCodeAt(0);\n        if (value >= 32 && !(prevSpace && value == 32)) {\n            s += character;\n        }\n        if (value == 32) {\n            prevSpace = true;\n        }\n        else {\n            prevSpace = false;\n        }\n    }\n    return s;\n}\nexports.removeInvisibleCharacters = removeInvisibleCharacters;\nfunction getSVGSVGAncestor(e) {\n    const parent = e.parentElement;\n    if (parent == null) {\n        return null;\n    }\n    else {\n        if (parent instanceof SVGSVGElement) {\n            return parent;\n        }\n        else {\n            return getSVGSVGAncestor(parent);\n        }\n    }\n}\nexports.getSVGSVGAncestor = getSVGSVGAncestor;\nfunction getSubAttributeFromAncestorsSub(e, subName, output) {\n    const attrs = e.attributes;\n    for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs.item(i);\n        const ps = attr.name.split(\"::\");\n        if (ps.length == 2 && ps[0] == subName) {\n            if (!output.has(ps[1])) {\n                output.set(ps[1], attr.value);\n            }\n        }\n    }\n    if (e.parentElement != null) {\n        getSubAttributeFromAncestorsSub(e.parentElement, subName, output);\n    }\n}\nfunction getSubAttributeFromAncestors(e, subName) {\n    const output = new Map();\n    getSubAttributeFromAncestorsSub(e, subName, output);\n    return output;\n}\nexports.getSubAttributeFromAncestors = getSubAttributeFromAncestors;\nfunction getAttributeFromAncestors(e, attrName) {\n    const attr = e.getAttribute(attrName);\n    if (attr != null) {\n        return attr;\n    }\n    else {\n        if (e.parentElement != null) {\n            return getAttributeFromAncestors(e.parentElement, attrName);\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.getAttributeFromAncestors = getAttributeFromAncestors;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/html_functions.ts?");

/***/ }),

/***/ "./src/html/index.ts":
/*!***************************!*\
  !*** ./src/html/index.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GUI = exports.DraggableObject = exports.GUIObserver = exports.HTMLFunctions = exports.CSS = void 0;\nconst GUIObserver = __webpack_require__(/*! ./gui_observer */ \"./src/html/gui_observer.ts\");\nexports.GUIObserver = GUIObserver;\n//import * as SVG from \"../interface/svg\"\nconst CSS = __webpack_require__(/*! ./css */ \"./src/html/css.ts\");\nexports.CSS = CSS;\nconst HTMLFunctions = __webpack_require__(/*! ./html_functions */ \"./src/html/html_functions.ts\");\nexports.HTMLFunctions = HTMLFunctions;\nconst DraggableObject = __webpack_require__(/*! ./draggable_object */ \"./src/html/draggable_object.ts\");\nexports.DraggableObject = DraggableObject;\nconst GUI = __webpack_require__(/*! ./gui */ \"./src/html/gui.ts\");\nexports.GUI = GUI;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/index.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TypeDoc = exports.Interfaces = exports.Debug = exports.Console = exports.Options = exports.Logics = exports.Objects = exports.Common = exports.HTML = void 0;\nconst HTML = __webpack_require__(/*! ./html/index */ \"./src/html/index.ts\");\nexports.HTML = HTML;\nconst Common = __webpack_require__(/*! ./common/index */ \"./src/common/index.ts\");\nexports.Common = Common;\nconst Objects = __webpack_require__(/*! ./objects/index */ \"./src/objects/index.ts\");\nexports.Objects = Objects;\nconst Options = __webpack_require__(/*! ./options/index */ \"./src/options/index.ts\");\nexports.Options = Options;\nconst Logics = __webpack_require__(/*! ./logics/index */ \"./src/logics/index.ts\");\nexports.Logics = Logics;\nconst Console = __webpack_require__(/*! ./options/console */ \"./src/options/console.ts\");\nexports.Console = Console;\nconst Debug = __webpack_require__(/*! ./debug/debug */ \"./src/debug/debug.ts\");\nexports.Debug = Debug;\nconst Interfaces = __webpack_require__(/*! ./interfaces/index */ \"./src/interfaces/index.ts\");\nexports.Interfaces = Interfaces;\nconst TypeDoc = __webpack_require__(/*! ./typedoc/index */ \"./src/typedoc/index.ts\");\nexports.TypeDoc = TypeDoc;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/index.ts?");

/***/ }),

/***/ "./src/interfaces/element_extension.ts":
/*!*********************************************!*\
  !*** ./src/interfaces/element_extension.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.collectAttributesByPrefix = exports.hasStyleAttribute = exports.setIsLoaded = exports.getIsLoaded = exports.gtGetAttributes = exports.setAttributeNumber = exports.gtGetAttribute = exports.gtGetAttributeBooleanWithUndefined = exports.gtGetInheritedAttributeString = exports.gtGetAttributeStringWithUndefined = exports._getAttribute = exports._getAttributeNumber = exports.gtGetAttributeNumberWithUndefined = exports.gtGetAttributeNumberWithoutNull = exports.gtGetAttributeNumber = exports.setPropertyStyleValue2 = exports.setPropertyStyleValue = exports.getActiveStyle = exports.getPropertyStyleNumberValue = exports.getInheritedPropertyStyleValueWithDefault = exports.getPropertyStyleValueWithDefault = exports.gtGetStyleBooleanWithUndefined = exports.getInheritedPropertyStyleValue = exports.getPropertyStyleValue = void 0;\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nfunction getPropertyStyleValue(item, name) {\n    const p = item.style.getPropertyValue(name).trim();\n    if (p.length == 0) {\n        const r = item.getAttribute(\"class\");\n        if (r == null) {\n            return null;\n        }\n        else {\n            const css = getComputedStyle(item);\n            //let css = GraphTableSVG.SVG.getStyleSheet(r);\n            //if (css == null) css = getComputedStyle(item);\n            const p2 = css.getPropertyValue(name).trim();\n            if (p2.length == 0) {\n                return null;\n            }\n            else {\n                return p2;\n            }\n        }\n    }\n    else {\n        return p;\n    }\n}\nexports.getPropertyStyleValue = getPropertyStyleValue;\nfunction getInheritedPropertyStyleValue(item, name) {\n    const p = item.style.getPropertyValue(name).trim();\n    if (p.length == 0) {\n        const r = item.getAttribute(\"class\");\n        const css = getComputedStyle(item);\n        const p2 = css.getPropertyValue(name).trim();\n        if (p2.length == 0) {\n            return null;\n        }\n        else {\n            return p2;\n        }\n    }\n    else {\n        return p;\n    }\n}\nexports.getInheritedPropertyStyleValue = getInheritedPropertyStyleValue;\nfunction gtGetStyleBooleanWithUndefined(item, name) {\n    const value = getPropertyStyleValue(item, name);\n    if (value != null) {\n        return value == \"true\";\n    }\n    else {\n        return undefined;\n    }\n}\nexports.gtGetStyleBooleanWithUndefined = gtGetStyleBooleanWithUndefined;\nfunction getPropertyStyleValueWithDefault(item, name, defaultValue) {\n    const p = getPropertyStyleValue(item, name);\n    if (p == null) {\n        return defaultValue;\n    }\n    else {\n        return p;\n    }\n}\nexports.getPropertyStyleValueWithDefault = getPropertyStyleValueWithDefault;\nfunction getInheritedPropertyStyleValueWithDefault(item, name, defaultValue) {\n    const p = getInheritedPropertyStyleValue(item, name);\n    if (p == null) {\n        return defaultValue;\n    }\n    else {\n        return p;\n    }\n}\nexports.getInheritedPropertyStyleValueWithDefault = getInheritedPropertyStyleValueWithDefault;\nfunction getPropertyStyleNumberValue(item, name, defaultValue) {\n    const p = getPropertyStyleValue(item, name);\n    if (p != null) {\n        return CommonFunctions.toPX(p);\n    }\n    else {\n        return defaultValue;\n    }\n}\nexports.getPropertyStyleNumberValue = getPropertyStyleNumberValue;\nfunction getActiveStyle(item) {\n    //const p: Element = this;\n    const r = item.getAttribute(\"class\");\n    if (r == null) {\n        return item.style;\n    }\n    else {\n        return getComputedStyle(item);\n    }\n}\nexports.getActiveStyle = getActiveStyle;\nfunction setPropertyStyleValue(item, name, value) {\n    item.style.setProperty(name, value);\n}\nexports.setPropertyStyleValue = setPropertyStyleValue;\nfunction setPropertyStyleValue2(item, name, value) {\n    const style = getComputedStyle(item);\n    const oldValue = style.getPropertyValue(name);\n    if (oldValue == value) {\n        return false;\n    }\n    else {\n        item.style.setProperty(name, value);\n        return true;\n    }\n}\nexports.setPropertyStyleValue2 = setPropertyStyleValue2;\nfunction gtGetAttributeNumber(item, name, defaultValue) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return Number(value);\n    }\n    else {\n        return defaultValue;\n    }\n}\nexports.gtGetAttributeNumber = gtGetAttributeNumber;\nfunction gtGetAttributeNumberWithoutNull(item, name, defaultValue) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return Number(value);\n    }\n    else {\n        return defaultValue;\n    }\n}\nexports.gtGetAttributeNumberWithoutNull = gtGetAttributeNumberWithoutNull;\nfunction gtGetAttributeNumberWithUndefined(item, name) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return Number(value);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.gtGetAttributeNumberWithUndefined = gtGetAttributeNumberWithUndefined;\nfunction _getAttributeNumber(item, name, remove) {\n    const value = item.getAttribute(name);\n    if (remove) {\n        item.removeAttribute(name);\n    }\n    if (value != null) {\n        return Number(value);\n    }\n    else {\n        return null;\n    }\n}\nexports._getAttributeNumber = _getAttributeNumber;\nfunction _getAttribute(item, name, remove) {\n    const value = item.getAttribute(name);\n    if (remove) {\n        item.removeAttribute(name);\n    }\n    return value;\n}\nexports._getAttribute = _getAttribute;\nfunction gtGetAttributeStringWithUndefined(item, name) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return value;\n    }\n    else {\n        return undefined;\n    }\n}\nexports.gtGetAttributeStringWithUndefined = gtGetAttributeStringWithUndefined;\nfunction gtGetInheritedAttributeString(item, name) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return value;\n    }\n    else {\n        if (item.parentElement == null) {\n            return undefined;\n        }\n        else {\n            return gtGetInheritedAttributeString(item.parentElement, name);\n        }\n    }\n}\nexports.gtGetInheritedAttributeString = gtGetInheritedAttributeString;\nfunction gtGetAttributeBooleanWithUndefined(item, name) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return value == \"true\";\n    }\n    else {\n        return undefined;\n    }\n}\nexports.gtGetAttributeBooleanWithUndefined = gtGetAttributeBooleanWithUndefined;\nfunction gtGetAttribute(item, name, defaultValue) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return value;\n    }\n    else {\n        return defaultValue;\n    }\n}\nexports.gtGetAttribute = gtGetAttribute;\nfunction setAttributeNumber(item, name, value) {\n    item.setAttribute(name, (0, vline_1.round100)(value).toString());\n}\nexports.setAttributeNumber = setAttributeNumber;\nfunction gtGetAttributes(item) {\n    //const p: Element = this;\n    const r = [];\n    for (let i = 0; i < item.attributes.length; i++) {\n        const subitem = item.attributes.item(i);\n        if (subitem != null) {\n            r.push({ name: subitem.name, value: subitem.value });\n        }\n    }\n    return r;\n}\nexports.gtGetAttributes = gtGetAttributes;\nfunction getIsLoaded(item) {\n    const item2 = item;\n    if (item2.__isLoaded === undefined) {\n        return undefined;\n    }\n    else {\n        return item2.__isLoaded;\n    }\n}\nexports.getIsLoaded = getIsLoaded;\nfunction setIsLoaded(item, b) {\n    const item2 = item;\n    item2.__isLoaded = b;\n}\nexports.setIsLoaded = setIsLoaded;\nfunction hasStyleAttribute(item, name) {\n    const p = getPropertyStyleValue(item, name);\n    return p !== null;\n}\nexports.hasStyleAttribute = hasStyleAttribute;\nfunction collectAttributesByPrefix(e, prefix) {\n    const r = new Map();\n    for (let i = 0; i < e.attributes.length; i++) {\n        const attr = e.attributes.item(i);\n        if (attr != null && attr.name.length > prefix.length) {\n            const attrNames = attr.name.split(\":\");\n            if (attrNames.length == 2 && attrNames[0] == prefix) {\n                r.set(attrNames[1], attr.value);\n            }\n        }\n    }\n    return r;\n}\nexports.collectAttributesByPrefix = collectAttributesByPrefix;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/element_extension.ts?");

/***/ }),

/***/ "./src/interfaces/extensions.ts":
/*!**************************************!*\
  !*** ./src/interfaces/extensions.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getPathLocations = exports.setPathLocations = exports.getEmphasis = exports.setEmphasis = exports.setTextContent = exports.tryGetPropertyValue = void 0;\nconst SVGTextBox = __webpack_require__(/*! ./svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nfunction tryGetPropertyValue(item, name) {\n    //const p: CSSStyleDeclaration = this;\n    const r = item.getPropertyValue(name).trim();\n    if (r.length == 0) {\n        return null;\n    }\n    else {\n        return r;\n    }\n}\nexports.tryGetPropertyValue = tryGetPropertyValue;\n/**\n * SVGTextElement\n * @param text \n * @param isLatexMode TrueLatex\n */\nfunction setTextContent(item, text, isLatexMode = false) {\n    SVGTextBox.setTextToTextPath(item, text, isLatexMode);\n}\nexports.setTextContent = setTextContent;\n/**\n * SVGLineElement\n * @param b TrueFalse\n */\nfunction setEmphasis(item, value) {\n    CSS.setGraphTableCSS();\n    if (getEmphasis(item) && !value) {\n        const tmp = item.getAttribute(AttributeNames.cellTemporaryBorderClass);\n        if (tmp != null) {\n            item.setAttribute(\"class\", tmp);\n            item.removeAttribute(AttributeNames.cellTemporaryBorderClass);\n        }\n        else {\n            item.removeAttribute(\"class\");\n            item.removeAttribute(AttributeNames.cellTemporaryBorderClass);\n        }\n    }\n    else if (!getEmphasis(item) && value) {\n        const lineClass = item.getAttribute(\"class\");\n        item.setAttribute(\"class\", AttributeNames.cellTemporaryBorderClass);\n        if (lineClass != null) {\n            item.setAttribute(AttributeNames.cellTemporaryBorderClass, lineClass);\n        }\n    }\n}\nexports.setEmphasis = setEmphasis;\nfunction getEmphasis(item) {\n    const emp = item.getAttribute(\"class\");\n    if (emp != null) {\n        return emp == AttributeNames.cellEmphasisBorderClass;\n    }\n    else {\n        return false;\n    }\n}\nexports.getEmphasis = getEmphasis;\n/**\n * SVGPathElement\n * @param points\n */\nfunction setPathLocations(item, points) {\n    let s = \"\";\n    for (let i = 0; i < points.length; i++) {\n        s += `${i == 0 ? \"M\" : \"L\"} ${points[i][0]} ${points[i][1]} `;\n    }\n    //points.forEach((x, y) => s += `M ${x} ${y} `);\n    item.setAttribute(\"d\", s);\n}\nexports.setPathLocations = setPathLocations;\n/**\n * SVGPathElement\n */\nfunction getPathLocations(item) {\n    const info = item.getAttribute(\"d\");\n    if (info == null)\n        return [];\n    const r = [];\n    let pos = [0, 0];\n    let pathType = \"\";\n    info.split(\" \").forEach((v, i) => {\n        if (i % 3 == 0) {\n            pathType = v;\n        }\n        else if (i % 3 == 1) {\n            pos[0] = parseInt(v);\n        }\n        else {\n            pos[1] = parseInt(v);\n            r.push(pos);\n            pos = [0, 0];\n        }\n    });\n    return r;\n}\nexports.getPathLocations = getPathLocations;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/extensions.ts?");

/***/ }),

/***/ "./src/interfaces/index.ts":
/*!*********************************!*\
  !*** ./src/interfaces/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SVG = void 0;\nconst SVG = __webpack_require__(/*! ./svg */ \"./src/interfaces/svg.ts\");\nexports.SVG = SVG;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/index.ts?");

/***/ }),

/***/ "./src/interfaces/svg.ts":
/*!*******************************!*\
  !*** ./src/interfaces/svg.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSVGHidden = exports.isSVGSVGHidden = exports.getAbsolutePosition = exports.getLeastContainer = exports.getSVGSVG = exports.getRegion2 = exports.getStyleSheet = exports.setClass = exports.createTextPath2 = exports.createTextPath = exports.createMarker = exports.createCircle = exports.resetStyle = exports.createGroup = exports.createCellRectangle = exports.createRectangle = exports.createText = exports.createLine = exports.getNewID = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\n//import * as CSS from \"./css\";\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGGExtension = __webpack_require__(/*! ./svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\n//export namespace SVG {\nlet idCounter = 0;\nfunction getNewID() {\n    return idCounter++;\n}\nexports.getNewID = getNewID;\n/**\n * SVGLineElement\n * @param x X\n * @param y Y\n * @param x2 X\n * @param y2 Y\n * @param className SVGLineElement\n * @returns SVGLineElement\n */\nfunction createLine(x, y, x2, y2, className) {\n    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n    line1.x1.baseVal.value = x;\n    line1.x2.baseVal.value = x2;\n    line1.y1.baseVal.value = y;\n    line1.y2.baseVal.value = y2;\n    //line1.style.color = \"black\";\n    line1.setAttribute(\"class\", className);\n    /*\n    if (className != null) {\n    } else {\n        line1.style.stroke = \"black\";\n    }\n    */\n    //line1.style.visibility = \"hidden\";\n    //line1.style.strokeWidth = `${5}`\n    //line1.setAttribute('stroke', 'black');\n    return line1;\n}\nexports.createLine = createLine;\n/**\n * SVGTextElement\n * @param className SVG\n * @returns SVGTextElement\n */\nfunction createText(className) {\n    const _svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    _svgText.setAttribute(AttributeNames.objectIDName, (idCounter++).toString());\n    //_svgText.style.textAnchor = \"middle\";\n    _svgText.setAttribute(\"class\", className);\n    /*\n    if (className == null) {\n        \n    } else {\n    }\n    */\n    return _svgText;\n}\nexports.createText = createText;\n/**\n * SVGRectElement\n * @param parent SVG\n * @param className SVG\n * @returns SVGRectElement\n */\nfunction createRectangle(parent, className = null) {\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    parent.appendChild(rect);\n    rect.width.baseVal.value = 30;\n    rect.height.baseVal.value = 30;\n    if (className == null) {\n        rect.style.fill = \"white\";\n        rect.style.stroke = \"black\";\n        rect.style.strokeWidth = \"1pt\";\n    }\n    else {\n        rect.setAttribute(\"class\", className);\n        //const dashStyle = rect.getPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName);\n        //if (dashStyle != null) msoDashStyle.setStyle(rect, dashStyle);\n        const width = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultWidth, null);\n        if (width != null) {\n            rect.width.baseVal.value = width;\n        }\n        const height = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultHeight, null);\n        if (height != null) {\n            rect.height.baseVal.value = height;\n        }\n    }\n    return rect;\n}\nexports.createRectangle = createRectangle;\n/**\n * SVGRectElement\n * @param parent SVG\n * @param className SVG\n * @returns SVGRectElement\n */\nfunction createCellRectangle(parent, className = null) {\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    rect.width.baseVal.value = 0;\n    parent.appendChild(rect);\n    if (className != null) {\n        rect.setAttribute(\"class\", className);\n    }\n    return rect;\n}\nexports.createCellRectangle = createCellRectangle;\n/**\n * SVGGElement\n * @param className SVG\n * @returns SVGGElement\n */\nfunction createGroup(parent) {\n    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    g.setAttribute(AttributeNames.objectIDName, (idCounter++).toString());\n    /*\n    if (className != null) {\n        g.setAttribute(\"class\", className);\n    }\n    */\n    if (parent != null)\n        parent.appendChild(g);\n    return g;\n}\nexports.createGroup = createGroup;\n/**\n * Style\n * @param style Style\n */\nfunction resetStyle(style) {\n    style.stroke = null;\n    style.strokeWidth = null;\n    style.fill = null;\n    style.fontSize = null;\n    style.fontWeight = null;\n    style.fontFamily = null;\n    /*\n    style.removeProperty(AttributeNames.Style.paddingTop);\n    style.removeProperty(AttributeNames.Style.paddingLeft);\n    style.removeProperty(AttributeNames.Style.paddingRight);\n    style.removeProperty(AttributeNames.Style.paddingBottom);\n    */\n}\nexports.resetStyle = resetStyle;\n/**\n * SVGCircleElement\n * @param parent SVG\n * @param className SVG\n * @returns SVGCircleElement\n */\nfunction createCircle(parent, className = null) {\n    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    parent.appendChild(circle);\n    circle.r.baseVal.value = AttributeNames.defaultCircleRadius;\n    if (className == null) {\n        circle.style.stroke = \"black\";\n        circle.style.strokeWidth = \"1pt\";\n        circle.style.fill = \"white\";\n    }\n    else {\n        circle.setAttribute(\"class\", className);\n        const radius = ElementExtension.getPropertyStyleNumberValue(circle, StyleNames.defaultRadius, null);\n        if (radius != null) {\n            circle.r.baseVal.value = radius;\n        }\n        //const dashStyle = circle.getPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName);\n        //if (dashStyle != null) msoDashStyle.setStyle(circle, dashStyle);\n    }\n    //circle.style.fill = \"#ffffff\";\n    circle.cx.baseVal.value = 0;\n    circle.cy.baseVal.value = 0;\n    //circle.r.baseVal.value = r;\n    return circle;\n}\nexports.createCircle = createCircle;\n/**\n * EdgeSVGMarkerElement\n * @param className SVG\n * @returns SVGMarkerElement\n */\nfunction createMarker(option = {}) {\n    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');\n    //const poly = <SVGPolygonElement>document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    poly.setAttribute(\"d\", \"M 0 0 L 10 5 L 0 10 z\");\n    //poly.setAttribute(\"points\", \"0,0 0,10 10,5\");\n    if (option.color != undefined) {\n        ElementExtension.setPropertyStyleValue(poly, \"stroke\", option.color);\n        ElementExtension.setPropertyStyleValue(marker, \"fill\", option.color);\n    }\n    else {\n        ElementExtension.setPropertyStyleValue(poly, \"stroke\", \"black\");\n        ElementExtension.setPropertyStyleValue(marker, \"fill\", \"black\");\n    }\n    ElementExtension.setPropertyStyleValue(poly, \"stroke-width\", \"1px\");\n    //poly.setAttribute(\"data-skip\", \"1\");\n    marker.setAttribute(\"markerUnits\", \"userSpaceOnUse\");\n    marker.setAttribute(\"markerHeight\", \"15\");\n    marker.setAttribute(\"markerWidth\", \"15\");\n    marker.setAttribute(\"refX\", \"10\");\n    marker.setAttribute(\"refY\", \"5\");\n    //marker.setAttribute(\"data-skip\", \"1\");\n    //marker.refX.baseVal.value = 10;\n    //marker.refY.baseVal.value = 5;\n    marker.setAttribute(\"preserveAspectRatio\", \"none\");\n    marker.setAttribute(\"orient\", \"auto\");\n    marker.setAttribute(\"viewBox\", \"0 0 10 10\");\n    //marker.setAttribute(\"stroke-width\", \"1px\");\n    marker.appendChild(poly);\n    if (option.className != null) {\n        //marker.setAttribute(\"class\", option.className);\n        //poly.setAttribute(\"class\", className);\n    }\n    else {\n    }\n    return [marker, poly];\n}\nexports.createMarker = createMarker;\n/**\n * SVGTextElementSVGTextPathElement\n * @param className SVGTextPathElement\n * @returns SVGTextElementSVGTextPathElement\n */\nfunction createTextPath(className = null) {\n    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    ;\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');\n    text.appendChild(path);\n    if (className == null) {\n        path.style.fill = \"black\";\n        path.style.fontSize = \"14px\";\n        path.style.fontWeight = \"bold\";\n        path.style.fontFamily = 'Times New Roman';\n    }\n    else {\n        path.setAttribute(\"class\", className);\n    }\n    return [text, path];\n}\nexports.createTextPath = createTextPath;\n/**\n* SVGTextElementSVGTextPathElement\n* @param className SVGTextPathElement\n* @returns SVGTextElementSVGTextPathElement\n*/\nfunction createTextPath2(className) {\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');\n    if (className !== undefined) {\n        path.setAttribute(\"class\", className);\n    }\n    return path;\n}\nexports.createTextPath2 = createTextPath2;\n/**\n * SVG\n * @param svg SVG\n * @param className \n */\nfunction setClass(svg, className = null) {\n    if (className == null) {\n        svg.removeAttribute(\"class\");\n    }\n    else {\n        resetStyle(svg.style);\n        svg.setAttribute(\"class\", className);\n    }\n}\nexports.setClass = setClass;\n/**\n * \n * @param name\n */\nfunction getStyleSheet(name) {\n    const name2 = \".\" + name;\n    for (let i = 0; i < document.styleSheets.length; i++) {\n        const sheet = document.styleSheets.item(i);\n        const rules = sheet.cssRules || sheet.rules;\n        if (rules != null) {\n            for (let j = 0; j < rules.length; j++) {\n                const rule = rules.item(j);\n                if (rule.selectorText == name2) {\n                    return rule.style;\n                }\n            }\n        }\n    }\n    return null;\n}\nexports.getStyleSheet = getStyleSheet;\nfunction getRegion2(e) {\n    if (e instanceof SVGSVGElement) {\n        const elements = HTMLFunctions.getChildren(e).filter((v) => v instanceof SVGElement);\n        const rectangles = elements.map((v) => getRegion2(v));\n        const parentRect = e.getBoundingClientRect();\n        const rect = vline_1.Rectangle.merge(rectangles);\n        let r = new vline_1.Rectangle();\n        r.x = 0;\n        r.y = 0;\n        r.width = rect.width + (rect.x - parentRect.left);\n        r.height = rect.height + (rect.y - parentRect.top);\n        return r;\n    }\n    else if (e instanceof SVGGElement) {\n        /*\n        const elements = <SVGElement[]>HTMLFunctions.getChildren(e).filter((v) => v instanceof SVGElement);\n        const rectangles = elements.map((v) => getRegion2(v));\n        const region = Rectangle.merge(rectangles);\n                        \n        return region;\n        */\n        const rect = e.getBoundingClientRect();\n        let r = new vline_1.Rectangle(rect.left, rect.top, rect.width, rect.height);\n        return r;\n    }\n    else {\n        const rect = e.getBoundingClientRect();\n        let r = new vline_1.Rectangle(rect.left, rect.top, rect.width, rect.height);\n        return r;\n    }\n}\nexports.getRegion2 = getRegion2;\nfunction getSVGSVG(e) {\n    if (e instanceof SVGSVGElement) {\n        return e;\n    }\n    else {\n        const parent = e.parentElement;\n        if (parent instanceof SVGElement) {\n            return getSVGSVG(parent);\n        }\n        else {\n            throw Error(\"svgsvg\");\n        }\n    }\n}\nexports.getSVGSVG = getSVGSVG;\nfunction getLeastContainer(e) {\n    const parent = e.parentElement;\n    if (parent instanceof SVGSVGElement || parent instanceof SVGGElement) {\n        return parent;\n    }\n    else if (parent == null) {\n        return null;\n    }\n    else {\n        if (parent instanceof SVGElement) {\n            return getLeastContainer(parent);\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.getLeastContainer = getLeastContainer;\nfunction getAbsolutePosition(g) {\n    if (g instanceof SVGSVGElement) {\n        const rect = g.getBoundingClientRect();\n        return { x: rect.left, y: rect.top };\n    }\n    else {\n        const parent = getLeastContainer(g);\n        if (parent instanceof SVGSVGElement) {\n            const rect = parent.getBoundingClientRect();\n            const x = rect.left + SVGGExtension.getX(g);\n            const y = rect.top + SVGGExtension.getY(g);\n            return { x: x, y: y };\n        }\n        else if (parent instanceof SVGGElement) {\n            const rect = getAbsolutePosition(parent);\n            const x = rect.x + SVGGExtension.getX(g);\n            const y = rect.y + SVGGExtension.getY(g);\n            return { x: x, y: y };\n        }\n        else {\n            throw Error(\"error\");\n        }\n    }\n}\nexports.getAbsolutePosition = getAbsolutePosition;\nfunction isSVGSVGHidden(e) {\n    const svgsvg = getSVGSVG(e);\n    return !HTMLFunctions.isShow(svgsvg);\n}\nexports.isSVGSVGHidden = isSVGSVGHidden;\nfunction isSVGHidden(e) {\n    if (e instanceof SVGSVGElement) {\n        return false;\n    }\n    else {\n        const p = getComputedStyle(e);\n        const disp = p.display;\n        const vis = p.visibility;\n        if (disp == \"none\" || vis == \"hidden\") {\n            return true;\n        }\n        else {\n            const parent = e.parentElement;\n            if (parent instanceof SVGElement) {\n                return isSVGHidden(parent);\n            }\n            else {\n                throw Error(\"svg\");\n            }\n        }\n    }\n}\nexports.isSVGHidden = isSVGHidden;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/svg.ts?");

/***/ }),

/***/ "./src/interfaces/svg_element_extension.ts":
/*!*************************************************!*\
  !*** ./src/interfaces/svg_element_extension.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getBackgroundVisible = exports.getStrokeColor = exports.getStrokeWidth = exports.getBackgroundColor = exports.getY = exports.getX = exports.setPaddingBottom = exports.setPaddingRight = exports.setPaddingTop = exports.setPaddingLeft = exports.getPaddingBottom = exports.getPaddingRight = exports.getPaddingTop = exports.getPaddingLeft = void 0;\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./src/interfaces/element_extension.ts\");\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nfunction getPaddingLeft(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingLeft, 0);\n}\nexports.getPaddingLeft = getPaddingLeft;\nfunction getPaddingTop(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingTop, 0);\n}\nexports.getPaddingTop = getPaddingTop;\nfunction getPaddingRight(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingRight, 0);\n}\nexports.getPaddingRight = getPaddingRight;\nfunction getPaddingBottom(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingBottom, 0);\n}\nexports.getPaddingBottom = getPaddingBottom;\nfunction setPaddingLeft(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingLeft, value.toString());\n}\nexports.setPaddingLeft = setPaddingLeft;\nfunction setPaddingTop(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingTop, value.toString());\n}\nexports.setPaddingTop = setPaddingTop;\nfunction setPaddingRight(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingRight, value.toString());\n}\nexports.setPaddingRight = setPaddingRight;\nfunction setPaddingBottom(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingBottom, value.toString());\n}\nexports.setPaddingBottom = setPaddingBottom;\nfunction getX(item) {\n    if (item instanceof SVGElement) {\n        return Number.parseInt(item.getAttribute(\"x\"));\n    }\n    else {\n        throw new exceptions_1.NotSupportedError();\n    }\n}\nexports.getX = getX;\nfunction getY(item) {\n    if (item instanceof SVGElement) {\n        return Number.parseInt(item.getAttribute(\"y\"));\n    }\n    else {\n        throw new exceptions_1.NotSupportedError();\n    }\n}\nexports.getY = getY;\nfunction getBackgroundColor(obj) {\n    const attr = obj.getAttribute(\"fill\");\n    if (attr != null) {\n        return attr;\n    }\n    else {\n        const color = ElementExtension.getPropertyStyleValueWithDefault(obj, \"fill\", \"gray\");\n        return color;\n    }\n}\nexports.getBackgroundColor = getBackgroundColor;\nfunction getStrokeWidth(obj) {\n    const attr = obj.getAttribute(\"stroke-width\");\n    if (attr != null) {\n        return parseInt(attr);\n    }\n    else {\n        const strokeWidth = ElementExtension.getPropertyStyleValue(obj, \"stroke-width\");\n        if (strokeWidth == null) {\n            const css = getComputedStyle(obj);\n            return parseInt(css.strokeWidth);\n        }\n        else {\n            return parseInt(strokeWidth);\n        }\n    }\n}\nexports.getStrokeWidth = getStrokeWidth;\nfunction getStrokeColor(obj) {\n    const attr = obj.getAttribute(\"stroke\");\n    if (attr != null) {\n        return attr;\n    }\n    else {\n        const color = ElementExtension.getPropertyStyleValueWithDefault(obj, \"stroke\", \"NoColor\");\n        if (color == \"NoColor\") {\n            const css = getComputedStyle(obj);\n            return css.stroke;\n        }\n        else {\n            return color;\n        }\n    }\n}\nexports.getStrokeColor = getStrokeColor;\nfunction getBackgroundVisible(obj) {\n    const backGroundvisible = ElementExtension.getPropertyStyleValue(obj, \"visibility\");\n    if (backGroundvisible != null) {\n        return backGroundvisible == \"visible\";\n    }\n    else {\n        const attr = obj.getAttribute(\"fill\");\n        if (attr != null) {\n            return !(attr == \"none\");\n        }\n        else {\n            return true;\n        }\n    }\n}\nexports.getBackgroundVisible = getBackgroundVisible;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/svg_element_extension.ts?");

/***/ }),

/***/ "./src/interfaces/svg_g_extension.ts":
/*!*******************************************!*\
  !*** ./src/interfaces/svg_g_extension.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setY = exports.getY = exports.setX = exports.getX = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\n/**\n * X\n */\nfunction getX(item) {\n    if (item.transform.baseVal.numberOfItems == 0) {\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\n    }\n    return (0, vline_1.round100)(item.transform.baseVal.getItem(0).matrix.e);\n}\nexports.getX = getX;\n/**\n * X\n */\nfunction setX(item, value) {\n    if (item.transform.baseVal.numberOfItems == 0) {\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\n    }\n    const a = item.transform.baseVal.getItem(0).matrix.a;\n    const b = item.transform.baseVal.getItem(0).matrix.b;\n    const c = item.transform.baseVal.getItem(0).matrix.c;\n    const d = item.transform.baseVal.getItem(0).matrix.d;\n    const e = value;\n    const f = item.transform.baseVal.getItem(0).matrix.f;\n    item.setAttribute('transform', `matrix(${(0, vline_1.round100)(a)} ${(0, vline_1.round100)(b)} ${(0, vline_1.round100)(c)} ${(0, vline_1.round100)(d)} ${(0, vline_1.round100)(e)} ${(0, vline_1.round100)(f)})`);\n}\nexports.setX = setX;\n/**\n * Y\n */\nfunction getY(item) {\n    if (item.transform.baseVal.numberOfItems == 0) {\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\n    }\n    return (0, vline_1.round100)(item.transform.baseVal.getItem(0).matrix.f);\n}\nexports.getY = getY;\n/**\n * Y\n */\nfunction setY(item, value) {\n    if (item.transform.baseVal.numberOfItems == 0) {\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\n    }\n    const a = item.transform.baseVal.getItem(0).matrix.a;\n    const b = item.transform.baseVal.getItem(0).matrix.b;\n    const c = item.transform.baseVal.getItem(0).matrix.c;\n    const d = item.transform.baseVal.getItem(0).matrix.d;\n    const e = item.transform.baseVal.getItem(0).matrix.e;\n    const f = value;\n    item.setAttribute('transform', `matrix(${(0, vline_1.round100)(a)} ${(0, vline_1.round100)(b)} ${(0, vline_1.round100)(c)} ${(0, vline_1.round100)(d)} ${(0, vline_1.round100)(e)} ${(0, vline_1.round100)(f)})`);\n}\nexports.setY = setY;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/svg_g_extension.ts?");

/***/ }),

/***/ "./src/interfaces/svg_text_extension.ts":
/*!**********************************************!*\
  !*** ./src/interfaces/svg_text_extension.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRegion = exports.getSize = exports.getWidth = exports.getHeight = exports.getUpdateFlagOfLocation = exports.updateLocation = exports.updateLocationOrGetUpdateFlag = exports.setMarginBottom = exports.getMarginBottom = exports.setMarginRight = exports.getMarginRight = exports.setMarginTop = exports.getMarginTop = exports.setMarginLeft = exports.getMarginLeft = exports.setTextContent = exports.setY = exports.getY = exports.setX = exports.getX = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\n//import { CommonFunctions } from \"../common/common_functions\";\n//import { HTMLFunctions } from \"./html_functions\";\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst SVGTextBox = __webpack_require__(/*! ./svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\n//import * as AttributeNames from \"../common/attribute_names\"\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./src/interfaces/element_extension.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst virtual_text_1 = __webpack_require__(/*! ./virtual_text */ \"./src/interfaces/virtual_text.ts\");\n/**\n * X\n */\nfunction getX(item) {\n    if (item.x.baseVal.numberOfItems == 0) {\n        item.setAttribute('x', \"0\");\n    }\n    return item.x.baseVal.getItem(0).value;\n}\nexports.getX = getX;\n/**\n * X\n */\nfunction setX(item, value) {\n    if (item.x.baseVal.numberOfItems == 0) {\n        item.setAttribute('x', \"0\");\n    }\n    //p.setAttribute('x', value.toString());\n    item.x.baseVal.getItem(0).value = value;\n}\nexports.setX = setX;\n/**\n * Y\n */\nfunction getY(item) {\n    if (item.y.baseVal.numberOfItems == 0) {\n        item.setAttribute('y', \"0\");\n    }\n    return item.y.baseVal.getItem(0).value;\n}\nexports.getY = getY;\n/**\n * Y\n */\nfunction setY(item, value) {\n    if (item.y.baseVal.numberOfItems == 0) {\n        item.setAttribute('y', \"0\");\n    }\n    item.y.baseVal.getItem(0).value = value;\n}\nexports.setY = setY;\n/**\n* SVGTextElement\n* @param text \n* @param isLatexMode TrueLatex\n*/\nfunction setTextContent(item, text, isLatexMode = false) {\n    SVGTextBox.setTextToSVGText(item, text, isLatexMode);\n}\nexports.setTextContent = setTextContent;\n//setTextContent(text: string): void;\nfunction getMarginLeft(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginLeft, 0);\n}\nexports.getMarginLeft = getMarginLeft;\nfunction setMarginLeft(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginLeft, value.toString());\n}\nexports.setMarginLeft = setMarginLeft;\nfunction getMarginTop(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginTop, 0);\n}\nexports.getMarginTop = getMarginTop;\nfunction setMarginTop(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginTop, value.toString());\n}\nexports.setMarginTop = setMarginTop;\nfunction getMarginRight(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginRight, 0);\n}\nexports.getMarginRight = getMarginRight;\nfunction setMarginRight(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginRight, value.toString());\n}\nexports.setMarginRight = setMarginRight;\nfunction getMarginBottom(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginBottom, 0);\n}\nexports.getMarginBottom = getMarginBottom;\nfunction setMarginBottom(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginBottom, value.toString());\n}\nexports.setMarginBottom = setMarginBottom;\nfunction updateLocationOrGetUpdateFlag(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText, executeUpdate) {\n    const box = (0, virtual_text_1.getVirtualRegion)(text);\n    let y = rect.y - box.y;\n    let x = rect.x - box.x;\n    if (vAnchor == enums_1.VerticalAnchor.Middle) {\n        y += (rect.height - box.height) / 2;\n    }\n    else if (vAnchor == enums_1.VerticalAnchor.Bottom) {\n        y += rect.height - box.height;\n    }\n    if (hAnchor == enums_1.HorizontalAnchor.Center) {\n        x += (rect.width - box.width) / 2;\n    }\n    else if (hAnchor == enums_1.HorizontalAnchor.Right) {\n        x += rect.width - box.width;\n    }\n    const roundX = (0, vline_1.round100)(x);\n    const roundY = (0, vline_1.round100)(y);\n    const _x = text.getAttribute('x', x.toString());\n    const _y = text.getAttribute('y', y.toString());\n    let b = false;\n    if (_x != roundX) {\n        b = true;\n        if (executeUpdate) {\n            text.setAttribute('x', roundX.toString());\n        }\n    }\n    if (_y != roundY) {\n        b = true;\n        if (executeUpdate) {\n            text.setAttribute('y', roundY.toString());\n        }\n    }\n    return b;\n}\nexports.updateLocationOrGetUpdateFlag = updateLocationOrGetUpdateFlag;\nfunction updateLocation(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText) {\n    return updateLocationOrGetUpdateFlag(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText, true);\n}\nexports.updateLocation = updateLocation;\nfunction getUpdateFlagOfLocation(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText) {\n    return updateLocationOrGetUpdateFlag(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText, false);\n}\nexports.getUpdateFlagOfLocation = getUpdateFlagOfLocation;\nfunction getHeight(text) {\n    const b = HTMLFunctions.isShow(text);\n    if (b) {\n        return text.getBBox().height;\n    }\n    else {\n        throw Error(\"error!\");\n    }\n}\nexports.getHeight = getHeight;\nfunction getWidth(text) {\n    const b = HTMLFunctions.isShow(text);\n    if (b) {\n        return text.getBBox().width;\n    }\n    else {\n        throw Error(\"error!\");\n    }\n    /*\n    if (text instanceof SVGTSpanElement) {\n        const style = getComputedStyle(text);\n        const fontSize = CommonFunctions.toPX(style.fontSize!);\n        const fontFamily = style.fontFamily!;\n\n        return text.getBBox().width;\n        //return superComputeTextWidth(text.textContent!, fontSize, fontFamily, style.fontWeight);\n\n        //return superComputeTextWidth(text.textContent!, fontSize, fontFamily);\n        //return computeTextWidth(text.textContent!, fontSize, fontFamily);\n    } else {\n\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(text).filter((v) => v.nodeName == \"tspan\");\n        let len = 0;\n        tspans.forEach((v) => { len += getVirtualWidth(v) });\n        return len;\n    }\n    */\n}\nexports.getWidth = getWidth;\nfunction getSize(svgText, showChecked = false) {\n    let r = new vline_1.Rectangle();\n    const b = showChecked ? true : HTMLFunctions.isShow(svgText);\n    if (b) {\n        const rect = svgText.getBBox();\n        r.x = rect.x;\n        r.y = rect.y;\n        r.width = rect.width;\n        r.height = rect.height;\n        return r;\n    }\n    else {\n        return new vline_1.Rectangle();\n    }\n}\nexports.getSize = getSize;\n/*\nfunction getLines(text: SVGTextElement | SVGTSpanElement | SVGTextPathElement) : SVGTSpanElement[][] | SVGTextElement | SVGTSpanElement | SVGTextPathElement{\n    if (text instanceof SVGTSpanElement) {\n        return text;\n    } else {\n        const r : SVGTSpanElement[][] = new Array();\n\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(text).filter((v) => v.nodeName == \"tspan\");\n        tspans.forEach((v) =>{\n            \n        })\n        let len = 0;\n        tspans.forEach((v) => { len += getVirtualTextLineLength(v) });\n        return len;\n    }\n}\n*/\nfunction getRegion(svgText) {\n    const b = HTMLFunctions.isShow(svgText);\n    let r = new vline_1.Rectangle();\n    r.x = getX(svgText);\n    r.y = getY(svgText);\n    if (b) {\n        const box = svgText.getBBox();\n        r.width = box.width;\n        r.height = box.height;\n        return r;\n    }\n    else {\n        throw Error(\"error!\");\n    }\n    //const style = getComputedStyle(svgText);\n    //const fontSize = CommonFunctions.toPX(style.fontSize!);\n    /*\n    let r = new Rectangle();\n    r.x = getX(svgText);\n    r.y = getY(svgText);\n    r.width = getVirtualWidth(svgText);\n    r.height = fontSize;\n    */\n    //const rect = svgText.getBBox();\n    /*\n    r.x = rect.x;\n    r.y = rect.y;\n    r.width = rect.width;\n    r.height = rect.height;\n    */\n    return r;\n}\nexports.getRegion = getRegion;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/svg_text_extension.ts?");

/***/ }),

/***/ "./src/interfaces/svg_textbox.ts":
/*!***************************************!*\
  !*** ./src/interfaces/svg_textbox.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getComputedTextLengthsOfTSpans = exports.constructSVGTextByHTMLElements = exports.sortText = exports.setTextToTextPath = exports.setTextToSVGText = exports.getRepresentativeFontSize = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./src/interfaces/element_extension.ts\");\n//import { CSS } from \"./css\";\n//export namespace SVGTextBox {\nfunction getRepresentativeFontSize(text) {\n    if (text instanceof SVGTSpanElement) {\n        const style = getComputedStyle(text);\n        const fontSize = CommonFunctions.toPX(style.fontSize);\n        return fontSize;\n    }\n    else {\n        const tspans = HTMLFunctions.getChildren(text).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n        if (tspans.length > 0) {\n            return getRepresentativeFontSize(tspans[0]);\n        }\n        else {\n            const style = getComputedStyle(text);\n            const fontSize = CommonFunctions.toPX(style.fontSize);\n            return fontSize;\n        }\n    }\n}\nexports.getRepresentativeFontSize = getRepresentativeFontSize;\n/**\n * LatexSVGTSpanElement\n * @param text Latex\n * @param className SVGTSpanElement\n * @param fontsize SVGTSpanElement\n * @param dxOfFirstElement SVGTSpanElementdx\n * @param dyOfFirstElement SVGTSpanElementdy\n * @returns LatexSVGTSpanElement\n */\nfunction createTextSpans(text, className = null, fontsize = 12, dxOfFirstElement = null, dyOfFirstElement = null) {\n    let r = [];\n    text += \"_\";\n    //const p: SVGTextElement = this;\n    //p.textContent = \"\";\n    //const h = parseInt(p.getPropertyStyleValueWithDefault(\"font-size\", \"12\"));\n    let isFst = true;\n    let mode = \"\";\n    let tmp = \"\";\n    const char_dy = (1 * fontsize) / 3;\n    let lastMode = \"none\";\n    const smallFontSize = (2 * fontsize) / 3;\n    for (let i = 0; i < text.length; i++) {\n        const c = text[i];\n        if (c == \"_\" || c == \"{\" || c == \"^\" || c == \"}\") {\n            mode += c;\n            if (mode == \"_{}\") {\n                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                tspan.textContent = tmp;\n                tspan.setAttribute(\"dy\", `${char_dy}`);\n                tspan.setAttribute(\"data-script\", \"subscript\");\n                tspan.style.fontSize = `${smallFontSize}pt`;\n                r.push(tspan);\n                lastMode = \"down\";\n                mode = \"\";\n                tmp = \"\";\n            }\n            else if (mode == \"^{}\") {\n                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                tspan.textContent = tmp;\n                tspan.setAttribute(\"dy\", `-${char_dy}`);\n                tspan.style.fontSize = `${smallFontSize}pt`;\n                tspan.setAttribute(\"data-script\", \"superscript\");\n                r.push(tspan);\n                lastMode = \"up\";\n                mode = \"\";\n                tmp = \"\";\n            }\n            else if (mode == \"_\" || mode == \"^\") {\n                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                tspan.textContent = tmp;\n                const normaldy = lastMode == \"up\" ? char_dy : lastMode == \"down\" ? -char_dy : 0;\n                if (isFst) {\n                    if (dxOfFirstElement != null)\n                        tspan.setAttribute(\"dx\", `${dxOfFirstElement}`);\n                    if (dyOfFirstElement != null)\n                        tspan.setAttribute(\"dy\", `${dyOfFirstElement}`);\n                }\n                else {\n                    tspan.setAttribute(\"dy\", `${normaldy}`);\n                }\n                r.push(tspan);\n                lastMode = \"none\";\n                tmp = \"\";\n                isFst = false;\n            }\n        }\n        else {\n            tmp += c;\n        }\n    }\n    return r;\n}\n/*\nexport function getLength(svgText : SVGTextElement) : number{\n    const children = svgText.children;\n    let m = 0;\n    for(let i=0;i<children.length;i++){\n        const child = children.item(i);\n        if(child instanceof SVGTSpanElement){\n            m += child.getComputedTextLength();\n        }\n    }\n    return             svgText.getComputedTextLength            ;\n}\n*/\n/**\n * SVGTextElement\n * @param svgText SVG\n * @param text SVG\n * @param isLatexMode Latex\n */\nfunction setTextToSVGText(svgText, text, isLatexMode) {\n    svgText.textContent = \"\";\n    const fontSize = ElementExtension.getPropertyStyleValueWithDefault(svgText, \"font-size\", \"12\");\n    const fs = parseInt(fontSize);\n    let dx = 0;\n    text.split(\"\\n\").forEach((lineText) => {\n        let dy = fs;\n        let width = 0;\n        if (isLatexMode) {\n            createTextSpans(lineText, null, fs, dx, dy).forEach((v) => {\n                svgText.appendChild(v);\n                const tLen = v.getComputedTextLength();\n                dx = 0;\n                dy = 0;\n                width += tLen;\n            });\n            dy += fs;\n        }\n        else {\n            svgText.appendChild(createSingleTextSpan(lineText, null));\n        }\n        dx = -(0, vline_1.round100)(width);\n    });\n    if (!HTMLFunctions.isShow(svgText)) {\n        throw new Error();\n    }\n}\nexports.setTextToSVGText = setTextToSVGText;\n/**\n* SVGTextPathElement\n* @param path \n* @param text \n* @param isLatexMode Latex\n*/\nfunction setTextToTextPath(path, text, isLatexMode) {\n    path.textContent = \"\";\n    const fontSize = ElementExtension.getPropertyStyleValueWithDefault(path, \"font-size\", \"12\");\n    if (isLatexMode) {\n        createTextSpans(text, null, parseInt(fontSize)).forEach((v) => path.appendChild(v));\n    }\n    else {\n        path.appendChild(createSingleTextSpan(text, null));\n    }\n}\nexports.setTextToTextPath = setTextToTextPath;\n/**\n * SVGTSpanElement\n * @param text SVGTSpanElement\n * @param className SVGTSpanElement\n * @returns SVGTSpanElement\n */\nfunction createSingleTextSpan(text, className = null) {\n    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n    tspan.textContent = text;\n    if (className != null) {\n        tspan.setAttribute(\"class\", className);\n    }\n    return tspan;\n}\nfunction copy(e, target) {\n    for (let i = 0; i < e.attributes.length; i++) {\n        const attr = e.attributes.item(i);\n        if (attr != null) {\n            const name = attr.name;\n            const value = attr.value;\n            target.setAttribute(name, value);\n        }\n    }\n}\nfunction getLines(svgText) {\n    const spans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n    let r = [];\n    if (spans.length == 0) {\n        return [];\n    }\n    else {\n        r.push([]);\n        let y = 0;\n        spans.forEach((v, i) => {\n            if (v.getAttribute(\"newline\") == \"true\") {\n                r.push([v]);\n                y++;\n            }\n            else {\n                r[y].push(v);\n            }\n        });\n        return r;\n    }\n}\nfunction alignTextByHorizontalAnchor(svgText, hAnchor) {\n    const lineSpans = getLines(svgText);\n    let dx = 0;\n    if (hAnchor == enums_1.HorizontalAnchor.Center) {\n        const tl = getComputedTextLengthsOfTSpans(svgText, true);\n        let p = 0;\n        let maxWidth = 0;\n        const widths = lineSpans.map((v) => {\n            let width = 0;\n            v.forEach((w) => {\n                width += tl[p++].width;\n            });\n            return width;\n        });\n        p = 0;\n        widths.forEach((v) => {\n            if (v > maxWidth)\n                maxWidth = v;\n        });\n        dx = 0;\n        if (widths.length > 0) {\n            for (let y = 0; y < lineSpans.length; y++) {\n                const offset = (maxWidth - widths[y]) / 2;\n                let width = offset;\n                for (let x = 0; x < lineSpans[y].length; x++) {\n                    const v = lineSpans[y][x];\n                    //const tLen = v.getComputedTextLength();\n                    const tLen = tl[p++].width;\n                    if (x == 0 && y != 0) {\n                        const new_dx = (0, vline_1.round100)(dx + offset);\n                        v.setAttribute(\"dx\", new_dx.toString());\n                    }\n                    width += tLen;\n                }\n                dx = -width;\n            }\n        }\n    }\n    else if (hAnchor == enums_1.HorizontalAnchor.Right) {\n    }\n}\nfunction alignTextAsText(svgText, showChecked) {\n    const lineSpans = getLines(svgText);\n    const fontSize = ElementExtension.getPropertyStyleValueWithDefault(svgText, \"font-size\", \"24\");\n    const fs = parseInt(fontSize);\n    let dx = 0;\n    //let dy = fs;\n    let c = 0;\n    const lengths = getComputedTextLengthsOfTSpans(svgText, showChecked);\n    for (let y = 0; y < lineSpans.length; y++) {\n        let width = 0;\n        let heightMax = fs;\n        let fstObj = null;\n        for (let x = 0; x < lineSpans[y].length; x++) {\n            const v = lineSpans[y][x];\n            //const tLen = v.getComputedTextLength();\n            const size = lengths[c++];\n            if (size.height > heightMax)\n                heightMax = size.height;\n            if (x == 0) {\n                dx = (0, vline_1.round100)(dx);\n                v.setAttribute(\"dx\", dx.toString());\n            }\n            if (x == 0)\n                fstObj = v;\n            width += size.width;\n        }\n        if (y != 0 && fstObj != null)\n            fstObj.setAttribute(\"dy\", heightMax.toString());\n        dx -= width;\n        //dy += fs;\n    }\n}\n/**\n * SVGTextElement\n * @param svgText\n * @param hAnchor\n */\nfunction sortText(svgText, hAnchor, showChecked) {\n    alignTextAsText(svgText, showChecked);\n    alignTextByHorizontalAnchor(svgText, hAnchor);\n}\nexports.sortText = sortText;\nfunction constructSVGTextByHTMLElements(svgText, text, isLatexMode) {\n    svgText.textContent = \"\";\n    const spans = text.map((v, i) => {\n        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n        tspan.innerHTML = v.innerHTML;\n        copy(v, tspan);\n        return tspan;\n    });\n    //let dy = 0;\n    spans.forEach((v, i) => {\n        svgText.appendChild(v);\n    });\n}\nexports.constructSVGTextByHTMLElements = constructSVGTextByHTMLElements;\nlet ura = null;\nfunction getComputedTextLengthsOfTSpans(svgText, showChecked) {\n    const b = showChecked ? true : HTMLFunctions.isShow(svgText);\n    if (b) {\n        const tspans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n        const r = tspans.map((v) => {\n            const w = v.getComputedTextLength();\n            //const h = v.getBoundingClientRect().height;\n            const fontSize = ElementExtension.getPropertyStyleValueWithDefault(v, \"font-size\", \"24\");\n            const fs = CommonFunctions.toPX(fontSize);\n            return new vline_1.Size(w, fs);\n        });\n        return r;\n    }\n    else {\n        const tspans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n        const r = tspans.map((v) => {\n            return new vline_1.Size(0, 0);\n        });\n        return r;\n        //return [];\n        /*\n        if(ura == null){\n            ura = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        }\n        document.body.appendChild(ura);\n        ura.innerHTML = svgText.outerHTML;\n        const fst = ura.firstChild;\n        if(fst instanceof SVGTextElement){\n\n            const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(fst).filter((v)=>v.nodeName==\"tspan\");\n            const r = tspans.map((v)=> {\n                const w = v.getComputedTextLength();\n            const fontSize = svgText.getPropertyStyleValueWithDefault(\"font-size\", \"24\");\n            const fs = CommonFunctions.toPX(fontSize);\n                return new Size(w, fs);\n            })\n            ura.removeChild(fst);\n            ura.remove();\n            return r;\n        }else if(fst != null){\n            ura.removeChild(fst);\n            ura.remove();\n            return [];\n        }else{\n            ura.remove();\n            return [];\n        }\n        */\n    }\n}\nexports.getComputedTextLengthsOfTSpans = getComputedTextLengthsOfTSpans;\n/*\nexport function getComputedTSpanLength(svgText:SVGTSpanElement) : number {\nif(HTMLFunctions.isShow(svgText)){\n    return svgText.getComputedTextLength();\n}else{\n    if(ura == null){\n        ura = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    }\n    document.body.appendChild(ura);\n    ura.innerHTML = svgText.outerHTML;\n    const fst = ura.firstChild;\n    if(fst instanceof SVGTextElement){\n\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(fst).filter((v)=>v.nodeName==\"tspan\");\n        const r = tspans.map((v)=>v.getComputedTextLength());\n        ura.removeChild(fst);\n        ura.remove();\n        return r;\n    }else if(fst != null){\n        ura.removeChild(fst);\n        ura.remove();\n        return [];\n    }else{\n        ura.remove();\n        return [];\n    }\n}\n}\n*/\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/svg_textbox.ts?");

/***/ }),

/***/ "./src/interfaces/virtual_text.ts":
/*!****************************************!*\
  !*** ./src/interfaces/virtual_text.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getVirtualRegion = void 0;\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nfunction createTSpanElement(text) {\n    const tspanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n    tspanElement.textContent = text.textContent;\n    tspanElement.style.fontFamily = text.fontFamily;\n    tspanElement.style.fontSize = text.fontSize;\n    //CommonFunctions.toPX(style.fontSize!);\n    tspanElement.style.fontWeight = text.fontWeight;\n    if (text.dx != null) {\n        tspanElement.setAttribute(\"dx\", text.dx);\n    }\n    if (text.dy != null) {\n        tspanElement.setAttribute(\"dy\", text.dy);\n    }\n    return tspanElement;\n}\nlet baseX = 30;\nlet baseY = 30;\nfunction createTextElement(text) {\n    const svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    text.children.forEach((v) => {\n        svgText.appendChild(createTSpanElement(v));\n    });\n    /*\n    svgText.textContent = text;\n    svgText.style.fontFamily = fontFamily;\n    svgText.style.fontSize = fontSize.toString() + \"px\";\n    svgText.style.fontWeight = fontWeight;\n    */\n    svgText.setAttribute(\"x\", baseX.toString());\n    svgText.setAttribute(\"y\", baseY.toString());\n    return svgText;\n}\nfunction createVirtualTSpan(tspan) {\n    const textContent = tspan.textContent;\n    const style = window.getComputedStyle(tspan);\n    const dx = tspan.getAttribute(\"dx\");\n    const dy = tspan.getAttribute(\"dy\");\n    return { textContent: textContent, fontSize: style.fontSize, fontFamily: style.fontFamily, fontWeight: style.fontWeight, type: \"span\", dx: dx, dy: dy };\n}\nfunction createVirtualText(svgText) {\n    const tpathItems = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName == \"textPath\");\n    let tspans = new Array();\n    if (tpathItems.length == 1) {\n        const tpath = tpathItems[0];\n        tspans = HTMLFunctions.getChildren(tpath).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n    }\n    else {\n        tspans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n    }\n    const r = new Array();\n    tspans.forEach((v) => {\n        r.push(createVirtualTSpan(v));\n    });\n    return { type: \"text\", children: r };\n}\nfunction superComputeRegion(text) {\n    var div = document.createElement('div');\n    var canvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    document.body.appendChild(div);\n    div.appendChild(canvas);\n    canvas.setAttribute(\"width\", \"300px\");\n    canvas.setAttribute(\"height\", \"300px\");\n    canvas.setAttribute(\"viewBox\", \"0 0 300 300\");\n    const obj = text.type == \"text\" ? createTextElement(text) : createTSpanElement(text);\n    //const svgText = createTextElement(obj);\n    canvas.appendChild(obj);\n    const box = obj.getBBox();\n    document.body.removeChild(div);\n    const x = (0, vline_1.round100)(box.x) - (0, vline_1.round100)(baseX);\n    const y = (0, vline_1.round100)(box.y) - (0, vline_1.round100)(baseY);\n    return new vline_1.Rectangle(x, y, (0, vline_1.round100)(box.width), (0, vline_1.round100)(box.height));\n}\nconst CharInfoMap = new Map();\nfunction superComputeTextWidth(text, fontSize, fontFamily, fontWeight) {\n    var div = document.createElement('div');\n    /*\n    div.style.position = 'absolute';\n    div.style.height = 'auto';\n    div.style.width = 'auto';\n    div.style.whiteSpace = 'nowrap';\n    */\n    var canvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    document.body.appendChild(div);\n    div.appendChild(canvas);\n    canvas.setAttribute(\"width\", \"300px\");\n    canvas.setAttribute(\"height\", \"300px\");\n    canvas.setAttribute(\"viewBox\", \"0 0 300 300\");\n    const svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    svgText.textContent = text;\n    svgText.style.fontFamily = fontFamily;\n    svgText.style.fontSize = fontSize.toString() + \"px\";\n    svgText.style.fontWeight = fontWeight;\n    svgText.setAttribute(\"x\", \"30\");\n    svgText.setAttribute(\"y\", \"30\");\n    canvas.appendChild(svgText);\n    /*\n    const b = HTMLFunctions.isShow(svgText);\n\n    if (b) {\n        const rect = svgText.getBBox();\n        return rect.width;\n    } else {\n        return 0;\n    }\n    */\n    const box = svgText.getBBox();\n    document.body.removeChild(div);\n    return box.width;\n    /*\n    div.style.fontFamily = fontFamily;\n    div.style.fontSize = fontSize.toString() + \"px\"; // large enough for good resolution\n\n    div.innerHTML = String.fromCharCode(text);\n    document.body.appendChild(div);\n    var clientWidth = div.clientWidth;\n    CharInfoMap.set(info, clientWidth);\n\n    document.body.removeChild(div);\n    return clientWidth;\n    */\n}\nfunction computeTextWidth(text, fontSize, fontFamily) {\n    if (typeof text == \"string\") {\n        let width = 0;\n        for (let i = 0; i < text.length; i++) {\n            const w = computeTextWidth(text.charCodeAt(i), fontSize, fontFamily);\n            width += w;\n        }\n        return width;\n    }\n    else {\n        const info = { char: text, fontSize: fontSize, fontFamily: fontFamily };\n        if (CharInfoMap.has(info)) {\n            return CharInfoMap.get(info);\n        }\n        else {\n            var div = document.createElement('div');\n            div.style.position = 'absolute';\n            div.style.height = 'auto';\n            div.style.width = 'auto';\n            div.style.whiteSpace = 'nowrap';\n            div.style.fontFamily = fontFamily;\n            div.style.fontSize = fontSize.toString() + \"px\"; // large enough for good resolution\n            div.innerHTML = String.fromCharCode(text);\n            document.body.appendChild(div);\n            var clientWidth = div.clientWidth;\n            CharInfoMap.set(info, clientWidth);\n            document.body.removeChild(div);\n            return clientWidth;\n        }\n    }\n}\n/*\nexport function getVirtualTextLineLength(text: SVGTextElement | SVGTSpanElement | SVGTextPathElement): number {\n\n    if (text instanceof SVGTSpanElement) {\n        const style = getComputedStyle(text);\n        const fontSize = CommonFunctions.toPX(style.fontSize!);\n        const fontFamily = style.fontFamily!;\n        const fontWeight = style.fontWeight!;\n\n        return superComputeTextWidth(text.textContent!, fontSize, fontFamily, fontWeight);\n    } else {\n\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(text).filter((v) => v.nodeName == \"tspan\");\n        let len = 0;\n        tspans.forEach((v) => { len += getVirtualTextLineLength(v) });\n        return len;\n    }\n}\n*/\nfunction getVirtualRegion(text) {\n    if (text instanceof SVGTextElement) {\n        const vtext = createVirtualText(text);\n        const rect = superComputeRegion(vtext);\n        return rect;\n        //return superComputeRegion(vtext);\n    }\n    else {\n        const vtext = createVirtualTSpan(text);\n        const rect = superComputeRegion(vtext);\n        return rect;\n    }\n    /*\n    else{\n        return new Rectangle();\n\n    }\n    */\n    /*\n    if (text instanceof SVGTSpanElement) {\n        const width = getVirtualTextLineLength(text);\n        const style = getComputedStyle(text);\n        const fontSize = CommonFunctions.toPX(style.fontSize!);\n        return new Rectangle(0, 0, width, fontSize);\n\n    } else {\n        const r = new Rectangle();\n        const line = new Rectangle();\n\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(text).filter((v) => v.nodeName == \"tspan\");\n        tspans.forEach((v) =>{\n            const region = getVirtualRegion(v);\n            line.width += region.width;\n            if(line.height > region.height) region.height = line.height;\n            if(v.hasAttribute(\"newline\")){\n                r.height += line.height;\n                if()\n            }\n        })\n        let len = 0;\n        tspans.forEach((v) => { len += getVirtualTextLineLength(v) });\n        return len;\n    }\n    */\n}\nexports.getVirtualRegion = getVirtualRegion;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/virtual_text.ts?");

/***/ }),

/***/ "./src/logics/gobject_functions.ts":
/*!*****************************************!*\
  !*** ./src/logics/gobject_functions.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createTextElementFromLogicCell = void 0;\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\nconst logic_text_1 = __webpack_require__(/*! ./logic_text */ \"./src/logics/logic_text.ts\");\nfunction createTextElementFromLogicCell(item, svgText) {\n    if (item.tTexts != null) {\n        SVGTextBox.constructSVGTextByHTMLElements(svgText, item.tTexts, true);\n    }\n    else if (item.text instanceof logic_text_1.LogicText) {\n        if (item.option.textOption.class != undefined) {\n            svgText.setAttribute(\"class\", item.option.textOption.class);\n        }\n        if (item.option.textOption.style != undefined) {\n            svgText.setAttribute(\"style\", item.option.textOption.style);\n        }\n        if (item.option.textOption.id != undefined) {\n            svgText.setAttribute(\"id\", item.option.textOption.id);\n        }\n        item.text.copyToTextElement(svgText);\n    }\n}\nexports.createTextElementFromLogicCell = createTextElementFromLogicCell;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/gobject_functions.ts?");

/***/ }),

/***/ "./src/logics/gobject_reterals.ts":
/*!****************************************!*\
  !*** ./src/logics/gobject_reterals.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toHTML = exports.deepCopy = exports.setSVGReteral = exports.convertAttributesIntoCellOption = exports.convertAttributesIntoAdditionalOption = exports.convertAttributesIntoTableOption = exports.convertAttributesIntoVertexOption = exports.convertAttributesIntoSVGOption = void 0;\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common/index.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\n/*\nexport type _GTableOption = {\n    rowCount?: number,\n    columnCount?: number,\n    rowHeight?: number,\n    columnWidth?: number,\n    //table?: LogicTable\n    \n    columnWidths?: (number | null)[];\n    rowHeights?: (number | null)[];\n    position? : CenterPosition | UpperLeftPosition;\n\n}\n*/\n/*\nfunction getAndRemoveAttribute(item:Element,name: string): string | undefined{\n    const p = ElementExtension.gtGetAttributeStringWithUndefined(item, name);\n    item.removeAttribute(name);\n    return p;\n}\n*/\n/*\nfunction getAndRemoveNumberAttribute(item:Element,name: string): number | undefined{\n    const p = ElementExtension.gtGetAttributeNumberWithUndefined(item, name);\n    item.removeAttribute(name);\n    return p;\n}\n*/\n/*\nfunction getAndRemoveInheritedAttribute(item:Element,name: string): string | undefined{\n    const p = ElementExtension.gtGetInheritedAttributeString(item, name);\n    item.removeAttribute(name);\n    return p;\n}\n*/\nfunction convertAttributesIntoSVGOption(e) {\n    var _a, _b, _c;\n    const output = new Object();\n    output.class = (_a = ElementExtension.gtGetInheritedAttributeString(e, common_1.AttributeNames.className)) !== null && _a !== void 0 ? _a : output.class;\n    output.style = (_b = ElementExtension.gtGetInheritedAttributeString(e, common_1.AttributeNames.style)) !== null && _b !== void 0 ? _b : output.style;\n    output.id = (_c = ElementExtension.gtGetAttributeStringWithUndefined(e, `${common_1.AttributeNames.id}`)) !== null && _c !== void 0 ? _c : output.id;\n    return output;\n}\nexports.convertAttributesIntoSVGOption = convertAttributesIntoSVGOption;\nfunction convertAttributesIntoVertexOption(e) {\n    var _a, _b, _c, _d;\n    const output = convertAttributesIntoSVGOption(e);\n    output.surfaceOption = convertAttributesIntoAdditionalOption(e, \"surface\");\n    output.textOption = convertAttributesIntoAdditionalOption(e, \"text\");\n    output.width = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.width);\n    output.height = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.height);\n    output.cx = (_a = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.cx)) !== null && _a !== void 0 ? _a : output.cx;\n    output.cy = (_b = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.cy)) !== null && _b !== void 0 ? _b : output.cy;\n    output.x = (_c = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.x)) !== null && _c !== void 0 ? _c : output.x;\n    output.y = (_d = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.y)) !== null && _d !== void 0 ? _d : output.y;\n    if (output.cx !== undefined || output.cy !== undefined) {\n        output.positionType = \"center\";\n    }\n    else if (output.x !== undefined || output.y !== undefined) {\n        output.positionType = \"upper-left\";\n    }\n    return output;\n}\nexports.convertAttributesIntoVertexOption = convertAttributesIntoVertexOption;\nfunction convertAttributesIntoTableOption(e) {\n    var _a, _b;\n    const output = convertAttributesIntoVertexOption(e);\n    output.rowHeight = (_a = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.rowHeight)) !== null && _a !== void 0 ? _a : output.rowHeight;\n    output.columnWidth = (_b = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.columnWidth)) !== null && _b !== void 0 ? _b : output.columnWidth;\n    return output;\n}\nexports.convertAttributesIntoTableOption = convertAttributesIntoTableOption;\nfunction convertAttributesIntoAdditionalOption(e, type) {\n    var _a, _b, _c;\n    const output = new Object();\n    output.class = (_a = ElementExtension.gtGetInheritedAttributeString(e, `${type}::${common_1.AttributeNames.className}`)) !== null && _a !== void 0 ? _a : output.class;\n    output.style = (_b = ElementExtension.gtGetInheritedAttributeString(e, `${type}::${common_1.AttributeNames.style}`)) !== null && _b !== void 0 ? _b : output.style;\n    output.id = (_c = ElementExtension.gtGetAttributeStringWithUndefined(e, `${type}::${common_1.AttributeNames.id}`)) !== null && _c !== void 0 ? _c : output.id;\n    return output;\n}\nexports.convertAttributesIntoAdditionalOption = convertAttributesIntoAdditionalOption;\nfunction convertAttributesIntoCellOption(e) {\n    var _a, _b;\n    const output = new Object();\n    output.w = (_a = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.w)) !== null && _a !== void 0 ? _a : output.w;\n    output.h = (_b = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.h)) !== null && _b !== void 0 ? _b : output.h;\n    output.topBorderOption = convertAttributesIntoAdditionalOption(e, \"topborder\");\n    output.leftBorderOption = convertAttributesIntoAdditionalOption(e, \"leftborder\");\n    output.rightBorderOption = convertAttributesIntoAdditionalOption(e, \"rightborder\");\n    output.bottomBorderOption = convertAttributesIntoAdditionalOption(e, \"bottomborder\");\n    output.surfaceOption = convertAttributesIntoAdditionalOption(e, \"surface\");\n    output.textOption = convertAttributesIntoAdditionalOption(e, \"text\");\n    return output;\n}\nexports.convertAttributesIntoCellOption = convertAttributesIntoCellOption;\nfunction setSVGReteral(obj, tag, id, _class, style) {\n    obj.tag = tag;\n    if (id != undefined) {\n        obj.id = id;\n    }\n    if (_class != undefined) {\n        if (typeof _class == \"string\") {\n            obj.class = _class;\n        }\n    }\n    if (style != undefined) {\n        if (typeof style == \"string\") {\n            obj.style = style;\n        }\n    }\n}\nexports.setSVGReteral = setSVGReteral;\nfunction deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.deepCopy = deepCopy;\nfunction toSpecialAttributes(obj, prefixName) {\n    const r = new Array();\n    for (const key in obj) {\n        const value = obj[key];\n        if (typeof value == \"string\" || typeof value == \"number\") {\n            const line = `${prefixName}:${key.toLowerCase()}=\"${value}\"`;\n            r.push(line);\n        }\n        else if (value instanceof Object) {\n            throw new Error(\"Error\");\n        }\n    }\n    return r;\n}\nfunction toHTML(obj, indent) {\n    const r = new Array();\n    const tag = obj[\"tag\"];\n    const replaceDic = new Map();\n    if (tag != undefined) {\n        let fstLine = `<${tag}`;\n        for (const key in obj) {\n            if (key == \"tag\") {\n            }\n            else if (key == \"children\") {\n            }\n            else {\n                const newKey = key.toLowerCase().replace(\"_\", \"-\");\n                const value = obj[key];\n                if (typeof value == \"string\" || typeof value == \"number\") {\n                    fstLine += ` ${newKey}=\"${value}\"`;\n                }\n                else if (typeof value == \"boolean\") {\n                    fstLine += ` ${newKey}=\"${value ? \"true\" : \"false\"}\"`;\n                }\n                else if (value instanceof Object) {\n                    const ind = key.indexOf(\"Option\");\n                    if (ind != -1 && ind == key.length - 6) {\n                        const prefixName = key.substring(0, key.length - 6).toLowerCase();\n                        toSpecialAttributes(value, prefixName).forEach((v) => {\n                            fstLine += ` ${v}`;\n                        });\n                    }\n                    else {\n                    }\n                }\n            }\n        }\n        //r.push(fstLine);\n        const centerLines = new Array();\n        const children = obj[\"children\"];\n        if (Array.isArray(children)) {\n            children.forEach((v) => {\n                const lines = toHTML(v, indent);\n                lines.forEach((w) => {\n                    centerLines.push(indent + w);\n                });\n            });\n        }\n        const lstLine = `</${tag}>`;\n        if (centerLines.length == 0) {\n            fstLine += \"/>\";\n            r.push(`${fstLine}`);\n        }\n        else if (centerLines.length == 1) {\n            fstLine += \">\";\n            r.push(`${fstLine}${centerLines[0].substring(indent.length)}${lstLine}`);\n        }\n        else {\n            fstLine += \">\";\n            r.push(fstLine);\n            centerLines.forEach((v) => {\n                r.push(v);\n            });\n            r.push(lstLine);\n        }\n        //r.push(lstLine);\n    }\n    else {\n        const textContent = obj[\"textContent\"];\n        if (typeof textContent == \"string\") {\n            return [`${textContent}`];\n        }\n        else {\n            return [];\n        }\n    }\n    return r;\n}\nexports.toHTML = toHTML;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/gobject_reterals.ts?");

/***/ }),

/***/ "./src/logics/index.ts":
/*!*****************************!*\
  !*** ./src/logics/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicGroup = exports.Test = exports.buildLogicObjectFromJSON = exports.buildLogicCellLine = exports.buildLogicTable = exports.getIndexArrayTableLine = exports.LogicSVGSVG = exports.LogicBasicShape = exports.LogicTreeNode = exports.LogicTree = exports.LogicGraphNode = exports.LogicGraphEdge = exports.LogicGraph = exports.LogicTable = exports.LogicCell = exports.LogicText = exports.LogicTSpan = void 0;\nconst logic_text_1 = __webpack_require__(/*! ./logic_text */ \"./src/logics/logic_text.ts\");\nObject.defineProperty(exports, \"LogicTSpan\", ({ enumerable: true, get: function () { return logic_text_1.LogicTSpan; } }));\nObject.defineProperty(exports, \"LogicText\", ({ enumerable: true, get: function () { return logic_text_1.LogicText; } }));\nconst logic_cell_1 = __webpack_require__(/*! ./logic_cell */ \"./src/logics/logic_cell.ts\");\nObject.defineProperty(exports, \"LogicCell\", ({ enumerable: true, get: function () { return logic_cell_1.LogicCell; } }));\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./src/logics/logic_table.ts\");\nObject.defineProperty(exports, \"LogicTable\", ({ enumerable: true, get: function () { return logic_table_1.LogicTable; } }));\nconst logic_tree_1 = __webpack_require__(/*! ./logic_tree */ \"./src/logics/logic_tree.ts\");\nObject.defineProperty(exports, \"LogicTree\", ({ enumerable: true, get: function () { return logic_tree_1.LogicTree; } }));\nObject.defineProperty(exports, \"LogicTreeNode\", ({ enumerable: true, get: function () { return logic_tree_1.LogicTreeNode; } }));\nObject.defineProperty(exports, \"LogicBasicShape\", ({ enumerable: true, get: function () { return logic_tree_1.LogicBasicShape; } }));\nObject.defineProperty(exports, \"Test\", ({ enumerable: true, get: function () { return logic_tree_1.Test; } }));\nconst logic_graph_1 = __webpack_require__(/*! ./logic_graph */ \"./src/logics/logic_graph.ts\");\nObject.defineProperty(exports, \"LogicGraph\", ({ enumerable: true, get: function () { return logic_graph_1.LogicGraph; } }));\nObject.defineProperty(exports, \"LogicGraphEdge\", ({ enumerable: true, get: function () { return logic_graph_1.LogicGraphEdge; } }));\nObject.defineProperty(exports, \"LogicGraphNode\", ({ enumerable: true, get: function () { return logic_graph_1.LogicGraphNode; } }));\nconst logic_svgsvg_1 = __webpack_require__(/*! ./logic_svgsvg */ \"./src/logics/logic_svgsvg.ts\");\nObject.defineProperty(exports, \"LogicSVGSVG\", ({ enumerable: true, get: function () { return logic_svgsvg_1.LogicSVGSVG; } }));\nconst logic_group_1 = __webpack_require__(/*! ./logic_group */ \"./src/logics/logic_group.ts\");\nObject.defineProperty(exports, \"LogicGroup\", ({ enumerable: true, get: function () { return logic_group_1.LogicGroup; } }));\nObject.defineProperty(exports, \"buildLogicObjectFromJSON\", ({ enumerable: true, get: function () { return logic_group_1.buildLogicObjectFromJSON; } }));\nconst logic_table_line_1 = __webpack_require__(/*! ./logic_table_line */ \"./src/logics/logic_table_line.ts\");\nObject.defineProperty(exports, \"getIndexArrayTableLine\", ({ enumerable: true, get: function () { return logic_table_line_1.getIndexArrayTableLine; } }));\nObject.defineProperty(exports, \"buildLogicTable\", ({ enumerable: true, get: function () { return logic_table_line_1.buildLogicTable; } }));\nObject.defineProperty(exports, \"buildLogicCellLine\", ({ enumerable: true, get: function () { return logic_table_line_1.buildLogicCellLine; } }));\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/index.ts?");

/***/ }),

/***/ "./src/logics/logic_cell.ts":
/*!**********************************!*\
  !*** ./src/logics/logic_cell.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicCell = void 0;\nconst logic_text_1 = __webpack_require__(/*! ./logic_text */ \"./src/logics/logic_text.ts\");\n/**\n * \n */\nclass LogicCell {\n    get backgroundOption() {\n        return this.option.surfaceOption;\n    }\n    get topBorderOption() {\n        return this.option.topBorderOption;\n    }\n    get leftBorderOption() {\n        return this.option.leftBorderOption;\n    }\n    get rightBorderOption() {\n        return this.option.rightBorderOption;\n    }\n    get bottomBorderOption() {\n        return this.option.bottomBorderOption;\n    }\n    get connectedColumnCount() {\n        if (this.option.w == undefined) {\n            return 1;\n        }\n        else {\n            return this.option.w;\n        }\n    }\n    get connectedRowCount() {\n        if (this.option.h == undefined) {\n            return 1;\n        }\n        else {\n            return this.option.h;\n        }\n    }\n    //public isLatexMode: boolean = false;\n    constructor() {\n        this.text = new logic_text_1.LogicText();\n        /*\n        public groupOption : GOptions.CellAttributes = { class : defaultCellClass}\n        public backgroundOption: GOptions.backgroundOption = {};\n        public topBorderOption: GOptions.BorderAttributes = {};\n        public leftBorderOption: GOptions.BorderAttributes = {};\n        public rightBorderOption: GOptions.BorderAttributes = {};\n        public bottomBorderOption: GOptions.BorderAttributes = {};\n        public connectedColumnCount: number = 1;\n        public connectedRowCount: number = 1;\n        */\n        this.tTexts = null;\n        this.option = new Object();\n        this.option.topBorderOption = new Object();\n        this.option.leftBorderOption = new Object();\n        this.option.rightBorderOption = new Object();\n        this.option.bottomBorderOption = new Object();\n        this.option.surfaceOption = new Object();\n        this.option.textOption = new Object();\n        //this.option.w = 1;\n        //this.option.h = 1;\n    }\n    buildFromObject(obj) {\n        this.text.buildFromObject(obj[\"text\"]);\n        //this.cellStyle = obj[\"cellStyle\"];\n        /*\n        this.groupOption = obj[\"groupOption\"];\n        this.backgroundOption = obj[\"backgroundOption\"];\n        this.topBorderOption = obj[\"topBorderOption\"];\n        this.leftBorderOption = obj[\"leftBorderOption\"];\n        this.rightBorderOption = obj[\"rightBorderOption\"];\n        this.bottomBorderOption = obj[\"bottomBorderOption\"];\n        this.connectedColumnCount = obj[\"connectedColumnCount\"];\n        this.connectedRowCount = obj[\"connectedRowCount\"];\n        */\n    }\n    copy(cell) {\n        this.text = cell.text;\n        /*\n        this.groupOption = {...cell.groupOption}\n        this.backgroundOption = {...cell.backgroundOption};\n        this.topBorderOption = {...cell.topBorderOption};\n        this.leftBorderOption = {...cell.leftBorderOption};\n        this.rightBorderOption = {...cell.rightBorderOption};\n        this.bottomBorderOption = {...cell.bottomBorderOption};\n        */\n        /*\n        if(cell.topBorderClass !== undefined)this.topBorderClass = cell.topBorderClass;\n        if(cell.leftBorderClass !== undefined)this.leftBorderClass = cell.topBorderClass;\n        if(cell.rightBorderClass !== undefined)this.rightBorderClass = cell.rightBorderClass;\n        if(cell.bottomBorderClass !== undefined){\n            this.bottomBorderClass = cell.bottomBorderClass;\n        }\n        */\n        /*\n         this.connectedRowCount = cell.connectedRowCount;\n         this.connectedColumnCount = cell.connectedColumnCount;\n         */\n        this.item = cell.item;\n    }\n    toReteral() {\n        const p = Object.assign({}, this.option);\n        p.tag = \"cell\";\n        const child = this.text.toReteral();\n        p.children = new Array();\n        p.children.push(child);\n        return p;\n    }\n}\nexports.LogicCell = LogicCell;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_cell.ts?");

/***/ }),

/***/ "./src/logics/logic_graph.ts":
/*!***********************************!*\
  !*** ./src/logics/logic_graph.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicGraph = exports.LogicGraphNode = exports.LogicGraphEdge = void 0;\nclass LogicGraphEdge {\n    constructor() {\n        this.text = null;\n        this.endNodeIndex = -1;\n    }\n}\nexports.LogicGraphEdge = LogicGraphEdge;\nclass LogicGraphNode {\n    constructor() {\n        this.text = null;\n        this.outputEdges = [];\n    }\n    addEdge(e) {\n        this.outputEdges.push(e);\n    }\n}\nexports.LogicGraphNode = LogicGraphNode;\nclass LogicGraph {\n    constructor() {\n        this.nodes = [];\n        this.edges = [];\n        this.option = { relocateStyle: \"standard\", direction: \"down\" };\n        this.className = \"LogicGraph\";\n    }\n    construct(iten) {\n    }\n    addNode() {\n        const node = new LogicGraphNode();\n        this.nodes.push(node);\n        return node;\n    }\n    createEdge() {\n        const edge = new LogicGraphEdge();\n        this.edges.push(edge);\n        return edge;\n    }\n    getIndex(node) {\n        return this.nodes.indexOf(node);\n    }\n}\nexports.LogicGraph = LogicGraph;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_graph.ts?");

/***/ }),

/***/ "./src/logics/logic_group.ts":
/*!***********************************!*\
  !*** ./src/logics/logic_group.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAdditionalLibraryPathList = exports.buildLogicObjectFromJSON = exports.LogicGroup = void 0;\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./src/logics/logic_table.ts\");\nconst logic_tree_1 = __webpack_require__(/*! ./logic_tree */ \"./src/logics/logic_tree.ts\");\nconst logic_graph_1 = __webpack_require__(/*! ./logic_graph */ \"./src/logics/logic_graph.ts\");\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nclass LogicGroup {\n    constructor() {\n        this.items = new Array(0);\n        this.className = \"LogicGroup\";\n        this.itemOrder = \"row\";\n        this.itemInterval = 50;\n    }\n    static build(itmes) {\n        const p = new LogicGroup();\n        itmes.forEach((v) => { p.items.push(v); });\n        return p;\n    }\n    buildFromObject(item) {\n        const temp = item[\"items\"];\n        if (temp !== undefined && temp instanceof Array) {\n            temp.forEach((v, i) => {\n                this.items.push(LogicGroup.buildLogicObjectFromObject(v));\n            });\n        }\n        this.position = item[\"position\"];\n        this.itemOrder = item[\"itemOrder\"];\n        this.itemInterval = item[\"itemInterval\"];\n    }\n    static buildLogicObjectFromObject(obj) {\n        const type = obj[\"className\"];\n        //const type : LogicType = obj[LogicGroup.buildLogicObjectFromObject.toString()];\n        if (type === undefined)\n            throw new exceptions_1.UndefinedError();\n        if (type == \"LogicTree\") {\n            const w = new logic_tree_1.LogicTree();\n            w.buildFromObject(obj);\n            return w;\n        }\n        else if (type == \"LogicTable\") {\n            const w = new logic_table_1.LogicTable();\n            w.buildFromObject(obj);\n            return w;\n        }\n        else if (type == \"LogicGroup\") {\n            const w = new LogicGroup();\n            w.buildFromObject(obj);\n            return w;\n        }\n        else {\n            const w = new logic_graph_1.LogicGraph();\n            //w.buildFromObject(obj);\n            return w;\n        }\n    }\n}\nexports.LogicGroup = LogicGroup;\nfunction buildLogicObjectFromJSON(data) {\n    const obj = JSON.parse(data);\n    return LogicGroup.buildLogicObjectFromObject(obj);\n}\nexports.buildLogicObjectFromJSON = buildLogicObjectFromJSON;\nfunction getAdditionalLibraryPathList(data) {\n    const r = new Set();\n    if (data instanceof LogicGroup) {\n        data.items.forEach((v) => {\n            const sub = getAdditionalLibraryPathList(v);\n            Array.from(sub.values()).forEach((w) => {\n                r.add(w);\n            });\n        });\n    }\n    else if (data instanceof logic_graph_1.LogicGraph) {\n    }\n    else if (data instanceof logic_tree_1.LogicTree) {\n        if (data.option.drawingFunction !== undefined && data.option.drawingFunction.url != null) {\n            r.add(data.option.drawingFunction.url);\n        }\n    }\n    else {\n    }\n    return r;\n}\nexports.getAdditionalLibraryPathList = getAdditionalLibraryPathList;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_group.ts?");

/***/ }),

/***/ "./src/logics/logic_svgsvg.ts":
/*!************************************!*\
  !*** ./src/logics/logic_svgsvg.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicSVGSVG = void 0;\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./src/logics/logic_table.ts\");\nclass LogicSVGSVG {\n    constructor(_option = new Object()) {\n        this.items = new Array(0);\n        this.option = Object.assign({}, _option);\n    }\n    toReteral() {\n        const obj = Object.assign({}, this.option);\n        obj.xmlns = \"http://www.w3.org/2000/svg\";\n        obj.tag = \"svg\";\n        obj.children = new Array();\n        this.items.forEach((v) => {\n            if (v instanceof logic_table_1.LogicTable) {\n                obj.children.push(v.toReteral());\n            }\n        });\n        return obj;\n    }\n    static createDefaultSVGSVG() {\n        const v = new LogicSVGSVG();\n        v.option.style = \"background:#e9e9e9;border:solid 1pt;\";\n        return v;\n    }\n}\nexports.LogicSVGSVG = LogicSVGSVG;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_svgsvg.ts?");

/***/ }),

/***/ "./src/logics/logic_table.ts":
/*!***********************************!*\
  !*** ./src/logics/logic_table.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicTable = void 0;\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst logic_cell_1 = __webpack_require__(/*! ./logic_cell */ \"./src/logics/logic_cell.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst gobject_reterals_1 = __webpack_require__(/*! ./gobject_reterals */ \"./src/logics/gobject_reterals.ts\");\nconst character_1 = __webpack_require__(/*! ../common/character */ \"./src/common/character.ts\");\n//import { Cell } from \"../object/table_helpers/cell\"\n//import * as GOptions from \"../object/x_options\"\n/**\n * \n */\nclass LogicTable {\n    get rowCount() {\n        return this.cells.length;\n    }\n    get columnCount() {\n        if (this.cells.length == 0) {\n            return 0;\n        }\n        else {\n            return this.cells[0].length;\n        }\n    }\n    buildFromObject(obj) {\n        /*\n        if(obj[\"position\"] !== undefined){\n            this.position = obj[\"position\"];\n        }\n        this.tableClassName = obj[\"tableClassName\"];\n        */\n        this.option = obj[\"option\"];\n        //this.rowHeights = obj[\"rowHeights\"];\n        //this.columnWidths = obj[\"columnWidths\"];\n        const cells = obj[\"cells\"];\n        const rowCount = cells.length;\n        const columnCount = rowCount == 0 ? 0 : cells[0].length;\n        this.cells = new Array(rowCount);\n        for (let y = 0; y < rowCount; y++) {\n            this.cells[y] = new Array(columnCount);\n            for (let x = 0; x < columnCount; x++) {\n                this.cells[y][x] = new logic_cell_1.LogicCell();\n                this.cells[y][x].buildFromObject(cells[y][x]);\n            }\n        }\n    }\n    constructor(option = { columnCount: 3, rowCount: 3 }) {\n        this.className = \"LogicTable\";\n        //if (option.columnCount == undefined) option.columnCount = 3;\n        //if (option.rowCount == undefined) option.rowCount = 3;\n        this.option = new Object();\n        //this.option.x = 0;\n        //this.option.y = 0;\n        if (option.table_option !== undefined) {\n            this.option = (0, gobject_reterals_1.deepCopy)(option.table_option);\n        }\n        //this.position = option.position;\n        //if(option.tableClassName == undefined) option.tableClassName = null;\n        //this.tableClassName = option.tableClassName == undefined ? null : option.tableClassName;\n        this.cells = new Array(option.rowCount);\n        for (let y = 0; y < option.rowCount; y++) {\n            this.cells[y] = new Array(option.columnCount);\n            for (let x = 0; x < option.columnCount; x++) {\n                this.cells[y][x] = new logic_cell_1.LogicCell();\n            }\n        }\n        /*\n        this.rowHeights = new Array(option.rowCount);\n        for (let y = 0; y < option.rowCount; y++) {\n            this.rowHeights[y] = null;\n        }\n        this.columnWidths = new Array(option.columnCount);\n        for (let x = 0; x < option.columnCount; x++) {\n            this.columnWidths[x] = null;\n        }\n        */\n    }\n    get cellArray() {\n        const r = new Array();\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                r.push(this.cells[y][x]);\n            }\n        }\n        return r;\n    }\n    getColumn(i) {\n        const r = new Array();\n        for (let y = 0; y < this.rowCount; y++) {\n            r.push(this.cells[y][i]);\n        }\n        return r;\n    }\n    getRow(i) {\n        const r = new Array();\n        for (let x = 0; x < this.columnCount; x++) {\n            r.push(this.cells[i][x]);\n        }\n        return r;\n    }\n    /*\n    public checkTable(): boolean {\n\n    }\n    */\n    static parse(str, delimiter) {\n        const lines = str.split(\"\\n\");\n        const r = new Array(lines.length);\n        for (let y = 0; y < lines.length; y++) {\n            const line = lines[y].split(delimiter);\n            r[y] = new Array(line.length);\n            for (let x = 0; x < line.length; x++) {\n                r[y][x] = line[x];\n            }\n            if (y > 0) {\n                if (r[y].length != r[y - 1].length) {\n                    alert(\"Parse Error\");\n                    throw Error(\"Parse Error\");\n                }\n            }\n        }\n        return r;\n    }\n    static create(str, option) {\n        const table = new LogicTable({ columnCount: str[0].length, rowCount: str.length, table_option: option });\n        for (let y = 0; y < str.length; y++) {\n            for (let x = 0; x < str[y].length; x++) {\n                const p = str[y][x].split(\"%%%\");\n                table.cells[y][x].text.textContent = p[0];\n                if (p.length == 3) {\n                    table.cells[y][x].option.w = Number(p[1]);\n                    table.cells[y][x].option.h = Number(p[2]);\n                }\n            }\n        }\n        return table;\n    }\n    /*\n    private static constructHTMLLogicCells(attributeElement: Element, cells: LogicCell[]): void {\n        const backGroundClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement, AttributeNames.backgroundClassName);\n        const backGroundStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement, AttributeNames.backgroundStyle);\n\n        const textClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement, AttributeNames.textClass);\n        const textStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement, AttributeNames.textStyle);\n\n        const topBorderClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.topBorderClassName);\n        const topBorderStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.topBorderStyle);\n\n        const leftBorderClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.leftBorderClassName);\n        const leftBorderStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.leftBorderStyle);\n\n        const rightBorderClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.rightBorderClassName);\n        const rightBorderStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.rightBorderStyle);\n\n        const bottomBorderClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.bottomBorderClassName);\n        const bottomBorderStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.bottomBorderStyle);\n\n        cells.forEach((outputCell) => {\n            if (backGroundClassName != null) {\n                outputCell.backgroundOption.class = backGroundClassName;\n            }\n            if (backGroundStyle != null) {\n                outputCell.backgroundOption.style = backGroundStyle;\n            }\n            if (textClassName != null) {\n                outputCell.text.class = textClassName;\n            }\n            if (textStyle != null) {\n                outputCell.text.style = textStyle;\n            }\n            if (topBorderClassName != null) {\n                outputCell.topBorderOption.class = topBorderClassName;\n            }\n            if (topBorderStyle != null) {\n                outputCell.topBorderOption.style = topBorderStyle;\n            }\n\n            if (leftBorderClassName != null) {\n                outputCell.leftBorderOption.class = leftBorderClassName;\n            }\n            if (leftBorderStyle != null) {\n                outputCell.leftBorderOption.style = leftBorderStyle;\n            }\n            if (rightBorderClassName != null) {\n                outputCell.rightBorderOption.class = rightBorderClassName;\n            }\n            if (rightBorderStyle != null) {\n                outputCell.rightBorderOption.style = rightBorderStyle;\n            }\n            if (bottomBorderClassName != null) {\n                outputCell.bottomBorderOption.class = bottomBorderClassName;\n            }\n            if (bottomBorderStyle != null) {\n                outputCell.bottomBorderOption.style = bottomBorderStyle;\n            }\n        })\n\n\n    }\n    */\n    /*\n    public static convertAttributesIntoLogicTableOption(e: Element) : TableOptionReteral{\n            const output : TableOptionReteral = <any> new Object();\n            \n            return output;\n    }\n    */\n    static constructHTMLLogicCell(cellElement, outputCell) {\n        outputCell.option = (0, gobject_reterals_1.convertAttributesIntoCellOption)(cellElement);\n        outputCell.text.textContent = (0, character_1.recoverFromEscapeCharacter)(cellElement.innerHTML);\n        //outputCell.text.class = outputCell.option.\n        const tNodes = HTMLFunctions.getTNodes(cellElement);\n        if (tNodes != null)\n            outputCell.tTexts = tNodes;\n    }\n    static constructHTMLLogicTable(e) {\n        const rows = HTMLFunctions.getChildren(e).filter((v) => v.getAttribute(AttributeNames.customElement) == \"row\").map((v) => v);\n        const widthsStr = ElementExtension.getPropertyStyleValue(e, \"--widths\");\n        if (rows.length == 0)\n            return null;\n        const cells = new Array(rows.length);\n        let columnSize = 0;\n        rows.forEach((v, i) => {\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(AttributeNames.customElement) == \"cell\");\n            cellArray.forEach((v) => v.removeAttribute(AttributeNames.customElement));\n            cells[i] = cellArray;\n            if (columnSize < cellArray.length)\n                columnSize = cellArray.length;\n        });\n        const logicTable = new LogicTable({ columnCount: columnSize, rowCount: rows.length });\n        ;\n        /*\n        if (widthsStr != null) {\n            const widths: (number | null)[] = JSON.parse(widthsStr);\n            widths.forEach((v, i) => logicTable.columnWidths[i] = v);\n        }\n        */\n        for (let y = 0; y < cells.length; y++) {\n            const h = ElementExtension.getPropertyStyleNumberValue(rows[y], \"--height\", null);\n            //logicTable.rowHeights[y] = h;\n            for (let x = 0; x < cells[y].length; x++) {\n                this.constructHTMLLogicCell(cells[y][x], logicTable.cells[y][x]);\n                /*\n                const backGroundClassName = cells[y][x].getAttribute(AttributeNames.backgroundClassName);\n                const backGroundStyle = cells[y][x].getAttribute(AttributeNames.backgroundStyle);\n                const textClassName = cells[y][x].getAttribute(AttributeNames.textClass);\n                const textStyle = cells[y][x].getAttribute(AttributeNames.textStyle);\n\n                if(backGroundClassName != null){\n                    logicTable.cells[y][x].backgroundOption.class = backGroundClassName;\n                }\n                if(backGroundStyle != null){\n                    logicTable.cells[y][x].backgroundOption.style = backGroundStyle;\n                }\n                if(textClassName != null){\n                    logicTable.cells[y][x].text.class = textClassName;\n                }\n                if(textStyle != null){\n                    logicTable.cells[y][x].text.style = textStyle;\n                }\n\n\n                logicTable.cells[y][x].text.textContent = cells[y][x].innerHTML;\n                if (cells[y][x].hasAttribute(\"w\")) {\n                    const w = Number(cells[y][x].getAttribute(\"w\"));\n                    logicTable.cells[y][x].connectedColumnCount = w;\n                }\n                if (cells[y][x].hasAttribute(\"h\")) {\n                    const h = Number(cells[y][x].getAttribute(\"h\"));\n                    logicTable.cells[y][x].connectedRowCount = h;\n                }\n                //const tNodes = openSVGFunctions.getTNodes(cells[y][x]);\n\n                logicTable.cells[y][x].text.textContent = cells[y][x].innerHTML;\n                */\n            }\n        }\n        return logicTable;\n    }\n    toReteral() {\n        const obj = (0, gobject_reterals_1.deepCopy)(this.option);\n        obj.tag = \"g-table\";\n        obj.children = new Array();\n        for (let i = 0; i < this.rowCount; i++) {\n            const row = new Object();\n            row.tag = \"row\";\n            row.children = new Array();\n            this.getRow(i).forEach((v) => {\n                const cell = v.toReteral();\n                row.children.push(cell);\n            });\n            obj.children.push(row);\n        }\n        return obj;\n    }\n    static constructLogicTable(e) {\n        const rows = HTMLFunctions.getChildren(e).filter((v) => v.getAttribute(AttributeNames.customElement) == \"row\").map((v) => v);\n        //const widthsStr = ElementExtension.getPropertyStyleValue(e, \"--widths\");\n        if (rows.length == 0)\n            return null;\n        const cells = new Array(rows.length);\n        let columnSize = 0;\n        rows.forEach((v, i) => {\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(AttributeNames.customElement) == \"cell\");\n            cellArray.forEach((v) => v.removeAttribute(AttributeNames.customElement));\n            cells[i] = cellArray;\n            if (columnSize < cellArray.length)\n                columnSize = cellArray.length;\n        });\n        const logicTable = new LogicTable({ columnCount: columnSize, rowCount: rows.length });\n        logicTable.option = (0, gobject_reterals_1.convertAttributesIntoTableOption)(e);\n        for (let y = 0; y < cells.length; y++) {\n            for (let x = 0; x < cells[y].length; x++) {\n                this.constructHTMLLogicCell(cells[y][x], logicTable.cells[y][x]);\n            }\n        }\n        return logicTable;\n    }\n}\nexports.LogicTable = LogicTable;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_table.ts?");

/***/ }),

/***/ "./src/logics/logic_table_line.ts":
/*!****************************************!*\
  !*** ./src/logics/logic_table_line.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buildLogicTable = exports.buildLogicCellLine = exports.getIndexArrayTableLine = exports.getIndexArray = void 0;\n//import {LogicCell} from \"./logic_cell\"\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./src/logics/logic_table.ts\");\nconst logic_cell_1 = __webpack_require__(/*! ./logic_cell */ \"./src/logics/logic_cell.ts\");\nconst gobject_reterals_1 = __webpack_require__(/*! ./gobject_reterals */ \"./src/logics/gobject_reterals.ts\");\n//export type LogicTableDetailLine = LogicCell[]; \nfunction setCell(cell, value) {\n    if (value instanceof logic_cell_1.LogicCell) {\n        cell.copy(value);\n    }\n    else {\n        cell.text.textContent = value.toString();\n    }\n    //if(cell.groupOption)\n    //cell.groupOption = svgGroupOption;\n}\n/*\nexport type LogicTableLine = { name: string, values: (number | string | LogicCell)[], cellClass?: string | GOptions.ZTextBoxCSS }\nfunction setRow(table: LogicTable, ithRow: number, line: LogicTableLine) {\n    table.cells[ithRow][0].text.textContent = line.name;\n    line.values.forEach((v, i) => {\n        setCell(table.cells[ithRow][i + 1], v, line.cellClass);\n    })\n}\nfunction setColumn(table: LogicTable, ithColumn: number, line: LogicTableLine) {\n    table.cells[0][ithColumn].text.textContent = line.name;\n    line.values.forEach((v, i) => {\n        setCell(table.cells[i + 1][ithColumn], v, line.cellClass);\n    })\n}\nexport function createLogicTable(lines: LogicTableLine[] | LogicTableLine,\n    option?: { isRowLines?: boolean }): LogicTable {\n    if (option == undefined) option = {};\n    if (option.isRowLines == undefined) option.isRowLines = true;\n    //if (option.withIndex == undefined) option.withIndex = false;\n\n    if (lines instanceof Array) {\n\n\n        let maximalLineLength = 0;\n        lines.forEach((v) => {\n            if (maximalLineLength < v.values.length) {\n                maximalLineLength = v.values.length\n            }\n        }\n        )\n        const rowCount = option.isRowLines ? lines.length : maximalLineLength + 1;\n        const columnCount = option.isRowLines ? maximalLineLength + 1 : lines.length;\n        const table: LogicTable = new LogicTable({ rowCount: rowCount, columnCount: columnCount });\n\n        if (option.isRowLines) {\n            lines.forEach((v, i) => {\n                setRow(table, i, v);\n            })\n        } else {\n            lines.forEach((v, i) => {\n                setColumn(table, i, v);\n            })\n\n        }\n        return table;\n    } else {\n        return createLogicTable([lines], option);\n    }\n}\n*/\nfunction getIndexArray(length, zeroBased = true) {\n    return Array.from(Array(length).keys()).map((i) => zeroBased ? i : (i + 1));\n}\nexports.getIndexArray = getIndexArray;\nfunction getIndexArrayTableLine(length, zeroBased = true) {\n    const arr = getIndexArray(length, zeroBased);\n    const name = \"Index\";\n    const r = { name: name, values: arr };\n    return buildLogicCellLine(r.name, r.values);\n}\nexports.getIndexArrayTableLine = getIndexArrayTableLine;\nfunction setRow2(table, ithRow, line) {\n    //table.cells[ithRow][0].text.textContent = line.name;\n    line.forEach((v, i) => {\n        setCell(table.cells[ithRow][i], v);\n    });\n}\nfunction setColumn2(table, ithColumn, line) {\n    line.forEach((v, i) => {\n        setCell(table.cells[i][ithColumn], v);\n    });\n}\n/**\n * LogicCellLine\n * @param name\n * @param values\n * @param svgGroupOption\n * @returns\n */\nfunction buildLogicCellLine(name, values, cellOption = undefined) {\n    const titleCell = new logic_cell_1.LogicCell();\n    titleCell.text.textContent = name;\n    if (cellOption != undefined) {\n        titleCell.option = (0, gobject_reterals_1.deepCopy)(cellOption);\n    }\n    /*\n    if(cellClass !== undefined){\n        titleCell.cellClass = cellClass;\n    }\n    */\n    const cells = values.map((v) => {\n        const cell = new logic_cell_1.LogicCell();\n        cell.text.textContent = v.toString();\n        if (cellOption != undefined) {\n            cell.option = (0, gobject_reterals_1.deepCopy)(cellOption);\n        }\n        return cell;\n    });\n    return [titleCell].concat(cells);\n}\nexports.buildLogicCellLine = buildLogicCellLine;\n/**\n * LogicCellLineLogicTable\n * @param lines\n * @param option\n * @returns\n */\nfunction buildLogicTable(lines, option) {\n    if (option == undefined)\n        option = {};\n    if (option.isRowLines == undefined)\n        option.isRowLines = true;\n    //if (option.withIndex == undefined) option.withIndex = false;\n    let maximalLineLength = 0;\n    lines.forEach((v) => {\n        if (maximalLineLength < v.length) {\n            maximalLineLength = v.length;\n        }\n    });\n    const rowCount = option.isRowLines ? lines.length : maximalLineLength;\n    const columnCount = option.isRowLines ? maximalLineLength : lines.length;\n    const table = new logic_table_1.LogicTable({ rowCount: rowCount, columnCount: columnCount });\n    if (option.isRowLines) {\n        lines.forEach((v, i) => {\n            setRow2(table, i, v);\n        });\n    }\n    else {\n        lines.forEach((v, i) => {\n            setColumn2(table, i, v);\n        });\n    }\n    return table;\n}\nexports.buildLogicTable = buildLogicTable;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_table_line.ts?");

/***/ }),

/***/ "./src/logics/logic_text.ts":
/*!**********************************!*\
  !*** ./src/logics/logic_text.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicText = exports.LogicTSpan = void 0;\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst gobject_reterals_1 = __webpack_require__(/*! ./gobject_reterals */ \"./src/logics/gobject_reterals.ts\");\nclass LogicTSpan {\n    constructor() {\n        this.textContent = \"\";\n        this.isLatexMode = false;\n        this.textDecoration = null;\n    }\n    createTSpan() {\n        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n        tspan.textContent = this.textContent;\n        CSS.setCSSClass(tspan, this.class);\n        CSS.setCSSStyle(tspan, this.style);\n        if (this.textDecoration != null) {\n            tspan.setAttribute(\"text-decoration\", this.textDecoration);\n        }\n        return tspan;\n    }\n    parse(obj) {\n        this.textContent = obj[\"textContent\"];\n        this.class = obj[\"class\"];\n        this.style = obj[\"style\"];\n        this.isLatexMode = obj[\"isLatexMode\"];\n        this.textDecoration = obj[\"textDecoration\"];\n    }\n}\nexports.LogicTSpan = LogicTSpan;\n/**\n * \n */\nclass LogicText {\n    constructor(_text = null, _class, _style) {\n        this.textContent = \"\";\n        this.isLatexMode = false;\n        this.textDecoration = null;\n        if (_text == null) {\n            this.textContent = \"\";\n        }\n        else {\n            this.textContent = _text;\n        }\n        this.class = _class;\n        this.style = _style;\n    }\n    copyToTextElement(svgText) {\n        CSS.setCSSClass(svgText, this.class);\n        CSS.setCSSStyle(svgText, this.style);\n        if (typeof this.textContent == \"string\") {\n            SVGTextExtension.setTextContent(svgText, this.textContent, this.isLatexMode);\n        }\n        else {\n            svgText.textContent = \"\";\n            this.textContent.map((v) => v.createTSpan()).forEach((v) => {\n                svgText.appendChild(v);\n            });\n        }\n        if (this.textDecoration != null) {\n            svgText.setAttribute(\"text-decoration\", this.textDecoration);\n        }\n    }\n    buildFromObject(obj) {\n        if (Array.isArray(obj[\"textContent\"])) {\n            const arr = obj[\"textContent\"];\n            this.textContent = new Array(arr.length);\n            for (let i = 0; i < arr.length; i++) {\n                this.textContent[i] = new LogicTSpan();\n                this.textContent[i].parse(arr[i]);\n            }\n        }\n        else {\n            this.textContent = obj[\"textContent\"];\n        }\n        this.class = obj[\"class\"];\n        this.style = obj[\"style\"];\n        this.isLatexMode = obj[\"isLatexMode\"];\n        this.textDecoration = obj[\"textDecoration\"];\n    }\n    toReteral() {\n        const obj = new Object();\n        if (typeof this.textContent == \"string\") {\n            obj.textContent = this.textContent;\n        }\n        else {\n            (0, gobject_reterals_1.setSVGReteral)(obj, \"t\", undefined, this.class, this.style);\n        }\n        return obj;\n    }\n}\nexports.LogicText = LogicText;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_text.ts?");

/***/ }),

/***/ "./src/logics/logic_tree.ts":
/*!**********************************!*\
  !*** ./src/logics/logic_tree.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicTree = exports.LogicTreeNode = exports.LogicBasicShape = exports.Test = void 0;\n/*\nexport class BaseLogicTree {\n    public edgeLabel: string | null = null;\n    public nodeText: string | null = null;\n}\n*/\n//import * as Console from \"../../options/console\"\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./src/logics/logic_table.ts\");\n/*\nexport type LogicTreeOption = {\n    x?: number,\n    y?: number,\n    isLatexMode?: boolean\n    relocateStyle?: string\n    direction?: Direction | null;\n}\n*/\nfunction Test(obj) {\n    console.log(obj);\n    console.log(\"test\");\n}\nexports.Test = Test;\nclass LogicBasicShape {\n    get textContent() {\n        if (typeof (this.option.text) == \"string\") {\n            return this.option.text;\n        }\n        else if (this.option.text === undefined) {\n            return \"\";\n        }\n        else {\n            return \"\";\n        }\n    }\n    set textContent(value) {\n        this.option.text = value;\n    }\n    buildFromObject(obj) {\n        this.option = obj[\"option\"];\n        this.shape = obj[\"shape\"];\n        this.item = obj[\"item\"];\n    }\n    constructor(constructorOption = {}) {\n        this.option = {};\n        this.shape = enums_1.ShapeObjectType.Circle;\n        this.className = \"LogicBasicShape\";\n        this.item = null;\n        if (constructorOption.shape !== undefined) {\n            this.shape = constructorOption.shape;\n        }\n        if (constructorOption.option !== undefined) {\n            this.option = constructorOption.option;\n        }\n        if (constructorOption.text !== undefined) {\n            this.textContent = constructorOption.text;\n        }\n    }\n}\nexports.LogicBasicShape = LogicBasicShape;\n/**\n * \n */\nclass LogicTreeNode {\n    constructor(constructorOption = {}) {\n        this.edgeOption = { class: { pathTextAlignment: enums_1.PathTextAlighnment.regularInterval } };\n        this.children = [];\n        this.shapeObject = new LogicBasicShape();\n        if (constructorOption.vertexShape === enums_1.ShapeObjectType.Table) {\n            this.shapeObject = new logic_table_1.LogicTable();\n        }\n        if (constructorOption.edgeText !== undefined) {\n            this.edgeTextContent = constructorOption.edgeText;\n        }\n        if (constructorOption.vertexText !== undefined) {\n            if (this.shapeObject instanceof logic_table_1.LogicTable) {\n                throw Error(\"You cannot use vertexText if you use LogicTable as the shapeObject property in LogicTreeNode\");\n            }\n            else {\n                this.shapeObject.textContent = constructorOption.vertexText;\n            }\n        }\n    }\n    get edgeTextContent() {\n        if (typeof (this.edgeOption.text) == \"string\") {\n            return this.edgeOption.text;\n        }\n        else if (this.edgeOption.text === undefined) {\n            return \"\";\n        }\n        else {\n            return \"\";\n        }\n    }\n    set edgeTextContent(value) {\n        this.edgeOption.text = value;\n    }\n    buildFromObject(obj) {\n        this.edgeOption = obj[\"edgeOption\"];\n        const className = obj[\"shapeObject\"][\"className\"];\n        if (className == \"LogicTable\") {\n            this.shapeObject = new logic_table_1.LogicTable();\n        }\n        else {\n            this.shapeObject = new LogicBasicShape();\n        }\n        this.shapeObject.buildFromObject(obj[\"shapeObject\"]);\n        const children = obj[\"children\"];\n        this.children = children.map((v) => {\n            if (v == null) {\n                return null;\n            }\n            else {\n                const w = new LogicTreeNode();\n                w.buildFromObject(v);\n                return w;\n            }\n        });\n    }\n    getOrderedNodes(order = enums_1.VertexOrder.Preorder) {\n        const r = [];\n        const edges = this.children;\n        if (order == enums_1.VertexOrder.Preorder) {\n            r.push(this);\n            edges.forEach((v) => {\n                if (v != null) {\n                    v.getOrderedNodes(order).forEach((w) => {\n                        r.push(w);\n                    });\n                }\n            });\n        }\n        else if (order == enums_1.VertexOrder.Postorder) {\n            edges.forEach((v) => {\n                if (v != null) {\n                    v.getOrderedNodes(order).forEach((w) => {\n                        r.push(w);\n                    });\n                }\n            });\n            r.push(this);\n        }\n        return r;\n    }\n}\nexports.LogicTreeNode = LogicTreeNode;\nclass LogicTree {\n    constructor() {\n        this.option = { relocateStyle: \"standard\", direction: \"down\" };\n        this.root = null;\n        this.className = \"LogicTree\";\n    }\n    buildFromObject(obj) {\n        this.option = obj[\"option\"];\n        if (obj[\"root\"] != null) {\n            this.root = new LogicTreeNode();\n            this.root.buildFromObject(obj[\"root\"]);\n        }\n    }\n}\nexports.LogicTree = LogicTree;\n/**\n * \n */\n/*\nexport class BinaryLogicTree extends LogicTree {\n    public get left(): BinaryLogicTree | null {\n        const left = this.children[0];\n        if (left == null) {\n            return null;\n        } else {\n            return <BinaryLogicTree>left;\n        }\n    }\n    public set left(value: BinaryLogicTree | null) {\n        this.children[0] = value;\n    }\n    public get right(): BinaryLogicTree | null {\n        const right = this.children[1];\n        if (right == null) {\n            return null;\n        } else {\n            return <BinaryLogicTree>right;\n        }\n\n    }\n    public set right(value: BinaryLogicTree | null) {\n        this.children[1] = value;\n    }\n    constructor(public item: any = null, left: BinaryLogicTree | null = null, right: BinaryLogicTree | null = null, vertexOption?: GOptions.ZTextBoxAttributes, edgeOption?: GOptions.GGraphAttributes) {\n        super({ item: item == null ? undefined : item, children: [left, right], vertexOption: vertexOption, edgeOption : edgeOption });\n    }\n}\n*/\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_tree.ts?");

/***/ }),

/***/ "./src/objects/element_builder.ts":
/*!****************************************!*\
  !*** ./src/objects/element_builder.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createSVGText = exports.createPath = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\n/**\n     * SVGPathElement\n     * @param parent SVGPathElement\n     * @param x X\n     * @param y Y\n     * @param x2 X\n     * @param y2 Y\n     * @param className SVGPathElement\n     * @returns SVGPathElement\n     */\nfunction createPath(parent, x, y, x2, y2, className, style) {\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    parent.appendChild(path);\n    path.setAttribute(\"d\", (0, vline_1.escapeWithRound100) `M ${x} ${y} L ${x2} ${y2}`);\n    path.setAttribute(AttributeNames.objectIDName, (SVG.getNewID()).toString());\n    GOptions.setClassAndStyle(path, className, style);\n    return path;\n}\nexports.createPath = createPath;\n/**\n* SVGTextElement\n* @param className SVG\n* @returns SVGTextElement\n*/\nfunction createSVGText(className, style, dataName) {\n    const _svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    _svgText.setAttribute(AttributeNames.objectIDName, (SVG.getNewID()).toString());\n    if (dataName != null) {\n        _svgText.setAttribute(AttributeNames.dataNameAttribute, dataName);\n    }\n    if (style !== undefined) {\n        _svgText.setAttribute(\"style\", style);\n    }\n    //_svgText.style.textAnchor = \"middle\";\n    if (className === undefined) {\n        _svgText.setAttribute(\"class\", DefaultClassNames.defaultTextClass);\n    }\n    else if (className == null) {\n    }\n    else {\n        _svgText.setAttribute(\"class\", className);\n        //_svgText.className = className;\n    }\n    return _svgText;\n}\nexports.createSVGText = createSVGText;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/element_builder.ts?");

/***/ }),

/***/ "./src/objects/global_gobject_manager.ts":
/*!***********************************************!*\
  !*** ./src/objects/global_gobject_manager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GlobalZObjectManager = exports.LocalZObjectManager = exports.updateSVGSVGTimer = exports.textObserveTimer = void 0;\nconst z_observer_1 = __webpack_require__(/*! ./z_observer */ \"./src/objects/z_observer.ts\");\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\nlet updateSVGSVGTimerCounter = 0;\n/*\nexport function registerGObject(svgsvg: SVGSVGElement, obj: IObject) {\n    if ((<any>svgsvg)._gobjects === undefined) {\n        (<any>svgsvg)._gobjects = new Map<string, Object>();\n\n        setTimeout(updateSVGSVGTimer, timerInterval, svgsvg);\n\n    }\n\n    const map: Map<string, Object> = (<any>svgsvg)._gobjects;\n    if (map instanceof Map) {\n        map.set(obj.objectID, obj);\n\n    }\n}\n*/\nfunction textObserveTimer(manager) {\n    manager.map.forEach((value, key) => {\n        const x = value;\n        const svgText = x.svgText;\n        if (svgText instanceof SVGTextElement) {\n            (0, z_observer_1.updateTextByTimer)(svgText);\n        }\n        const svgPath = x.svgPath;\n        if (svgPath instanceof SVGPathElement) {\n            (0, z_observer_1.updatePathByTimer)(svgPath);\n        }\n    });\n}\nexports.textObserveTimer = textObserveTimer;\nfunction updateSVGSVGTimer(svgsvg) {\n    updateSVGSVGTimerCounter++;\n    const manager = svgsvg._manager;\n    if (manager instanceof LocalZObjectManager) {\n        textObserveTimer(manager);\n        manager.map.forEach((value, key) => {\n            const b = value.stableFlag;\n            if (!b) {\n                const b2 = value.childrenStableFlag;\n                if (b2) {\n                    const b3 = value.updateSurfaceWithoutSVGText();\n                    if (b3) {\n                        debugger_1.Debugger.updateUnstableFlagLog(value, updateSVGSVGTimer, \"false -> true\");\n                        value.svgGroup.setAttribute(z_observer_1.ObjectStableFlagName, \"true\");\n                    }\n                }\n            }\n        });\n    }\n    setTimeout(updateSVGSVGTimer, z_observer_1.timerInterval, svgsvg);\n}\nexports.updateSVGSVGTimer = updateSVGSVGTimer;\nclass LocalZObjectManager {\n    constructor(_svgsvgElement) {\n        this.map = new Map();\n        this.incomingEdgeMapFromVertexID = new Map();\n        this.outgoingEdgeMapFromVertexID = new Map();\n        this.beginVertexMapFromEdgeID = new Map();\n        this.endVertexMapFromEdgeID = new Map();\n        this.svgsvgElement = _svgsvgElement;\n        setTimeout(updateSVGSVGTimer, z_observer_1.timerInterval, this.svgsvgElement);\n    }\n    registerObject(obj) {\n        this.map.set(obj.objectID, obj);\n    }\n    getObject(key) {\n        return this.map.get(key);\n    }\n    dispose() {\n    }\n    removeBeginVertexObjectID(edge, beginVertexID) {\n        const objectID = edge.objectID;\n        const arr = this.outgoingEdgeMapFromVertexID.get(beginVertexID);\n        if (arr != undefined) {\n            for (let i = 0; i < arr.length; i++) {\n                if (arr[i].objectID == objectID) {\n                    arr.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    removeEndVertexObjectID(edge, endVertexID) {\n        const objectID = edge.objectID;\n        const arr = this.incomingEdgeMapFromVertexID.get(endVertexID);\n        if (arr != undefined) {\n            for (let i = 0; i < arr.length; i++) {\n                if (arr[i].objectID == objectID) {\n                    arr.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    addBeginVertexObjectID(edge, beginVertexID) {\n        const objectID = edge.objectID;\n        const arr = this.outgoingEdgeMapFromVertexID.get(beginVertexID);\n        if (arr == null) {\n            this.outgoingEdgeMapFromVertexID.set(beginVertexID, new Array(0));\n            this.addBeginVertexObjectID(edge, beginVertexID);\n        }\n        else {\n            arr.push(edge);\n        }\n    }\n    addEndVertexObjectID(edge, endVertexID) {\n        const objectID = edge.objectID;\n        const arr = this.incomingEdgeMapFromVertexID.get(endVertexID);\n        if (arr == null) {\n            this.incomingEdgeMapFromVertexID.set(endVertexID, new Array(0));\n            this.addEndVertexObjectID(edge, endVertexID);\n        }\n        else {\n            arr.push(edge);\n        }\n    }\n    getBeginVertexID(edge) {\n        const objectID = edge.objectID;\n        const beginVertexID = this.beginVertexMapFromEdgeID.get(objectID);\n        if (beginVertexID == null || beginVertexID == undefined) {\n            return null;\n        }\n        else {\n            return beginVertexID;\n        }\n    }\n    getEndVertexID(edge) {\n        const objectID = edge.objectID;\n        const endVertexID = this.endVertexMapFromEdgeID.get(objectID);\n        if (endVertexID == null || endVertexID == undefined) {\n            return null;\n        }\n        else {\n            return endVertexID;\n        }\n    }\n    registerBeginVertexID(edge, vertexID) {\n        const objectID = edge.objectID;\n        const oldBeginVertexID = this.beginVertexMapFromEdgeID.get(objectID);\n        if (oldBeginVertexID != undefined) {\n            this.removeBeginVertexObjectID(edge, oldBeginVertexID);\n        }\n        if (vertexID != null) {\n            this.addBeginVertexObjectID(edge, vertexID);\n        }\n        this.beginVertexMapFromEdgeID.set(objectID, vertexID);\n    }\n    registerEndVertexID(edge, vertexID) {\n        const objectID = edge.objectID;\n        const oldEndVertexID = this.endVertexMapFromEdgeID.get(objectID);\n        if (oldEndVertexID != undefined) {\n            this.removeEndVertexObjectID(edge, oldEndVertexID);\n        }\n        if (vertexID != null) {\n            this.addEndVertexObjectID(edge, vertexID);\n        }\n        this.endVertexMapFromEdgeID.set(objectID, vertexID);\n    }\n    getIncmoingEdges(obj) {\n        const id = obj.svgGroup.getAttribute(\"id\");\n        if (id == null) {\n            return null;\n        }\n        else {\n            const xb = this.incomingEdgeMapFromVertexID.get(id);\n            if (xb == undefined) {\n                return null;\n            }\n            else {\n                return xb.map((v) => v);\n            }\n        }\n    }\n    getOutgoingEdges(obj) {\n        const id = obj.svgGroup.getAttribute(\"id\");\n        if (id == null) {\n            return null;\n        }\n        else {\n            const xb = this.outgoingEdgeMapFromVertexID.get(id);\n            if (xb == undefined) {\n                return null;\n            }\n            else {\n                return xb.map((v) => v);\n            }\n        }\n    }\n}\nexports.LocalZObjectManager = LocalZObjectManager;\nclass GlobalZObjectManager {\n    //static items : LocalGObjectManager[] = new Array();\n    static getLocalGobjectManager(svgsvg) {\n        const p = svgsvg;\n        if (p._manager != undefined) {\n            return p._manager;\n        }\n        else {\n            return null;\n        }\n    }\n    static tryRegisterSVGSVGElement(svgsvg) {\n        const p = svgsvg;\n        if (p._manager == undefined) {\n            p._manager = new LocalZObjectManager(p);\n            return p._manager;\n        }\n        else {\n            return p._manager;\n        }\n    }\n    static deleteSVGSVGElement(svgsvg) {\n        const p = svgsvg;\n        if (p._manager != undefined) {\n            p._manager.dispose();\n            p._manager = undefined;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n}\nexports.GlobalZObjectManager = GlobalZObjectManager;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/global_gobject_manager.ts?");

/***/ }),

/***/ "./src/objects/graph_helpers/common_functions.ts":
/*!*******************************************************!*\
  !*** ./src/objects/graph_helpers/common_functions.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getGraph = void 0;\nconst z_object_1 = __webpack_require__(/*! ../z_object */ \"./src/objects/z_object.ts\");\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./src/common/attribute_names.ts\");\nfunction getGraph(obj) {\n    const v = obj.svgGroup.parentElement;\n    if (v != null && v instanceof SVGGElement && v.hasAttribute(AttributeNames.objectIDName)) {\n        const id = v.getAttribute(AttributeNames.objectIDName);\n        const obj = z_object_1.ZObject.getObjectFromIDOrObjectID(id);\n        if (obj instanceof z_object_1.ZObject) {\n            return obj;\n        }\n    }\n    return null;\n}\nexports.getGraph = getGraph;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/graph_helpers/common_functions.ts?");

/***/ }),

/***/ "./src/objects/graph_helpers/graph_arrangement.ts":
/*!********************************************************!*\
  !*** ./src/objects/graph_helpers/graph_arrangement.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GraphArrangement = void 0;\nconst SVGTextBox = __webpack_require__(/*! ../../interfaces/svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\nconst z_abstract_text_edge_1 = __webpack_require__(/*! ../z_abstract_text_edge */ \"./src/objects/z_abstract_text_edge.ts\");\nconst virtual_text_1 = __webpack_require__(/*! ../../interfaces/virtual_text */ \"./src/interfaces/virtual_text.ts\");\nconst virtual_tree_constructor_1 = __webpack_require__(/*! ./virtual_tree_constructor */ \"./src/objects/graph_helpers/virtual_tree_constructor.ts\");\nvar GraphArrangement;\n(function (GraphArrangement) {\n    function standardTreeWidthArrangement(graph) {\n        const [xi, yi] = graph.getXYIntervals();\n        const direction = graph.direction == null ? \"down\" : graph.direction;\n        const trees = (0, virtual_tree_constructor_1.createForestInLevelOrder)(graph);\n        let [x, y] = [0, 0];\n        trees.forEach((tree => {\n            standardTreeWidthArrangementSub(tree, xi, yi, direction);\n            tree.setRegionXYLocation(x, y);\n            x += tree.region().width;\n        }));\n    }\n    GraphArrangement.standardTreeWidthArrangement = standardTreeWidthArrangement;\n    function computeChildBInterval(tree, xInterval, yInterval, direction) {\n        const children = tree.virtualTreeChildren;\n        let interval = (direction == \"up\" || direction == \"down\") ? yInterval : xInterval;\n        //let childYInterval = yInterval;\n        children.forEach((v) => {\n            const edge = v.parentEdge;\n            if (edge instanceof z_abstract_text_edge_1.ZAbstractTextEdge) {\n                const path = edge.svgTextPath;\n                const textElement = edge.svgText;\n                if (path.textContent == null || path.textContent.length == 0) {\n                }\n                else if (path.textContent.length == 1) {\n                    const padding = SVGTextBox.getRepresentativeFontSize(path);\n                    const textVRegion = (0, virtual_text_1.getVirtualRegion)(textElement);\n                    const edgeLen = Math.max(textVRegion.width, textVRegion.height) + (padding);\n                    if (edgeLen > interval)\n                        interval = edgeLen;\n                }\n                else {\n                    const padding = SVGTextBox.getRepresentativeFontSize(path);\n                    const textVRegion = (0, virtual_text_1.getVirtualRegion)(textElement);\n                    const edgeLen = Math.max(textVRegion.width, textVRegion.height) + (padding * 4);\n                    //const edgeLen = (SVGTextExtensions.getWidth(path)) + (padding * 4);\n                    if (edgeLen > interval)\n                        interval = edgeLen;\n                }\n            }\n        });\n        return interval;\n    }\n    function preprocessParentWithSingleLeaf(parent, leaf, direction) {\n        if (direction == \"down\" || direction == \"up\") {\n            parent.cx = leaf.cx;\n        }\n        else {\n            parent.cy = leaf.cy;\n        }\n    }\n    function processSingleLeaf(parent, leafSubTree, width, direction) {\n        if (direction == \"down\") {\n            leafSubTree.setRootLocation(parent.cx, width);\n        }\n        else if (direction == \"up\") {\n            leafSubTree.setRootLocation(parent.cx, -width);\n        }\n        else if (direction == \"right\") {\n            leafSubTree.setRootLocation(width, parent.cy);\n        }\n        else {\n            leafSubTree.setRootLocation(-width, parent.cy);\n        }\n    }\n    function processIthChild(children, i, centerA, _a, aInterval, bInterval, childBInterval, direction) {\n        const ithChildrenRect = children[i].region();\n        const ratio = 2;\n        if (direction == \"down\" || direction == \"up\") {\n            const diffX = children[i].root.cx - ithChildrenRect.x;\n            let _x = _a;\n            let _centerX = centerA;\n            if (direction == \"down\") {\n                children[i].setRootLocation(_x + diffX, childBInterval);\n            }\n            else {\n                children[i].setRootLocation(_x + diffX, -childBInterval);\n            }\n            _x += ithChildrenRect.width + aInterval / ratio;\n            if (i < children.length - 1) {\n                _centerX += _x - (aInterval / (2 * ratio));\n            }\n            return [_centerX, _x];\n        }\n        else {\n            const diffY = children[i].root.cy - ithChildrenRect.y;\n            let _y = _a;\n            let _centerY = centerA;\n            if (direction == \"right\") {\n                children[i].setRootLocation(childBInterval, _y + diffY);\n            }\n            else {\n                children[i].setRootLocation(-childBInterval, _y + diffY);\n            }\n            _y += ithChildrenRect.height + bInterval / ratio;\n            if (i < children.length - 1) {\n                _centerY += _y - (bInterval / (2 * ratio));\n            }\n            return [_centerY, _y];\n        }\n    }\n    function processChildren(subtreeRoot, children, centerA, direction) {\n        if (direction == \"down\" || direction == \"up\") {\n            centerA = centerA / (children.length - 1);\n            subtreeRoot.cx = centerA;\n            return centerA;\n        }\n        else {\n            centerA = centerA / (children.length - 1);\n            subtreeRoot.cy = centerA;\n            return centerA;\n        }\n    }\n    function standardTreeWidthArrangementSub(tree, xInterval, yInterval, direction) {\n        tree.subTreeRoot.cx = 0;\n        tree.subTreeRoot.cy = 0;\n        const children = tree.virtualTreeChildren;\n        const childBInterval = computeChildBInterval(tree, xInterval, yInterval, direction);\n        if (children.length == 1) {\n            preprocessParentWithSingleLeaf(tree.subTreeRoot, children[0].root, direction);\n            standardTreeWidthArrangementSub(children[0], xInterval, yInterval, direction);\n            processSingleLeaf(tree.root, children[0], childBInterval, direction);\n        }\n        else if (children.length == 0) {\n        }\n        else {\n            let centerA = 0;\n            let _a = 0;\n            for (let i = 0; i < children.length; i++) {\n                standardTreeWidthArrangementSub(children[i], xInterval, yInterval, direction);\n                [centerA, _a] = processIthChild(children, i, centerA, _a, xInterval, yInterval, childBInterval, direction);\n            }\n            centerA = processChildren(tree.subTreeRoot, children, centerA, direction);\n            //= centerA / (children.length - 1);\n            //tree.subTreeRoot.cx = centerA;\n        }\n    }\n})(GraphArrangement || (exports.GraphArrangement = GraphArrangement = {}));\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/graph_helpers/graph_arrangement.ts?");

/***/ }),

/***/ "./src/objects/graph_helpers/virtual_tree.ts":
/*!***************************************************!*\
  !*** ./src/objects/graph_helpers/virtual_tree.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n//namespace GraphTableSVG {\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VirtualTree = void 0;\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./src/common/vline.ts\");\nclass VirtualTree {\n    constructor(_root, _externalEdgeDic) {\n        this.subTreeRoot = _root;\n        if (_externalEdgeDic !== undefined) {\n            this.externalEdges = _externalEdgeDic;\n        }\n        else {\n            this.externalEdges = new Set();\n        }\n    }\n    get root() {\n        return this.subTreeRoot;\n    }\n    /**\n     * \n     */\n    get children() {\n        //const p = this;\n        return this.subTreeRoot.outgoingEdges.filter((v) => !this.externalEdges.has(v) && v.endVertex != null).map((v) => v.endVertex);\n        /*\n        return this.subTreeRoot.children.map(function (x, i, arr) {\n            return x;\n        });\n        */\n    }\n    get virtualTreeChildren() {\n        return this.children.map((v) => v.createVirtualTree(this.externalEdges));\n        //const child = this.children[nth];\n        //return child.createVirtualTree(this.externalEdges);\n    }\n    /**\n     * \n     */\n    get parentEdge() {\n        const p = this.subTreeRoot.incomingEdges.filter((v) => !this.externalEdges.has(v) && v.beginVertex != null);\n        if (p.length != 0) {\n            return p[0];\n        }\n        else {\n            return null;\n        }\n        //return this.subTreeRoot.parentEdge;\n    }\n    /**\n     * Vertex\n     * @param result\n     */\n    getSubtree(result = []) {\n        result.push(this.subTreeRoot);\n        const children = this.virtualTreeChildren;\n        if (children.length == 0) {\n            return result;\n        }\n        else {\n            children.forEach(function (x, i, arr) {\n                x.getSubtree(result);\n            });\n            return result;\n        }\n    }\n    /*\n    public getLeaves(): Vertex[] {\n        const p = this;\n        return this.getSubtree().filter(function (x, i, arr) {\n            return x.outcomingEdges.length == 0;\n        });\n    }\n    */\n    getHeight() {\n        const children = this.virtualTreeChildren;\n        if (children.length == 0) {\n            return 1;\n        }\n        else {\n            let max = 0;\n            children.forEach(function (x, i, arr) {\n                if (max < x.getHeight())\n                    max = x.getHeight();\n            });\n            return max + 1;\n        }\n    }\n    /**\n     * \n     */\n    region() {\n        const p = this.getSubtree();\n        let minX = this.subTreeRoot.x;\n        let maxX = this.subTreeRoot.x;\n        let minY = this.subTreeRoot.y;\n        let maxY = this.subTreeRoot.y;\n        p.forEach(function (x, i, arr) {\n            const rect = x.region;\n            if (minX > rect.x)\n                minX = rect.x;\n            if (maxX < rect.right)\n                maxX = rect.right;\n            if (minY > rect.y)\n                minY = rect.y;\n            if (maxY < rect.bottom)\n                maxY = rect.bottom;\n        });\n        const result = new vline_1.Rectangle();\n        result.x = minX;\n        result.y = minY;\n        result.width = maxX - minX;\n        result.height = maxY - minY;\n        return result;\n    }\n    /**\n     * \n     */\n    get mostLeftLeave() {\n        return this.leaves[0];\n    }\n    addOffset(_x, _y) {\n        this.getSubtree().forEach(function (x, i, arr) {\n            x.cx += _x;\n            x.cy += _y;\n        });\n    }\n    setRectangleLocation(_x, _y) {\n        const x = this.mostLeftLeave.region.x;\n        const y = this.subTreeRoot.region.y;\n        const diffX = _x - x;\n        const diffY = _y - y;\n        this.addOffset(diffX, diffY);\n        //this.graph.updateEdges();\n    }\n    /**\n     * \n     * @param _x\n     * @param _y\n     */\n    setRootLocation(_x, _y) {\n        const x = this.subTreeRoot.cx;\n        const y = this.subTreeRoot.cy;\n        const diffX = _x - x;\n        const diffY = _y - y;\n        this.addOffset(diffX, diffY);\n        //this.graph.updateEdges();\n    }\n    setRegionXYLocation(_x, _y) {\n        const region = this.region();\n        const newX = _x - region.x;\n        const newY = _y - region.y;\n        this.addOffset(newX, newY);\n        //this.graph.updateEdges();\n    }\n    /**\n     * \n     */\n    get leaves() {\n        //const p = this;\n        return this.getSubtree().filter((x) => {\n            const r = x.outgoingEdges.filter((v) => !this.externalEdges.has(v) && v.endVertex != null).length;\n            return r == 0;\n        });\n        //return this.getSubtree().filter(function (x, i, arr) {\n        //\n        //    return x.outcomingEdges.length == 0;\n        //});\n    }\n}\nexports.VirtualTree = VirtualTree;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/graph_helpers/virtual_tree.ts?");

/***/ }),

/***/ "./src/objects/graph_helpers/virtual_tree_constructor.ts":
/*!***************************************************************!*\
  !*** ./src/objects/graph_helpers/virtual_tree_constructor.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createForestInLevelOrder = void 0;\nfunction createForestInLevelOrder(graph) {\n    const roots = graph.roots.length == 0 ? [graph.vertices[0]] : graph.roots;\n    const externalEdges = createExternalEdgeDicInLevelOrder(graph);\n    return roots.map((v) => v.createVirtualTree(externalEdges));\n}\nexports.createForestInLevelOrder = createForestInLevelOrder;\nfunction createExternalEdgeDicInLevelOrder(graph) {\n    const externalEdges = new Set();\n    const touchedVertexes = new Set();\n    const inputEdges = new Array(0);\n    if (graph.vertices.length > 0) {\n        const roots = graph.roots.length == 0 ? [graph.vertices[0]] : graph.roots;\n        roots.forEach((v => {\n            touchedVertexes.add(v);\n            v.outgoingEdges.forEach((w) => inputEdges.push(w));\n        }));\n        createExternalEdgeDicInLevelOrderSub(inputEdges, externalEdges, touchedVertexes, 0);\n    }\n    return externalEdges;\n}\nfunction createExternalEdgeDicInLevelOrderSub(inputEdges, externalEdges, touchedVertexes, level) {\n    //const edges = inputEdges.filter((v) => v.endVertex != null);\n    const nextEdges = new Array(0);\n    inputEdges.forEach((v) => {\n        if (v.endVertex != null) {\n            const node = v.endVertex;\n            if (!touchedVertexes.has(node)) {\n                touchedVertexes.add(node);\n                node.outgoingEdges.forEach((w) => nextEdges.push(w));\n            }\n            else {\n                externalEdges.add(v);\n            }\n        }\n    });\n    if (nextEdges.length > 0) {\n        createExternalEdgeDicInLevelOrderSub(nextEdges, externalEdges, touchedVertexes, level + 1);\n    }\n}\nfunction createExternalEdgeDicInPreorder(node, incomingEdge, externalEdges, touchedVertexes) {\n    if (incomingEdge == null) {\n        node.outgoingEdges.forEach((v) => {\n            const child = v.endVertex;\n            if (child != null) {\n                createExternalEdgeDicInPreorder(child, v, externalEdges, touchedVertexes);\n            }\n        });\n    }\n    else {\n        if (!touchedVertexes.has(node)) {\n            touchedVertexes.add(node);\n            node.outgoingEdges.forEach((v) => {\n                const child = v.endVertex;\n                if (child != null) {\n                    createExternalEdgeDicInPreorder(child, v, externalEdges, touchedVertexes);\n                }\n            });\n        }\n        else {\n            if (incomingEdge != null) {\n                externalEdges.add(incomingEdge);\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/graph_helpers/virtual_tree_constructor.ts?");

/***/ }),

/***/ "./src/objects/index.ts":
/*!******************************!*\
  !*** ./src/objects/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * \n * @module\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZForeignObject = exports.GraphArrangement = exports.VirtualTree = exports.GOptions = exports.ZPathTextBox = exports.ZVertex = exports.ZTextBox = exports.ZTable = exports.ZRect = exports.ZRectButton = exports.ZGraph = exports.ZEllipse = exports.ZEdge = exports.ZCircle = exports.ZCallout = exports.ZArrowCallout = exports.ZObject = void 0;\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nObject.defineProperty(exports, \"ZObject\", ({ enumerable: true, get: function () { return z_object_1.ZObject; } }));\nconst z_arrow_callout_1 = __webpack_require__(/*! ./z_arrow_callout */ \"./src/objects/z_arrow_callout.ts\");\nObject.defineProperty(exports, \"ZArrowCallout\", ({ enumerable: true, get: function () { return z_arrow_callout_1.ZArrowCallout; } }));\nconst z_callout_1 = __webpack_require__(/*! ./z_callout */ \"./src/objects/z_callout.ts\");\nObject.defineProperty(exports, \"ZCallout\", ({ enumerable: true, get: function () { return z_callout_1.ZCallout; } }));\nconst z_circle_1 = __webpack_require__(/*! ./z_circle */ \"./src/objects/z_circle.ts\");\nObject.defineProperty(exports, \"ZCircle\", ({ enumerable: true, get: function () { return z_circle_1.ZCircle; } }));\nconst z_edge_1 = __webpack_require__(/*! ./z_edge */ \"./src/objects/z_edge.ts\");\nObject.defineProperty(exports, \"ZEdge\", ({ enumerable: true, get: function () { return z_edge_1.ZEdge; } }));\nconst z_ellipse_1 = __webpack_require__(/*! ./z_ellipse */ \"./src/objects/z_ellipse.ts\");\nObject.defineProperty(exports, \"ZEllipse\", ({ enumerable: true, get: function () { return z_ellipse_1.ZEllipse; } }));\nconst z_graph_1 = __webpack_require__(/*! ./z_graph */ \"./src/objects/z_graph.ts\");\nObject.defineProperty(exports, \"ZGraph\", ({ enumerable: true, get: function () { return z_graph_1.ZGraph; } }));\nconst z_rect_button_1 = __webpack_require__(/*! ./z_rect_button */ \"./src/objects/z_rect_button.ts\");\nObject.defineProperty(exports, \"ZRectButton\", ({ enumerable: true, get: function () { return z_rect_button_1.ZRectButton; } }));\nconst z_rect_1 = __webpack_require__(/*! ./z_rect */ \"./src/objects/z_rect.ts\");\nObject.defineProperty(exports, \"ZRect\", ({ enumerable: true, get: function () { return z_rect_1.ZRect; } }));\nconst z_table_1 = __webpack_require__(/*! ./z_table */ \"./src/objects/z_table.ts\");\nObject.defineProperty(exports, \"ZTable\", ({ enumerable: true, get: function () { return z_table_1.ZTable; } }));\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\nObject.defineProperty(exports, \"ZTextBox\", ({ enumerable: true, get: function () { return z_textbox_1.ZTextBox; } }));\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nObject.defineProperty(exports, \"ZVertex\", ({ enumerable: true, get: function () { return z_vertex_1.ZVertex; } }));\nconst z_foreign_object_1 = __webpack_require__(/*! ./z_foreign_object */ \"./src/objects/z_foreign_object.ts\");\nObject.defineProperty(exports, \"ZForeignObject\", ({ enumerable: true, get: function () { return z_foreign_object_1.ZForeignObject; } }));\nconst virtual_tree_1 = __webpack_require__(/*! ./graph_helpers/virtual_tree */ \"./src/objects/graph_helpers/virtual_tree.ts\");\nObject.defineProperty(exports, \"VirtualTree\", ({ enumerable: true, get: function () { return virtual_tree_1.VirtualTree; } }));\nconst graph_arrangement_1 = __webpack_require__(/*! ./graph_helpers/graph_arrangement */ \"./src/objects/graph_helpers/graph_arrangement.ts\");\nObject.defineProperty(exports, \"GraphArrangement\", ({ enumerable: true, get: function () { return graph_arrangement_1.GraphArrangement; } }));\n//import * as TreeArrangement from \"./graph_helpers/tree_arrangement\"\nconst z_path_textbox_1 = __webpack_require__(/*! ./z_path_textbox */ \"./src/objects/z_path_textbox.ts\");\nObject.defineProperty(exports, \"ZPathTextBox\", ({ enumerable: true, get: function () { return z_path_textbox_1.ZPathTextBox; } }));\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nexports.GOptions = GOptions;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/index.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/border_column.ts":
/*!****************************************************!*\
  !*** ./src/objects/table_helpers/border_column.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BorderColumn = void 0;\n//namespace GraphTableSVG {\nconst cell_1 = __webpack_require__(/*! ./cell */ \"./src/objects/table_helpers/cell.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./src/interfaces/svg.ts\");\nclass BorderColumn {\n    /**\n    Y\n    */\n    get borderX() {\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\n    }\n    set borderX(v) {\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\n    }\n    get svgGroup() {\n        return this._svgGroup;\n    }\n    constructor(_table, _x, rowSize, borderClass) {\n        this._borders = new Array(0);\n        this.table = _table;\n        this._svgGroup = SVG.createGroup(this.table.svgColumnBorderGroup);\n        this._svgGroup.setAttribute(\"name\", \"border_column\");\n        this.borderX = _x;\n        for (let y = 0; y < rowSize; y++) {\n            this.insertBorder(y, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\n        }\n    }\n    get borders() {\n        return this._borders;\n    }\n    insertBorder(rowi, borderClass) {\n        const line = SVG.createLine(0, 0, 0, 0, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\n        this._svgGroup.appendChild(line);\n        this._borders.splice(rowi, 0, line);\n    }\n    removeBorder(i) {\n        this._borders[i].remove();\n        this._borders.splice(i, 1);\n    }\n    remove() {\n        this.svgGroup.remove();\n    }\n}\nexports.BorderColumn = BorderColumn;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/border_column.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/border_row.ts":
/*!*************************************************!*\
  !*** ./src/objects/table_helpers/border_row.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BorderRow = void 0;\n//namespace GraphTableSVG {\nconst cell_1 = __webpack_require__(/*! ./cell */ \"./src/objects/table_helpers/cell.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./src/interfaces/svg.ts\");\n/**\n * \n */\nclass BorderRow {\n    get svgGroup() {\n        return this._svgGroup;\n    }\n    /**\n    Y\n    */\n    get borderY() {\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\n    }\n    set borderY(v) {\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\n    }\n    constructor(_table, _y, columnSize, borderClass) {\n        this._borders = new Array(0);\n        this.table = _table;\n        this._svgGroup = SVG.createGroup(this.table.svgRowBorderGroup);\n        this._svgGroup.setAttribute(\"name\", \"border_row\");\n        this.borderY = _y;\n        for (let x = 0; x < columnSize; x++) {\n            this.insertBorder(x, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\n        }\n    }\n    get borders() {\n        return this._borders;\n    }\n    insertBorder(coromni, borderClass) {\n        const line = SVG.createLine(0, 0, 0, 0, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\n        this._svgGroup.appendChild(line);\n        this._borders.splice(coromni, 0, line);\n    }\n    removeBorder(i) {\n        this._borders[i].remove();\n        this._borders.splice(i, 1);\n    }\n    remove() {\n        this.svgGroup.remove();\n    }\n}\nexports.BorderRow = BorderRow;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/border_row.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/cell.ts":
/*!*******************************************!*\
  !*** ./src/objects/table_helpers/cell.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n//namespace GraphTableSVG {\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Cell = exports.DirectionType2 = void 0;\nconst CommonFunctions = __webpack_require__(/*! ../../common/common_functions */ \"./src/common/common_functions.ts\");\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./src/common/vline.ts\");\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../../common/style_names */ \"./src/common/style_names.ts\");\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./src/interfaces/svg.ts\");\n//import {CellOption} from \"../../options/attributes_option\"\nconst enums_1 = __webpack_require__(/*! ../../common/enums */ \"./src/common/enums.ts\");\nconst ElementExtension = __webpack_require__(/*! ../../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGGExtension = __webpack_require__(/*! ../../interfaces/svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\nconst SVGElementExtension = __webpack_require__(/*! ../../interfaces/svg_element_extension */ \"./src/interfaces/svg_element_extension.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst virtual_text_1 = __webpack_require__(/*! ../../interfaces/virtual_text */ \"./src/interfaces/virtual_text.ts\");\nconst debugger_1 = __webpack_require__(/*! ../../common/debugger */ \"./src/common/debugger.ts\");\nconst column_1 = __webpack_require__(/*! ./column */ \"./src/objects/table_helpers/column.ts\");\nconst row_1 = __webpack_require__(/*! ./row */ \"./src/objects/table_helpers/row.ts\");\nconst GObserver = __webpack_require__(/*! ../z_observer */ \"./src/objects/z_observer.ts\");\nconst html_functions_1 = __webpack_require__(/*! ../../html/html_functions */ \"./src/html/html_functions.ts\");\nconst global_gobject_manager_1 = __webpack_require__(/*! ../global_gobject_manager */ \"./src/objects/global_gobject_manager.ts\");\n//{\n//    top = 0, left = 1, right = 2, bottom = 3\n//}\nvar DirectionType2;\n(function (DirectionType2) {\n    DirectionType2[DirectionType2[\"topLeft\"] = 0] = \"topLeft\";\n    DirectionType2[DirectionType2[\"bottomLeft\"] = 1] = \"bottomLeft\";\n    DirectionType2[DirectionType2[\"bottomRight\"] = 2] = \"bottomRight\";\n    DirectionType2[DirectionType2[\"topRight\"] = 3] = \"topRight\";\n})(DirectionType2 || (exports.DirectionType2 = DirectionType2 = {}));\nlet uniqueCellID = 0;\n/**\n * SVG\n */\nclass Cell {\n    constructor(parent, _px, _py, cellMap, option = {}) {\n        this.__currentClass = null;\n        this.tmpStyle = null;\n        this._observerFunc = (x) => {\n            for (let i = 0; i < x.length; i++) {\n                const p = x[i];\n                if (p.attributeName == \"style\" || p.attributeName == \"class\") {\n                    if (p.attributeName == \"class\") {\n                        const className = this.svgGroup.getAttribute(\"class\");\n                        if (className != this.__currentClass) {\n                            this.recomputeDefaultProperties();\n                            this.__currentClass = className;\n                        }\n                    }\n                    this.locateSVGText();\n                }\n            }\n        };\n        // #endregion\n        this._assurancevisibility = false;\n        this._svgGroup = SVG.createGroup(null);\n        this._table = parent;\n        this.table.rows[_py].svgGroup.appendChild(this.svgGroup);\n        //this.table.svgGroup.insertBefore(this.svgGroup, this.table.svgGroup.firstChild);\n        this.svgGroup.setAttribute(\"class\", option.cellClass !== undefined ? option.cellClass : DefaultClassNames.defaultCellClass);\n        this.svgGroup.setAttribute(AttributeNames.GroupAttribute, \"cell\");\n        this.svgGroup.setAttribute(Cell.cellXName, `${_px}`);\n        this.svgGroup.setAttribute(Cell.cellYName, `${_py}`);\n        this.setMasterDiffX(0);\n        this.setMasterDiffY(0);\n        const backGroundClass = DefaultClassNames.defaultCellBackgroungClass;\n        this._svgSurface = SVG.createCellRectangle(this.svgGroup, backGroundClass);\n        this._svgSurface.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Surface);\n        const textClass = DefaultClassNames.defaultTextClass;\n        this._svgText = SVG.createText(textClass);\n        this._svgText.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Text);\n        this.svgGroup.appendChild(this.svgText);\n        cellMap.set(this.objectID, this);\n        this.stableFlag = false;\n        //const borderClass = option.borderClass === undefined ? null : option.borderClass;\n        //const option1: MutationObserverInit = { childList: true, subtree: true };\n        //this.table.cellTextObserver.observe(this.svgText, option1);\n        //this.unstableCounter = GObserver.unstableCounterDefault;\n        this._observer = new MutationObserver(this._observerFunc);\n        const option2 = { attributes: true };\n        this._observer.observe(this.svgGroup, option2);\n        const svgsvgAncestor = (0, html_functions_1.getSVGSVGAncestor)(this.svgGroup);\n        if (svgsvgAncestor != null) {\n            const xb = global_gobject_manager_1.GlobalZObjectManager.tryRegisterSVGSVGElement(svgsvgAncestor);\n            xb.registerObject(this);\n        }\n    }\n    updateSurfaceWithoutSVGText() {\n        if (this.childrenStableFlag) {\n            this.tryUpdateWithUpdateFlag(true);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    get stableFlag() {\n        return this.svgGroup.getAttribute(GObserver.ObjectStableFlagName) == \"true\";\n    }\n    set stableFlag(b) {\n        this.svgGroup.setAttribute(GObserver.ObjectStableFlagName, b ? \"true\" : \"false\");\n    }\n    get childrenStableFlag() {\n        const b = this.svgText.getAttribute(GObserver.ObjectStableFlagName);\n        return b == \"true\";\n    }\n    get objectID() {\n        return this.svgGroup.getAttribute(AttributeNames.objectIDName);\n    }\n    getBorderPosition(borderType, positionType) {\n        let border = this.svgTopBorder;\n        switch (borderType) {\n            case \"top\":\n                border = this.svgTopBorder;\n                break;\n            case \"left\":\n                border = this.svgLeftBorder;\n                break;\n            case \"right\":\n                border = this.svgRightBorder;\n                break;\n            case \"bottom\":\n                border = this.svgBottomBorder;\n                break;\n        }\n        switch (positionType) {\n            case \"x1\":\n                return (0, vline_1.round100)(border.x1.baseVal.value);\n            case \"x2\":\n                return (0, vline_1.round100)(border.x2.baseVal.value);\n            case \"y1\":\n                return (0, vline_1.round100)(border.y1.baseVal.value);\n            case \"y2\":\n                return (0, vline_1.round100)(border.y2.baseVal.value);\n        }\n        throw new Error(\"Error\");\n    }\n    // #region style\n    recomputeDefaultProperties() {\n        /*\n        if(this.defaultBackgroundClass != null){\n            this._svgBackground.setAttribute(\"class\", this.defaultBackgroundClass);\n        }\n        if(this.defaultTextClass != null){\n            this._svgText.setAttribute(\"class\", this.defaultTextClass);\n        }\n        */\n    }\n    /*\n    public get class() : string | null{\n        return this.svgGroup.getAttribute(\"class\");\n    }\n    public set class(value : string | null){\n        if(value == null){\n            this.svgGroup.removeAttribute(\"class\");\n        }else{\n            this.svgGroup.setAttribute(\"class\", value);\n        }\n    }\n    */\n    /**\n     * \n     */\n    get isEmphasized() {\n        const cellClass = this.svgSurface.getAttribute(\"class\");\n        return cellClass == AttributeNames.cellEmphasisCellClass;\n    }\n    set isEmphasized(v) {\n        if (v) {\n            if (!this.isEmphasized) {\n                this.tmpStyle = this.svgSurface.getAttribute(\"class\");\n                this.svgSurface.setAttribute(\"class\", AttributeNames.cellEmphasisCellClass);\n            }\n        }\n        else {\n            if (this.isEmphasized) {\n                if (this.tmpStyle == null) {\n                    this.svgSurface.removeAttribute(\"class\");\n                }\n                else {\n                    this.svgSurface.setAttribute(\"class\", this.tmpStyle);\n                    this.tmpStyle = null;\n                }\n            }\n        }\n    }\n    /**\n     * \n     */\n    get fontSize() {\n        const p = ElementExtension.getPropertyStyleValueWithDefault(this.svgText, \"font-size\", \"24\");\n        const p2 = parseInt(p);\n        return p2;\n    }\n    get primitivePaddingLeft() {\n        return 3;\n    }\n    get primitivePaddingRight() {\n        return 3;\n    }\n    /**\n    \n    */\n    get paddingLeft() {\n        return SVGElementExtension.getPaddingLeft(this.svgGroup);\n    }\n    /**\n    \n    */\n    get paddingRight() {\n        return SVGElementExtension.getPaddingRight(this.svgGroup);\n    }\n    /**\n    \n    */\n    get paddingTop() {\n        return SVGElementExtension.getPaddingTop(this.svgGroup);\n    }\n    /**\n    \n    */\n    get paddingBottom() {\n        return SVGElementExtension.getPaddingBottom(this.svgGroup);\n    }\n    get horizontalAnchor() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.horizontalAnchor, \"center\");\n        return enums_1.HorizontalAnchor.toHorizontalAnchor(b);\n    }\n    /**\n    \n    */\n    set horizontalAnchor(value) {\n        if (this.horizontalAnchor != value)\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.horizontalAnchor, value);\n    }\n    /**\n    \n    */\n    get verticalAnchor() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.verticalAnchor, \"middle\");\n        return enums_1.VerticalAnchor.toVerticalAnchor(b);\n    }\n    /**\n    \n    */\n    set verticalAnchor(value) {\n        if (this.verticalAnchor != value)\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.verticalAnchor, value);\n    }\n    /**\n    Table\n    */\n    get table() {\n        return this._table;\n    }\n    /**\n    SVGRectElement\n    */\n    get svgSurface() {\n        return this._svgSurface;\n    }\n    /**\n    SVGTextElement\n    */\n    get svgText() {\n        return this._svgText;\n    }\n    /**\n    SVGGElement\n    */\n    get svgGroup() {\n        return this._svgGroup;\n    }\n    // #endregion\n    // #region property\n    get innerExtraPaddingLeft() {\n        const p = this.fontSize;\n        return p / 16;\n    }\n    get innerExtraPaddingRight() {\n        const p = this.fontSize;\n        return p / 16;\n    }\n    //private _masterID: number;\n    /**\n     * xX\n     */\n    get masterDiffX() {\n        return Number(this.svgGroup.getAttribute(Cell.masterDiffXName));\n    }\n    /**\n     * xX\n     */\n    setMasterDiffX(id) {\n        this.svgGroup.setAttribute(Cell.masterDiffXName, `${id}`);\n    }\n    /**\n     * yy\n     */\n    get masterDiffY() {\n        return Number(this.svgGroup.getAttribute(Cell.masterDiffYName));\n    }\n    /**\n     * yy\n     */\n    setMasterDiffY(id) {\n        this.svgGroup.setAttribute(Cell.masterDiffYName, `${id}`);\n    }\n    /**\n     * x\n     */\n    get masterCellX() {\n        return this.cellX + this.masterDiffX;\n    }\n    /**\n     * x\n     */\n    setMasterCellX(id) {\n        this.setMasterDiffX(id - this.cellX);\n    }\n    /**\n     * y\n     */\n    get masterCellY() {\n        return this.cellY + this.masterDiffY;\n    }\n    /**\n     * y\n     */\n    setMasterCellY(id) {\n        this.setMasterDiffY(id - this.cellY);\n    }\n    /**\n     * ID\n     */\n    get masterObjectID() {\n        return this.table.cells[this.masterCellY][this.masterCellX].objectID;\n    }\n    /*\n    public set masterID(id: number) {\n        this.svgGroup.setAttribute(Cell.masterIDName, `${id}`);\n    }\n    */\n    /**\n     * \n     */\n    get master() {\n        return this.table.getCellFromObjectID(this.masterObjectID);\n    }\n    /**\n    X\n    */\n    get cellX() {\n        return Number(this.svgGroup.getAttribute(Cell.cellXName));\n    }\n    /**\n    X\n    */\n    set cellX(value) {\n        if (this.cellX != value)\n            this.svgGroup.setAttribute(Cell.cellXName, value.toString());\n    }\n    /**\n    Y\n    */\n    get cellY() {\n        return Number(this.svgGroup.getAttribute(Cell.cellYName));\n    }\n    /**\n    Y\n    */\n    set cellY(value) {\n        if (this.cellY != value)\n            this.svgGroup.setAttribute(Cell.cellYName, value.toString());\n    }\n    /*\n    get defaultTextClass(): string | null {\n        const r = this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultTextClass);\n        return r;\n    }\n    get defaultBackgroundClass(): string | null {\n        const v = this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultCellBackgroundClass);\n        return v;\n    }\n    */\n    /**\n    CellDocumentDOM\n    */\n    get isLocated() {\n        return CommonFunctions.IsDescendantOfBody(this.svgGroup);\n    }\n    /**\n     * True\n     */\n    get isMaster() {\n        return this.objectID == this.masterObjectID;\n    }\n    /**\n     * True\n     */\n    get isSlave() {\n        return !this.isMaster;\n    }\n    /*\n     get ID(): number {\n         return this.cellX + (this.cellY * this.table.columnCount);\n     }\n     */\n    get isErrorCell() {\n        return this.table.cells[this.cellY][this.cellX] != this;\n    }\n    /**\n     * \n     */\n    get GroupRowCount() {\n        if (!this.isMaster)\n            throw Error(\"Slave Error\");\n        return this.leftSideGroupCells.length;\n    }\n    /**\n     * \n     */\n    get GroupColumnCount() {\n        if (!this.isMaster)\n            throw Error(\"Slave Error\");\n        return this.upperSideGroupCells.length;\n    }\n    /**\n     * 2\n     */\n    get cellsInGroup() {\n        if (this.isMaster) {\n            return this.table.getRangeCells(this.cellX, this.cellY, this.GroupColumnCount, this.GroupRowCount);\n        }\n        else {\n            throw Error(\"Slave Error\");\n        }\n    }\n    /**\n     * \n     */\n    get cellArrayInGroup() {\n        if (this.isMaster) {\n            return this.table.getRangeCellArray(this.cellX, this.cellY, this.GroupColumnCount, this.GroupRowCount);\n        }\n        else {\n            throw Error(\"Slave Error\");\n        }\n    }\n    /**\n     * True\n     */\n    get isSingleCell() {\n        return this.isMaster && this.leftSideGroupCells.length == 1 && this.upperSideGroupCells.length == 1;\n    }\n    /**\n     * True\n     */\n    get isMasterCellOfRowCountOne() {\n        return this.isMaster && this.leftSideGroupCells.length == 1;\n    }\n    /**\n     * True\n     */\n    get isMasterCellOfColumnCountOne() {\n        return this.isMaster && this.upperSideGroupCells.length == 1;\n    }\n    /**\n    X\n    */\n    get x() {\n        return (0, vline_1.round100)(SVGGExtension.getX(this.svgGroup));\n    }\n    /**\n    X\n    */\n    set x(value) {\n        SVGGExtension.setX(this.svgGroup, (0, vline_1.round100)(value));\n    }\n    /**\n    Y\n    */\n    get y() {\n        return (0, vline_1.round100)(SVGGExtension.getY(this.svgGroup));\n    }\n    /**\n    Y\n    */\n    set y(value) {\n        SVGGExtension.setY(this.svgGroup, (0, vline_1.round100)(value));\n    }\n    /**\n    \n    */\n    get width() {\n        return (0, vline_1.round100)(this.svgSurface.width.baseVal.value);\n    }\n    /**\n    \n    */\n    set width(value) {\n        const newValue = (0, vline_1.round100)(value);\n        this.svgSurface.width.baseVal.value = newValue;\n    }\n    /**\n    \n    */\n    get height() {\n        return (0, vline_1.round100)(this.svgSurface.height.baseVal.value);\n    }\n    /**\n    \n    */\n    set height(value) {\n        const newValue = (0, vline_1.round100)(value);\n        this.svgSurface.height.baseVal.value = newValue;\n    }\n    /**\n    RectangleSVGGElement\n    */\n    get region() {\n        const p = new vline_1.Rectangle(this.x, this.y, this.width, this.height);\n        return p;\n    }\n    /**\n     * \n     */\n    get computeGroupWidth() {\n        if (this.isSingleCell) {\n            return this.width;\n        }\n        else {\n            const p = this.master.upperSideGroupCells;\n            const x2 = p[p.length - 1].cellX;\n            let w = 0;\n            for (let i = this.cellX; i <= x2; i++) {\n                w += this.table.columns[i].width;\n            }\n            return w;\n        }\n    }\n    /**\n     * \n     */\n    get computeGroupHeight() {\n        if (this.isSingleCell) {\n            return this.height;\n        }\n        else {\n            const p = this.master.leftSideGroupCells;\n            const y2 = p[p.length - 1].cellY;\n            let w = 0;\n            for (let i = this.cellY; i <= y2; i++) {\n                w += this.table.rows[i].height;\n            }\n            return w;\n        }\n    }\n    /**\n     * \n     * @param v\n     * @param w\n     */\n    static computeOverlapRange(v, w) {\n        if (w[0] < v[0]) {\n            return Cell.computeOverlapRange(w, v);\n        }\n        else {\n            if (v[1] < w[0]) {\n                return null;\n            }\n            else {\n                if (w[1] < v[1]) {\n                    return [w[0], w[1]];\n                }\n                else {\n                    return [w[0], v[1]];\n                }\n            }\n        }\n    }\n    /**\n     * \n     * @param v\n     * @param w\n     */\n    static computeDisjunction(v, w) {\n        if (w[0] < v[0]) {\n            return Cell.computeDisjunction(w, v);\n        }\n        else {\n            if (v[1] < w[0]) {\n                return null;\n            }\n            else {\n                return [v[0], Math.max(v[1], w[1])];\n            }\n        }\n    }\n    /**\n     * XX\n     */\n    get groupColumnRange() {\n        return [this.master.cellX, this.master.mostRightCellX];\n    }\n    /**\n     * YY\n     */\n    get groupRowRange() {\n        return [this.master.cellY, this.master.mostBottomCellY];\n    }\n    computeBorderLength2(dir) {\n        //const andFunc = ((v, w) => v);\n        const d1 = dir == \"top\" || dir == \"bottom\" ? this.master.x : this.master.y;\n        const d2 = dir == \"top\" || dir == \"bottom\" ? this.master.x + this.computeGroupWidth : this.master.y + this.computeGroupHeight;\n        const nextCell = this.getNextMasterCell(dir);\n        if (nextCell != null) {\n            const e1 = dir == \"top\" || dir == \"bottom\" ? nextCell.x : nextCell.y;\n            const e2 = dir == \"top\" || dir == \"bottom\" ? nextCell.x + nextCell.computeGroupWidth : nextCell.y + nextCell.computeGroupHeight;\n            //const e2 = nextCell.x;\n            const range = Cell.computeOverlapRange([d1, d2], [e1, e2]);\n            if (range == null) {\n                return 0;\n            }\n            else {\n                return (0, vline_1.round100)(range[1]) - (0, vline_1.round100)(range[0]);\n            }\n        }\n        else {\n            if (dir == \"top\" || dir == \"bottom\") {\n                const newW = Math.max(column_1.CellColumn.defaultWidth, (0, vline_1.round100)(d2) - (0, vline_1.round100)(d1));\n                return newW;\n            }\n            else {\n                const newH = Math.max(row_1.CellRow.defaultHeight, (0, vline_1.round100)(d2) - (0, vline_1.round100)(d1));\n                return newH;\n            }\n        }\n    }\n    // #endregion\n    // #region border\n    //private _borders: SVGLineElement[] = new Array(4);\n    //private _topBorder: SVGLineElement;\n    /**\n    \n    */\n    get svgTopBorder() {\n        return this._table.borderRows[this.cellY].borders[this.cellX];\n        //return this._borders[DirectionType.top];\n    }\n    /*\n    set svgTopBorder(line: SVGLineElement) {\n\n        this._borders[DirectionType.top] = line;\n    }\n    */\n    /**\n    \n    */\n    get svgLeftBorder() {\n        return this._table.borderColumns[this.cellX].borders[this.cellY];\n        //return this._borders[DirectionType.left];\n    }\n    /*\n    set svgLeftBorder(line: SVGLineElement) {\n        this._borders[DirectionType.left] = line;\n    }\n    */\n    /**\n    \n    */\n    get svgRightBorder() {\n        return this._table.borderColumns[this.cellX + 1].borders[this.cellY];\n        //return this._borders[DirectionType.right];\n    }\n    /*\n    set svgRightBorder(line: SVGLineElement) {\n        this._borders[DirectionType.right] = line;\n\n    }\n    */\n    /**\n    \n    */\n    get svgBottomBorder() {\n        return this._table.borderRows[this.cellY + 1].borders[this.cellX];\n        //return this._borders[DirectionType.bottom];\n    }\n    /*\n    set svgBottomBorder(line: SVGLineElement) {\n        this._borders[DirectionType.bottom] = line;\n\n    }\n    */\n    // #endregion\n    // #region other\n    /**\n    \n    */\n    get logicalWidth() {\n        if (this.isMaster) {\n            let w = 0;\n            let now = this;\n            while (now != null && this.objectID == now.masterObjectID) {\n                now = this.rightCell;\n                w++;\n            }\n            return w;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n    \n    */\n    get logicalHeight() {\n        if (this.isMaster) {\n            let h = 0;\n            let now = this;\n            while (now != null && this.objectID == now.masterObjectID) {\n                now = this.bottomCell;\n                h++;\n            }\n            return h;\n        }\n        else {\n            return 0;\n        }\n    }\n    /*\n    get calculatedWidthUsingText(): number {\n        if (this.isLocated) {\n            const textRect = SVGTextExtension.getSize(this.svgText, this._assurancevisibility);\n            const w = textRect.width + this.innerExtraPaddingLeft + this.innerExtraPaddingRight\n            + this.paddingLeft + this.paddingRight;\n            return w;\n        } else {\n            return 0;\n        }\n    }\n\n    get calculatedHeightUsingText(): number {\n        if (this.isLocated) {\n            const textRect = SVGTextExtension.getSize(this.svgText, this._assurancevisibility);\n\n            return textRect.height + this.paddingTop + this.paddingBottom;\n        } else {\n            return 0;\n        }\n    }\n    */\n    computeSidePosition(dir) {\n        switch (dir) {\n            case DirectionType2.topLeft: return [this.x, this.y];\n            case DirectionType2.topRight: return [this.x + this.width, this.y];\n            case DirectionType2.bottomLeft: return [this.x, this.y + this.height];\n            case DirectionType2.bottomRight: return [this.x + this.width, this.y + this.height];\n        }\n        throw Error(\"error\");\n    }\n    // #endregion\n    // #region NextCell\n    /**\n     * \n     * @param direction\n     */\n    getNextCell(direction) {\n        switch (direction) {\n            case \"top\": return this.cellY != 0 ? this.table.cells[this.cellY - 1][this.cellX] : null;\n            case \"left\": return this.cellX != 0 ? this.table.cells[this.cellY][this.cellX - 1] : null;\n            case \"right\": return this.cellX + 1 != this.table.columnCount ? this.table.cells[this.cellY][this.cellX + 1] : null;\n            case \"bottom\": return this.cellY + 1 != this.table.rowCount ? this.table.cells[this.cellY + 1][this.cellX] : null;\n        }\n        throw Error(\"error\");\n    }\n    /**\n     * \n     * @param direction\n     */\n    getNextMasterCell(direction) {\n        const nextCell = this.getNextCell(direction);\n        return nextCell == null ? null :\n            nextCell.masterObjectID != this.masterObjectID ? nextCell.master : nextCell.getNextMasterCell(direction);\n    }\n    /**\n    \n    */\n    get topCell() {\n        return this.getNextCell(\"top\");\n    }\n    /**\n    \n    */\n    get leftCell() {\n        return this.getNextCell(\"left\");\n    }\n    /**\n    \n    */\n    get rightCell() {\n        return this.getNextCell(\"right\");\n    }\n    /**\n    \n    */\n    get bottomCell() {\n        return this.getNextCell(\"bottom\");\n    }\n    /**\n     * \n     */\n    get bottomRightCell() {\n        return this.bottomCell == null ? null : this.bottomCell.rightCell == null ? null : this.bottomCell.rightCell;\n    }\n    /**\n     * \n     */\n    get topRightCell() {\n        return this.topCell == null ? null : this.topCell.rightCell == null ? null : this.topCell.rightCell;\n    }\n    /**\n     * \n     */\n    get bottomLeftCell() {\n        return this.bottomCell == null ? null : this.bottomCell.leftCell == null ? null : this.bottomCell.leftCell;\n    }\n    /**\n     * \n     */\n    get topLeftCell() {\n        return this.topCell == null ? null : this.topCell.leftCell == null ? null : this.topCell.leftCell;\n    }\n    /**\n     * \n     */\n    get topMasterCell() {\n        return this.getNextMasterCell(\"top\");\n    }\n    /**\n     * \n     */\n    get leftMasterCell() {\n        return this.getNextMasterCell(\"left\");\n    }\n    /**\n     * \n     */\n    get rightMasterCell() {\n        return this.getNextMasterCell(\"right\");\n    }\n    /**\n     * \n     */\n    get bottomMasterCell() {\n        return this.getNextMasterCell(\"bottom\");\n    }\n    /**\n     * X\n     */\n    get mostRightCellX() {\n        return this.cellX + this.GroupColumnCount - 1;\n    }\n    /**\n     * Y\n     */\n    get mostBottomCellY() {\n        return this.cellY + this.GroupRowCount - 1;\n    }\n    /**\n     * \n     * @param direction\n     */\n    getNextGroupCells(direction) {\n        if (this.isMaster) {\n            //if(this.isErrorCell) throw new Error(\"error!\");\n            const w = [this];\n            let now = this.getNextCell(direction);\n            while (now != null && this.objectID == now.masterObjectID) {\n                w.push(now);\n                now = now.getNextCell(direction);\n                if (this.table.columnCount < w.length && (direction == \"left\" || direction == \"right\")) {\n                    throw new Error(\"Invalid getNextGroupCells-Loop!\");\n                }\n            }\n            return w;\n        }\n        else {\n            return [];\n        }\n    }\n    /**\n    \n    */\n    get leftSideGroupCells() {\n        return this.getNextGroupCells(\"bottom\");\n    }\n    /**\n    \n    */\n    get upperSideGroupCells() {\n        return this.getNextGroupCells(\"right\");\n    }\n    // #endregion\n    /**\n     * SVGRectElement\n     * @param className\n     */\n    /*\n    private static createCellRectangle(parent : SVGElement, className: string | null = null): SVGRectElement {\n        const rect = <SVGRectElement>document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        parent.appendChild(rect);\n        rect.width.baseVal.value = 30;\n        rect.height.baseVal.value = 30;\n        if (className == null) {\n            rect.style.fill = \"#ffffff\";\n        } else {\n            SVG.createRectangle(className);\n        }\n        return rect;\n    }\n    */\n    toPlainText() {\n        if (this.isMaster) {\n            const textContext = this.svgText.textContent != null ? this.svgText.textContent : \"\";\n            if (this.isSingleCell) {\n                return textContext;\n            }\n            else {\n                return `${textContext}%%%${this.GroupColumnCount}%%%${this.GroupRowCount}`;\n            }\n        }\n        else {\n            return \"\";\n        }\n    }\n    // #region update\n    updateNodeRelations() {\n        this.updateSVGGroupParent();\n        this.updateBorderParent();\n        //this.updateBorderAttributes();\n    }\n    tryUpdateWithUpdateFlag(withUpdate) {\n        let b = false;\n        if (this.table.isNoneMode)\n            return false;\n        const className = this.svgGroup.getAttribute(\"class\");\n        if (className != this.__currentClass) {\n            if (withUpdate) {\n                this.recomputeDefaultProperties();\n                this.__currentClass = className;\n            }\n            else {\n                return true;\n            }\n        }\n        b = this.tryResizeWithUpdateFlag(withUpdate) || b;\n        if (!withUpdate && b) {\n            debugger_1.Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag, this.tryResizeWithUpdateFlag.name);\n            return b;\n        }\n        b = this.tryLocateSVGTextWithUpdateFlag(withUpdate) || b;\n        if (!withUpdate && b) {\n            debugger_1.Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag, this.tryLocateSVGTextWithUpdateFlag.name);\n            return b;\n        }\n        /*\n        b = this.tryLocateSVGTextWithUpdateFlag(withUpdate) || b;\n        if (!withUpdate && b) {\n            Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag, this.tryLocateSVGTextWithUpdateFlag.name)\n            return b;\n        }\n        */\n        return b;\n    }\n    getUpdateFlag() {\n        return this.tryUpdateWithUpdateFlag(false);\n    }\n    /**\n     * \n     */\n    update() {\n        this.tryUpdateWithUpdateFlag(true);\n    }\n    /**\n     * svgGroup\n     */\n    updateSVGGroupParent() {\n        if (this.isMaster) {\n            if (this.table.rows[this.cellY].svgGroup != this.table.svgGroup) {\n                this.table.rows[this.cellY].svgGroup.appendChild(this.svgGroup);\n            }\n        }\n        else {\n            this.table.svgHiddenGroup.appendChild(this.svgGroup);\n            this.svgText.textContent = \"\";\n        }\n    }\n    get topBorderRow() {\n        return this.table.borderRows[this.cellY];\n    }\n    get bottomBorderRow() {\n        return this.table.borderRows[this.cellY + 1];\n    }\n    get leftBorderColumn() {\n        return this.table.borderColumns[this.cellX];\n    }\n    get rightBorderColumn() {\n        return this.table.borderColumns[this.cellX + 1];\n    }\n    /**\n     * \n     */\n    updateBorderParent() {\n        if (this.isMaster || (this.topCell != null && this.topCell.isMaster)) {\n            if (this.topBorderRow.svgGroup != this.svgTopBorder.parentNode)\n                this.topBorderRow.svgGroup.appendChild(this.svgTopBorder);\n        }\n        else {\n            if (this.table.svgHiddenGroup != this.svgTopBorder.parentNode)\n                this.table.svgHiddenGroup.appendChild(this.svgTopBorder);\n        }\n        if (this.isMaster || (this.leftCell != null && this.leftCell.isMaster)) {\n            if (this.leftBorderColumn.svgGroup != this.svgLeftBorder.parentNode)\n                this.leftBorderColumn.svgGroup.appendChild(this.svgLeftBorder);\n        }\n        else {\n            if (this.table.svgHiddenGroup != this.svgLeftBorder.parentNode)\n                this.table.svgHiddenGroup.appendChild(this.svgLeftBorder);\n        }\n        if (this.isMaster || (this.rightCell != null && this.rightCell.isMaster)) {\n            if (this.rightBorderColumn.svgGroup != this.svgRightBorder.parentNode)\n                this.rightBorderColumn.svgGroup.appendChild(this.svgRightBorder);\n        }\n        else {\n            if (this.table.svgHiddenGroup != this.svgRightBorder.parentNode)\n                this.table.svgHiddenGroup.appendChild(this.svgRightBorder);\n        }\n        if (this.isMaster || (this.bottomCell != null && this.bottomCell.isMaster)) {\n            if (this.bottomBorderRow.svgGroup != this.svgBottomBorder.parentNode)\n                this.bottomBorderRow.svgGroup.appendChild(this.svgBottomBorder);\n        }\n        else {\n            if (this.table.svgHiddenGroup != this.svgBottomBorder.parentNode)\n                this.table.svgHiddenGroup.appendChild(this.svgBottomBorder);\n        }\n    }\n    tryResizeWithUpdateFlag(withUpdate) {\n        let b = false;\n        if (!this.isMaster) {\n            return false;\n        }\n        const [w, h] = this.calculatedSizeUsingGroup();\n        if (!(0, vline_1.nearlyEqual)(this.width, w)) {\n            b = true;\n            if (withUpdate) {\n                debugger_1.Debugger.updateLog(this, this.tryResizeWithUpdateFlag, `Width: ${this.width} -> ${w}`);\n                this.width = w;\n            }\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryResizeWithUpdateFlag, `Width: ${this.width} -> ${w}`);\n                return b;\n            }\n        }\n        if (!(0, vline_1.nearlyEqual)(this.height, h)) {\n            b = true;\n            if (withUpdate) {\n                debugger_1.Debugger.updateLog(this, this.tryResizeWithUpdateFlag, `Height: ${this.height} -> ${h}`);\n                this.height = h;\n            }\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryResizeWithUpdateFlag, `Height: ${this.height} -> ${h}`);\n                return b;\n            }\n        }\n        const rect = this.getVirtualRegion();\n        if (this.width < rect.width) {\n            b = true;\n            if (withUpdate) {\n                debugger_1.Debugger.updateLog(this, this.tryResizeWithUpdateFlag, `W: ${this.width} << ${rect.width}`);\n                this.width = rect.width;\n            }\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryResizeWithUpdateFlag, `W: ${this.width} << ${rect.width}`);\n                return b;\n            }\n        }\n        if (this.height < rect.height) {\n            b = true;\n            if (withUpdate) {\n                debugger_1.Debugger.updateLog(this, this.tryResizeWithUpdateFlag, `H: ${this.height} << ${rect.height}`);\n                this.height = rect.height;\n            }\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryResizeWithUpdateFlag, `H: ${this.height} << ${rect.height}`);\n                return b;\n            }\n        }\n        return b;\n    }\n    /**\n     *\n     */\n    resize() {\n        this.tryResizeWithUpdateFlag(true);\n    }\n    /**\n     * \n     * @param dir\n     */\n    removeBorder(dir) {\n        /*\n        const border = this._borders[dir];\n        if (this.table.svgHiddenGroup.contains(border)) {\n            this.table.svgHiddenGroup.removeChild(border);\n        } else if (this.table.svgGroup.contains(border)) {\n            this.table.svgGroup.removeChild(border);\n        } else {\n            throw Error(\"error\");\n        }\n        */\n    }\n    /**\n     * \n     * @param isColumn\n     */\n    removeFromTable(isColumn) {\n        this.svgGroup.remove();\n        /*\n        if (this.table.svgGroup.contains(this.svgGroup)) {\n            this.table.svgGroup.removeChild(this.svgGroup);\n        } else if (this.table.svgHiddenGroup.contains(this.svgGroup)) {\n            this.table.svgHiddenGroup.removeChild(this.svgGroup);\n        } else {\n            throw Error(\"error\");\n        }\n        */\n        /*\n         if (isColumn) {\n             this.removeBorder(DirectionType.top);\n             if (this.table.svgGroup.contains(this.svgTopBorder)) {\n                 throw Error(\"err\");\n             }\n             if (this.bottomCell == null) this.removeBorder(DirectionType.bottom);\n             if (this.leftCell == null) this.removeBorder(DirectionType.left);\n             if (this.rightCell == null) this.removeBorder(DirectionType.right);\n         } else {\n\n             this.removeBorder(DirectionType.left);\n             if (this.rightCell == null) this.removeBorder(DirectionType.right);\n             if (this.topCell == null) this.removeBorder(DirectionType.top);\n             if (this.bottomCell == null) this.removeBorder(DirectionType.bottom);\n         }\n         */\n    }\n    /**\n     * \n     */\n    updateBorderAttributes() {\n        /*\n        if (this.leftCell != null && this.leftCell.svgRightBorder != this.svgLeftBorder) {\n            this.removeBorder(DirectionType.left);\n            this.svgLeftBorder = this.leftCell.svgRightBorder;\n        }\n\n        if (this.topCell != null && this.topCell.svgBottomBorder != this.svgTopBorder) {\n            this.removeBorder(DirectionType.top);\n            this.svgTopBorder = this.topCell.svgBottomBorder;\n        }\n\n        if (this.rightCell != null && this.rightCell.svgLeftBorder != this.svgRightBorder) {\n            this.rightCell.removeBorder(DirectionType.left);\n            this.rightCell.svgLeftBorder = this.svgRightBorder;\n        }\n\n        if (this.bottomCell != null && this.bottomCell.svgTopBorder != this.svgBottomBorder) {\n            this.bottomCell.removeBorder(DirectionType.top);\n            this.bottomCell.svgTopBorder = this.svgBottomBorder;\n        }\n        */\n        const topCellX = this.svgTopBorder.getAttribute(Cell.borderXName);\n        const topCellY = this.svgTopBorder.getAttribute(Cell.borderYName);\n        const topCellAttr = this.svgTopBorder.getAttribute(Cell.borderTypeName);\n        if (topCellX != `${this.cellX}`)\n            this.svgTopBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\n        if (topCellY != `${this.cellY}`)\n            this.svgTopBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\n        if (topCellAttr != `horizontal`)\n            this.svgTopBorder.setAttribute(Cell.borderTypeName, \"horizontal\");\n        //this.topBorder.setAttribute(\"data-border\", \"top\");\n        const leftCellX = this.svgLeftBorder.getAttribute(Cell.borderXName);\n        const leftCellY = this.svgLeftBorder.getAttribute(Cell.borderYName);\n        const leftCellAttr = this.svgLeftBorder.getAttribute(Cell.borderTypeName);\n        if (leftCellX != `${this.cellX}`)\n            this.svgLeftBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\n        if (leftCellY != `${this.cellY}`)\n            this.svgLeftBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\n        if (leftCellAttr != `vertical`)\n            this.svgLeftBorder.setAttribute(Cell.borderTypeName, \"vertical\");\n        const rightCellX = this.svgRightBorder.getAttribute(Cell.borderXName);\n        const rightCellY = this.svgRightBorder.getAttribute(Cell.borderYName);\n        const rightCellAttr = this.svgRightBorder.getAttribute(Cell.borderTypeName);\n        if (rightCellX != `${this.cellX + 1}`)\n            this.svgRightBorder.setAttribute(Cell.borderXName, `${this.cellX + 1}`);\n        if (rightCellY != `${this.cellY}`)\n            this.svgRightBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\n        if (rightCellAttr != `vertical`)\n            this.svgRightBorder.setAttribute(Cell.borderTypeName, \"vertical\");\n        const bottomCellX = this.svgBottomBorder.getAttribute(Cell.borderXName);\n        const bottomCellY = this.svgBottomBorder.getAttribute(Cell.borderYName);\n        const bottomCellAttr = this.svgBottomBorder.getAttribute(Cell.borderTypeName);\n        if (bottomCellX != `${this.cellX}`)\n            this.svgBottomBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\n        if (bottomCellY != `${this.cellY + 1}`)\n            this.svgBottomBorder.setAttribute(Cell.borderYName, `${this.cellY + 1}`);\n        if (bottomCellAttr != `horizontal`)\n            this.svgBottomBorder.setAttribute(Cell.borderTypeName, \"horizontal\");\n    }\n    // #endregion\n    // #region relocate\n    /*\n    private relocateTopBorder() {\n        this.tryRelocateTopBorderWithUpdateFlag(true);\n    }\n    private relocateLeftBorder() {\n        this.tryRelocateLeftBorderWithUpdateFlag(true);\n    }\n    private relocateRightBorder() {\n        this.tryRelocateRightBorderWithUpdateFlag(true);\n    }\n    private relocateBottomBorder() {\n        this.tryRelocateBottomBorderWithUpdateFlag(true);\n    }\n    */\n    /*\n    public tryAAA(withUpdate: boolean): boolean {\n        //let b = false;\n        if (!CommonFunctions.IsDescendantOfBody(this.svgGroup)) {\n            return false;\n        }\n\n        const b5 = this.tryLocateSVGTextWithUpdateFlag(withUpdate);\n        if (withUpdate && b5) {\n            Debugger.updateLog(this, this.tryAAA, `${this.tryLocateSVGTextWithUpdateFlag.name}`)\n        }\n        if (!withUpdate && b5) {\n            Debugger.updateFlagLog(this, this.tryAAA, `${this.tryLocateSVGTextWithUpdateFlag.name}`)\n            return true;\n        }\n\n        return b5;\n    }\n    */\n    relocation() {\n        this.tryLocateSVGTextWithUpdateFlag(true);\n    }\n    // #endregion\n    // #region merge\n    /**\n     * \n     */\n    mergeRight() {\n        const range = this.getMergedRangeRight();\n        if (range != null) {\n            this.merge(range[0], range[1]);\n        }\n        else {\n            throw Error(\"Error\");\n        }\n    }\n    /**\n     * \n     */\n    mergeBottom() {\n        const range = this.getMergedRangeBottom();\n        if (range != null) {\n            this.merge(range[0], range[1]);\n        }\n        else {\n            throw Error(\"Error\");\n        }\n    }\n    /**\n     * whTrue\n     * @param w\n     * @param h\n     */\n    canMerge(w, h) {\n        const range = this.table.getRangeCells(this.cellX, this.cellY, w, h);\n        for (let x = 0; x < w; x++) {\n            const topCell = range[0][x].topCell;\n            if (topCell != null) {\n                if (range[0][x].masterObjectID == topCell.masterObjectID)\n                    return false;\n            }\n            const bottomCell = range[h - 1][x].bottomCell;\n            if (bottomCell != null) {\n                if (range[h - 1][x].masterObjectID == bottomCell.masterObjectID)\n                    return false;\n            }\n        }\n        for (let y = 0; y < h; y++) {\n            const leftCell = range[y][0].leftCell;\n            if (leftCell != null) {\n                if (range[y][0].masterObjectID == leftCell.masterObjectID)\n                    return false;\n            }\n            const rightCell = range[y][w - 1].rightCell;\n            if (rightCell != null) {\n                if (range[y][w - 1].masterObjectID == rightCell.masterObjectID)\n                    return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * wh\n     * @param w\n     * @param h\n     */\n    merge(w, h) {\n        if (!this.isMaster)\n            throw Error(\"Error\");\n        const range = this.table.getRangeCellArray(this.cellX, this.cellY, w, h);\n        range.forEach((v) => { v.setMasterCellX(this.masterCellX); v.setMasterCellY(this.masterCellY); });\n        range.forEach((v) => { v.updateNodeRelations(); v.update(); });\n    }\n    /**\n     * YY\n     * null\n     */\n    getMergedRangeRight() {\n        if (!this.isMaster)\n            return null;\n        if (this.rightMasterCell != null) {\n            const b1 = this.cellY == this.rightMasterCell.cellY;\n            const b2 = this.GroupRowCount == this.rightMasterCell.GroupRowCount;\n            if (b1 && b2) {\n                return [this.GroupColumnCount + this.rightMasterCell.GroupColumnCount, this.GroupRowCount];\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * XX\n     * null\n     */\n    getMergedRangeBottom() {\n        if (!this.isMaster)\n            return null;\n        if (this.bottomMasterCell != null) {\n            const b1 = this.cellX == this.bottomMasterCell.cellX;\n            const b2 = this.GroupColumnCount == this.bottomMasterCell.GroupColumnCount;\n            if (b1 && b2) {\n                return [this.GroupColumnCount, this.GroupRowCount + this.bottomMasterCell.GroupRowCount];\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * True\n     */\n    get canMergeRight() {\n        return this.getMergedRangeRight() != null;\n    }\n    /**\n     * True\n     */\n    get canMergeBottom() {\n        return this.getMergedRangeBottom() != null;\n    }\n    // #endregion\n    // #region decompose\n    decomposeRow(upperRowCount) {\n        if (this.isMaster) {\n            const upperSide = this.table.getRangeCellArray(this.cellX, this.cellY, this.GroupColumnCount, upperRowCount);\n            const lowerSide = this.table.getRangeCellArray(this.cellX, this.cellY + upperRowCount, this.GroupColumnCount, this.GroupRowCount - upperRowCount);\n            const lowerMaster = lowerSide[0];\n            lowerSide.forEach((v) => {\n                v.setMasterCellX(lowerMaster.cellX);\n                v.setMasterCellY(lowerMaster.cellY);\n            });\n            upperSide.forEach((v) => v.update());\n            lowerSide.forEach((v) => v.update());\n        }\n        else {\n            throw Error(\"Slave Error\");\n        }\n    }\n    decomposeColomn(leftColumnCount) {\n        if (this.isMaster) {\n            const leftSide = this.table.getRangeCellArray(this.cellX, this.cellY, leftColumnCount, this.GroupRowCount);\n            const rightSide = this.table.getRangeCellArray(this.cellX + leftColumnCount, this.cellY, this.GroupColumnCount - leftColumnCount, this.GroupRowCount);\n            const rightMaster = rightSide[0];\n            rightSide.forEach((v) => {\n                v.setMasterCellX(rightMaster.cellX);\n                v.setMasterCellY(rightMaster.cellY);\n            });\n            leftSide.forEach((v) => v.update());\n            rightSide.forEach((v) => v.update());\n        }\n        else {\n            throw Error(\"Slave Error\");\n        }\n    }\n    /**\n    \n    */\n    getVirtualRegion() {\n        //const textRect = SVGTextExtension.getRegion(this.svgText);\n        const textRect = (0, virtual_text_1.getVirtualRegion)(this.svgText);\n        const rect = new vline_1.Rectangle();\n        rect.x = 0;\n        rect.width = textRect.width + this.paddingRight + this.paddingLeft + this.primitivePaddingLeft + this.primitivePaddingRight;\n        rect.y = 0;\n        rect.height = textRect.height + this.paddingBottom + this.paddingTop;\n        return rect;\n    }\n    getVirtualInnerRegion() {\n        //const rect = this.getVirtualRegion();\n        const innerRec = new vline_1.Rectangle();\n        innerRec.x = 0 + this.paddingLeft + this.primitivePaddingLeft;\n        innerRec.y = 0 + this.paddingTop;\n        innerRec.width = this.width - this.paddingLeft - this.paddingRight - this.primitivePaddingLeft - this.primitivePaddingRight;\n        innerRec.height = this.height - this.paddingBottom - this.paddingTop;\n        //innerRec.width = rect.width - this.paddingLeft - this.paddingRight;\n        //innerRec.height = rect.height - this.paddingBottom - this.paddingTop;\n        return innerRec;\n    }\n    calculatedSizeUsingGroup() {\n        if (this.isLocated) {\n            let w = 0;\n            let h = 0;\n            this.leftSideGroupCells.forEach((v) => h += (0, vline_1.round100)(this.table.rows[v.cellY].height));\n            this.upperSideGroupCells.forEach((v) => w += (0, vline_1.round100)(this.table.columns[v.cellX].width));\n            const newW = Math.max(column_1.CellColumn.defaultWidth, w);\n            const newH = Math.max(row_1.CellRow.defaultHeight, h);\n            return [newW, newH];\n        }\n        else {\n            return [column_1.CellColumn.defaultWidth, row_1.CellRow.defaultHeight];\n        }\n    }\n    /**\n     * \n     */\n    tryLocateSVGTextWithUpdateFlag(withUpdate) {\n        const innerRect = this.getVirtualInnerRegion();\n        return SVGTextExtension.updateLocationOrGetUpdateFlag(this.svgText, innerRect, this.verticalAnchor, this.horizontalAnchor, enums_1.AutoSizeShapeToFitText.None, withUpdate);\n    }\n    /**\n     * \n     */\n    locateSVGText() {\n        this.tryLocateSVGTextWithUpdateFlag(true);\n    }\n}\nexports.Cell = Cell;\n// #endregion\n// #region field\n//private static readonly defaultBackgroundClassName: string = \"--default-background-class\";\n//\nCell.cellXName = \"data-cellX\";\nCell.cellYName = \"data-cellY\";\nCell.borderXName = \"data-borderX\";\nCell.borderYName = \"data-borderY\";\nCell.borderTypeName = \"data-borderType\";\nCell.masterIDName = \"data-masterID\";\nCell.masterDiffXName = \"data-masterDiffX\";\nCell.masterDiffYName = \"data-masterDiffY\";\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/cell.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/column.ts":
/*!*********************************************!*\
  !*** ./src/objects/table_helpers/column.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CellColumn = void 0;\n//namespace GraphTableSVG {\nconst cell_1 = __webpack_require__(/*! ./cell */ \"./src/objects/table_helpers/cell.ts\");\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./src/common/vline.ts\");\nconst element_extension_1 = __webpack_require__(/*! ../../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst debugger_1 = __webpack_require__(/*! ../../common/debugger */ \"./src/common/debugger.ts\");\n/**\n * \n */\nclass CellColumn {\n    /**\n    X\n    */\n    get cellX() {\n        return Number(this._svgMetaData.getAttribute(cell_1.Cell.cellXName));\n    }\n    set cellX(v) {\n        this._svgMetaData.setAttribute(cell_1.Cell.cellXName, `${v}`);\n        this.cells.forEach((w) => w.cellX = v);\n    }\n    get minimumWidth() {\n        const attr = this._svgMetaData.getAttribute(CellColumn.minimumWidthAttributeName);\n        if (attr != null) {\n            return Number.parseInt(attr);\n        }\n        else {\n            return CellColumn.defaultWidth;\n        }\n    }\n    set minimumWidth(value) {\n        this._svgMetaData.setAttribute(CellColumn.minimumWidthAttributeName, value.toString());\n    }\n    //public defaultWidth : number | null = null;\n    /**\n    \n    */\n    get width() {\n        return Number(this._svgMetaData.getAttribute(CellColumn.rowWidthName));\n    }\n    /**\n    \n    */\n    set width(value) {\n        (0, element_extension_1.setAttributeNumber)(this._svgMetaData, CellColumn.rowWidthName, value);\n        //this._svgGroup.setAttribute(CellColumn.rowWidthName, `${value}`);\n        //this.setWidthToCells();\n        /*\n        let b = false;\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (cell.isColumnSingleCell && cell.width != value) {\n                cell.width = value;\n                b = true;\n            }\n        }\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (!cell.isColumnSingleCell) {\n                cell.update();\n                //cell.resize();\n                b = true;\n            }\n        }\n        if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\n        */\n    }\n    /*\n    public setWidthToCellsWithUpdateFlag(withUpdate: boolean): boolean {\n        let b = false;\n        const width = Math.max(this.width, CellColumn.defaultWidth);\n\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (cell.isMasterCellOfColumnCountOne && !nearlyEqual(cell.width, width)) {\n                b = true;\n                if (withUpdate) {\n                    cell.width = width;\n                }\n\n                if (!withUpdate && b) {\n                    Debugger.updateFlagLog(this, this.setWidthToCellsWithUpdateFlag, `${cell.width} != ${width} y = ${y}`)\n\n                    return true;\n                }\n            }\n        }\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (!cell.isMasterCellOfColumnCountOne) {\n\n                b = cell.tryUpdateWithUpdateFlag(withUpdate)  || b;\n                if (!withUpdate && b) {\n                    Debugger.updateFlagLog(this, this.setWidthToCellsWithUpdateFlag, `${cell.tryUpdateWithUpdateFlag.name} y = ${y}`)\n                    return b;\n                }\n            }\n        }\n        return b;\n\n    }\n    */\n    /*\n    private setWidthToCells() {\n        this.setWidthToCellsWithUpdateFlag(true);\n        // TODO : implement the event of the below code.\n        //if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\n\n    }\n    */\n    /**\n     * \n     */\n    get cells() {\n        const items = [];\n        for (let i = 0; i < this.table.rowCount; i++) {\n            //if(this.table.rows[i].cells.length <= this.cellX) throw new Error(\"error\");\n            items.push(this.table.rows[i].cells[this.cellX]);\n        }\n        return items;\n    }\n    get length() {\n        return this.cells.length;\n    }\n    constructor(_table, _x, _width = CellColumn.defaultWidth) {\n        this.table = _table;\n        this._svgMetaData = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');\n        this._svgMetaData.setAttribute(\"name\", \"cell_column\");\n        this.table.svgColumnInfo.appendChild(this._svgMetaData);\n        //this._svgMetaData = SVG.createGroup(this.table.svgColumnInfo);\n        //this.table.svgGroup.appendChild(this._svgGroup);\n        this.cellX = _x;\n        this._svgMetaData.setAttribute(CellColumn.rowWidthName, `${_width}`);\n        //this.width = this.getMaxWidth();\n    }\n    /**\n     * \n     */\n    getVirtualSize() {\n        let height = 0;\n        let width = 0;\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            const rect = cell.getVirtualRegion();\n            if (cell.isMasterCellOfColumnCountOne) {\n                if (width < rect.width)\n                    width = rect.width;\n            }\n            height += cell.master.getVirtualRegion().height;\n        }\n        return new vline_1.Size((0, vline_1.round100)(width), (0, vline_1.round100)(height));\n    }\n    /*\n    private getMaxWidth(): number {\n        let width = 0;\n\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (cell.isMasterCellOfColumnCountOne) {\n                const rect = cell.getVirtualRegion();\n                if (width < rect.width) width = rect.width;\n                //if (width < cell.width) width = cell.width;\n            }\n        }\n\n        return width;\n    }\n    */\n    /**\n     * \n     */\n    /*\n     public update() {\n        this.setWidthToCells();\n        //this.width = this.getMaxWidth();\n    }\n    */\n    /*\n     public tryResizeWithUpdateFlag(withUpdate: boolean) {\n         let b = false;\n         const cells = this.cells;\n         for (let i = 0; i < cells.length; i++) {\n             b = cells[i].tryUpdateWithUpdateFlag(withUpdate)  || b;\n             if (!withUpdate && b) {\n                 return b;\n             }\n         }\n         b = this.setHeightToCellsWithUpdateFlag(withUpdate)  || b;\n \n         return b;\n     }\n     */\n    /**\n     * \n     */\n    /*\n    public resize() {\n\n        this.tryResizeWithUpdateFlag(true);\n    }\n    */\n    tryUpdateWidthWithUpdateFlag(allowShrink, withUpdate) {\n        let b = false;\n        const __width = allowShrink ? this.getVirtualSize().width : Math.max(this.width, this.getVirtualSize().width);\n        const newWidth = Math.max(this.minimumWidth, (0, vline_1.round100)(__width));\n        if (!(0, vline_1.nearlyEqual)(this.width, newWidth)) {\n            b = true;\n            if (withUpdate) {\n                this.width = newWidth;\n            }\n            else {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdateWidthWithUpdateFlag, `Width: ${this.width} -> ${newWidth}`);\n            }\n        }\n        return b;\n    }\n    /**\n     * \n     * @param allowShrink \n     */\n    fitWidthToOriginalCell(allowShrink) {\n        this.tryUpdateWidthWithUpdateFlag(allowShrink, true);\n    }\n    setXWithUpdate(posX, withUpdate) {\n        const posx100 = (0, vline_1.round100)(posX);\n        let b = false;\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (cell.x != posx100) {\n                b = true;\n                if (withUpdate) {\n                    cell.x = posx100;\n                }\n                if (!withUpdate && b) {\n                    debugger_1.Debugger.updateFlagLog(this, this.setXWithUpdate, `${this.selfx}, ${posx100}`);\n                    return b;\n                }\n            }\n        }\n        return b;\n    }\n    /**\n     * X\n     * @param posX\n     */\n    setX(posX) {\n        this.setXWithUpdate(posX, true);\n    }\n    /**\n     * \n     */\n    get leftBorders() {\n        const r = [];\n        this.cells.forEach((v) => {\n            if (r.length == 0) {\n                r.push(v.svgLeftBorder);\n            }\n            else {\n                const last = r[r.length - 1];\n                if (last != v.svgLeftBorder)\n                    r.push(v.svgLeftBorder);\n            }\n        });\n        return r;\n    }\n    /**\n     * \n     */\n    get rightBorders() {\n        const r = [];\n        this.cells.forEach((v) => {\n            if (r.length == 0) {\n                r.push(v.svgRightBorder);\n            }\n            else {\n                const last = r[r.length - 1];\n                if (last != v.svgRightBorder)\n                    r.push(v.svgRightBorder);\n            }\n        });\n        return r;\n    }\n    /**\n     * \n     */\n    get topBorder() {\n        return this.cells[0].svgTopBorder;\n    }\n    /**\n     * \n     */\n    get bottomBorder() {\n        const cells = this.cells;\n        return cells[cells.length - 1].svgBottomBorder;\n    }\n    get selfx() {\n        for (let i = 0; i < this.table.columnCount; i++) {\n            if (this.table.columns[i] == this) {\n                return i;\n            }\n        }\n        throw new Error(\"error\");\n    }\n    /**\n     * \n     * @param isUnit\n     */\n    _dispose() {\n        /*\n        while (this.length > 0){\n            const x = this.length - 1;\n            this.cells[x].removeFromTable(false);\n            this.cells.splice(x, 1);\n        }\n        */\n        const x = this.selfx;\n        this.table.rows.forEach((v, i) => v._removeCell(x));\n        this._svgMetaData.remove();\n        /*\n        if (isUnit) {\n            if (this.table.columns.length > 1) {\n                this.table.columns[this.cellX].cells.forEach((v) => {\n                    v.removeFromTable(true);\n                    this.table.cells[v.cellY].splice(this.cellX, 1);\n                });\n\n\n                this.table.columns.splice(this.cellX, 1);\n                this.table.columns.forEach((v, i) => v.cellX = i);\n                this.table.svgGroup.removeChild(this._svgGroup);\n                this.table.update();\n            } else if (this.table.columns.length == 1) {\n                while (this.table.rows.length > 0) {\n                    this.table.rows[this.table.rows.length - 1].remove(true);\n                }\n                if (this.table.columns.length == 1) this.table.columns.splice(0, 1);\n            } else {\n                throw Error(\"error\");\n            }\n        } else {\n            const [b, e] = this.groupColumnRange;\n            for (let x = e; x >= b; x--) {\n                this.table.columns[x].remove(true);\n            }\n        }\n        */\n    }\n    /**\n     * \n     */\n    relocation() {\n        this.cells.forEach((v) => v.relocation());\n    }\n    /**\n     * \n     */\n    get groupColumnRange() {\n        let range = this.cells[0].groupColumnRange;\n        this.cells.forEach((v) => {\n            if (range != null) {\n                range = cell_1.Cell.computeDisjunction(range, v.groupColumnRange);\n            }\n        });\n        if (range == null) {\n            throw Error(\"error\");\n        }\n        else {\n            return range;\n        }\n    }\n}\nexports.CellColumn = CellColumn;\n//private readonly _cellX: number;\nCellColumn.rowWidthName = \"data-width\";\nCellColumn.minimumWidthAttributeName = \"data-minimum-width\";\nCellColumn.defaultWidth = 20;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/column.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/row.ts":
/*!******************************************!*\
  !*** ./src/objects/table_helpers/row.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CellRow = void 0;\n//namespace GraphTableSVG {    \nconst cell_1 = __webpack_require__(/*! ./cell */ \"./src/objects/table_helpers/cell.ts\");\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./src/common/vline.ts\");\nconst element_extension_1 = __webpack_require__(/*! ../../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst debugger_1 = __webpack_require__(/*! ../../common/debugger */ \"./src/common/debugger.ts\");\nconst GObserver = __webpack_require__(/*! ../z_observer */ \"./src/objects/z_observer.ts\");\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst html_functions_1 = __webpack_require__(/*! ../../html/html_functions */ \"./src/html/html_functions.ts\");\nconst global_gobject_manager_1 = __webpack_require__(/*! ../global_gobject_manager */ \"./src/objects/global_gobject_manager.ts\");\n/**\n * \n */\nclass CellRow {\n    constructor(_table, _y, _height = CellRow.defaultHeight) {\n        /*\n        public removeCell(i: number) {\n            this.cells[i].removeFromTable(false);\n            //this.cells.forEach((v) => v.removeFromTable(false));\n            this.cells.splice(i, 1);\n        }\n    \n        */\n        this._cells = [];\n        this.table = _table;\n        this._svgGroup = SVG.createGroup(this.table.svgGroup);\n        this.svgGroup.setAttribute(\"name\", \"cell_row\");\n        this.stableFlag = false;\n        this.table.svgGroup.insertBefore(this.svgGroup, this.table.svgRowBorderGroup);\n        this.cellY = _y;\n        this._svgGroup.setAttribute(CellRow.heightAttributeName, `${_height}`);\n        //this.unstableCounter = GObserver.unstableCounterDefault;\n        const svgsvgAncestor = (0, html_functions_1.getSVGSVGAncestor)(this.svgGroup);\n        if (svgsvgAncestor != null) {\n            const xb = global_gobject_manager_1.GlobalZObjectManager.tryRegisterSVGSVGElement(svgsvgAncestor);\n            xb.registerObject(this);\n        }\n        /*\n        for(let i=0;i<cellCount;i++){\n            this._cells.push(this.createCell(i, _y));\n        }\n        */\n        //this.height = this.getMaxHeight();\n    }\n    get minimumHeight() {\n        const attr = this.svgGroup.getAttribute(CellRow.minimumHeightAttributeName);\n        if (attr != null) {\n            return Number.parseInt(attr);\n        }\n        else {\n            return CellRow.defaultHeight;\n        }\n    }\n    set minimumHeight(value) {\n        this.svgGroup.setAttribute(CellRow.minimumHeightAttributeName, value.toString());\n    }\n    /*\n    public get unstableCounter(): number | null {\n        const p = this.svgGroup.getAttribute(GObserver.unstableCounterName);\n        if (p == null) {\n            return null;\n        } else {\n            const num = Number(p);\n            return num;\n        }\n    }\n    private set unstableCounter(value: number | null) {\n        if (value == null) {\n            this.svgGroup.removeAttribute(GObserver.unstableCounterName)\n        } else {\n            this.svgGroup.setAttribute(GObserver.unstableCounterName, value.toString());\n \n        }\n    }\n    public resetUnstableCounter(): void {\n        this.unstableCounter = GObserver.unstableCounterDefault;\n    }\n    */\n    get childrenStableFlag() {\n        let b = true;\n        for (let i = 0; i < this._cells.length; i++) {\n            if (!this._cells[i].stableFlag) {\n                b = false;\n                break;\n            }\n        }\n        return b;\n    }\n    updateSurfaceWithoutSVGText() {\n        if (this.childrenStableFlag) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    createCell(cellX, cellY, cellMap) {\n        const cellClass = undefined; //this.table.defaultCellClass == null ? undefined : this.table.defaultCellClass;\n        const borderClass = undefined;\n        //this.table.defaultBorderClass == null ? undefined : this.table.defaultBorderClass;\n        const option = { cellClass: cellClass, borderClass: borderClass };\n        return new cell_1.Cell(this.table, cellX, cellY, cellMap, option);\n    }\n    _insertCell(i, cellMap) {\n        const cell = this.createCell(i, this.cellY, cellMap);\n        this.cells.splice(i, 0, cell);\n    }\n    _appendCell(cellMap, num = 1) {\n        for (let i = 0; i < num; i++) {\n            const cell = this.createCell(this.cells.length, this.cellY, cellMap);\n            this.cells.push(cell);\n        }\n    }\n    get cells() {\n        return this._cells;\n    }\n    get length() {\n        return this.cells.length;\n    }\n    get svgGroup() {\n        return this._svgGroup;\n    }\n    get stableFlag() {\n        return this.svgGroup.getAttribute(GObserver.ObjectStableFlagName) == \"true\";\n    }\n    set stableFlag(b) {\n        this.svgGroup.setAttribute(GObserver.ObjectStableFlagName, b ? \"true\" : \"false\");\n    }\n    /**\n    Y\n    */\n    get cellY() {\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\n    }\n    set cellY(v) {\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\n        this.cells.forEach((w) => w.cellY = v);\n    }\n    /**\n    \n    */\n    get height() {\n        return Number(this._svgGroup.getAttribute(CellRow.heightAttributeName));\n    }\n    /**\n    \n    */\n    set height(value) {\n        (0, element_extension_1.setAttributeNumber)(this._svgGroup, CellRow.heightAttributeName, (0, vline_1.round100)(value));\n        //this._svgGroup.setAttribute(CellRow.columnHeightName, `${value}`);\n        //this.setHeightToCells();\n        /*\n        let b = false;\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            if (cell.isRowSingleCell && cell.height != value) {\n                cell.height = value;\n                b = true;\n            }\n        }\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            if (!cell.isRowSingleCell) {\n                cell.update();\n                //cell.resize();\n                b = true;\n            }\n        }\n        if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\n        */\n    }\n    getVirtualSize() {\n        let height = 0;\n        let width = 0;\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            const rect = cell.getVirtualRegion();\n            if (cell.isMasterCellOfRowCountOne) {\n                if (height < rect.height)\n                    height = rect.height;\n            }\n            width += cell.master.getVirtualRegion().width;\n        }\n        return new vline_1.Size((0, vline_1.round100)(width), (0, vline_1.round100)(height));\n    }\n    /**\n     * \n     */\n    /*\n     public get cells(): Cell[] {\n        return this.table.cells[this.cellY];\n    }\n    */\n    /**\n     * \n     */\n    get topBorders() {\n        const r = [];\n        this.cells.forEach((v) => {\n            if (r.length == 0) {\n                r.push(v.svgTopBorder);\n            }\n            else {\n                const last = r[r.length - 1];\n                if (last != v.svgTopBorder)\n                    r.push(v.svgTopBorder);\n            }\n        });\n        return r;\n    }\n    /**\n     * \n     */\n    get bottomBorders() {\n        const r = [];\n        this.cells.forEach((v) => {\n            if (r.length == 0) {\n                r.push(v.svgBottomBorder);\n            }\n            else {\n                const last = r[r.length - 1];\n                if (last != v.svgBottomBorder)\n                    r.push(v.svgBottomBorder);\n            }\n        });\n        return r;\n    }\n    /**\n     * \n     */\n    get leftBorder() {\n        return this.cells[0].svgLeftBorder;\n    }\n    /**\n     * \n     */\n    get rightBorder() {\n        const cells = this.cells;\n        return cells[cells.length - 1].svgRightBorder;\n    }\n    /*\n    public setHeightToCellsWithUpdateFlag(withUpdate : boolean) : boolean {\n        let b = false;\n        const height = Math.max(this.height, CellRow.defaultHeight);\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            if (cell.isMasterCellOfRowCountOne && !nearlyEqual(cell.height, height)) {\n                b = true;\n                if(withUpdate){\n                    cell.height = height;\n                }\n                if(!withUpdate && b){\n                    Debugger.updateFlagLog(this, this.setHeightToCellsWithUpdateFlag, `${cell.height} != ${height}`)\n\n                    return b;\n                }\n            }\n        }\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            if (!cell.isMasterCellOfRowCountOne) {\n                b = cell.tryUpdateWithUpdateFlag(withUpdate)  || b;\n\n                if(!withUpdate && b){\n                    Debugger.updateFlagLog(this, this.setHeightToCellsWithUpdateFlag, `${cell.tryUpdateWithUpdateFlag.name} x = ${x}`)\n                    return b;\n                }\n            }\n        }\n        return b;\n\n    }\n    */\n    //public setHeightToCells() {\n    //this.setHeightToCellsWithUpdateFlag(true);\n    // TODO : implement the event of the below code.\n    //if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\n    //}\n    /**\n     * \n     */\n    /*\n     public update() {\n        this.setHeightToCells();\n        //this.height = this.getMaxHeight();\n    }\n    */\n    /*\n    public tryResizeWithUpdateFlag(withUpdate : boolean) : boolean {\n        let b = false;\n        const cells = this.cells;\n        for(let i = 0;i<cells.length;i++){\n            b = cells[i].tryUpdateWithUpdateFlag(withUpdate)  || b;\n            if(!withUpdate && b){\n                return b;\n            }\n        }\n        b = this.setHeightToCellsWithUpdateFlag(withUpdate)  || b;\n        return b;\n    }\n    */\n    /**\n     * \n     */\n    //public resize() {\n    //this.setHeightToCellsWithUpdateFlag(true);\n    //this.tryResizeWithUpdateFlag(true);\n    //this.height = this.getMaxHeight();\n    //}\n    tryUpdateHeightWithUpdateFlag(allowShrink, withUpdate) {\n        let b = false;\n        const __height = allowShrink ? this.getVirtualSize().height : Math.max(this.height, this.getVirtualSize().height);\n        const newHeight = Math.max(this.minimumHeight, (0, vline_1.round100)(__height));\n        if (!(0, vline_1.nearlyEqual)(this.height, newHeight)) {\n            b = true;\n            if (withUpdate) {\n                this.height = newHeight;\n            }\n            else {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdateHeightWithUpdateFlag, `Height: ${this.height} -> ${newHeight}`);\n            }\n        }\n        return b;\n    }\n    /**\n     * \n     * @param allowShrink \n     */\n    fitHeightToOriginalCell(allowShrink) {\n        this.tryUpdateHeightWithUpdateFlag(allowShrink, true);\n    }\n    setYWithUpdate(posY, withUpdate) {\n        const posY100 = (0, vline_1.round100)(posY);\n        let b = false;\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            if (cell.y != posY100) {\n                b = true;\n                if (withUpdate) {\n                    cell.y = posY100;\n                }\n                if (!withUpdate && b) {\n                    return b;\n                }\n            }\n        }\n        return b;\n    }\n    /**\n     * Y\n     *\n     */\n    setY(posY) {\n        this.setYWithUpdate(posY, true);\n    }\n    /**\n     * \n     */\n    /*\n    private getMaxHeight(): number {\n        let height = 0;\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            const rect = cell.getVirtualRegion();\n            if (cell.isMasterCellOfRowCountOne) {\n                if (height < rect.height) height = rect.height;\n                if (height < cell.height) height = cell.height;\n            }\n        }\n        return height;\n    }\n    */\n    get selfy() {\n        for (let i = 0; i < this.table.rowCount; i++) {\n            if (this.table.rows[i] == this) {\n                return i;\n            }\n        }\n        throw new Error(\"error\");\n    }\n    _dispose() {\n        while (this.length > 0) {\n            const x = this.length - 1;\n            this._removeCell(x);\n        }\n        this.svgGroup.remove();\n        //this.rows.splice(this.rows[i].selfy, 1);\n    }\n    _removeCell(i) {\n        this.cells[i].removeFromTable(false);\n        this.cells.splice(i, 1);\n    }\n    /**\n     * \n     * @param isUnit\n     */\n    /*\n    public remove(isUnit: boolean = false) {\n        while (this.cells.length > 0) this.removeCell(this.cells.length - 1);\n        this.svgGroup.remove();\n        this.table.rows.splice(this.selfy, 1);\n    }\n    */\n    /*\n    public updateBorders() {\n        this.cells.forEach((v) => v.updateBorder());\n    }\n    */\n    /**\n     * \n     */\n    //public relocation() {\n    //    this.cells.forEach((v) => v.relocation());\n    //}\n    /**\n     * \n     */\n    get groupRowRange() {\n        let range = this.cells[0].groupRowRange;\n        this.cells.forEach((v) => {\n            if (range != null) {\n                range = cell_1.Cell.computeDisjunction(range, v.groupRowRange);\n            }\n        });\n        if (range == null) {\n            throw Error(\"error\");\n        }\n        else {\n            return range;\n        }\n    }\n    /*\n    public getBase1UpdateFlag(){\n        const b = this.cells.every((v) => v.unstableCounter == null);\n        return !b;\n    }\n    public base1Update(){\n        this.cells.forEach((v) => {\n            const b = v.tryUpdateWithUpdateFlag(true);\n            if(b){\n                v.resetUnstableCounter();\n            }else{\n                GObserver.decrementUnstableCounter(v);\n            }\n        })\n    }\n    */\n    get objectID() {\n        return this.svgGroup.getAttribute(AttributeNames.objectIDName);\n    }\n}\nexports.CellRow = CellRow;\nCellRow.heightAttributeName = \"data-height\";\nCellRow.minimumHeightAttributeName = \"data-minimum-height\";\nCellRow.defaultHeight = 20;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/row.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/update_table.ts":
/*!***************************************************!*\
  !*** ./src/objects/table_helpers/update_table.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n//namespace GraphTableSVG {\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UpdateTable = void 0;\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./src/common/vline.ts\");\nconst debugger_1 = __webpack_require__(/*! ../../common/debugger */ \"./src/common/debugger.ts\");\nclass UpdateTable {\n    static tryUpdateBorderCoodinateWithUpdateFlag(cell, borderType, newValue, type, withUpdate) {\n        let b = false;\n        const oldValue = cell.getBorderPosition(borderType, type);\n        const newValue100 = (0, vline_1.round100)(newValue);\n        if (!(0, vline_1.nearlyEqual)(oldValue, newValue100)) {\n            b = true;\n            if (withUpdate) {\n                debugger_1.Debugger.updateLog(cell, UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag, `Border = ${borderType}, Position = ${type}: ${oldValue}->${newValue100}`);\n                UpdateTable.setBorderPosition(cell, borderType, type, newValue100);\n            }\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag, `Border = ${borderType}, Position = ${type}: ${oldValue}->${newValue100}`);\n            }\n        }\n        return b;\n    }\n    static setBorderPosition(cell, borderType, positionType, newValue) {\n        let border = cell.svgTopBorder;\n        switch (borderType) {\n            case \"top\":\n                border = cell.svgTopBorder;\n                break;\n            case \"left\":\n                border = cell.svgLeftBorder;\n                break;\n            case \"right\":\n                border = cell.svgRightBorder;\n                break;\n            case \"bottom\":\n                border = cell.svgBottomBorder;\n                break;\n        }\n        switch (positionType) {\n            case \"x1\":\n                border.setAttribute(\"x1\", (0, vline_1.round100)(newValue).toString());\n            case \"x2\":\n                border.setAttribute(\"x2\", (0, vline_1.round100)(newValue).toString());\n            case \"y1\":\n                border.setAttribute(\"y1\", (0, vline_1.round100)(newValue).toString());\n            case \"y2\":\n                border.setAttribute(\"y2\", (0, vline_1.round100)(newValue).toString());\n        }\n    }\n    static tryRelocateBottomBorderWithUpdateFlag(cell, withUpdate) {\n        if (!cell.isMaster) {\n            return false;\n        }\n        if (cell.table.svgGroup.contains(cell.svgBottomBorder)) {\n            if (cell.isMaster) {\n                const x1 = cell.x;\n                const b1 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"bottom\", x1, \"x1\", withUpdate);\n                if (!withUpdate && b1) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateBottomBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x1`);\n                    return true;\n                }\n                const x2 = cell.x + cell.computeBorderLength2(\"bottom\");\n                const b2 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"bottom\", x2, \"x2\", withUpdate);\n                if (!withUpdate && b2) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateBottomBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x2`);\n                    return true;\n                }\n                const y1 = cell.y + cell.height;\n                const b3 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"bottom\", y1, \"y1\", withUpdate);\n                if (!withUpdate && b3) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateBottomBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y1`);\n                    return true;\n                }\n                const y2 = cell.getBorderPosition(\"bottom\", \"y1\");\n                const b4 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"bottom\", y2, \"y2\", withUpdate);\n                if (!withUpdate && b4) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateBottomBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y2`);\n                    return true;\n                }\n                return b1 || b2 || b3 || b4;\n            }\n            else if (cell.bottomCell != null && cell.bottomCell.isMaster) {\n                const b = UpdateTable.tryRelocateTopBorderWithUpdateFlag(cell.bottomCell, withUpdate);\n                return b;\n            }\n            else {\n                throw Error(\"error\");\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    static tryRelocateTopBorderWithUpdateFlag(cell, withUpdate) {\n        //let b = false;\n        if (!cell.isMaster)\n            return false;\n        if (cell.table.svgGroup.contains(cell.svgTopBorder)) {\n            if (cell.isMaster) {\n                const x1 = cell.x;\n                const b1 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"top\", x1, \"x1\", withUpdate);\n                if (!withUpdate && b1) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateTopBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x1`);\n                    return true;\n                }\n                //const x2 = cell.x;\n                const x2 = cell.x + cell.computeBorderLength2(\"top\");\n                const b2 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"top\", x2, \"x2\", withUpdate);\n                if (!withUpdate && b2) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateTopBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x2`);\n                    return true;\n                }\n                const y1 = cell.y;\n                const b3 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"top\", y1, \"y1\", withUpdate);\n                if (!withUpdate && b3) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateTopBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y1`);\n                    return true;\n                }\n                const y2 = cell.getBorderPosition(\"top\", \"y1\");\n                const b4 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"top\", y2, \"y2\", withUpdate);\n                if (!withUpdate && b4) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateTopBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y2`);\n                    return true;\n                }\n                return b1 || b2 || b3 || b4;\n            }\n            else if (cell.topCell != null && cell.topCell.isMaster) {\n                const b = UpdateTable.tryRelocateBottomBorderWithUpdateFlag(cell.topCell, withUpdate);\n                return b;\n            }\n            else {\n                throw Error(\"error\");\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    static tryRelocateLeftBorderWithUpdateFlag(cell, withUpdate) {\n        if (!cell.isMaster) {\n            return false;\n        }\n        if (cell.table.svgGroup.contains(cell.svgLeftBorder)) {\n            if (cell.isMaster) {\n                const x1 = cell.x;\n                const b1 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"left\", x1, \"x1\", withUpdate);\n                if (!withUpdate && b1) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateLeftBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x1`);\n                    return true;\n                }\n                const x2 = cell.getBorderPosition(\"left\", \"x1\");\n                ;\n                const b2 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"left\", x2, \"x2\", withUpdate);\n                if (!withUpdate && b2) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateLeftBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x2`);\n                    return true;\n                }\n                const y1 = cell.y;\n                const b3 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"left\", y1, \"y1\", withUpdate);\n                if (!withUpdate && b3) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateLeftBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y1`);\n                    return true;\n                }\n                const y2 = cell.y + cell.computeBorderLength2(\"left\");\n                const b4 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"left\", y2, \"y2\", withUpdate);\n                if (!withUpdate && b4) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateLeftBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y2`);\n                    return true;\n                }\n                return b1 || b2 || b3 || b4;\n            }\n            else if (cell.leftCell != null && cell.leftCell.isMaster) {\n                const b = UpdateTable.tryRelocateRightBorderWithUpdateFlag(cell.leftCell, withUpdate);\n                return b;\n            }\n            else {\n                throw Error(\"error\");\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    static tryRelocateRightBorderWithUpdateFlag(cell, withUpdate) {\n        if (!cell.isMaster) {\n            return false;\n        }\n        if (cell.table.svgGroup.contains(cell.svgRightBorder)) {\n            if (cell.isMaster) {\n                const x1 = cell.x + cell.width;\n                const b1 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"right\", x1, \"x1\", withUpdate);\n                if (!withUpdate && b1) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateRightBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x1`);\n                    return true;\n                }\n                const x2 = cell.x + cell.width;\n                const b2 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"right\", x2, \"x2\", withUpdate);\n                if (!withUpdate && b2) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateRightBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x2`);\n                    return true;\n                }\n                const y1 = cell.y;\n                const b3 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"right\", y1, \"y1\", withUpdate);\n                if (!withUpdate && b3) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateRightBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y1`);\n                    return true;\n                }\n                const y2 = cell.y + cell.computeBorderLength2(\"right\");\n                const b4 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"right\", y2, \"y2\", withUpdate);\n                if (!withUpdate && b4) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateRightBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y2`);\n                    return true;\n                }\n                return b1 || b2 || b3 || b4;\n            }\n            else if (cell.rightCell != null && cell.rightCell.isMaster) {\n                const b = UpdateTable.tryRelocateLeftBorderWithUpdateFlag(cell.rightCell, withUpdate);\n                return b;\n            }\n            else {\n                throw Error(\"error\");\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n    *\n    */\n    static tryUpdateBordersWithUpdateFlag(cell, withUpdate) {\n        //let b = false;\n        const b1 = UpdateTable.tryRelocateTopBorderWithUpdateFlag(cell, withUpdate);\n        if (!withUpdate && b1) {\n            debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryUpdateBordersWithUpdateFlag, `${UpdateTable.tryRelocateTopBorderWithUpdateFlag.name}`);\n            return true;\n        }\n        const b2 = UpdateTable.tryRelocateLeftBorderWithUpdateFlag(cell, withUpdate);\n        if (!withUpdate && b2) {\n            debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryUpdateBordersWithUpdateFlag, `${UpdateTable.tryRelocateLeftBorderWithUpdateFlag.name}`);\n            return true;\n        }\n        const b3 = UpdateTable.tryRelocateRightBorderWithUpdateFlag(cell, withUpdate);\n        if (!withUpdate && b3) {\n            debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryUpdateBordersWithUpdateFlag, `${UpdateTable.tryRelocateRightBorderWithUpdateFlag.name}`);\n            return true;\n        }\n        const b4 = UpdateTable.tryRelocateBottomBorderWithUpdateFlag(cell, withUpdate);\n        if (!withUpdate && b4) {\n            debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryUpdateBordersWithUpdateFlag, `${UpdateTable.tryRelocateBottomBorderWithUpdateFlag.name}`);\n            return true;\n        }\n        return b1 || b2 || b3 || b4;\n    }\n    static tryUpdateBorders(cellArray, withUpdate) {\n        let b = false;\n        const date1 = new Date();\n        cellArray.forEach((v) => {\n            if (v.isMaster) {\n                b = UpdateTable.tryUpdateBordersWithUpdateFlag(v, withUpdate) || b;\n            }\n        });\n        const date2 = new Date();\n        debugger_1.Debugger.showTime(date1, date2, `Table: X`, \"updateBorders\");\n        return b;\n    }\n    static updateCellSizeAfterUpdatingRowsAndColumns(rows, columns, withUpdate) {\n        let b = false;\n        for (let y = 0; y < rows.length; y++) {\n            const height = Math.max(rows[y].height, rows[y].minimumHeight);\n            for (let x = 0; x < rows[y].length; x++) {\n                const width = Math.max(columns[x].width, columns[x].minimumWidth);\n                const cell = rows[y].cells[x];\n                if (cell.isMasterCellOfRowCountOne && !(0, vline_1.nearlyEqual)(cell.height, height)) {\n                    b = true;\n                    if (withUpdate) {\n                        debugger_1.Debugger.updateLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.height} != ${height}`);\n                        cell.height = height;\n                    }\n                    if (!withUpdate && b) {\n                        debugger_1.Debugger.updateFlagLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.height} != ${height}`);\n                        return b;\n                    }\n                }\n                if (cell.isMasterCellOfColumnCountOne && !(0, vline_1.nearlyEqual)(cell.width, width)) {\n                    b = true;\n                    if (withUpdate) {\n                        debugger_1.Debugger.updateLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.width} != ${width} y = ${y}`);\n                        cell.width = width;\n                    }\n                    if (!withUpdate && b) {\n                        debugger_1.Debugger.updateFlagLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.width} != ${width} y = ${y}`);\n                        return true;\n                    }\n                }\n                if (!cell.isMasterCellOfRowCountOne) {\n                    b = cell.tryUpdateWithUpdateFlag(withUpdate) || b;\n                    if (!withUpdate && b) {\n                        debugger_1.Debugger.updateFlagLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.tryUpdateWithUpdateFlag.name} x = ${x}`);\n                        return b;\n                    }\n                }\n                if (!cell.isMasterCellOfColumnCountOne) {\n                    b = cell.tryUpdateWithUpdateFlag(withUpdate) || b;\n                    if (!withUpdate && b) {\n                        debugger_1.Debugger.updateFlagLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.tryUpdateWithUpdateFlag.name} y = ${y}`);\n                        return b;\n                    }\n                }\n            }\n        }\n        return b;\n    }\n    static relocateCellsAfterUpdatingCellSize(rows, columns, withUpdate) {\n        let b = false;\n        let height = 0;\n        for (let i = 0; i < rows.length; i++) {\n            b = rows[i].setYWithUpdate(height, withUpdate) || b;\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(rows[i], UpdateTable.relocateCellsAfterUpdatingCellSize, rows[i].setYWithUpdate.name);\n                return b;\n            }\n            height += rows[i].height;\n        }\n        let width = 0;\n        for (let i = 0; i < columns.length; i++) {\n            b = columns[i].setXWithUpdate(width, withUpdate) || b;\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(columns[i], UpdateTable.relocateCellsAfterUpdatingCellSize, columns[i].setXWithUpdate.name);\n                return b;\n            }\n            width += columns[i].width;\n        }\n        return b;\n    }\n    static tryUpdateRowHeightAndColumnWidthWithUpdateFlag(rows, columns, allowShrink, withUpdate) {\n        let b = false;\n        for (let i = 0; i < rows.length; i++) {\n            b = rows[i].tryUpdateHeightWithUpdateFlag(allowShrink, withUpdate) || b;\n            if (!withUpdate && b) {\n                return b;\n            }\n        }\n        for (let i = 0; i < columns.length; i++) {\n            b = columns[i].tryUpdateWidthWithUpdateFlag(allowShrink, withUpdate) || b;\n            if (!withUpdate && b) {\n                return b;\n            }\n        }\n        return b;\n    }\n}\nexports.UpdateTable = UpdateTable;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/update_table.ts?");

/***/ }),

/***/ "./src/objects/z_abstract_edge.ts":
/*!****************************************!*\
  !*** ./src/objects/z_abstract_edge.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZAbstractEdge = void 0;\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst common_functions_1 = __webpack_require__(/*! ./graph_helpers/common_functions */ \"./src/objects/graph_helpers/common_functions.ts\");\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./src/html/enum_extension.ts\");\nconst element_builder_1 = __webpack_require__(/*! ./element_builder */ \"./src/objects/element_builder.ts\");\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\nconst html_1 = __webpack_require__(/*! ../html */ \"./src/html/index.ts\");\nconst z_observer_1 = __webpack_require__(/*! ./z_observer */ \"./src/objects/z_observer.ts\");\n//import { Direction } from \"readline\";\nclass ZAbstractEdge extends z_object_1.ZObject {\n    constructor(svgbox) {\n        super(svgbox);\n        this.connectPositionChangedFunc = () => {\n            //this.update();\n        };\n        this.updateAttributes.push(AttributeNames.beginNodeName);\n        this.updateAttributes.push(AttributeNames.endNodeName);\n        const pathClass = this.svgSurface.getAttribute(\"class\");\n        if (pathClass == DefaultClassNames.defaultSurfaceClass) {\n            this.svgSurface.setAttribute(\"class\", DefaultClassNames.defaultPathSurfaceClass);\n        }\n        this.svgPath.id = `path-${this.objectID}`;\n    }\n    createSurface(svgbox, option = {}) {\n        if (option.surfaceClass === undefined)\n            option.surfaceClass = DefaultClassNames.defaultEdgePathClass;\n        const path = (0, element_builder_1.createPath)(this.svgGroup, 0, 0, 0, 0, option.surfaceClass, option.surfaceStyle);\n        path.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Surface);\n        this._svgSurface = path;\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        const edgeColor = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke\");\n        const edgeColor2 = edgeColor == null ? undefined : edgeColor;\n        const strokeWidth = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke-width\");\n        const strokeWidth2 = strokeWidth == null ? undefined : strokeWidth;\n        const style = getComputedStyle(this.svgGroup);\n        const markerStart = style.getPropertyValue(StyleNames.EdgeStyleNames.markerStart);\n        const markerEnd = style.getPropertyValue(StyleNames.EdgeStyleNames.markerEnd);\n        if (markerStart.length != 0)\n            this.markerStart = ZAbstractEdge.createStartMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\n        if (markerEnd.length != 0)\n            this.markerEnd = ZAbstractEdge.createEndMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\n        const x1 = ElementExtension._getAttributeNumber(source, AttributeNames.x1, true);\n        const x2 = ElementExtension._getAttributeNumber(source, AttributeNames.x2, true);\n        const y1 = ElementExtension._getAttributeNumber(source, AttributeNames.y1, true);\n        const y2 = ElementExtension._getAttributeNumber(source, AttributeNames.y2, true);\n        if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {\n            this.pathPoints = [[x1, y1], [x2, y2]];\n        }\n        const beginVertex = ElementExtension._getAttribute(source, AttributeNames.beginVertex, true);\n        const endVertex = ElementExtension._getAttribute(source, AttributeNames.endVertex, true);\n        if (beginVertex != null) {\n            this.beginVertexID = beginVertex;\n        }\n        if (endVertex != null) {\n            this.endVertexID = endVertex;\n        }\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZAbstractEdgeAttributes) {\n\n        super.setBasicOption(option);\n\n        const edgeColor = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke\");\n        const edgeColor2 = edgeColor == null ? undefined : edgeColor;\n        const strokeWidth = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke-width\");\n        const strokeWidth2 = strokeWidth == null ? undefined : strokeWidth;\n\n        const style = getComputedStyle(this.svgGroup);\n        const markerStart = style.getPropertyValue(StyleNames.markerStart);\n        const markerEnd = style.getPropertyValue(StyleNames.markerEnd);\n\n        if (markerStart.length != 0) this.markerStart = ZAbstractEdge.createStartMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\n        if (markerEnd.length != 0) this.markerEnd = ZAbstractEdge.createEndMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\n\n        if (option.x1 !== undefined && option.y1 !== undefined && option.x2 !== undefined && option.y2 !== undefined) {\n            this.pathPoints = [[option.x1!, option.y1!], [option.x2!, option.y2!]];\n        }\n\n\n        if (typeof option.beginVertex == \"object\") {\n            if (option.beginVertex instanceof ZVertex) this.beginVertex = option.beginVertex;\n        } else if (typeof option.beginVertex == \"string\") {\n            this.beginVertexID = option.beginVertex;\n        }\n\n        if (typeof option.endVertex == \"object\") {\n            if (option.endVertex instanceof ZVertex) this.endVertex = option.endVertex;\n        } else if (typeof option.endVertex == \"string\") {\n            this.endVertexID = option.endVertex;\n        }\n\n    }\n    */\n    get edgeType() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.EdgeStyleNames.edgeType, \"none\");\n        if (b == \"straight\") {\n            return \"straight\";\n        }\n        else if (b == \"elbow\") {\n            return \"elbow\";\n        }\n        else if (b == \"curve\") {\n            return \"curve\";\n        }\n        else {\n            return \"none\";\n        }\n        /*\n        if (b == undefined) {\n            return false;\n        } else {\n            return b;\n        }\n        */\n    }\n    set edgeType(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.edgeType, value);\n        //this.svgGroup.setPropertyStyleValue(AttributeNames.Style.autoSizeShapeToFitText, value ? \"true\" : \"false\");\n    }\n    get svgPath() {\n        return this.svgSurface;\n    }\n    get degree() {\n        const rad = Math.atan2(this.y2 - this.y1, this.x2 - this.x1);\n        const degree = (180 * rad) / Math.PI;\n        return degree;\n    }\n    get childrenStableFlag() {\n        const b = this.svgPath.getAttribute(z_observer_1.ObjectStableFlagName);\n        return b == \"true\";\n    }\n    /**\n     * \n     */\n    dispose() {\n        this.beginVertex = null;\n        this.endVertex = null;\n    }\n    get coordinateType() {\n        return \"group00\";\n    }\n    get defaultClassName() {\n        return DefaultClassNames.defaultEdgeClass;\n    }\n    get hasSize() {\n        return false;\n    }\n    get graph() {\n        return (0, common_functions_1.getGraph)(this);\n    }\n    get beginVertexID() {\n        return this.svgGroup.getAttribute(AttributeNames.beginNodeName);\n    }\n    set beginVertexID(v) {\n        if (v == null) {\n            this.svgGroup.removeAttribute(AttributeNames.beginNodeName);\n        }\n        else {\n            this.svgGroup.setAttribute(AttributeNames.beginNodeName, v);\n        }\n        const svgsvg = html_1.HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvg != null) {\n            const manager = svgsvg._manager;\n            if (manager != undefined) {\n                manager.registerBeginVertexID(this, v);\n            }\n        }\n    }\n    /**\n     * svgPathstyle:stroke\n     */\n    get lineColor() {\n        if (this.svgPath != null) {\n            return ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"black\");\n        }\n        else {\n            return null;\n        }\n    }\n    get endVertexID() {\n        return this.svgGroup.getAttribute(AttributeNames.endNodeName);\n    }\n    set endVertexID(v) {\n        if (v == null) {\n            this.svgGroup.removeAttribute(AttributeNames.endNodeName);\n        }\n        else {\n            this.svgGroup.setAttribute(AttributeNames.endNodeName, v);\n        }\n        const svgsvg = html_1.HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvg != null) {\n            const manager = svgsvg._manager;\n            if (manager != undefined) {\n                manager.registerEndVertexID(this, v);\n            }\n        }\n    }\n    /*\n    protected updateSurface() {\n        this.updateDashArray();\n        if (this.markerStart != null) {\n            var node = <SVGPolygonElement>this.markerStart.firstChild;\n            if (this.lineColor != null) {\n                node.setAttribute(\"fill\", this.lineColor);\n            }\n        }\n        if (this.markerEnd != null) {\n            var node = <SVGPolygonElement>this.markerEnd.firstChild;\n            if (this.lineColor != null) {\n                node.setAttribute(\"fill\", this.lineColor);\n            }\n        }\n\n\n    }\n\n    private updateDashArray() {\n\n        this.hasConnectedObserverFunction = false;\n        const dashStyle = this.msoDashStyle;\n        if (dashStyle != null) {\n            updateAppropriateDashArray(this.svgPath);\n        }\n        this.hasConnectedObserverFunction = true;\n    }\n    */\n    /**\n     * True\n     */\n    get pathTextAlignment() {\n        const value = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.EdgeStyleNames.pathTextAlignment, \"center\");\n        return enums_1.PathTextAlighnment.toPathTextAlighnment(value);\n    }\n    set pathTextAlignment(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.pathTextAlignment, value);\n    }\n    get pathPoints() {\n        const dAttr = this.svgPath.getAttribute(\"d\");\n        if (dAttr == null)\n            throw Error(\"error\");\n        const r = [];\n        if (dAttr.length > 0) {\n            const d = dAttr.split(\" \");\n            let i = 0;\n            while (i < d.length) {\n                if (d[i] == \"M\") {\n                    r.push([(0, vline_1.round100)(Number(d[i + 1])), (0, vline_1.round100)(Number(d[i + 2]))]);\n                    i += 3;\n                }\n                else if (d[i] == \"L\") {\n                    r.push([(0, vline_1.round100)(Number(d[i + 1])), (0, vline_1.round100)(Number(d[i + 2]))]);\n                    i += 3;\n                }\n                else if (d[i] == \"Q\") {\n                    r.push([(0, vline_1.round100)(Number(d[i + 1])), (0, vline_1.round100)(Number(d[i + 2]))]);\n                    r.push([(0, vline_1.round100)(Number(d[i + 3])), (0, vline_1.round100)(Number(d[i + 4]))]);\n                    i += 5;\n                }\n                else {\n                    throw Error(\"path points parse error/\" + dAttr + \"/\" + dAttr.length);\n                }\n            }\n            return r;\n        }\n        else {\n            return r;\n        }\n    }\n    set pathPoints(points) {\n        points.forEach((v) => {\n            if (v[0] === undefined) {\n                throw new exceptions_1.UndefinedError();\n            }\n        });\n        let path = \"\";\n        if (this.edgeType == \"elbow\") {\n            path += `M ${points[0][0]} ${points[0][1]} `;\n            for (let i = 1; i < points.length - 1; i++) {\n                path += `L ${points[i][0]} ${points[i][1]} `;\n            }\n            path += `L ${points[points.length - 1][0]} ${points[points.length - 1][1]}`;\n        }\n        else {\n            if (points.length == 2) {\n                const [x1, y1] = points[0];\n                const [x2, y2] = points[1];\n                path = (0, vline_1.escapeWithRound100) `M ${x1} ${y1} L ${x2} ${y2}`;\n            }\n            else if (points.length == 3) {\n                const [x1, y1] = points[0];\n                const [x2, y2] = points[2];\n                const [cx1, cy1] = points[1];\n                path = (0, vline_1.escapeWithRound100) `M ${x1} ${y1} Q ${cx1} ${cy1} ${x2} ${y2}`;\n            }\n            else if (points.length == 1) {\n                throw Error(\"path points ivnalid error\");\n            }\n            else {\n                path = (0, vline_1.escapeWithRound100) `M ${0} ${0} L ${0} ${0}`;\n            }\n        }\n        const prevPath = this.svgPath.getAttribute(\"d\");\n        if (prevPath == null || path != prevPath) {\n            this.svgPath.setAttribute(\"d\", path);\n        }\n    }\n    /**\n    \n    */\n    get beginVertex() {\n        if (this.beginVertexID == null) {\n            return null;\n        }\n        else {\n            return z_object_1.ZObject.getObjectFromIDOrObjectID(this.beginVertexID);\n        }\n    }\n    /**\n    \n    */\n    set beginVertex(value) {\n        if (value == null) {\n            this.beginVertexID = null;\n        }\n        else {\n            this.beginVertexID = value.objectID;\n        }\n        //this.update();\n    }\n    /**\n    \n    */\n    get endVertex() {\n        if (this.endVertexID == null) {\n            return null;\n        }\n        else {\n            return z_object_1.ZObject.getObjectFromIDOrObjectID(this.endVertexID);\n        }\n    }\n    /**\n    \n    */\n    set endVertex(value) {\n        if (value == null) {\n            this.endVertexID = null;\n        }\n        else {\n            this.endVertexID = value.objectID;\n        }\n        //this.update();\n    }\n    /**\n        X\n        */\n    get x1() {\n        return this.pathPoints[0][0];\n    }\n    set x1(value) {\n        const p = this.pathPoints;\n        p[0][0] = value;\n        this.pathPoints = p;\n    }\n    /**\n    Y\n    */\n    get y1() {\n        return this.pathPoints[0][1];\n    }\n    set y1(value) {\n        const p = this.pathPoints;\n        p[0][1] = value;\n        this.pathPoints = p;\n    }\n    /**\n    X\n    */\n    get x2() {\n        const d = this.pathPoints;\n        return d[d.length - 1][0];\n    }\n    set x2(value) {\n        const p = this.pathPoints;\n        p[p.length - 1][0] = value;\n        this.pathPoints = p;\n    }\n    /**\n    Y\n    */\n    get y2() {\n        const d = this.pathPoints;\n        return d[d.length - 1][1];\n    }\n    set y2(value) {\n        const p = this.pathPoints;\n        p[p.length - 1][1] = value;\n        this.pathPoints = p;\n    }\n    /**\n    \n    */\n    get beginConnectorType() {\n        const p = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.beginConnectorType);\n        const type = enums_1.ConnectorType.ToConnectorPosition(p);\n        if (type == enums_1.ConnectorType.Auto) {\n            if (this.graph != null) {\n                const dir = this.graph.direction;\n                if (dir != null) {\n                    if (dir == \"up\") {\n                        return enums_1.ConnectorType.Top;\n                    }\n                    else if (dir == \"left\") {\n                        return enums_1.ConnectorType.Left;\n                    }\n                    else if (dir == \"right\") {\n                        return enums_1.ConnectorType.Right;\n                    }\n                    else {\n                        return enums_1.ConnectorType.Bottom;\n                    }\n                }\n                else {\n                    return type;\n                }\n            }\n            else {\n                return type;\n            }\n        }\n        else {\n            return type;\n        }\n    }\n    /**\n    \n    */\n    set beginConnectorType(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.beginConnectorType, value);\n        //this.svgGroup.setAttribute(Edge.beginConnectorTypeName, ToStrFromConnectorPosition(value));\n    }\n    /**\n    \n    */\n    get endConnectorType() {\n        const p = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.endConnectorType);\n        const type = enums_1.ConnectorType.ToConnectorPosition(p);\n        if (type == enums_1.ConnectorType.Auto) {\n            if (this.graph != null) {\n                const dir = this.graph.direction;\n                if (dir != null) {\n                    if (dir == \"up\") {\n                        return enums_1.ConnectorType.Bottom;\n                    }\n                    else if (dir == \"left\") {\n                        return enums_1.ConnectorType.Right;\n                    }\n                    else if (dir == \"right\") {\n                        return enums_1.ConnectorType.Left;\n                    }\n                    else {\n                        return enums_1.ConnectorType.Top;\n                    }\n                }\n                else {\n                    return type;\n                }\n            }\n            else {\n                return type;\n            }\n        }\n        else {\n            return type;\n        }\n    }\n    /**\n    \n    */\n    set endConnectorType(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.endConnectorType, value);\n    }\n    /**\n     * \n     */\n    static createMark(option = {}) {\n        var [marker, path] = SVG.createMarker(option);\n        if (option.isEnd != undefined && option.isEnd) {\n            path.setAttribute(\"transform\", \"rotate(180,5,5)\");\n            marker.setAttribute(\"refX\", \"0\");\n        }\n        marker.id = `marker-${ZAbstractEdge.markerCounter++}`;\n        return marker;\n    }\n    static createStartMarker(option = {}) {\n        const option2 = { className: option.className, strokeWidth: option.strokeWidth, color: option.color, isEnd: true };\n        return this.createMark(option2);\n    }\n    static createEndMarker(option = {}) {\n        return this.createMark(option);\n    }\n    /**\n         * \n         */\n    get markerStart() {\n        if (this.svgPath != null) {\n            var p = this.svgPath.getAttribute(\"marker-start\");\n            if (p != null) {\n                const str = p.substring(5, p.length - 1);\n                const ele = document.getElementById(str);\n                return ele;\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * \n     * @param value SVGMarkerElementNull\n     */\n    set markerStart(value) {\n        if (this.svgPath != null) {\n            if (value == null) {\n                this.svgPath.removeAttribute(\"marker-start\");\n            }\n            else {\n                this.svgGroup.appendChild(value);\n                this.svgPath.setAttribute(\"marker-start\", `url(#${value.id})`);\n            }\n        }\n    }\n    /**\n     * \n     */\n    get markerEnd() {\n        if (this.svgPath != null) {\n            var p = this.svgPath.getAttribute(\"marker-end\");\n            if (p != null) {\n                const str = p.substring(5, p.length - 1);\n                const ele = document.getElementById(str);\n                return ele;\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    set markerEnd(value) {\n        if (this.svgPath != null) {\n            if (value == null) {\n                this.svgPath.removeAttribute(\"marker-end\");\n            }\n            else {\n                this.svgGroup.appendChild(value);\n                this.svgPath.setAttribute(\"marker-end\", `url(#${value.id})`);\n            }\n        }\n    }\n    get msoDashStyle() {\n        if (this.svgSurface != null) {\n            const dashStyle = ElementExtension.getPropertyStyleValue(this.svgSurface, StyleNames.msoDashStyleName);\n            if (dashStyle != null) {\n                return enums_1.msoDashStyle.toMSODashStyle(dashStyle);\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    set msoDashStyle(value) {\n        if (this.svgSurface != null) {\n            if (enums_1.msoDashStyle == null) {\n                this.svgSurface.style.removeProperty(StyleNames.msoDashStyleName);\n            }\n            else {\n                ElementExtension.setPropertyStyleValue(this.svgSurface, StyleNames.msoDashStyleName, value);\n            }\n        }\n    }\n    removeVertexEvent(vertex) {\n        vertex.svgGroup.removeEventListener(AttributeNames.connectPositionChangedEventName, this.connectPositionChangedFunc);\n    }\n    addVertexEvent(vertex) {\n        vertex.svgGroup.addEventListener(AttributeNames.connectPositionChangedEventName, this.connectPositionChangedFunc);\n    }\n    tryUpdateConnectorWithUpdateFlag(withUpdate) {\n        let b = false;\n        const svgsvg = html_1.HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvg != null) {\n            const manager = svgsvg._manager;\n            if (manager != null) {\n                const oldBeginVertexID = manager.getBeginVertexID(this);\n                const oldEndVertexID = manager.getEndVertexID(this);\n                if (this.beginVertexID != oldBeginVertexID) {\n                    b = true;\n                    if (!withUpdate) {\n                        debugger_1.Debugger.updateFlagLog(this, this.tryUpdateConnectorWithUpdateFlag, `this.beginVertex != oldBeginVertex`);\n                        return b;\n                    }\n                    if (withUpdate) {\n                        if (oldBeginVertexID != null) {\n                            const oldBeginVertex = z_object_1.ZObject.getObjectFromIDOrObjectID(oldBeginVertexID);\n                            if (oldBeginVertex != null && oldBeginVertex instanceof z_vertex_1.ZVertex) {\n                                this.removeVertexEvent(oldBeginVertex);\n                            }\n                        }\n                        if (this.beginVertex != null) {\n                            this.addVertexEvent(this.beginVertex);\n                        }\n                    }\n                }\n                if (this.endVertexID != oldEndVertexID) {\n                    b = true;\n                    if (!withUpdate) {\n                        debugger_1.Debugger.updateFlagLog(this, this.tryUpdateConnectorWithUpdateFlag, `this.endVertex != oldEndVertex`);\n                        return b;\n                    }\n                    if (withUpdate) {\n                        if (oldEndVertexID != null) {\n                            const oldEndVertex = z_object_1.ZObject.getObjectFromIDOrObjectID(oldEndVertexID);\n                            if (oldEndVertex != null && oldEndVertex instanceof z_vertex_1.ZVertex) {\n                                this.removeVertexEvent(oldEndVertex);\n                            }\n                        }\n                        if (this.endVertex != null) {\n                            this.addVertexEvent(this.endVertex);\n                        }\n                    }\n                }\n            }\n        }\n        return b;\n    }\n    tryUpdateDashArrayWithUpdateFlag(withUpdate) {\n        let b = false;\n        this.hasConnectedObserverFunction = false;\n        const dashStyle = this.msoDashStyle;\n        if (dashStyle != null) {\n            b = (0, enum_extension_1.tryUpdateAppropriateDashArrayWithUpdateFlag)(this.svgPath, withUpdate);\n        }\n        this.hasConnectedObserverFunction = true;\n        return b;\n    }\n    updateSurfaceWithUpdateFlag(withUpdate) {\n        let b = this.tryUpdateDashArrayWithUpdateFlag(withUpdate);\n        if (!withUpdate && b) {\n            debugger_1.Debugger.updateFlagLog(this, this.updateSurfaceWithUpdateFlag, `${this.tryUpdateDashArrayWithUpdateFlag.name}`);\n        }\n        if (this.markerStart != null) {\n            var node = this.markerStart.firstChild;\n            if (this.lineColor != null) {\n                const fill = node.getAttribute(\"fill\");\n                if (fill != this.lineColor) {\n                    b = true;\n                    if (withUpdate) {\n                        node.setAttribute(\"fill\", this.lineColor);\n                    }\n                    else {\n                        debugger_1.Debugger.updateFlagLog(this, this.updateSurfaceWithUpdateFlag, \"fill != this.lineColor (markerStart)\");\n                        return b;\n                    }\n                }\n            }\n        }\n        if (this.markerEnd != null) {\n            var node = this.markerEnd.firstChild;\n            if (this.lineColor != null) {\n                const fill = node.getAttribute(\"fill\");\n                if (fill != this.lineColor) {\n                    b = true;\n                    if (withUpdate) {\n                        node.setAttribute(\"fill\", this.lineColor);\n                    }\n                    else {\n                        debugger_1.Debugger.updateFlagLog(this, this.updateSurfaceWithUpdateFlag, \"fill != this.lineColor (markerEnd)\");\n                        return b;\n                    }\n                }\n            }\n        }\n        return b;\n    }\n    updateLocationWithUpdateFlag(withUpdate) {\n        let b = false;\n        const [x1, y1] = this.beginConnectoPosition;\n        const [x2, y2] = this.endConnectorPosition;\n        const equalFunc = (prevObj, newObj) => {\n            if (prevObj.length != newObj.length) {\n                return false;\n            }\n            else {\n                for (let i = 0; i < prevObj.length; i++) {\n                    if (!(0, vline_1.nearlyEqual)(prevObj[i][0], newObj[i][0])) {\n                        return false;\n                    }\n                    else if (!(0, vline_1.nearlyEqual)(prevObj[i][1], newObj[i][1])) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        const arrayRound100 = (obj) => {\n            for (let i = 0; i < obj.length; i++) {\n                obj[i] = [(0, vline_1.round100)(obj[i][0]), (0, vline_1.round100)(obj[i][1])];\n            }\n        };\n        if (this.edgeType == \"elbow\") {\n            const points = new Array();\n            const elbowPositions = this.elbowCalculator(x1, y1, this.beginConnectorType, x2, y2, this.endConnectorType);\n            points.push([x1, y1]);\n            elbowPositions.forEach((v) => points.push(v));\n            points.push([x2, y2]);\n            arrayRound100(points);\n            if (!equalFunc(this.pathPoints, points)) {\n                b = true;\n                if (withUpdate) {\n                    this.pathPoints = points;\n                }\n            }\n        }\n        else if (this.edgeType == \"curve\") {\n        }\n        else {\n            const points = new Array();\n            this.pathPoints.forEach((v) => points.push(v));\n            points[0] = [x1, y1];\n            points[points.length - 1] = [x2, y2];\n            arrayRound100(points);\n            if (!equalFunc(this.pathPoints, points)) {\n                b = true;\n                if (withUpdate) {\n                    this.pathPoints = points;\n                }\n            }\n        }\n        //if (points[0][0] == undefined) throw new UndefinedError();\n        //this.pathPoints = points;\n        return b;\n    }\n    getUpdateFlag() {\n        const b1 = super.getUpdateFlag();\n        if (b1) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${super.getUpdateFlag.name}`);\n        }\n        const b2 = this.tryUpdateConnectorWithUpdateFlag(false);\n        if (b2) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.tryUpdateConnectorWithUpdateFlag.name}`);\n        }\n        const b3 = this.updateSurfaceWithUpdateFlag(false);\n        if (b3) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.updateSurfaceWithUpdateFlag.name}`);\n        }\n        const b4 = this.updateLocationWithUpdateFlag(false);\n        if (b4) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.updateLocationWithUpdateFlag.name}`);\n        }\n        return b1 || b2 || b3 || b4;\n    }\n    update() {\n        super.update();\n        const b2 = this.tryUpdateConnectorWithUpdateFlag(true);\n        const b3 = this.updateSurfaceWithUpdateFlag(true);\n        const b4 = this.updateLocationWithUpdateFlag(true);\n    }\n    /*\n    protected updateConnectorInfo() {\n        const oldBeginVertex = ZAbstractEdge.getConnectedVertexFromDic(this, true);\n        const oldEndVertex = ZAbstractEdge.getConnectedVertexFromDic(this, false);\n        if (this.beginVertex != oldBeginVertex) {\n            if (oldBeginVertex != null) {\n\n                this.removeVertexEvent(oldBeginVertex);\n                if (oldBeginVertex.outcomingEdges.indexOf(this) != -1) {\n                    oldBeginVertex.removeOutcomingEdge(this);\n                }\n            }\n\n            if (this.beginVertex != null) {\n                this.addVertexEvent(this.beginVertex);\n                if (this.beginVertex.outcomingEdges.indexOf(this) == -1) {\n                    this.beginVertex.insertOutcomingEdge(this);\n                }\n            }\n            ZAbstractEdge.setConnectedVertexFromDic(this, true);\n        }\n        if (this.endVertex != oldEndVertex) {\n            if (oldEndVertex != null) {\n                this.removeVertexEvent(oldEndVertex);\n                if (oldEndVertex.incomingEdges.indexOf(this) != -1) {\n                    oldEndVertex.removeIncomingEdge(this);\n                }\n            }\n\n            if (this.endVertex != null) {\n                this.addVertexEvent(this.endVertex);\n                if (this.endVertex.incomingEdges.indexOf(this) == -1) {\n                    this.endVertex.insertIncomingEdge(this);\n                }\n            }\n            ZAbstractEdge.setConnectedVertexFromDic(this, false);\n        }\n        //if(this.beginVertexID != )\n    }\n    */\n    get beginConnectoPosition() {\n        const [cx1, cy1] = this.beginVertex != null ? [this.beginVertex.cx, this.beginVertex.cy] : [this.x1, this.y1];\n        const [cx2, cy2] = this.endVertex != null ? [this.endVertex.cx, this.endVertex.cy] : [this.x2, this.y2];\n        const [x1, y1] = this.beginVertex != null ? this.beginVertex.getContactPosition(this.beginConnectorType, cx2, cy2) : [cx1, cy1];\n        return [x1, y1];\n    }\n    get endConnectorPosition() {\n        const [cx1, cy1] = this.beginVertex != null ? [this.beginVertex.cx, this.beginVertex.cy] : [this.x1, this.y1];\n        const [cx2, cy2] = this.endVertex != null ? [this.endVertex.cx, this.endVertex.cy] : [this.x2, this.y2];\n        const [x2, y2] = this.endVertex != null ? this.endVertex.getContactPosition(this.endConnectorType, cx1, cy1) : [cx2, cy2];\n        return [x2, y2];\n    }\n    elbowCalculator(x1, y1, type1, x2, y2, type2, recursion = 0) {\n        if (recursion > 6) {\n            return [];\n        }\n        const xgap = Math.abs(x2 - x1) / 2;\n        const ygap = Math.abs(y2 - y1) / 2;\n        const gap = 30;\n        let area = \"leftup\";\n        if (x1 < x2) {\n            if (y1 < y2) {\n                area = \"rightdown\";\n            }\n            else {\n                area = \"rightup\";\n            }\n        }\n        else {\n            if (y1 < y2) {\n                area = \"leftdown\";\n            }\n            else {\n                area = \"leftup\";\n            }\n        }\n        const right = area == \"rightdown\" || area == \"rightup\";\n        const left = area == \"leftdown\" || area == \"leftup\";\n        const up = area == \"rightup\" || area == \"leftup\";\n        const down = area == \"rightdown\" || area == \"leftdown\";\n        if (type1 == enums_1.ConnectorType.Bottom) {\n            const x3 = x1;\n            const type3 = right ? enums_1.ConnectorType.Right : enums_1.ConnectorType.Left;\n            let y3 = 0;\n            if (type2 == enums_1.ConnectorType.Top) {\n                if (x1 == x2 && down) {\n                    return [];\n                }\n                else {\n                    y3 = y1 + ygap;\n                }\n            }\n            else if (type2 == enums_1.ConnectorType.Left) {\n                y3 = (area == \"rightdown\") ? y2 : y1 + gap;\n            }\n            else if (type2 == enums_1.ConnectorType.Right) {\n                y3 = (area == \"leftdown\") ? y2 : y1 + ygap;\n            }\n            else {\n                y3 = down ? y2 + gap : y1 + gap;\n            }\n            const arr = this.elbowCalculator(x3, y3, type3, x2, y2, type2, recursion + 1);\n            arr.unshift([x3, y3]);\n            return arr;\n        }\n        else if (type1 == enums_1.ConnectorType.Right) {\n            const y3 = y1;\n            const type3 = up ? enums_1.ConnectorType.Top : enums_1.ConnectorType.Bottom;\n            let x3 = 0;\n            if (type2 == enums_1.ConnectorType.Top) {\n                x3 = area == \"rightdown\" ? x2 : x1 + gap;\n            }\n            else if (type2 == enums_1.ConnectorType.Bottom) {\n                x3 = area == \"rightup\" ? x2 : x1 + xgap;\n            }\n            else if (type2 == enums_1.ConnectorType.Left) {\n                if (y1 == y2 && right) {\n                    return [];\n                }\n                else {\n                    x3 = x1 + xgap;\n                }\n            }\n            else {\n                x3 = right ? x2 + gap : x1 + gap;\n            }\n            const arr = this.elbowCalculator(x3, y3, type3, x2, y2, type2, recursion + 1);\n            arr.unshift([x3, y3]);\n            return arr;\n        }\n        else if (type1 == enums_1.ConnectorType.Left) {\n            const y3 = y1;\n            const type3 = up ? enums_1.ConnectorType.Top : enums_1.ConnectorType.Bottom;\n            let x3 = 0;\n            if (type2 == enums_1.ConnectorType.Top) {\n                x3 = area == \"leftdown\" ? x2 : x1 - gap;\n            }\n            else if (type2 == enums_1.ConnectorType.Bottom) {\n                x3 = area == \"leftup\" ? x2 : x1 - gap;\n            }\n            else if (type2 == enums_1.ConnectorType.Right) {\n                if (y1 == y2 && left) {\n                    return [];\n                }\n                else {\n                    x3 = x1 - gap;\n                }\n            }\n            else {\n                x3 = right ? x1 - gap : x2 - gap;\n            }\n            const arr = this.elbowCalculator(x3, y3, type3, x2, y2, type2, recursion + 1);\n            arr.unshift([x3, y3]);\n            return arr;\n        }\n        else {\n            const x3 = x1;\n            const type3 = right ? enums_1.ConnectorType.Right : enums_1.ConnectorType.Left;\n            let y3 = 0;\n            if (type2 == enums_1.ConnectorType.Bottom) {\n                if (x1 == x2 && up) {\n                    return [];\n                }\n                else {\n                    y3 = y1 - gap;\n                }\n            }\n            else if (type2 == enums_1.ConnectorType.Left) {\n                y3 = (area == \"rightup\") ? y2 : y1 - gap;\n            }\n            else if (type2 == enums_1.ConnectorType.Right) {\n                y3 = (area == \"leftup\") ? y2 : y1 - gap;\n            }\n            else {\n                //y3 = up ? y2 + gap : y1 - gap;\n                y3 = y1 - gap;\n            }\n            const arr = this.elbowCalculator(x3, y3, type3, x2, y2, type2, recursion + 1);\n            arr.unshift([x3, y3]);\n            return arr;\n        }\n    }\n}\nexports.ZAbstractEdge = ZAbstractEdge;\nZAbstractEdge.markerCounter = 0;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_abstract_edge.ts?");

/***/ }),

/***/ "./src/objects/z_abstract_text_edge.ts":
/*!*********************************************!*\
  !*** ./src/objects/z_abstract_text_edge.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZAbstractTextEdge = void 0;\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst virtual_text_1 = __webpack_require__(/*! ../interfaces/virtual_text */ \"./src/interfaces/virtual_text.ts\");\nconst z_abstract_edge_1 = __webpack_require__(/*! ./z_abstract_edge */ \"./src/objects/z_abstract_edge.ts\");\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst element_builder_1 = __webpack_require__(/*! ./element_builder */ \"./src/objects/element_builder.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\nconst z_observer_1 = __webpack_require__(/*! ./z_observer */ \"./src/objects/z_observer.ts\");\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\nclass ZAbstractTextEdge extends z_abstract_edge_1.ZAbstractEdge {\n    createSurface(svgbox, option = {}) {\n        super.createSurface(svgbox, option);\n        this.svgGroup.insertBefore(this.svgPath, this.svgText);\n    }\n    constructor(svgbox) {\n        super(svgbox);\n        this._isSpecialTextBox = false;\n        this.textObserverFunc = (x) => {\n            if (!this.isShown)\n                return;\n            if (!this.isLocated)\n                return;\n            let b = false;\n            for (let i = 0; i < x.length; i++) {\n                const p = x[i];\n                if (ZAbstractTextEdge.updateTextAttributes.some((v) => v == p.attributeName)) {\n                    b = true;\n                }\n                if (p.attributeName == null) {\n                    b = true;\n                }\n            }\n            if (b) {\n                //this.resetUnstableCounter();\n                //this.update();\n            }\n        };\n        this._svgText = (0, element_builder_1.createSVGText)(DefaultClassNames.defaultTextClass, undefined, \"text\");\n        this.svgGroup.appendChild(this.svgText);\n        this._textObserver = new MutationObserver(this.textObserverFunc);\n        const option2 = { childList: true, attributes: true, subtree: true };\n        this._textObserver.observe(this.svgText, option2);\n        this._isSpecialTextBox = true;\n        this.svgText.textContent = \"\";\n        this._svgTextPath = SVG.createTextPath2(undefined);\n        this.svgText.appendChild(this._svgTextPath);\n        this._svgTextPath.href.baseVal = `#${this.svgPath.id}`;\n        //if (this.type == ShapeObjectType.Edge) this.firstFunctionAfterInitialized();\n        //this.setAppropriateText();\n    }\n    get svgText() {\n        return this._svgText;\n    }\n    get svgTextPath() {\n        return this._svgTextPath;\n    }\n    get childrenStableFlag() {\n        const b1 = this.svgPath.getAttribute(z_observer_1.ObjectStableFlagName);\n        const b2 = this.svgText.getAttribute(z_observer_1.ObjectStableFlagName);\n        return b1 == \"true\" && b2 == \"true\";\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        z_textbox_1.ZTextBox.importTextFromSource(this.svgTextPath, null, source);\n        if (this.svgText != null) {\n            z_object_1.ZObject.setSubAttributes(this.svgText, source);\n        }\n    }\n    get readableTextFlag() {\n        const p = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.readableText);\n        if (p == \"true\") {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    set readableTextFlag(value) {\n        if (value) {\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.beginConnectorType, \"true\");\n        }\n        else {\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.beginConnectorType, \"false\");\n        }\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZAbstractTextEdgeAttributes) {\n\n        super.setBasicOption(option);\n        const textClass = CSS.createCSSClass(option.textClass);\n        const styleClass = CSS.createCSSClass(option.textStyle);\n        GOptions.setClassAndStyle(this.svgText, textClass, styleClass);\n        if (option.textClass === undefined) option.textClass = DefaultClassNames.defaultTextClass;\n\n        if (typeof option.text == \"string\") {\n            Extensions.setTextContent(this.svgTextPath, option.text);\n        } else if (Array.isArray(option.text)) {\n            SVGTextBox.constructSVGTextByHTMLElements(this.svgTextPath, option.text, false);\n\n        } else {\n\n        }\n    }\n    */\n    /*\n     static constructAttributes(e: Element, removeAttributes: boolean = false, output: GOptions.ZAbstractTextEdgeAttributes = {}): GOptions.ZAbstractTextEdgeAttributes {\n         ZAbstractEdge.constructAttributes(e, removeAttributes, output);\n         //output.isAutoSizeShapeToFitText = e.gtGetStyleBooleanWithUndefined(AttributeNames.Style.autoSizeShapeToFitText);\n         //const textChild = HTMLFunctions.getChildByNodeName(e, AttributeNames.textStyle);\n         output.textClass = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.textClass);\n         output.textStyle = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.textStyle);\n \n \n         if (e.children.length > 0) {\n             const tNodes = HTMLFunctions.getTNodes(e);\n             if (tNodes != null) {\n                 tNodes.forEach((v) => v.remove())\n                 output.text = tNodes;\n             }\n         } else if (e.innerHTML.length > 0) {\n             output.text = e.innerHTML;\n         }\n \n \n         if (removeAttributes) {\n             //e.removeAttribute(AttributeNames.text);\n             e.removeAttribute(AttributeNames.textClass);\n             e.removeAttribute(AttributeNames.textStyle);\n \n             (<any>e).style.removeProperty(StyleNames.autoSizeShapeToFitText);\n         }\n         return output;\n     }\n     */\n    get startOffset() {\n        return ElementExtension.gtGetAttributeNumber(this.svgTextPath, \"startOffset\", null);\n    }\n    set startOffset(value) {\n        if (value == null) {\n            this.svgTextPath.removeAttribute(\"startOffset\");\n        }\n        else {\n            ElementExtension.setAttributeNumber(this.svgTextPath, \"startOffset\", value);\n        }\n    }\n    get isShown() {\n        const b1 = super.isShown;\n        const b2 = true;\n        const b3 = HTMLFunctions.isShow(this.svgText);\n        return b1 && b2 && b3;\n    }\n    removeTextLengthAttributeOrGetUpdateFlag(withUpdate) {\n        let b = false;\n        if (this.svgText.hasAttribute(\"textLength\")) {\n            b = true;\n            if (withUpdate) {\n                this.svgText.removeAttribute(\"textLength\");\n            }\n        }\n        if (this.svgTextPath.hasAttribute(\"textLength\")) {\n            b = true;\n            if (withUpdate) {\n                this.svgTextPath.removeAttribute(\"textLength\");\n            }\n        }\n        if (this.svgText.hasAttribute(\"letter-spacing\")) {\n            b = true;\n            if (withUpdate) {\n                this.svgText.removeAttribute(\"letter-spacing\");\n            }\n        }\n        return b;\n    }\n    setRegularIntervalOrGetUpdateFlag(newTextPathLen, newTextWidth, withUpdate) {\n        let b = false;\n        const svgTextTextLength = ElementExtension.gtGetAttributeNumber(this.svgText, \"textLength\", null);\n        const svgTextPathTextLength = ElementExtension.gtGetAttributeNumber(this.svgTextPath, \"textLength\", null);\n        const svgTextLetterSpacing = ElementExtension.gtGetAttributeNumber(this.svgText, \"letter-spacing\", null);\n        if (newTextPathLen != svgTextTextLength) {\n            b = true;\n            if (withUpdate) {\n                ElementExtension.setAttributeNumber(this.svgText, \"textLength\", newTextPathLen);\n            }\n        }\n        if (newTextPathLen != svgTextPathTextLength) {\n            b = true;\n            if (withUpdate) {\n                ElementExtension.setAttributeNumber(this.svgTextPath, \"textLength\", newTextPathLen);\n            }\n        }\n        if (svgTextLetterSpacing != null) {\n            b = true;\n            if (withUpdate) {\n                this.svgText.removeAttribute(\"letter-spacing\");\n            }\n        }\n        return b;\n    }\n    /*\n    private removeTextLengthAttribute(): void {\n        if (this.svgText.hasAttribute(\"textLength\")) this.svgText.removeAttribute(\"textLength\");\n        if (this.svgTextPath.hasAttribute(\"textLength\")) this.svgTextPath.removeAttribute(\"textLength\");\n        if (this.svgText.hasAttribute(\"letter-spacing\")) this.svgText.removeAttribute(\"letter-spacing\");\n    }\n    private setRegularInterval(textPathLen: number, textWidth : number): void {\n        this.removeTextLengthAttribute();\n        ElementExtension.setAttributeNumber(this.svgText, \"textLength\", textPathLen);\n        ElementExtension.setAttributeNumber(this.svgTextPath, \"textLength\", textPathLen);\n    }\n    */\n    get isAppropriatelyReverseMode() {\n        const p = this.svgGroup.getAttribute(AttributeNames.isAppropriatelyReverseTextMode);\n        if (p == null) {\n            return false;\n        }\n        else {\n            return p == \"true\";\n        }\n        //return this.svgGroup.getAttribute(AttributeNames.appropriateEdgeText);\n    }\n    set isAppropriatelyReverseMode(v) {\n        this.svgGroup.setAttribute(AttributeNames.isAppropriatelyReverseTextMode, v.toString());\n    }\n    get side() {\n        return this.svgTextPath.getAttribute(\"side\");\n    }\n    set side(v) {\n        if (v == null) {\n            this.svgTextPath.removeAttribute(\"side\");\n        }\n        else {\n            this.svgTextPath.setAttribute(\"side\", v);\n        }\n    }\n    revTextForApp() {\n        if (this.side == \"left\" || this.side == null) {\n            this.side = \"right\";\n        }\n        else {\n            this.side = \"left\";\n        }\n        const tspans = new Array(0);\n        this.svgTextPath.children.item;\n        for (let i = this.svgTextPath.children.length; i >= 0; i--) {\n            const tspan = this.svgTextPath.children.item(i);\n            if (tspan instanceof SVGTSpanElement) {\n                tspans.push(tspan);\n            }\n        }\n        tspans.forEach((v) => v.remove());\n        tspans.forEach((v) => {\n            const text = v.textContent;\n            if (text != null) {\n                const revText = ZAbstractTextEdge.getRevString(text);\n                v.textContent = revText;\n            }\n            this.svgTextPath.appendChild(v);\n        });\n    }\n    static getRevString(text) {\n        let s = \"\";\n        for (let i = text.length - 1; i >= 0; i--) {\n            s += text[i];\n        }\n        return s;\n    }\n    get svgElements() {\n        const r = [];\n        r.push(this.svgGroup);\n        r.push(this.svgText);\n        return r;\n    }\n    hasDescendant(obj) {\n        const ids = this.svgElements.map((v) => v.getAttribute(AttributeNames.objectIDName)).filter((v) => v != null);\n        const id = obj.getAttribute(AttributeNames.objectIDName);\n        return ids.some((v) => v == id);\n    }\n    isDrawnText() {\n        const text = this.svgTextPath.textContent;\n        if (text == null || text.length == 0) {\n            return true;\n        }\n        else {\n            const len = this.svgTextPath.getComputedTextLength();\n            return len != 0;\n        }\n    }\n    /**\n     * \n     */\n    update() {\n        super.update();\n        /*\n        this.updateConnectorInfoOrGetUpdateFlag(true);\n        this.updateSurfaceOrGetUpdateFlag(true);\n        this.updateLocationOrGetUpdateFlag(true);\n        */\n        this.tryUpdateTextPathWithUpdateFlag(true);\n    }\n    getUpdateFlag() {\n        const b1 = super.getUpdateFlag();\n        if (b1) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${super.getUpdateFlag.name}`);\n        }\n        const b2 = this.tryUpdateTextPathWithUpdateFlag(false);\n        if (b2) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.tryUpdateTextPathWithUpdateFlag.name}`);\n        }\n        return b1 || b2;\n    }\n    tryUpdateTextPathWithUpdateFlag(withUpdate) {\n        const b1 = this.tryUpdateDYWithUpdateFlag(withUpdate);\n        if (!withUpdate && b1) {\n            debugger_1.Debugger.updateFlagLog(this, this.tryUpdateTextPathWithUpdateFlag, `${this.tryUpdateDYWithUpdateFlag.name}`);\n        }\n        /*\n        if (this.isAppropriatelyReverseMode) {\n            const degree = this.degree;\n            if (degree < -90 || degree > 90) {\n                //Rev\n                if (this.side == \"left\" || this.side == null) {\n                    this.revTextForApp();\n                }\n            } else {\n                if (this.side == \"right\") {\n                    this.revTextForApp();\n                }\n            }\n        }\n        */\n        /*\n        if (!HTMLFunctions.isShow(this.svgTextPath)) {\n            throw new Error();\n        }\n        */\n        const b2 = this.tryUpdatePathOffsetWithUpdateFlag(withUpdate);\n        if (!withUpdate && b2) {\n            debugger_1.Debugger.updateFlagLog(this, this.tryUpdateTextPathWithUpdateFlag, `${this.tryUpdatePathOffsetWithUpdateFlag.name}`);\n        }\n        const b3 = this.tryUpdateRotateAttributeWithUpdateFlag(withUpdate);\n        if (!withUpdate && b3) {\n            debugger_1.Debugger.updateFlagLog(this, this.tryUpdateTextPathWithUpdateFlag, `${this.tryUpdatePathOffsetWithUpdateFlag.name}`);\n        }\n        return b1 || b2 || b3;\n    }\n    tryUpdateRotateAttributeWithUpdateFlag(withUpdate) {\n        let b = false;\n        if (this.readableTextFlag) {\n            const rotateAttr = this.svgText.getAttribute(\"rotate\");\n            const oldRotate = rotateAttr == null ? 0 : parseInt(rotateAttr);\n            const degree = this.degree;\n            if (degree < -90 || degree > 90) {\n                if (oldRotate != 180) {\n                    b = true;\n                    if (withUpdate) {\n                        this.svgText.setAttribute(\"rotate\", \"180\");\n                    }\n                    else {\n                        debugger_1.Debugger.updateFlagLog(this, this.tryUpdateDYWithUpdateFlag, `oldRotate != newRotate`);\n                        return b;\n                    }\n                }\n            }\n            else {\n                if (oldRotate != 0) {\n                    b = true;\n                    if (withUpdate) {\n                        this.svgText.setAttribute(\"rotate\", \"0\");\n                    }\n                    else {\n                        debugger_1.Debugger.updateFlagLog(this, this.tryUpdateDYWithUpdateFlag, `oldRotate != newRotate`);\n                        return b;\n                    }\n                }\n            }\n        }\n        else {\n            if (this.svgText.hasAttribute(\"rotate\")) {\n                b = true;\n                if (withUpdate) {\n                    this.svgText.removeAttribute(\"rotate\");\n                }\n                else {\n                    debugger_1.Debugger.updateFlagLog(this, this.tryUpdateDYWithUpdateFlag, `oldRotate != newRotate`);\n                    return b;\n                }\n            }\n        }\n        return b;\n    }\n    tryUpdateDYWithUpdateFlag(withUpdate) {\n        let b = false;\n        const strokeWidth = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke-width\");\n        const oldDY = this.svgText.getAttribute(\"dy\");\n        let newDY = \"0\";\n        if (strokeWidth != null) {\n            const diffy = CommonFunctions.toPX(strokeWidth) + 3;\n            newDY = `-${diffy}`;\n        }\n        if (oldDY != newDY) {\n            b = true;\n            if (withUpdate) {\n                this.svgText.setAttribute(\"dy\", newDY);\n            }\n            else {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdateDYWithUpdateFlag, `oldDY != newDY`);\n                return b;\n            }\n        }\n        return b;\n    }\n    tryUpdatePathOffsetWithUpdateFlag(withUpdate) {\n        let b = false;\n        const region = (0, virtual_text_1.getVirtualRegion)(this.svgText);\n        const strWidth = (0, vline_1.round100)(region.width);\n        const pathLen = (0, vline_1.round100)(this.svgPath.getTotalLength());\n        if (this.pathTextAlignment == enums_1.PathTextAlighnment.regularInterval) {\n            const strCharCount = this.svgTextPath.textContent == null ? 0 : this.svgTextPath.textContent.length;\n            if (strWidth > 0) {\n                const paddingWidth = (0, vline_1.round100)(pathLen - strWidth);\n                if (strCharCount != 0) {\n                    const paddingUnit = (0, vline_1.round100)(paddingWidth / (strCharCount + 1));\n                    let textPathLen = (0, vline_1.round100)(pathLen - (paddingUnit * 2));\n                    if (textPathLen <= 0)\n                        textPathLen = 5;\n                    const _startOffset = this.startOffset;\n                    const xb = _startOffset == null || !(0, vline_1.nearlyEqual)(_startOffset, paddingUnit);\n                    if (xb) {\n                        b = true;\n                        if (withUpdate) {\n                            this.startOffset = paddingUnit;\n                        }\n                        else {\n                            debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, this.startOffset != paddingUnit`);\n                            return b;\n                        }\n                    }\n                    b = this.setRegularIntervalOrGetUpdateFlag(textPathLen, strWidth, withUpdate) || b;\n                    if (!withUpdate && b) {\n                        debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, ${this.setRegularIntervalOrGetUpdateFlag.name}`);\n                        return b;\n                    }\n                }\n            }\n        }\n        else if (this.pathTextAlignment == enums_1.PathTextAlighnment.end) {\n            b = this.removeTextLengthAttributeOrGetUpdateFlag(withUpdate);\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, ${this.removeTextLengthAttributeOrGetUpdateFlag.name}`);\n                return b;\n            }\n            const newStartOffset = (0, vline_1.round100)(this.side == \"right\" ? 0 : (pathLen - strWidth));\n            const _startOffset = this.startOffset;\n            const xb = _startOffset == null || !(0, vline_1.nearlyEqual)(_startOffset, newStartOffset);\n            if (xb) {\n                b = true;\n                if (withUpdate) {\n                    this.startOffset = newStartOffset;\n                }\n                else {\n                    debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, _startOffset == null || !nearlyEqual(_startOffset, newStartOffset)`);\n                    return b;\n                }\n            }\n        }\n        else if (this.pathTextAlignment == enums_1.PathTextAlighnment.center) {\n            b = this.removeTextLengthAttributeOrGetUpdateFlag(withUpdate);\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, ${this.removeTextLengthAttributeOrGetUpdateFlag.name}`);\n                return b;\n            }\n            const newStartOffset = (0, vline_1.round100)((pathLen / 2) - (strWidth / 2));\n            const _startOffset = this.startOffset;\n            const xb = _startOffset == null || !(0, vline_1.nearlyEqual)(_startOffset, newStartOffset);\n            if (xb) {\n                b = true;\n                if (withUpdate) {\n                    this.startOffset = newStartOffset;\n                }\n                else {\n                    debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, _startOffset == null || !nearlyEqual(_startOffset, newStartOffset)`);\n                    return b;\n                }\n            }\n            //Edge\n            //this.svgTextPath.startOffset.baseVal.value = (pathLen - box.width)/2;                    \n        }\n        else {\n            b = this.removeTextLengthAttributeOrGetUpdateFlag(withUpdate);\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, ${this.removeTextLengthAttributeOrGetUpdateFlag.name}`);\n                return b;\n            }\n            const newStartOffset = (0, vline_1.round100)(this.side == \"right\" ? (pathLen - strWidth) : 0);\n            const _startOffset = this.startOffset;\n            const xb = _startOffset == null || !(0, vline_1.nearlyEqual)(_startOffset, newStartOffset);\n            if (xb) {\n                b = true;\n                if (withUpdate) {\n                    this.startOffset = newStartOffset;\n                }\n                else {\n                    debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, _startOffset == null || !nearlyEqual(_startOffset, newStartOffset)`);\n                    return b;\n                }\n            }\n        }\n        return b;\n    }\n    updateSurfaceWithoutSVGText() {\n        this.update();\n        return true;\n    }\n}\nexports.ZAbstractTextEdge = ZAbstractTextEdge;\nZAbstractTextEdge.updateTextAttributes = [\"style\"];\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_abstract_text_edge.ts?");

/***/ }),

/***/ "./src/objects/z_arrow_callout.ts":
/*!****************************************!*\
  !*** ./src/objects/z_arrow_callout.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZArrowCallout = void 0;\n/// <reference path=\"z_path_textbox.ts\"/>\n//namespace GraphTableSVG {\nconst z_path_textbox_1 = __webpack_require__(/*! ./z_path_textbox */ \"./src/objects/z_path_textbox.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\n//import {ZTextBoxAttributes, ZObjectAttributes, ZCalloutAttributes, ZShapeArrowCalloutAttributes} from \"../options/attributes_option\"\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nclass ZArrowCallout extends z_path_textbox_1.ZPathTextBox {\n    constructor(svgbox) {\n        super(svgbox);\n        //this.height = 100;\n        //this.width = 100;\n        this.arrowNeckWidth = 10;\n        this.arrowNeckHeight = 10;\n        this.arrowHeadWidth = 20;\n        this.arrowHeadHeight = 20;\n        this.svgGroup.setAttribute(\"data-direction\", \"down\");\n        this.updateAttributes.push(\"data-direction\");\n        if (this.type == enums_1.ShapeObjectType.ArrowCallout)\n            this.firstFunctionAfterInitialized();\n    }\n    /*\n    static constructAttributes(e: Element, removeAttributes: boolean = false, output: ZShapeArrowCalloutAttributes = {}): ZShapeArrowCalloutAttributes {\n        ZTextBox.constructAttributes(e, removeAttributes, output);\n        output.arrowNeckWidth = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.arrowNeckWidth);\n        output.arrowNeckHeight = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.arrowNeckHeight);\n        output.arrowHeadWidth = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.arrowHeadWidth);\n        output.arrowHeadHeight = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.arrowNeckHeight);\n        const p = <string>ElementExtension.gtGetAttributeStringWithUndefined(e, AttributeNames.direction);\n        if (p !== undefined) {\n            output.direction = Direction.toDirection(p);\n        }\n\n        if (removeAttributes) {\n            e.removeAttribute(AttributeNames.arrowNeckWidth);\n            e.removeAttribute(AttributeNames.arrowNeckHeight);\n            e.removeAttribute(AttributeNames.arrowHeadWidth);\n            e.removeAttribute(AttributeNames.arrowHeadHeight);\n            e.removeAttribute(AttributeNames.direction);\n        }\n\n        return output;\n    }\n    */\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        const _arrowNeckWidth = ElementExtension._getAttributeNumber(source, AttributeNames.arrowNeckWidth, true);\n        const _arrowNeckHeight = ElementExtension._getAttributeNumber(source, AttributeNames.arrowNeckHeight, true);\n        const _arrowHeadWidth = ElementExtension._getAttributeNumber(source, AttributeNames.arrowHeadWidth, true);\n        const _arrowHeadHeight = ElementExtension._getAttributeNumber(source, AttributeNames.arrowNeckHeight, true);\n        const _direction = ElementExtension._getAttribute(source, AttributeNames.direction, true);\n        this.arrowNeckWidth = _arrowNeckWidth !== null ? _arrowNeckWidth : this.arrowNeckWidth;\n        this.arrowNeckHeight = _arrowNeckHeight !== null ? _arrowNeckHeight : this.arrowNeckHeight;\n        this.arrowHeadWidth = _arrowHeadWidth !== null ? _arrowHeadWidth : this.arrowHeadWidth;\n        this.arrowHeadHeight = _arrowHeadHeight !== null ? _arrowHeadHeight : this.arrowHeadHeight;\n        this.direction = _direction !== null ? enums_1.Direction.toDirection(_direction) : this.direction;\n    }\n    /*\n    protected setBasicOption(option: ZShapeArrowCalloutAttributes) {\n        super.setBasicOption(option);\n    }\n    public setOption(option: ZShapeArrowCalloutAttributes) {\n        super.setOption(option)\n    }\n    */\n    /*\n    static openCustomElement(e: SVGElement): ShapeArrowCallout {\n        const parent = e.parentElement;\n        if (parent instanceof SVGSVGElement) {\n            const option = ShapeArrowCallout.constructAttributes(e, true);\n            const attrs = e.gtGetAttributes();\n            const r = new ShapeArrowCallout(parent, option);\n            e.remove();\n            attrs.forEach((v) => r.svgGroup.setAttribute(v.name, v.value));\n            return r;\n        } else {\n            throw Error(\"error!\");\n        }\n    }\n    */\n    get type() {\n        return enums_1.ShapeObjectType.ArrowCallout;\n    }\n    get arrowNeckWidth() {\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-neck-width\", 0);\n    }\n    set arrowNeckWidth(value) {\n        if (this.arrowNeckWidth != value)\n            this.svgGroup.setAttribute(\"data-arrow-neck-width\", value.toString());\n    }\n    get arrowNeckHeight() {\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-neck-height\", 0);\n    }\n    set arrowNeckHeight(value) {\n        if (this.arrowNeckHeight != value)\n            this.svgGroup.setAttribute(\"data-arrow-neck-height\", value.toString());\n    }\n    get arrowHeadWidth() {\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-head-width\", 0);\n    }\n    set arrowHeadWidth(value) {\n        if (this.arrowHeadWidth != value)\n            this.svgGroup.setAttribute(\"data-arrow-head-width\", value.toString());\n    }\n    get arrowHeadHeight() {\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-head-height\", 0);\n    }\n    set arrowHeadHeight(value) {\n        if (this.arrowHeadHeight != value)\n            this.svgGroup.setAttribute(\"data-arrow-head-height\", value.toString());\n    }\n    get direction() {\n        const r = this.svgGroup.getAttribute(\"data-direction\");\n        return enums_1.Direction.toDirection(r);\n    }\n    set direction(value) {\n        if (this.direction != value) {\n            this.svgGroup.setAttribute(\"data-direction\", value.toString());\n        }\n    }\n    get topExtraLength() {\n        if (this.direction == \"up\") {\n            return this.arrowHeadHeight + this.arrowNeckHeight + this.marginPaddingTop;\n        }\n        else {\n            return this.marginPaddingTop;\n        }\n    }\n    get leftExtraLength() {\n        if (this.direction == \"left\") {\n            return this.arrowHeadHeight + this.arrowNeckHeight + this.marginPaddingLeft;\n        }\n        else {\n            return this.marginPaddingLeft;\n        }\n    }\n    get rightExtraLength() {\n        if (this.direction == \"right\") {\n            return this.arrowHeadHeight + this.arrowNeckHeight + this.marginPaddingRight;\n        }\n        else {\n            return this.marginPaddingRight;\n        }\n    }\n    get bottomExtraLength() {\n        if (this.direction == \"down\") {\n            return this.arrowHeadHeight + this.arrowNeckHeight + this.marginPaddingBottom;\n        }\n        else {\n            return this.marginPaddingBottom;\n        }\n    }\n    /*\n    get innerRectangle(): Rectangle {\n        const rect = new Rectangle();\n        if (this.isAutoSizeShapeToFitText == AutoSizeShapeToFitText.Auto) {\n            \n            const textRect = SVGTextExtensions.getSize(this.svgText);\n            //const b = this.svgText.getBBox();\n            rect.width = textRect.width;\n            rect.height = textRect.height;\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\n        } else {\n            rect.width = this.boxWidth - this.marginPaddingLeft;\n            rect.height = this.boxHeight - this.marginPaddingTop;\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\n        }\n        if (this.direction == \"up\") rect.y += this.arrowNeckHeight + this.arrowHeadHeight;\n        if (this.direction == \"left\") rect.x += this.arrowNeckHeight + this.arrowHeadHeight;\n        return rect;\n    }\n    */\n    /**\n     * \n     */\n    get boxHeight() {\n        if (this.direction == \"up\" || this.direction == \"down\") {\n            return this.height - this.arrowNeckHeight - this.arrowHeadWidth;\n        }\n        else {\n            return this.height;\n        }\n    }\n    get boxWidth() {\n        if (this.direction == \"up\" || this.direction == \"down\") {\n            return this.width;\n        }\n        else {\n            return this.width - this.arrowNeckHeight - this.arrowHeadWidth;\n        }\n    }\n    /*\n    protected updateToFitText() {\n\n        const textRect = SVGTextExtensions.getSize(this.svgText);\n        //const box = this.svgText.getBBox();\n        if (this.direction == \"up\" || this.direction == \"down\") {\n            this.width = textRect.width + this.marginPaddingLeft + this.marginPaddingRight;\n            this.height = textRect.height + this.marginPaddingTop + this.marginPaddingBottom + this.arrowNeckHeight + this.arrowHeadHeight;\n        } else {\n            this.width = textRect.width + this.marginPaddingLeft + this.marginPaddingRight + this.arrowNeckHeight + this.arrowHeadHeight;\n            this.height = textRect.height + this.marginPaddingTop + this.marginPaddingBottom;\n        }\n    }\n    */\n    /*\n     public getVirtualRegion(): Rectangle {\n         const textRect = SVGTextExtension.getVirtualRegion(this.svgText);\n         let _w = 0;\n         let _h = 0;\n         if (this.direction == \"up\" || this.direction == \"down\") {\n             _w = textRect.width + this.marginPaddingLeft + this.marginPaddingRight;\n             _h = textRect.height + this.marginPaddingTop + this.marginPaddingBottom + this.arrowNeckHeight + this.arrowHeadHeight;\n         } else {\n             _w = textRect.width + this.marginPaddingLeft + this.marginPaddingRight + this.arrowNeckHeight + this.arrowHeadHeight;\n             _h = textRect.height + this.marginPaddingTop + this.marginPaddingBottom;\n         }\n\n         if (this.isAutoSizeShapeToFitText == AutoSizeShapeToFitText.Auto) {\n \n\n             const textWidth = _w < this._minimumWidth ? this._minimumWidth : _w;\n             const textHeight = _h < this._minimumHeight ? this._minimumHeight : _h;\n             const width = _w;\n             const height = _h;\n \n             return new Rectangle(this.cx - (width / 2), this.cy - (height / 2), width, height);\n \n         } else if (this.isAutoSizeShapeToFitText == AutoSizeShapeToFitText.SemiAuto) {\n             const newWidth = this.width < _w ? _w : this.width;\n             const newHeigth = this.height < _h ? _h : this.height;\n             return new Rectangle(this.cx - (newWidth / 2), this.cy - (newHeigth / 2), newWidth, newHeigth);\n         } else {\n \n             return new Rectangle(this.cx - (this.width / 2), this.cy - (this.height / 2), this.width, this.height);\n \n             //return new Rectangle(this.x, this.y, this.width, this.height);\n         }\n     }\n     */\n    update() {\n        super.update();\n        const region = this.getVirtualRegion();\n        const x1 = region.x;\n        const y1 = region.y;\n        const x2 = region.right;\n        const y2 = region.bottom;\n        if (this.direction == \"up\") {\n            const bx1 = x1;\n            const by1 = y1 + this.arrowHeadHeight + this.arrowNeckHeight;\n            const bx2 = x2;\n            const by2 = y2;\n            let nx1 = -(this.arrowNeckWidth / 2);\n            let nx2 = (this.arrowNeckWidth / 2);\n            let ny = by1 - this.arrowNeckHeight;\n            let cx = 0;\n            let hx1 = -(this.arrowHeadWidth / 2);\n            let hx2 = (this.arrowHeadWidth / 2);\n            let hy = y1;\n            const mes = (0, vline_1.escapeWithRound100) `H ${nx1} V ${ny} H ${hx1} L ${cx} ${hy} L ${hx2} ${ny} H ${nx2} V ${by1}`;\n            const top = (0, vline_1.escapeWithRound100) `M ${bx1} ${by1} ${mes} H ${bx2}`;\n            const right = (0, vline_1.escapeWithRound100) `V ${by2}`;\n            const bottom = (0, vline_1.escapeWithRound100) `H ${bx1}`;\n            const left = (0, vline_1.escapeWithRound100) `V ${by1}`;\n            this.svgPath.setAttribute(\"d\", (0, vline_1.escapeWithRound100) `${top} ${right} ${bottom} ${left} z`);\n        }\n        else if (this.direction == \"left\") {\n            const bx1 = x1 + this.arrowHeadHeight + this.arrowNeckHeight;\n            const by1 = y1;\n            const bx2 = x2;\n            const by2 = y2;\n            let ny1 = 0 + (this.arrowNeckWidth / 2);\n            let ny2 = 0 - (this.arrowNeckWidth / 2);\n            let nx = bx1 - this.arrowNeckHeight;\n            let cy = 0;\n            let hy1 = 0 + (this.arrowHeadWidth / 2);\n            let hy2 = 0 - (this.arrowHeadWidth / 2);\n            let hx = x1;\n            const top = (0, vline_1.escapeWithRound100) `M ${bx1} ${by1} H ${bx2}`;\n            const right = (0, vline_1.escapeWithRound100) `V ${by2}`;\n            const bottom = (0, vline_1.escapeWithRound100) `H ${bx1}`;\n            const left = (0, vline_1.escapeWithRound100) `V ${ny1} H ${nx} V ${hy1} L ${hx} ${cy} L ${nx} ${hy2} V ${ny2} H ${bx1} V ${by1}`;\n            this.svgPath.setAttribute(\"d\", (0, vline_1.escapeWithRound100) `${top} ${right} ${bottom} ${left} z`);\n        }\n        else if (this.direction == \"right\") {\n            const bx1 = x1;\n            const by1 = y1;\n            const bx2 = x2 - this.arrowNeckHeight - this.arrowHeadHeight;\n            const by2 = y2;\n            let ny1 = 0 - (this.arrowNeckWidth / 2);\n            let ny2 = 0 + (this.arrowNeckWidth / 2);\n            let nx = bx2 + this.arrowNeckHeight;\n            let cy = 0;\n            let hy1 = 0 - (this.arrowHeadWidth / 2);\n            let hy2 = 0 + (this.arrowHeadWidth / 2);\n            let hx = x2;\n            const top = (0, vline_1.escapeWithRound100) `M ${bx1} ${by1} H ${bx2}`;\n            const right = (0, vline_1.escapeWithRound100) `V ${ny1} H ${nx} V ${hy1} L ${hx} ${cy} L ${nx} ${hy2} V ${ny2} H ${bx2} V ${by2}`;\n            const bottom = (0, vline_1.escapeWithRound100) `H ${bx1}`;\n            const left = (0, vline_1.escapeWithRound100) `V ${by1}`;\n            this.svgPath.setAttribute(\"d\", (0, vline_1.escapeWithRound100) `${top} ${right} ${bottom} ${left} z`);\n        }\n        else {\n            const bx1 = x1;\n            const by1 = y1;\n            const bx2 = x2;\n            const by2 = y2 - this.arrowHeadHeight - this.arrowNeckHeight;\n            //const by = boxHeight + dy;\n            let nx1 = -(this.arrowNeckWidth / 2);\n            let nx2 = (this.arrowNeckWidth / 2);\n            let ny = by2 + this.arrowNeckHeight;\n            let cx = 0;\n            let hx1 = -(this.arrowHeadWidth / 2);\n            let hx2 = (this.arrowHeadWidth / 2);\n            let hy = y2;\n            const top = (0, vline_1.escapeWithRound100) `M ${bx1} ${by1} H ${bx2}`;\n            const right = (0, vline_1.escapeWithRound100) `V ${by2}`;\n            const bottom = (0, vline_1.escapeWithRound100) `H ${nx2} V ${ny} H ${hx2} L ${cx} ${hy} L ${hx1} ${ny} H ${nx1} V ${by2} H ${bx1}`;\n            const left = (0, vline_1.escapeWithRound100) `V ${by1}`;\n            this.svgPath.setAttribute(\"d\", (0, vline_1.escapeWithRound100) `${top} ${right} ${bottom} ${left} z`);\n        }\n    }\n    get shape() {\n        switch (this.direction) {\n            case \"up\": return enums_1.VBAShapeType.UpArrowCallout;\n            case \"left\": return enums_1.VBAShapeType.LeftArrowCallout;\n            case \"right\": return enums_1.VBAShapeType.RightArrowCallout;\n            case \"down\": return enums_1.VBAShapeType.DownArrowCallout;\n        }\n        return enums_1.VBAShapeType.DownArrowCallout;\n    }\n    /**\n     * VBAShapeVBAAdjustments\n     * \n     * \n     * @returns VBAAdjustments\n     */\n    get VBAAdjustments() {\n        if (this.direction == \"up\") {\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\n            const headHeightRatio = this.arrowHeadHeight / this.height;\n            const boxHeightRatio = this.boxHeight / this.height;\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxHeightRatio];\n        }\n        else if (this.direction == \"right\") {\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\n            const headHeightRatio = this.arrowHeadHeight / this.height;\n            const boxWidthRatio = this.boxWidth / this.width;\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxWidthRatio];\n        }\n        else if (this.direction == \"left\") {\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\n            const headHeightRatio = this.arrowHeadHeight / this.height;\n            const boxWidthRatio = this.boxWidth / this.width;\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxWidthRatio];\n        }\n        else {\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\n            const headHeightRatio = this.arrowHeadHeight / this.height;\n            const boxHeightRatio = this.boxHeight / this.height;\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxHeightRatio];\n        }\n    }\n    /**\n             * \n             * @param type\n             * @param x\n             * @param y\n             */\n    getContactPosition(type, x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        switch (type) {\n            case enums_1.ConnectorType.Top:\n                return [this.x, this.y - hr];\n            case enums_1.ConnectorType.TopRight:\n            case enums_1.ConnectorType.Right:\n            case enums_1.ConnectorType.BottomRight:\n                return [this.x + wr, this.y];\n            case enums_1.ConnectorType.Bottom:\n                return [this.x, this.y + hr];\n            case enums_1.ConnectorType.BottomLeft:\n            case enums_1.ConnectorType.Left:\n            case enums_1.ConnectorType.TopLeft:\n                return [this.x - wr, this.y];\n            default:\n                const autoType = this.getContactAutoPosition(x, y);\n                return this.getContactPosition(autoType, x, y);\n        }\n    }\n    getContactAutoPosition(x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        const line1 = new vline_1.VLine(this.x, this.y, this.x + wr, this.y + hr);\n        const line2 = new vline_1.VLine(this.x, this.y, this.x + wr, this.y - hr);\n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n        if (b1) {\n            if (b2) {\n                return enums_1.ConnectorType.Top;\n            }\n            else {\n                return enums_1.ConnectorType.Right;\n            }\n        }\n        else {\n            if (b2) {\n                return enums_1.ConnectorType.Left;\n            }\n            else {\n                return enums_1.ConnectorType.Bottom;\n            }\n        }\n    }\n}\nexports.ZArrowCallout = ZArrowCallout;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_arrow_callout.ts?");

/***/ }),

/***/ "./src/objects/z_callout.ts":
/*!**********************************!*\
  !*** ./src/objects/z_callout.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZCallout = void 0;\nconst z_path_textbox_1 = __webpack_require__(/*! ./z_path_textbox */ \"./src/objects/z_path_textbox.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common/index.ts\");\nclass ZCallout extends z_path_textbox_1.ZPathTextBox {\n    constructor(svgbox) {\n        super(svgbox);\n        //const defaultSX = this.cx - 100 : this.fixedX - 50;\n        //const defaultSY = this.fixedY == null ? this.cy - 100 : this.fixedY - 50;\n        // const defaultSX = this.fixedX == null ? this.cx - 100 : this.fixedX - 50;\n        //const defaultSY = this.fixedY == null ? this.cy - 100 : this.fixedY - 50;\n        /*\n        */\n        if (this.type == enums_1.ShapeObjectType.Callout)\n            this.firstFunctionAfterInitialized();\n    }\n    /*\n    protected setBasicOption(option: ZCalloutAttributes) {\n        super.setBasicOption(option);\n        this.speakerX = option.speakerX == undefined ? 0 : option.speakerX;\n        this.speakerY = option.speakerY == undefined ? 0 : option.speakerY;\n\n    }\n    public setOption(option: ZCalloutAttributes) {\n        super.setOption(option)\n    }\n    */\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        const _speakerX = ElementExtension._getAttributeNumber(source, common_1.AttributeNames.speakerX, true);\n        const _speakerY = ElementExtension._getAttributeNumber(source, common_1.AttributeNames.speakerY, true);\n        this.speakerX = _speakerX == null ? 0 : _speakerX;\n        this.speakerY = _speakerY == null ? 0 : _speakerY;\n    }\n    /*\n    static constructAttributes(e: Element, removeAttributes: boolean = false, output: ZCalloutAttributes = {}): ZCalloutAttributes {\n        ZTextBox.constructAttributes(e, removeAttributes, output);\n\n\n        if (e.hasAttribute(AttributeNames.speakerX)) output.speakerX = ElementExtension.gtGetAttributeNumber(e, AttributeNames.speakerX, 0)!;\n        if (e.hasAttribute(AttributeNames.speakerY)) output.speakerY = ElementExtension.gtGetAttributeNumber(e, AttributeNames.speakerY, 0)!;\n\n        if (removeAttributes) {\n            e.removeAttribute(AttributeNames.speakerX);\n            e.removeAttribute(AttributeNames.speakerY);\n        }\n\n        return output;\n    }\n    */\n    /*\n    static openCustomElement(e: SVGElement): ZCallout {\n        const parent = e.parentElement;\n        if (parent instanceof SVGSVGElement) {\n            const option = ZCallout.constructAttributes(e,true);\n            const attrs = e.gtGetAttributes();\n\n            const r = new ZCallout(parent, option);\n            attrs.forEach((v)=>r.svgGroup.setAttribute(v.name, v.value));\n            e.remove();\n            return r;\n        } else {\n            throw Error(\"error!\");\n        }\n    }\n    */\n    get type() {\n        return enums_1.ShapeObjectType.Callout;\n    }\n    updateSurfaceSize() {\n        const region = this.getVirtualRegion();\n        if (this.width != region.width) {\n            this.width = region.width;\n        }\n        if (this.height != region.height) {\n            this.height = region.height;\n        }\n        return false;\n    }\n    update() {\n        super.update();\n        const x1 = -(this.width / 2);\n        const y1 = -(this.height / 2);\n        const x2 = (this.width / 2);\n        const y2 = (this.height / 2);\n        const speakerDiffX = this.speakerX - this.cx;\n        const speakerDiffY = this.speakerY - this.cy;\n        let px1 = 0, px2 = 0, py1 = 0, py2 = 0;\n        let mes = \"\";\n        switch (this.speakerPosition) {\n            case \"upleft\":\n                px1 = (x1 / 3) * 2;\n                px2 = (x1 / 3) * 1;\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y1}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} ${mes} H ${x2} V ${y2} H ${x1} V ${y1} z`);\n                break;\n            case \"upright\":\n                px1 = (x2 / 3) * 1;\n                px2 = (x2 / 3) * 2;\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y1}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} ${mes} H ${x2} V ${y2} H ${x1} V ${y1} z`);\n                break;\n            case \"rightup\":\n                py1 = (y1 / 3) * 2;\n                py2 = (y1 / 3) * 1;\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x2} ${py2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} ${mes} V ${y2} H ${x1} V ${y1} z`);\n                break;\n            case \"rightdown\":\n                py1 = (y2 / 3) * 1;\n                py2 = (y2 / 3) * 2;\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x2} ${py2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} ${mes} V ${y2} H ${x1} V ${y1} z`);\n                break;\n            case \"leftup\":\n                py1 = (y1 / 3) * 1;\n                py2 = (y1 / 3) * 2;\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x1} ${py2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} ${mes} V ${y1} z`);\n                break;\n            case \"leftdown\":\n                py1 = (y2 / 3) * 2;\n                py2 = (y2 / 3) * 1;\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x1} ${py2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} ${mes} V ${y1} z`);\n                break;\n            case \"downleft\":\n                px1 = (x1 / 3) * 1;\n                px2 = (x1 / 3) * 2;\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} ${mes} H ${x1} V ${y1} z`);\n                break;\n            case \"downright\":\n                px1 = (x2 / 3) * 2;\n                px2 = (x2 / 3) * 1;\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} ${mes} H ${x1} V ${y1} z`);\n                break;\n            default:\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} V ${y1} z`);\n                break;\n        }\n        //this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x1 + this.width} V ${y1 + this.height} H ${x1} V ${y1} z`);\n    }\n    get speakerX() {\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-speaker-x\", 0);\n    }\n    set speakerX(value) {\n        if (this.speakerX != value)\n            this.svgGroup.setAttribute(\"data-speaker-x\", value.toString());\n    }\n    get speakerY() {\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-speaker-y\", 0);\n    }\n    set speakerY(value) {\n        if (this.speakerY != value)\n            this.svgGroup.setAttribute(\"data-speaker-y\", value.toString());\n    }\n    get speakerPosition() {\n        const speakerDiffX = this.speakerX - this.cx;\n        const speakerDiffY = this.speakerY - this.cy;\n        const x1 = -(this.width / 2);\n        const y1 = -(this.height / 2);\n        const x2 = (this.width / 2);\n        const y2 = (this.height / 2);\n        if (x1 <= speakerDiffX && speakerDiffX <= x2 && y1 <= speakerDiffY && speakerDiffY <= y2) {\n            return \"inner\";\n        }\n        if (this.speakerX > this.cx) {\n            if (this.speakerY > this.cy) {\n                const line = new vline_1.VLine(0, 0, this.width, this.height);\n                if (line.contains(speakerDiffX, speakerDiffY)) {\n                    return \"rightdown\";\n                }\n                else {\n                    return \"downright\";\n                }\n            }\n            else {\n                const line = new vline_1.VLine(0, 0, this.width, -this.height);\n                if (line.contains(speakerDiffX, speakerDiffY)) {\n                    return \"upright\";\n                }\n                else {\n                    return \"rightup\";\n                }\n            }\n        }\n        else {\n            if (this.speakerY > this.cy) {\n                const line = new vline_1.VLine(0, 0, this.width, -this.height);\n                if (line.contains(speakerDiffX, speakerDiffY)) {\n                    return \"leftdown\";\n                }\n                else {\n                    return \"downleft\";\n                }\n            }\n            else {\n                const line = new vline_1.VLine(0, 0, this.width, this.height);\n                if (line.contains(speakerDiffX, speakerDiffY)) {\n                    return \"upleft\";\n                }\n                else {\n                    return \"leftup\";\n                }\n            }\n        }\n    }\n    get shape() {\n        return enums_1.VBAShapeType.Callout;\n    }\n    get VBAAdjustments() {\n        const y1 = this.speakerY - this.cy;\n        const py = y1 / this.height;\n        const x1 = this.speakerX - this.cx;\n        const px = x1 / this.width;\n        return [px, py];\n    }\n}\nexports.ZCallout = ZCallout;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_callout.ts?");

/***/ }),

/***/ "./src/objects/z_circle.ts":
/*!*********************************!*\
  !*** ./src/objects/z_circle.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZCircle = void 0;\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst z_ellipse_1 = __webpack_require__(/*! ./z_ellipse */ \"./src/objects/z_ellipse.ts\");\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nclass ZCircle extends z_ellipse_1.ZAbstractEllipseCircle {\n    get svgCircle() {\n        return this._svgSurface;\n    }\n    constructor(svgbox) {\n        super(svgbox);\n        if (this.type == enums_1.ShapeObjectType.Circle)\n            this.firstFunctionAfterInitialized();\n    }\n    createSurface(svgbox) {\n        //if(option.surfaceClass === undefined) option.surfaceClass = DefaultClassNames.defaultSurfaceClass;\n        this._svgSurface = ZCircle.createCircle(this.svgGroup, DefaultClassNames.defaultSurfaceClass, undefined);\n        this.svgGroup.insertBefore(this.svgCircle, this.svgText);\n    }\n    static createCircle(parent, className, style) {\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n        circle.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Surface);\n        parent.appendChild(circle);\n        GOptions.setClassAndStyle(circle, className, style);\n        /*\n        if(style !== undefined){\n            if(typeof(style) == \"string\"){\n                circle.setAttribute(\"style\", style);\n            }else{\n                circle.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\n            }\n\n        }\n        */\n        //if(style !== undefined) circle.setAttribute(\"style\", style);\n        circle.r.baseVal.value = AttributeNames.defaultCircleRadius;\n        //circle.setAttribute(\"class\", className);\n        /*\n        if(typeof(className) == \"string\"){\n            circle.setAttribute(\"class\", className);\n        }else{\n            circle.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\n        }\n        */\n        const radius = ElementExtension.getPropertyStyleNumberValue(circle, StyleNames.defaultRadius, null);\n        if (radius != null) {\n            circle.r.baseVal.value = radius;\n        }\n        circle.cx.baseVal.value = 0;\n        circle.cy.baseVal.value = 0;\n        return circle;\n    }\n    get rx() {\n        return this.svgCircle.r.baseVal.value;\n    }\n    get ry() {\n        return this.svgCircle.r.baseVal.value;\n    }\n    set width(value) {\n        const _rx = value / 2;\n        if (this.width != value)\n            this.svgCircle.setAttribute(\"r\", _rx.toString());\n    }\n    set height(value) {\n        const _ry = value / 2;\n        if (this.height != value)\n            this.svgCircle.setAttribute(\"r\", _ry.toString());\n    }\n    get width() {\n        return this.svgCircle.r.baseVal.value * 2;\n    }\n    get height() {\n        return this.svgCircle.r.baseVal.value * 2;\n    }\n    get type() {\n        return enums_1.ShapeObjectType.Circle;\n    }\n    get shape() {\n        return enums_1.VBAShapeType.Oval;\n    }\n}\nexports.ZCircle = ZCircle;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_circle.ts?");

/***/ }),

/***/ "./src/objects/z_edge.ts":
/*!*******************************!*\
  !*** ./src/objects/z_edge.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n//namespace GraphTableSVG {\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZEdge = void 0;\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./src/common/vba_functions.ts\");\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./src/html/enum_extension.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst z_abstract_text_edge_1 = __webpack_require__(/*! ./z_abstract_text_edge */ \"./src/objects/z_abstract_text_edge.ts\");\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common/index.ts\");\nconst html_1 = __webpack_require__(/*! ../html */ \"./src/html/index.ts\");\n/**\n * SVG\n */\nclass ZEdge extends z_abstract_text_edge_1.ZAbstractTextEdge {\n    //public tag: any;\n    constructor(svgbox) {\n        super(svgbox);\n        //private isFixTextSize: boolean = false;\n        this.surfaceAttributes = [];\n        this._minimumWidth = 10;\n        this._minimumHeight = 10;\n        this.VBAConnectorNumber = 1;\n        if (this.type == enums_1.ShapeObjectType.Edge)\n            this.firstFunctionAfterInitialized();\n        //this.setAppropriateText();\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        const x3 = ElementExtension._getAttributeNumber(source, common_1.AttributeNames.x3, true);\n        const y3 = ElementExtension._getAttributeNumber(source, common_1.AttributeNames.y3, true);\n        if (x3 != null && y3 != null) {\n            this.controlPoint = [[x3, y3]];\n        }\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZEdgeAttributes) {\n        super.setBasicOption(option);\n\n        if (option.x3 !== undefined && option.y3 !== undefined) {\n            this.controlPoint = [[option.x3, option.y3]];\n        }\n    }\n    */\n    /*\n    static constructAttributes(e: Element, removeAttributes: boolean = false, output: GOptions.ZEdgeAttributes = {}): GOptions.ZEdgeAttributes {\n        ZAbstractTextEdge.constructAttributes(e, removeAttributes, output);\n\n        if (e.hasAttribute(AttributeNames.x3)) {\n            output.x3 = ElementExtension.gtGetAttributeNumberWithoutNull(e, AttributeNames.x3, 0);\n        }\n        if (e.hasAttribute(AttributeNames.y3)) {\n            output.y3 = ElementExtension.gtGetAttributeNumberWithoutNull(e, AttributeNames.y3, 0);\n        }\n\n\n        if (removeAttributes) {\n            e.removeAttribute(AttributeNames.x3);\n            e.removeAttribute(AttributeNames.y3);\n        }\n        return output;\n    }\n    */\n    get type() {\n        return enums_1.ShapeObjectType.Edge;\n    }\n    /**\n     * \n     */\n    get controlPoint() {\n        const r = this.pathPoints;\n        r.shift();\n        r.pop();\n        return r;\n    }\n    set controlPoint(value) {\n        const fst = [this.x1, this.y1];\n        const lst = [this.x2, this.y2];\n        value.unshift(fst);\n        value.push(lst);\n        this.pathPoints = value;\n    }\n    setIndexDictionaryForVBA(vertexDic, edgeDic) {\n        if (this.controlPoint.length == 0) {\n            edgeDic[this.objectID] = Object.keys(edgeDic).length;\n        }\n        else if (this.controlPoint.length > 0) {\n            //edgeDic[this.objectID] = Object.keys(edgeDic).length;\n            for (let i = 0; i < this.VBAConnectorNumber; i++) {\n                vertexDic[`${this.objectID}_${i}`] = Object.keys(vertexDic).length;\n            }\n            for (let i = 0; i <= this.VBAConnectorNumber; i++) {\n                edgeDic[`${this.objectID}_${i}`] = Object.keys(edgeDic).length;\n            }\n        }\n    }\n    get shape() {\n        return \"msoConnectorStraight\";\n    }\n    createVBACode(id) {\n        const lineArr = [];\n        const r = [];\n        r.push(`Sub create${id}(createdSlide As slide)`);\n        r.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n        r.push(` Dim obj As Shape`);\n        if (this.controlPoint.length == 0 || this.edgeType == \"elbow\") {\n            if (this.edgeType == \"elbow\") {\n                r.push(` Set obj = shapes_.AddConnector(msoConnectorElbow, ${this.x1}, ${this.y1}, ${this.x2}, ${this.y2})`);\n            }\n            else {\n                r.push(` Set obj = shapes_.AddConnector(msoConnectorStraight, ${this.x1}, ${this.y1}, ${this.x2}, ${this.y2})`);\n            }\n            if (this.markerStart != null) {\n                r.push(` obj.Line.BeginArrowheadLength = msoArrowheadLong`);\n                r.push(` obj.Line.BeginArrowheadStyle = msoArrowheadTriangle`);\n                r.push(` obj.Line.BeginArrowheadWidth = msoArrowheadWide`);\n            }\n            if (this.markerEnd != null) {\n                r.push(` obj.Line.EndArrowheadLength = msoArrowheadLong`);\n                r.push(` obj.Line.EndArrowheadStyle = msoArrowheadTriangle`);\n                r.push(` obj.Line.EndArrowheadWidth = msoArrowheadWide`);\n            }\n            if (this.beginVertex != null) {\n                const endX = this.endVertex == null ? this.x2 : this.endVertex.cx;\n                const endY = this.endVertex == null ? this.y2 : this.endVertex.cy;\n                let begType = 0;\n                if (this.beginConnectorType == \"auto\") {\n                    begType = enums_1.ConnectorType.ToVBAConnectorPosition2(this.beginVertex.shape, this.beginVertex.getContactAutoPosition(endX, endY));\n                }\n                else {\n                    begType = enums_1.ConnectorType.ToVBAConnectorPosition2(this.beginVertex.shape, this.beginConnectorType);\n                }\n                r.push(` Call obj.ConnectorFormat.BeginConnect(shapes_(\"${this.beginVertex.objectID}\"), ${begType})`);\n            }\n            if (this.endVertex != null) {\n                const beginX = this.beginVertex == null ? this.x1 : this.beginVertex.cx;\n                const beginY = this.beginVertex == null ? this.y1 : this.beginVertex.cy;\n                let endType = 0;\n                if (this.endConnectorType == \"auto\") {\n                    endType = enums_1.ConnectorType.ToVBAConnectorPosition2(this.endVertex.shape, this.endVertex.getContactAutoPosition(beginX, beginY));\n                }\n                else {\n                    endType = enums_1.ConnectorType.ToVBAConnectorPosition2(this.endVertex.shape, this.endConnectorType);\n                }\n                r.push(` Call obj.ConnectorFormat.EndConnect(shapes_(\"${this.endVertex.objectID}\"), ${endType})`);\n            }\n            const lineType = (0, enum_extension_1.getLineType)(this.svgPath);\n            const colorName = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"gray\");\n            const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(colorName);\n            const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke-width\", \"4\"));\n            const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n            r.push(` Call EditLine(obj.Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\n        }\n        else if (this.controlPoint.length > 0) {\n            //subline.push(` Set obj = shapes_.AddConnector(msoConnectorStraight, 0, 0, 0, 0)`);\n            //lineArr.push(i);\n            r.push(` Dim nodes(${this.VBAConnectorNumber}) As Shape`);\n            for (let j = 0; j < this.VBAConnectorNumber; j++) {\n                const t = (j + 1) / (this.VBAConnectorNumber + 1);\n                const centerPoint = CommonFunctions.bezierLocation([this.x1, this.y1], this.controlPoint[0], [this.x2, this.y2], t);\n                r.push(`shapes_.AddShape(msoShapeOval, ${centerPoint[0]}, ${centerPoint[1]}, 0, 0).name = \"${this.objectID}_node_${j}\"`);\n            }\n            for (let j = 0; j <= this.VBAConnectorNumber; j++) {\n                //const centerPoint = Common.bezierLocation([this.x1, this.y1], this.controlPoint[0], [this.x2, this.y2], 0.5);\n                const edgeID = `${this.objectID}_edge_${j}`;\n                r.push(` shapes_.AddConnector(msoConnectorStraight, ${this.x1}, ${this.y1}, ${this.x2}, ${this.y2}).name = \"${this.objectID}_edge_${j}\"`);\n                const lineType = (0, enum_extension_1.getLineType)(this.svgPath);\n                const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"gray\"));\n                const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke-width\", \"4\"));\n                const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n                r.push(` Call EditLine(shapes_(\"${edgeID}\").Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\n                if (this.beginVertex != null) {\n                    const beg = j == 0 ? this.beginVertex.objectID : `${this.objectID}_node_${j - 1}`;\n                    const endX = this.endVertex == null ? this.x2 : this.endVertex.x;\n                    const endY = this.endVertex == null ? this.y2 : this.endVertex.y;\n                    const begType = j == 0 ? enums_1.ConnectorType.ToVBAConnectorPosition2(this.beginVertex.shape, this.beginVertex.getConnectorType(this.beginConnectorType, endX, endY)) : 1;\n                    r.push(` Call shapes_(\"${edgeID}\").ConnectorFormat.BeginConnect(shapes_(\"${beg}\"), ${begType})`);\n                }\n                if (this.endVertex != null) {\n                    const end = j == this.VBAConnectorNumber ? this.endVertex.objectID : `${this.objectID}_node_${j}`;\n                    const beginX = this.beginVertex == null ? this.x1 : this.beginVertex.x;\n                    const beginY = this.beginVertex == null ? this.y1 : this.beginVertex.y;\n                    const endType = j == this.VBAConnectorNumber ? enums_1.ConnectorType.ToVBAConnectorPosition2(this.endVertex.shape, this.endVertex.getConnectorType(this.endConnectorType, beginX, beginY)) : 1;\n                    r.push(` Call shapes_(\"${edgeID}\").ConnectorFormat.EndConnect(shapes_(\"${end}\"), ${endType})`);\n                }\n                //r.push(` Call EditConnector(shapes_(\"${edgeID}\").ConnectorFormat, shapes_(\"${beg}\"), shapes_(\"${end}\"), ${begType}, ${endType})`)\n            }\n        }\n        lineArr.forEach((v) => {\n            const lineType = (0, enum_extension_1.getLineType)(this.svgPath);\n            const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"gray\"));\n            const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke-width\", \"4\"));\n            const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n            r.push(` Call EditLine(edges(${v}).Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\n        });\n        //subline.forEach((v) => sub.push([v]));\n        const textCodes = this.createVBACodeOfText(id);\n        textCodes.forEach((v, i) => r.push(`Call create${id}_label_${i}(shapes_)`));\n        r.push(`End Sub`);\n        textCodes.forEach((v) => v.forEach((w) => r.push(w)));\n        return r;\n    }\n    static getVisibleCharElements(e) {\n        const r = new Array(0);\n        for (let i = 0; i < e.childNodes.length; i++) {\n            const child = e.childNodes.item(i);\n            if (child instanceof SVGTextPathElement) {\n                const r2 = this.getVisibleCharElements(child);\n                r2.forEach(([a, b]) => {\n                    r.push([a, b]);\n                });\n            }\n            else if (child instanceof SVGTSpanElement) {\n                const r2 = this.getVisibleCharElements(child);\n                r2.forEach(([a, b]) => {\n                    r.push([a, b]);\n                });\n            }\n            else {\n                if (child.textContent != null && child.textContent.length > 0) {\n                    const newText = html_1.HTMLFunctions.removeInvisibleCharacters(child.textContent);\n                    for (let j = 0; j < newText.length; j++) {\n                        const character = newText[j];\n                        r.push([e, character]);\n                    }\n                }\n            }\n        }\n        return r;\n    }\n    /**\n     * VBA\n     * @param shapes\n     * @param result\n     */\n    createVBACodeOfText(id) {\n        const r = [];\n        const globalX = this.graph != null ? this.graph.x : 0;\n        const globalY = this.graph != null ? this.graph.y : 0;\n        //let pid = 0;\n        const charInfoArray = ZEdge.getVisibleCharElements(this.svgText);\n        charInfoArray.forEach(([parent, character], i) => {\n            if (parent instanceof SVGTSpanElement) {\n                //const character = this.svgText.textContent![i];\n                const fontSize = parseInt(ElementExtension.getInheritedPropertyStyleValueWithDefault(parent, \"font-size\", \"12\"));\n                const fontFamily = vba_functions_1.VBATranslateFunctions.ToVBAFont(ElementExtension.getInheritedPropertyStyleValueWithDefault(parent, \"font-family\", \"MS PGothic\"));\n                const fontBold = vba_functions_1.VBATranslateFunctions.ToFontBold(ElementExtension.getInheritedPropertyStyleValueWithDefault(parent, \"font-weight\", \"none\"));\n                const css = getComputedStyle(parent);\n                const childColor = common_1.Color.createRGBFromColorName(css.fill);\n                const s = new Array(0);\n                const p1 = this.svgText.getStartPositionOfChar(i);\n                const p2 = this.svgText.getEndPositionOfChar(i);\n                const width = Math.abs(p2.x - p1.x);\n                //const height = Math.abs(p2.y - p1.y);\n                const rad = this.svgText.getRotationOfChar(i);\n                const diffx = (fontSize * 1 / 2) * Math.sin((rad / 180) * Math.PI);\n                const diffy = (fontSize * 3 / 8) + ((fontSize * 3 / 8) * Math.cos((rad / 180) * Math.PI));\n                const left = p1.x + globalX + diffx;\n                //const top = this.graph.svgGroup.getY() + p1.y - (fontSize / 2);\n                const top = p1.y + globalY - (fontSize * 1 / 4) - diffy;\n                //const top = p1.y + globalY  - diffy;\n                //const top = this.graph.svgGroup.getY() + p1.y - diffy;\n                s.push(`Sub create${id}_label_${i}(shapes_ As Shapes)`);\n                s.push(`With shapes_.AddTextBox(msoTextOrientationHorizontal, ${left}, ${top},${width},${fontSize})`);\n                s.push(`.TextFrame.TextRange.Text = \"${(0, vba_functions_1.sanityze)(character)}\"`);\n                s.push(`.TextFrame.marginLeft = 0`);\n                s.push(`.TextFrame.marginRight = 0`);\n                s.push(`.TextFrame.marginTop = 0`);\n                s.push(`.TextFrame.marginBottom = 0`);\n                s.push(`.TextFrame.TextRange.Font.color.RGB = RGB(CInt(${childColor.r}), CInt(${childColor.g}), CInt(${childColor.b}))`);\n                s.push(`.TextFrame.TextRange.Font.Size = ${fontSize}`);\n                s.push(`.TextFrame.TextRange.Font.name = \"${fontFamily}\"`);\n                s.push(`.TextFrame.TextRange.Font.Bold = ${fontBold}`);\n                s.push(`.IncrementRotation(${this.svgText.getRotationOfChar(i)})`);\n                //s.push(`.IncrementRotation(${this.svgText.transform.baseVal.getItem(0).angle})`);\n                s.push(`End With`);\n                s.push(`End Sub`);\n                r.push(s);\n            }\n        });\n        /*\n        for (let i = 0; i < this.svgText.getNumberOfChars(); i++) {\n        }\n        */\n        /*\n        if (this.svgTextPath.textContent != null) {\n        }\n        */\n        return r;\n    }\n}\nexports.ZEdge = ZEdge;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_edge.ts?");

/***/ }),

/***/ "./src/objects/z_ellipse.ts":
/*!**********************************!*\
  !*** ./src/objects/z_ellipse.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZEllipse = exports.ZAbstractEllipseCircle = void 0;\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nclass ZAbstractEllipseCircle extends z_textbox_1.ZTextBox {\n    get rx() {\n        return 5;\n    }\n    get ry() {\n        return 5;\n    }\n    /**\n    \n    */\n    get width() {\n        return this.rx * 2;\n    }\n    /**\n    \n    */\n    get height() {\n        return this.ry * 2;\n    }\n    constructor(svgbox) {\n        super(svgbox);\n    }\n    /**\n    \n    */\n    /*\n     get innerRectangle(): Rectangle {\n         const rect = new Rectangle();\n         const textRect = SVGTextExtension.getVirtualRegion(this.svgText);\n \n         //const rect = new Rectangle();\n         rect.width = this.width;\n         rect.height = this.height;\n         rect.x = -this.rx;\n         rect.y = -this.ry;\n         return rect;\n     }\n     */\n    /*\n    public getPosition(type: ConnectorType) : [number, number]{\n        const centerX = (Math.sqrt(2) / 2) * this.rx;\n        const centerY = (Math.sqrt(2) / 2) * this.ry;\n\n        switch (type) {\n            case ConnectorType.Top:\n                return [this.cx, this.cy - this.ry];\n            case ConnectorType.TopRight:\n                return [this.cx + centerX, this.cy - centerY];\n            case ConnectorType.Right:\n                return [this.cx + this.rx, this.cy];\n            case ConnectorType.BottomRight:\n                return [this.cx + centerX, this.cy + centerY];\n            case ConnectorType.Bottom:\n                return [this.cx, this.cy + this.ry];\n            case ConnectorType.BottomLeft:\n                return [this.cx - centerX, this.cy + centerY];\n            case ConnectorType.Left:\n                return [this.cx - this.rx, this.cy];\n            case ConnectorType.TopLeft:\n                return [this.cx - centerX, this.cy - centerY];\n            default:\n                return [this.cx, this.cy - this.ry];\n        }\n\n    }\n    */\n    getContactPosition(type, x, y) {\n        const centerX = (Math.sqrt(2) / 2) * this.rx;\n        const centerY = (Math.sqrt(2) / 2) * this.ry;\n        switch (type) {\n            case enums_1.ConnectorType.Top:\n                return [this.cx, this.cy - this.ry];\n            case enums_1.ConnectorType.TopRight:\n                return [this.cx + centerX, this.cy - centerY];\n            case enums_1.ConnectorType.Right:\n                return [this.cx + this.rx, this.cy];\n            case enums_1.ConnectorType.BottomRight:\n                return [this.cx + centerX, this.cy + centerY];\n            case enums_1.ConnectorType.Bottom:\n                return [this.cx, this.cy + this.ry];\n            case enums_1.ConnectorType.BottomLeft:\n                return [this.cx - centerX, this.cy + centerY];\n            case enums_1.ConnectorType.Left:\n                return [this.cx - this.rx, this.cy];\n            case enums_1.ConnectorType.TopLeft:\n                return [this.cx - centerX, this.cy - centerY];\n            default:\n                const autoType = this.getContactAutoPosition(x, y);\n                return this.getContactPosition(autoType, x, y);\n        }\n    }\n    getContactAutoPosition(x, y) {\n        const centerX = (Math.sqrt(2) / 2) * this.rx;\n        const centerY = (Math.sqrt(2) / 2) * this.ry;\n        const lineTop = new vline_1.VLine(x, y, this.cx, this.cy - centerY);\n        const lineTopRight = new vline_1.VLine(x, y, this.cx + centerX, this.cy - centerY);\n        const lineRight = new vline_1.VLine(x, y, this.cx + centerX, this.cy);\n        const lineBottomRight = new vline_1.VLine(x, y, this.cx + centerX, this.cy + centerY);\n        const lineBottom = new vline_1.VLine(x, y, this.cx, this.cy + centerY);\n        const lineBottomLeft = new vline_1.VLine(x, y, this.cx - centerX, this.cy + centerY);\n        const lineLeft = new vline_1.VLine(x, y, this.cx - centerX, this.cy);\n        const lineTopLeft = new vline_1.VLine(x, y, this.cx - centerX, this.cy - centerY);\n        const arr = [[lineTop.distance(), enums_1.ConnectorType.Top], [lineTopRight.distance(), enums_1.ConnectorType.TopRight], [lineRight.distance(), enums_1.ConnectorType.Right],\n            [lineBottomRight.distance(), enums_1.ConnectorType.BottomRight], [lineBottom.distance(), enums_1.ConnectorType.Bottom], [lineBottomLeft.distance(), enums_1.ConnectorType.BottomLeft],\n            [lineLeft.distance(), enums_1.ConnectorType.Left], [lineTopLeft.distance(), enums_1.ConnectorType.TopLeft]];\n        const [minDis, minDir] = arr.reduce(([a, b], [c, d]) => {\n            if (a < c) {\n                return [a, b];\n            }\n            else {\n                return [c, d];\n            }\n        });\n        return minDir;\n        /*\n        const line2 = new VLine(this.x, this.y, this.x + r, this.y - r);\n \n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n \n        if (b1) {\n            if (b2) {\n                return ConnectorType.Top;\n            } else {\n                return ConnectorType.Right;\n            }\n        } else {\n            if (b2) {\n                return ConnectorType.Left;\n            } else {\n                return ConnectorType.Bottom;\n            }\n        }\n        */\n    }\n    get surfaceRegion() {\n        const x = -this.rx;\n        const y = -this.ry;\n        const w = this.width;\n        const h = this.height;\n        return new vline_1.Rectangle(x, y, w, h);\n    }\n}\nexports.ZAbstractEllipseCircle = ZAbstractEllipseCircle;\nclass ZEllipse extends ZAbstractEllipseCircle {\n    get svgEllipse() {\n        return this._svgSurface;\n    }\n    constructor(svgbox) {\n        super(svgbox);\n        if (this.type == enums_1.ShapeObjectType.Ellipse)\n            this.firstFunctionAfterInitialized();\n    }\n    createSurface(svgbox) {\n        //if(option.surfaceClass === undefined) option.surfaceClass = DefaultClassNames.defaultSurfaceClass;\n        this._svgSurface = ZEllipse.createEllipse(this.svgGroup, DefaultClassNames.defaultSurfaceClass, undefined);\n        this.svgGroup.insertBefore(this.svgEllipse, this.svgText);\n    }\n    static createEllipse(parent, className, style) {\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');\n        circle.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Surface);\n        parent.appendChild(circle);\n        GOptions.setClassAndStyle(circle, className, style);\n        circle.rx.baseVal.value = AttributeNames.defaultCircleRadius;\n        circle.ry.baseVal.value = AttributeNames.defaultCircleRadius;\n        const radius = ElementExtension.getPropertyStyleNumberValue(circle, StyleNames.defaultRadius, null);\n        if (radius != null) {\n            circle.rx.baseVal.value = radius;\n            circle.ry.baseVal.value = radius;\n        }\n        circle.cx.baseVal.value = 0;\n        circle.cy.baseVal.value = 0;\n        return circle;\n    }\n    /*\n    public static constructAttributes(e: Element, removeAttributes: boolean = false, output: GOptions.ZTextBoxAttributes = {}): GOptions.ZTextBoxAttributes {\n        ZTextBox.constructAttributes(e, removeAttributes, output);\n\n\n        return output;\n    }\n    */\n    get width() {\n        return (0, vline_1.round100)(this.svgEllipse.rx.baseVal.value * 2);\n    }\n    get height() {\n        return (0, vline_1.round100)(this.svgEllipse.ry.baseVal.value * 2);\n    }\n    set width(value) {\n        const _rx = value / 2;\n        if (this.width != value)\n            ElementExtension.setAttributeNumber(this.svgEllipse, \"rx\", _rx);\n    }\n    set height(value) {\n        const _ry = value / 2;\n        if (this.height != value)\n            ElementExtension.setAttributeNumber(this.svgEllipse, \"ry\", _ry);\n        //this.svgEllipse.setAttribute(\"ry\", _ry.toString());\n    }\n    get rx() {\n        return (0, vline_1.round100)(this.svgEllipse.rx.baseVal.value);\n    }\n    get ry() {\n        return (0, vline_1.round100)(this.svgEllipse.ry.baseVal.value);\n    }\n    get type() {\n        return enums_1.ShapeObjectType.Ellipse;\n    }\n    /*\n    public getLocation(type: ConnectorPosition, x: number, y: number): [number, number] {\n\n        const centerX = (Math.sqrt(2) / 2) * this.svgEllipse.rx.baseVal.value;\n        const centerY = (Math.sqrt(2) / 2) * this.svgEllipse.ry.baseVal.value;\n\n        switch (type) {\n            case ConnectorType.Top:\n                return [this.cx, this.cy - this.ry];\n            case ConnectorType.TopRight:\n                return [this.cx + centerX, this.cy - centerY];\n            case ConnectorType.Right:\n                return [this.cx + this.rx, this.cy];\n            case ConnectorType.BottomRight:\n                return [this.cx + centerX, this.cy + centerY];\n            case ConnectorType.Bottom:\n                return [this.cx, this.cy + this.ry];\n            case ConnectorType.BottomLeft:\n                return [this.cx - centerX, this.cy + centerY];\n            case ConnectorType.Left:\n                return [this.cx - this.rx, this.cy];\n            case ConnectorType.TopLeft:\n                return [this.cx - centerX, this.cy - centerY];\n            default:\n                const autoType = this.getAutoPosition(x, y);\n                return this.getLocation(autoType, x, y);\n        }\n    }\n    protected getAutoPosition(x: number, y: number): ConnectorPosition {\n        const radius = this.rx;\n        const r = (Math.sqrt(2) / 2) * radius;\n        const line1 = new VLine(this.x, this.y, this.x + r, this.y + r);\n        const line2 = new VLine(this.x, this.y, this.x + r, this.y - r);\n\n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n\n        if (b1) {\n            if (b2) {\n                return ConnectorType.Top;\n            } else {\n                return ConnectorType.Right;\n            }\n        } else {\n            if (b2) {\n                return ConnectorType.Left;\n            } else {\n                return ConnectorType.Bottom;\n            }\n        }\n    }\n    */\n    get shape() {\n        return enums_1.VBAShapeType.Oval;\n    }\n}\nexports.ZEllipse = ZEllipse;\n/*\nexport type EllipseAttributes = TextBoxShapeAttributes & {\n    speakerX? : number,\n    speakerY? : number,\n}\n*/\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_ellipse.ts?");

/***/ }),

/***/ "./src/objects/z_foreign_button.ts":
/*!*****************************************!*\
  !*** ./src/objects/z_foreign_button.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZForeignButton = void 0;\nconst z_foreign_object_1 = __webpack_require__(/*! ./z_foreign_object */ \"./src/objects/z_foreign_object.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst html_1 = __webpack_require__(/*! ../html */ \"./src/html/index.ts\");\nclass ZForeignButton extends z_foreign_object_1.ZForeignObject {\n    //private static updateTextAttributes = [\"style\"]\n    constructor(svgbox) {\n        super(svgbox);\n        //console.log(option);\n        this._button = document.createElement(\"button\");\n        /*\n        if(option != null){\n            if(option.text != undefined){\n                if(typeof option.text == \"string\"){\n                    this._button.textContent = option.text;\n                }else{\n                    let s = \"\";\n                    option.text.forEach((v) => s += v.textContent);\n                    this._button.textContent = s;\n                }\n            }\n        }\n        */\n        this.foreignObject.appendChild(this._button);\n        if (this.type == enums_1.ShapeObjectType.Object)\n            this.firstFunctionAfterInitialized();\n    }\n    get type() {\n        return enums_1.ShapeObjectType.ForeignButton;\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        if (source.children.length > 0) {\n            let s = \"\";\n            const tNodes = html_1.HTMLFunctions.getTNodes(source);\n            if (tNodes != null) {\n                tNodes.forEach((v) => v.remove());\n                tNodes.forEach((v) => {\n                    s += v.textContent;\n                });\n                this._button.textContent = s;\n            }\n        }\n        else if (source.innerHTML.length > 0) {\n            this._button.textContent = source.textContent;\n            source.innerHTML = \"\";\n        }\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZTextBoxAttributes) {\n        super.setBasicOption(option)\n        const textClass = CSS.createCSSClass(option.textClass);\n        const styleClass = CSS.createCSSClass(option.textStyle);\n        //GOptions.setClassAndStyle(this._button, textClass, styleClass);\n        \n\n        if (typeof option.text == \"string\") {\n            this._button.textContent = option.text\n        } else if (Array.isArray(option.text)) {\n            let s = \"\";\n            option.text.forEach((v) => s += v.textContent);\n            this._button.textContent = s;\n        } else {\n\n        }\n    }\n    */\n    get width() {\n        return this._button.getBoundingClientRect().width;\n    }\n    set width(value) {\n        this._button.style.setProperty(\"width\", `${value}px`);\n    }\n    /**\n    \n    */\n    get height() {\n        return this._button.getBoundingClientRect().height;\n    }\n    set height(value) {\n        this._button.style.setProperty(\"height\", `${value}px`);\n    }\n}\nexports.ZForeignButton = ZForeignButton;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_foreign_button.ts?");

/***/ }),

/***/ "./src/objects/z_foreign_object.ts":
/*!*****************************************!*\
  !*** ./src/objects/z_foreign_object.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZForeignObject = void 0;\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nclass ZForeignObject extends z_vertex_1.ZVertex {\n    //private static updateTextAttributes = [\"style\"]\n    get foreignObject() {\n        return this._foreignObject;\n    }\n    constructor(svgbox) {\n        super(svgbox);\n        this._foreignObject = ZForeignObject.createForeignObject(this.svgGroup, undefined, undefined);\n        if (this.type == enums_1.ShapeObjectType.Object)\n            this.firstFunctionAfterInitialized();\n    }\n    static createForeignObject(parent, className, style) {\n        const obj = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n        parent.appendChild(obj);\n        obj.width.baseVal.value = 30;\n        obj.height.baseVal.value = 30;\n        if (style !== undefined) {\n            if (typeof (style) == \"string\") {\n                obj.setAttribute(\"style\", style);\n            }\n            else {\n                obj.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\n            }\n        }\n        //if(style !== undefined) rect.setAttribute(\"style\", style);\n        return obj;\n    }\n    get type() {\n        return enums_1.ShapeObjectType.ForeignObject;\n    }\n}\nexports.ZForeignObject = ZForeignObject;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_foreign_object.ts?");

/***/ }),

/***/ "./src/objects/z_graph.ts":
/*!********************************!*\
  !*** ./src/objects/z_graph.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZGraph = void 0;\n//namespace GraphTableSVG {\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nconst z_edge_1 = __webpack_require__(/*! ./z_edge */ \"./src/objects/z_edge.ts\");\nconst z_rect_1 = __webpack_require__(/*! ./z_rect */ \"./src/objects/z_rect.ts\");\nconst z_callout_1 = __webpack_require__(/*! ./z_callout */ \"./src/objects/z_callout.ts\");\nconst z_arrow_callout_1 = __webpack_require__(/*! ./z_arrow_callout */ \"./src/objects/z_arrow_callout.ts\");\nconst z_ellipse_1 = __webpack_require__(/*! ./z_ellipse */ \"./src/objects/z_ellipse.ts\");\nconst z_circle_1 = __webpack_require__(/*! ./z_circle */ \"./src/objects/z_circle.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst graph_arrangement_1 = __webpack_require__(/*! ./graph_helpers/graph_arrangement */ \"./src/objects/graph_helpers/graph_arrangement.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\nconst z_table_1 = __webpack_require__(/*! ./z_table */ \"./src/objects/z_table.ts\");\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\n/**\n\n*/\nclass ZGraph extends z_object_1.ZObject {\n    constructor(box) {\n        super(box);\n        this.objectCreatedFunction = (e) => {\n            const obj = z_object_1.ZObject.getObjectFromIDOrObjectID(e.target);\n            if (obj instanceof z_vertex_1.ZVertex) {\n                this.dispatchVertexCreatedEvent(obj);\n            }\n            else if (obj instanceof z_edge_1.ZEdge) {\n            }\n            else {\n            }\n        };\n        if (this.type == enums_1.ShapeObjectType.Graph)\n            this.firstFunctionAfterInitialized();\n        //this.setOptionInGObject(option)\n        //this.svgGroup.addEventListener(AttributeNames.objectCreatedEventName, this.objectCreatedFunction);\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZGraphAttributes){\n        super.setBasicOption(option);\n        if (option.isLatexMode == undefined) option.isLatexMode = false;\n        if (option.direction !== undefined) {\n            this.direction = option.direction;\n        }\n\n        if (option.relocateStyle !== undefined) {\n            this.relocateStyle = option.relocateStyle;\n        } else {\n            //this.relocateStyle = \"standard\"\n        }\n    }\n    */\n    /*\n    public setOption(option: GOptions.ZGraphAttributes){\n        super.setOption(option);\n    }\n    */\n    get graphAllocateFunction() {\n        const svg = this.svgGroup;\n        const f = svg.__graph_allocate_function;\n        return f;\n    }\n    set graphAllocateFunction(value) {\n        this.svgGroup.__graph_allocate_function = value;\n    }\n    get isCenterBased() {\n        return false;\n    }\n    get vertices() {\n        const r = [];\n        HTMLFunctions.getChildren(this.svgGroup).filter((v) => v.hasAttribute(AttributeNames.objectIDName)).forEach((v) => {\n            const item = z_object_1.ZObject.getObjectFromIDOrObjectID(v.getAttribute(AttributeNames.objectIDName));\n            if (item instanceof z_vertex_1.ZVertex) {\n                r.push(item);\n            }\n        });\n        return r;\n    }\n    get edges() {\n        const r = [];\n        HTMLFunctions.getChildren(this.svgGroup).filter((v) => v.hasAttribute(AttributeNames.objectIDName)).forEach((v) => {\n            const item = z_object_1.ZObject.getObjectFromIDOrObjectID(v.getAttribute(AttributeNames.objectIDName));\n            if (item instanceof z_edge_1.ZEdge) {\n                r.push(item);\n            }\n        });\n        return r;\n    }\n    get roots() {\n        return this.vertices.filter((v) => v.incomingEdges.length == 0);\n    }\n    //protected _roots: ZVertex[] = [];\n    get vertexXInterval() {\n        const v = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.vertexXInterval);\n        if (v == null) {\n            return null;\n        }\n        else {\n            return parseInt(v);\n        }\n    }\n    set vertexXInterval(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.vertexXInterval, value == null ? null : value.toString());\n    }\n    get vertexYInterval() {\n        const v = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.vertexYInterval);\n        if (v == null) {\n            return null;\n        }\n        else {\n            return parseInt(v);\n        }\n    }\n    get direction() {\n        const v = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.graphDirection);\n        if (v == null) {\n            return null;\n        }\n        else {\n            if (v == \"up\") {\n                return \"up\";\n            }\n            else if (v == \"left\") {\n                return \"left\";\n            }\n            else if (v == \"right\") {\n                return \"right\";\n            }\n            else {\n                return \"down\";\n            }\n        }\n    }\n    set direction(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.graphDirection, value == null ? null : value.toString());\n    }\n    set vertexYInterval(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.vertexYInterval, value == null ? null : value.toString());\n    }\n    /*\n    get defaultVertexClass(): string | null {\n        return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultVertexClass);\n    }\n    set defaultVertexClass(value: string | null) {\n        this.svgGroup.setPropertyStyleValue(AttributeNames.Style.defaultVertexClass, value);\n    }\n    */\n    /*\n     get defaultEdgeClass(): string | null {\n         return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultEdgeClass);\n     }\n     */\n    /*\n     set defaultEdgeClass(value: string | null) {\n         this.svgGroup.setPropertyStyleValue(AttributeNames.Style.defaultEdgeClass, value);\n     }\n     */\n    /**\n    \n    */\n    get rootVertex() {\n        if (this.roots.length == 0) {\n            return null;\n        }\n        else {\n            return this.roots[0];\n        }\n    }\n    /**\n     * \n     * @param item\n     */\n    add(item) {\n        if (item instanceof z_edge_1.ZEdge) {\n            this.svgGroup.appendChild(item.svgGroup);\n        }\n        else {\n            this.svgGroup.insertBefore(item.svgGroup, this.svgGroup.firstChild);\n        }\n    }\n    /**\n     * \n     * @param item\n     */\n    remove(item) {\n        this.svgGroup.removeChild(item.svgGroup);\n        item.dispose();\n    }\n    clear() {\n        while (this.edges.length > 0) {\n            this.remove(this.edges[0]);\n        }\n        while (this.vertices.length > 0) {\n            this.remove(this.vertices[0]);\n        }\n    }\n    /*\n    public connect(beginVertex: ZVertex, edge: ZEdge, endVertex: ZVertex, option: GOptions.ConnecterOption = {}) {\n\n        const oIndex = option.outcomingInsertIndex == undefined ? beginVertex.outgoingEdges.length : option.outcomingInsertIndex;\n        const iIndex = option.incomingInsertIndex == undefined ? endVertex.incomingEdges.length : option.incomingInsertIndex;\n        //this._connect(node1, edge, node2);\n\n        beginVertex.insertOutcomingEdge(edge, oIndex);\n        endVertex.insertIncomingEdge(edge, iIndex);\n\n        const i = this.roots.indexOf(beginVertex);\n        const j = this.roots.indexOf(endVertex);\n        if (j != -1) {\n            if (i == -1) {\n                this.roots[j] = beginVertex;\n            } else {\n                this.roots.splice(j, 1);\n            }\n        }\n        if (option.beginConnectorType != undefined) edge.beginConnectorType = option.beginConnectorType;\n        if (option.endConnectorType != undefined) edge.endConnectorType = option.endConnectorType;\n    }\n    */\n    getOrderedVertices(order, node = null) {\n        const r = [];\n        if (node == null) {\n            this.roots.forEach((v) => {\n                this.getOrderedVertices(order, v).forEach((w) => {\n                    r.push(w);\n                });\n            });\n        }\n        else {\n            const edges = node.outgoingEdges;\n            if (order == enums_1.VertexOrder.Preorder) {\n                r.push(node);\n                edges.forEach((v) => {\n                    this.getOrderedVertices(order, v.endVertex).forEach((w) => {\n                        r.push(w);\n                    });\n                });\n            }\n            else if (order == enums_1.VertexOrder.Postorder) {\n                edges.forEach((v) => {\n                    this.getOrderedVertices(order, v.endVertex).forEach((w) => {\n                        r.push(w);\n                    });\n                });\n                r.push(node);\n            }\n        }\n        return r;\n    }\n    /**\n     * \n     * @param parent\n     * @param child\n     * @param option\n     */\n    /*\n    public appendChild(parent: ZVertex, child: ZVertex | null, option: { insertIndex?: number } = {}) {\n        const _child = child == null ? ZGraph.createVertex2(this) : child;\n        const edge: ZEdge = <any>GGraph.createEdge(this);\n        this.connect(parent, edge, _child, { beginConnectorType: \"bottom\", endConnectorType: \"top\" });\n        //this.createdNodeCallback(child);\n        this.relocate();\n\n    }\n    */\n    get relocateStyle() {\n        return ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.relocateName);\n    }\n    set relocateStyle(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.relocateName, value);\n    }\n    relocate() {\n        //if(this.isDrawnText()){\n        this.hasConnectedObserverFunction = false;\n        const value = this.relocateStyle;\n        if (this.graphAllocateFunction !== undefined) {\n            this.graphAllocateFunction(this);\n        }\n        else if (value != null) {\n            if (value == \"standard\") {\n                graph_arrangement_1.GraphArrangement.standardTreeWidthArrangement(this);\n            }\n            else {\n                //const p = Function(\"v\", `return ${value}(v)`);\n                const f = Function(\"graph\", `${value}(graph)`);\n                f(this);\n            }\n        }\n        //this.relocate();\n        //this.moveInCanvas();\n        this.hasConnectedObserverFunction = true;\n        // }\n    }\n    get width() {\n        return this.Noderegion().width;\n    }\n    get height() {\n        return this.Noderegion().height;\n    }\n    set width(value) {\n    }\n    set height(value) {\n    }\n    Noderegion() {\n        const _x = SVGGExtension.getX(this.svgGroup);\n        const _y = SVGGExtension.getY(this.svgGroup);\n        let left = _x;\n        let right = _y;\n        let top = _x;\n        let bottom = _y;\n        this.vertices.forEach((v) => {\n            const x = v.x + _x;\n            const y = v.y + _y;\n            if (x < left)\n                left = x;\n            if (right < (x + v.width))\n                right = x + v.width;\n            if (y < top)\n                top = y;\n            if (bottom < (y + v.height))\n                bottom = y + v.height;\n        });\n        return new vline_1.Rectangle(left, top, right - left, bottom - top);\n    }\n    moveInCanvas() {\n        const rect = this.Noderegion();\n        if (rect.x < 0) {\n            this.x = this.x - (rect.x);\n        }\n        if (rect.y < 0) {\n            this.y = this.y - (rect.y);\n        }\n    }\n    /**\n     * VertexVertex\n     * @param graph\n     */\n    computeAutoXYIntervals() {\n        let yMaximalInterval = 10;\n        let xMaximalInterval = 10;\n        this.vertices.forEach((v) => {\n            if (v.width > xMaximalInterval)\n                xMaximalInterval = v.width;\n            if (v.height > yMaximalInterval)\n                yMaximalInterval = v.height;\n        });\n        return [xMaximalInterval + 30, yMaximalInterval + 30];\n    }\n    /**\n     * Vertex\n     * @param graph\n     */\n    getXYIntervals() {\n        const [xMaximalInterval, yMaximalInterval] = this.computeAutoXYIntervals();\n        const xi = this.vertexXInterval != null ? this.vertexXInterval : xMaximalInterval;\n        const yi = this.vertexYInterval != null ? this.vertexYInterval : yMaximalInterval;\n        return [xi, yi];\n    }\n    /*\n    public build(logicGraph: LogicGraph | LogicTree ) {\n        const option = logicGraph.option;\n        if(option ===undefined){\n            throw new Exceptions.UndefinedError();\n        }\n        //this.setOption(option);\n        //if (option.isLatexMode == undefined) option.isLatexMode = false;\n        this.clear();\n        const svgsvg = SVG.getSVGSVG(this.svgGroup);\n        //if (option.direction !== undefined) {\n        //    this.direction = option.direction;\n       // }\n\n        \n\n        if (logicGraph instanceof LogicGraph) {\n            const dic: Map<number, ZVertex> = new Map();\n\n            logicGraph.nodes.forEach((v, i) => {\n                const node = ZGraph.createVertex(svgsvg, ShapeObjectType.Circle)\n                const svgText = node.tryGetSVGText();\n                if(svgText != null){\n                    svgText.textContent = v.text;\n                }\n                this.add(node);\n                dic.set(i, node);\n            })\n            logicGraph.nodes.forEach((v, i) => {\n                v.outputEdges.forEach((e, j) => {\n                    const edge = ZGraph.createEdge(svgsvg)\n                    if (e.text != undefined) {\n                        const b = option.isLatexMode == undefined ? false : option.isLatexMode;\n                        Extensions.setTextContent(edge.svgTextPath, e.text, b);\n\n                    }\n                    this.add(edge);\n                    const beginNode = dic.get(i);\n                    const endNode = dic.get(e.endNodeIndex);\n                    if (beginNode == undefined || endNode == undefined) throw Error(\"error\");\n                    this.connect(beginNode, edge, endNode);\n                })\n            })\n        } else {\n    \n            const dic: Map<LogicTreeNode, ZVertex> = new Map();\n            if(logicGraph.root != null){\n                logicGraph.root.getOrderedNodes(VertexOrder.Preorder).forEach((v, i) => {\n                    const node = v.shapeObject instanceof LogicTable ? ZGraph.createVertexTable(svgsvg, v.shapeObject) : ZGraph.createVertex(svgsvg, v.shapeObject.shape, v.shapeObject.option)\n                    if(this.roots.length == 0) this.roots.push(node);\n                    this.add(node);\n                    dic.set(v, node);\n                })\n                logicGraph.root.getOrderedNodes(VertexOrder.Preorder).forEach((v, i) => {\n                    v.children.forEach((e, j) => {\n                        if (e != null) {\n                            const edge = ZGraph.createEdge(svgsvg, e.edgeOption)\n                            if (edge.svgTextPath.textContent != null) {\n                                edge.isAppropriatelyReverseMode = true;\n                            }\n                            this.add(edge);\n                            const beginNode = dic.get(v);\n                            const endNode = dic.get(e);\n\n                            if (beginNode == undefined || endNode == undefined) throw Error(\"error\");\n                            this.connect(beginNode, edge, endNode);\n                        }\n    \n                    })\n                })\n    \n            }else{\n                throw Error(\"error\")\n            }\n        }\n\n        this.relocate();\n\n    }\n    */\n    /*\n     public constructFromLogicTree(roots: LogicTree[] | LogicTree, option: { x?: number, y?: number, isLatexMode?: boolean } = {}) {\n         if (option.isLatexMode == undefined) option.isLatexMode = false;\n         if (roots instanceof Array) {\n             this.clear();\n             roots.forEach((v) => {\n                 if (v != null) {\n                     this.createChildFromLogicTree(null, v, option);\n                 }\n             });\n             this.relocate();\n \n         } else {\n             this.constructFromLogicTree([roots], option);\n         }\n         if (option.x != undefined) this.svgGroup.setX(option.x);\n         if (option.y != undefined) this.svgGroup.setY(option.y);\n \n         //this.roots = roots;\n     }\n     */\n    removeGraph(svg) {\n        if (svg.contains(this.svgGroup)) {\n            svg.removeChild(this.svgGroup);\n        }\n    }\n    /*\n    public isDrawnText() :boolean{\n        if(this.edges.length == 0){\n            return true;\n        }else{\n            \n            const b = this.edges.every((v) => v.isDrawnText());\n            return b;\n        }\n    }\n    */\n    /**\n     * RectangleNode\n     */\n    getRegion() {\n        const rects = this.vertices.map((v) => v.region);\n        const rect = vline_1.Rectangle.merge(rects);\n        rect.addOffset(SVGGExtension.getX(this.svgGroup), SVGGExtension.getY(this.svgGroup));\n        return rect;\n    }\n    /**\n     * VertexLogicTree\n     * @param parent Vertex\n     * @param logicVertex LogicTree\n     * @param option \n     * @returns logicVertexVertex\n     */\n    /*\n    private createChildFromLogicTree<T>(parent: ZVertex | null = null, logicVertex: LogicTreeGraph, option: { isLatexMode?: boolean } = {}): ZVertex {\n        if (option.isLatexMode == undefined) option.isLatexMode = false;\n        const node: ZVertex = <any>GGraph.createVertex2(this, logicVertex.vertexOption);\n\n        if (parent != null) {\n            const edge: ZEdge = ZGraph.createEdge(this, logicVertex.edgeOption);\n            this.connect(parent, edge, node, { beginConnectorType: \"bottom\", endConnectorType: \"top\" });\n        } else {\n            this.roots.push(node);\n        }\n        logicVertex.children.forEach((v) => {\n            if (v != null) this.createChildFromLogicTree(node, v, option);\n        });\n        return node;\n    }\n    */\n    createVBACode(id) {\n        const r = [];\n        this.vertices.forEach((v) => v.createVBACode(id++).forEach((w) => r.push(w)));\n        this.edges.forEach((v) => v.createVBACode(id++).forEach((w) => r.push(w)));\n        return r;\n    }\n    get VBAObjectNum() {\n        return this.vertices.length + this.edges.length;\n    }\n    getStyleValue(className, valueName) {\n        if (this.svgGroup.hasAttribute(\"class\")) {\n            const oldClass = this.svgGroup.getAttribute(\"class\");\n            this.svgGroup.setAttribute(\"class\", className);\n            const r = ElementExtension.getPropertyStyleValue(this.svgGroup, valueName);\n            this.svgGroup.setAttribute(\"class\", oldClass);\n            return r;\n        }\n        else {\n            this.svgGroup.setAttribute(\"class\", className);\n            const r = ElementExtension.getPropertyStyleValue(this.svgGroup, valueName);\n            this.svgGroup.removeAttribute(\"class\");\n            return r;\n        }\n    }\n    dispatchVertexCreatedEvent(vertex) {\n        var event = document.createEvent(\"HTMLEvents\");\n        event.initEvent(AttributeNames.vertexCreatedEventName, true, true);\n        vertex.svgGroup.dispatchEvent(event);\n    }\n    setRootIndex(vertex, rootIndex) {\n        if (vertex.graph == this) {\n            if (rootIndex < this.roots.length) {\n                this.svgGroup.insertBefore(vertex.svgGroup, this.roots[rootIndex].svgGroup);\n            }\n            else {\n                if (this.roots.length == 0) {\n                    if (this.svgGroup.firstChild == null) {\n                        this.svgGroup.appendChild(vertex.svgGroup);\n                    }\n                    else {\n                        this.svgGroup.insertBefore(vertex.svgGroup, this.svgGroup.firstChild);\n                    }\n                }\n                else {\n                    if (this.roots[this.roots.length - 1].svgGroup.nextSibling == null) {\n                        this.svgGroup.appendChild(vertex.svgGroup);\n                    }\n                    else {\n                        this.svgGroup.insertBefore(vertex.svgGroup, this.roots[this.roots.length - 1].svgGroup.nextSibling);\n                    }\n                }\n            }\n        }\n        else {\n            throw Error(\"error!\");\n        }\n    }\n    observerFunction(x) {\n        super.observerFunction(x);\n        for (let i = 0; i < x.length; i++) {\n            const p = x[i];\n            if (p.attributeName == \"style\") {\n                this.relocate();\n            }\n        }\n    }\n    get type() {\n        return enums_1.ShapeObjectType.Graph;\n    }\n    update() {\n        super.update();\n        this.vertices.forEach((v) => {\n            v.update();\n        });\n        this.edges.forEach((v) => {\n            v.update();\n        });\n        this.relocate();\n    }\n    getUpdateFlag() {\n        const b0 = super.getUpdateFlag();\n        const arr1 = this.vertices.map((v) => v.getUpdateFlag());\n        const arr2 = this.edges.map((v) => v.getUpdateFlag());\n        const b1 = arr1.reduce((x, y) => x || y, false);\n        const b2 = arr2.reduce((x, y) => x || y, false);\n        const b = b0 || b1 || b2;\n        if (b) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `getUpdateFlag Type = ${this.type} ID = ${this.objectID}: (b0 = ${b0}, b1 = ${b1}, b2 = ${b2})`);\n        }\n        return b0 || b1 || b2;\n    }\n    static createVertex2(parent, option = {}) {\n        let _parent = parent.svgGroup;\n        if (option.class == undefined)\n            option.class = DefaultClassNames.defaultVertexClass;\n        const type = typeof (option.class) == \"string\" ? parent.getStyleValue(option.class, StyleNames.defaultSurfaceType) : null;\n        if (type != null) {\n            switch (type) {\n                case enums_1.ShapeObjectType.Callout: return new z_callout_1.ZCallout(_parent);\n                case enums_1.ShapeObjectType.ArrowCallout: return new z_arrow_callout_1.ZArrowCallout(_parent);\n                case enums_1.ShapeObjectType.Ellipse: return new z_ellipse_1.ZEllipse(_parent);\n                case enums_1.ShapeObjectType.Circle: return new z_circle_1.ZCircle(_parent);\n                case enums_1.ShapeObjectType.Rect: return new z_rect_1.ZRect(_parent);\n            }\n        }\n        return new z_ellipse_1.ZEllipse(_parent);\n    }\n    /*\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-rect-button\", option?: GOptions.ZTextBoxAttributes): ZRectButton\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-rect\", option?: GOptions.ZTextBoxAttributes): ZRect\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-path-textbox\", option?: GOptions.ZTextBoxAttributes): ZPathTextBox\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-ellipse\", option?: GOptions.ZTextBoxAttributes): ZEllipse\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-callout\", option?: GOptions.ZTextBoxAttributes): ZCallout\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-circle\", option?: GOptions.ZTextBoxAttributes): ZCircle\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-arrow-callout\", option?: GOptions.ZTextBoxAttributes): ZArrowCallout\n    */\n    static getParent(parent) {\n        let _parent;\n        if (parent instanceof z_object_1.ZObject) {\n            _parent = parent.svgGroup;\n        }\n        else if (parent instanceof SVGElement) {\n            _parent = parent;\n        }\n        else {\n            _parent = document.getElementById(parent);\n        }\n        return _parent;\n    }\n    /*\n    public static createVertex(parent: SVGElement | string | ZObject, type: VertexObjectType, option: any = {}): ZVertex {\n        const _parent: SVGElement = ZGraph.getParent(parent);\n\n        switch (type) {\n            case ShapeObjectType.Callout:\n                const call = new ZCallout(_parent);\n                call.setOption(option);\n                return call;\n            case ShapeObjectType.ArrowCallout:\n                const arr = new ZArrowCallout(_parent);\n                arr.setOption(option);\n            case ShapeObjectType.Ellipse:\n                const ell = new ZEllipse(_parent);\n                ell.setOption(option);\n                return ell;\n            case ShapeObjectType.Rect:\n                const rect = new ZRect(_parent);\n                rect.setOption(option);\n                return rect;\n            case ShapeObjectType.Table:\n                const table = new ZTable(_parent);\n                table.setOption(option);\n                return table;\n            case ShapeObjectType.RectButton:\n                const rectb = new ZRectButton(_parent);\n                rectb.setOption(option);\n                return rectb;\n            case ShapeObjectType.Circle:\n                const circle = new ZCircle(_parent);\n                circle.setOption(option);\n                return circle;\n        }\n        throw new ArgumentOutOfRangeError();\n    }\n    */\n    static createVertexTable(parent, obj) {\n        const _parent = ZGraph.getParent(parent);\n        const table = new z_table_1.ZTable(_parent);\n        table.buildFromLogicTable(obj);\n        return table;\n    }\n    /*\n    public static createEdge(parent: SVGElement | string | ZObject, option: any = {}): ZEdge {\n        const _parent: SVGElement = ZGraph.getParent(parent);\n        const edge = new ZEdge(_parent);\n        edge.setOption(option);\n        return edge;\n    }\n    */\n    updateSurfaceWithoutSVGText() {\n        //super.updateSurfaceWithoutSVGText();\n        /*\n        this.vertices.forEach((v) =>{\n            v.update();\n        })\n        */\n        /*\n         this.edges.forEach((v) =>{\n             v.update();\n         })\n         */\n        this.relocate();\n        return true;\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        while (source.children.length > 0) {\n            const fst = source.children.item(0);\n            if (fst != null) {\n                this.svgGroup.append(fst);\n            }\n        }\n    }\n}\nexports.ZGraph = ZGraph;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_graph.ts?");

/***/ }),

/***/ "./src/objects/z_object.ts":
/*!*********************************!*\
  !*** ./src/objects/z_object.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZObject = void 0;\n//namespace GraphTableSVG {\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\nconst GUIObserver = __webpack_require__(/*! ../html/gui_observer */ \"./src/html/gui_observer.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst draggable_object_1 = __webpack_require__(/*! ../html/draggable_object */ \"./src/html/draggable_object.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst enums_2 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\nconst GObserver = __webpack_require__(/*! ./z_observer */ \"./src/objects/z_observer.ts\");\nconst global_gobject_manager_1 = __webpack_require__(/*! ./global_gobject_manager */ \"./src/objects/global_gobject_manager.ts\");\nclass ZObject {\n    constructor(svgbox) {\n        this._svgSurface = null;\n        /*\n        public get id() : string | null{\n            return this.svgGroup.getAttribute(\"id\");\n        }\n        */\n        /*\n        public setUnstableFlag() : void {\n            this.isStable = false;\n        }\n        */\n        /*\n        public get unstableCounter(): number | null {\n            const p = this.svgGroup.getAttribute(GObserver.unstableCounterName);\n            if (p == null) {\n                return null;\n            } else {\n                const num = Number(p);\n                return num;\n            }\n        }\n        protected set unstableCounter(value: number | null) {\n            if (value == null) {\n                this.svgGroup.removeAttribute(GObserver.unstableCounterName)\n            } else {\n                this.svgGroup.setAttribute(GObserver.unstableCounterName, value.toString());\n    \n            }\n        }\n        public resetUnstableCounter(): void {\n            this.unstableCounter = GObserver.unstableCounterDefault;\n        }\n        */\n        /*\n        public get shape() : ShapeObjectType {\n            return ShapeObjectType.Object;\n        }\n        */\n        this._isInitialized = false;\n        this._hasConnectedObserverFunction = false;\n        this.groupObserverOption = { attributes: true, childList: true, subtree: true };\n        this.pUpdateFunc = () => {\n            if (!this.isShown)\n                return;\n        };\n        this.observerFunc = (x) => {\n            this.observerFunction(x);\n        };\n        /*\n        public get isStable(): boolean {\n            const p = this.svgGroup.getAttribute(\"data-object-stable\");\n            return p == \"true\";\n        }\n        protected set isStable(value: boolean) {\n            this.svgGroup.setAttribute(\"data-object-stable\", value == true ? \"true\" : \"false\");\n        }\n        */\n        this._isUpdating = false;\n        this.updateAttributes = [\"style\", \"transform\", \"data-speaker-x\", \"data-speaker-y\",\n            \"data-width\", \"data-height\", \"data-arrow-neck-width\", \"data-arrow-neck-height\",\n            \"data-arrow-head-width\", \"data-arrow-head-height\"];\n        CSS.setGraphTableCSS();\n        let parentElement = svgbox instanceof SVGElement ? svgbox : document.getElementById(svgbox);\n        if (parentElement instanceof SVGSVGElement && !GUIObserver.isObserved(parentElement)) {\n            GUIObserver.observeSVGSVG(parentElement);\n        }\n        this._svgGroup = SVG.createGroup(parentElement);\n        this.stableFlag = false;\n        /*\n        GOptions.setClassAndStyle(this._svgGroup, option.class, option.style);\n        if(option.attributes !== undefined){\n            Object.keys(option.attributes).forEach((v) =>{\n                const value : string = option.attributes![v];\n                this._svgGroup.setAttribute(v, value);\n            })\n        }\n        */\n        ZObject.setObjectFromObjectID(this);\n        this.svgGroup.operator = this;\n        this.svgGroup.setAttribute(AttributeNames.GroupAttribute, this.type);\n        this.createSurface(parentElement);\n        this._observer = new MutationObserver(this.observerFunc);\n        this._observerOption = { attributes: true, childList: true, subtree: true };\n        this.hasConnectedObserverFunction = true;\n        this.dispatchObjectCreatedEvent();\n        this.addResizeEvent();\n        const __svg = this.svgGroup;\n        __svg.operator = this;\n        this.allowHover = true;\n        //this.unstableCounter = GObserver.unstableCounterDefault;\n        const svgsvgAncestor = HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvgAncestor instanceof SVGSVGElement) {\n            const xb = global_gobject_manager_1.GlobalZObjectManager.tryRegisterSVGSVGElement(svgsvgAncestor);\n            xb.registerObject(this);\n        }\n        //this.setOptionInGObject(option);\n        /*\n        if (_option.x !== undefined) this.fixedX = _option.x;\n        if (_option.y !== undefined) this.fixedY = _option.y;\n        */\n        if (this.type == enums_2.ShapeObjectType.Object)\n            this.firstFunctionAfterInitialized();\n    }\n    copyAttribute(from, to, attributeName, remove) {\n        const attr = from.getAttribute(attributeName);\n        if (attr != null) {\n            to.setAttribute(attributeName, attr);\n        }\n        if (remove) {\n            from.removeAttribute(attributeName);\n        }\n    }\n    initializeSetBasicOption(source) {\n        this.copyAttribute(source, this._svgGroup, \"class\", true);\n        this.copyAttribute(source, this._svgGroup, \"style\", true);\n        this.copyAttribute(source, this._svgGroup, \"id\", true);\n        const width = ElementExtension._getAttributeNumber(source, AttributeNames.width, true);\n        if (width != null) {\n            this.width = width;\n        }\n        const height = ElementExtension._getAttributeNumber(source, AttributeNames.height, true);\n        if (height != null) {\n            this.height = height;\n        }\n        if (this.svgSurface != null) {\n            ZObject.setSubAttributes(this.svgSurface, source);\n        }\n    }\n    static setSubAttributes(e, source) {\n        const objName = e.getAttribute(AttributeNames.dataNameAttribute);\n        if (objName != null) {\n            this.setSubAttributesWithObjName(e, objName, source);\n        }\n    }\n    static setSubAttributesWithObjName(e, objName, source) {\n        if (objName != null) {\n            const map = HTMLFunctions.getSubAttributeFromAncestors(source, objName);\n            map.forEach((value, key) => {\n                e.setAttribute(key, value);\n            });\n        }\n    }\n    //protected setText\n    initializeOptionalPosition(source) {\n        const cx = ElementExtension._getAttributeNumber(source, AttributeNames.cx, true);\n        const cy = ElementExtension._getAttributeNumber(source, AttributeNames.cy, true);\n        const x = ElementExtension._getAttributeNumber(source, AttributeNames.x, true);\n        const y = ElementExtension._getAttributeNumber(source, AttributeNames.y, true);\n        if (x != null || y != null) {\n            this.positionType = vline_1.PositionType.UpperLeft;\n            const __x = x == null ? 0 : x;\n            const __y = y == null ? 0 : y;\n            this.setVirtualXY(__x, __y);\n        }\n        else {\n            this.positionType = vline_1.PositionType.Center;\n            this.cx = cx == null ? 0 : cx;\n            this.cy = cy == null ? 0 : cy;\n        }\n    }\n    initialize(source) {\n        this.initializeSetBasicOption(source);\n        this.initializeOptionalPosition(source);\n        while (source.attributes.length > 0) {\n            const attr = source.attributes.item(0);\n            if (attr != null) {\n                this.svgGroup.setAttribute(attr.name, attr.value);\n                source.removeAttribute(attr.name);\n            }\n        }\n        source.remove();\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZObjectAttributes): void {\n\n        GOptions.setClassAndStyle(this._svgGroup, option.class, option.style);\n\n        if (option.attributes !== undefined) {\n            Object.keys(option.attributes).forEach((v) => {\n                const value: string = option.attributes![v];\n                this._svgGroup.setAttribute(v, value);\n            })\n        }\n        if (typeof option.id !== \"undefined\") this.svgGroup.id = option.id;\n    }\n    */\n    /*\n    public setOption(option: GOptions.ZObjectAttributes) {\n        this.setBasicOption(option);\n        //this.setOptionalSize(option);\n        this.setOptionalPosition(option)\n    }\n    */\n    /*\n    protected setOptionalSize(option: GOptions.ZObjectAttributes) {\n        if (this.svgSurface !== null) {\n            GOptions.setClassAndStyle(this.svgSurface, option.surfaceClass, option.surfaceStyle)\n        }\n\n        this.width = (option.width !== undefined ? option.width : 25);\n        this.height = (option.height !== undefined ? option.height : 25);\n    }\n    */\n    /*\n    protected setOptionalPosition(option: GOptions.ZObjectAttributes) {\n\n        if (option.position !== undefined) {\n            if (option.position.type == \"center\") {\n                this.positionType = PositionType.Center;\n                this.cx = option.position.x;\n                this.cy = option.position.y;\n            } else {\n\n                this.positionType = PositionType.UpperLeft;\n                this.setVirtualXY(option.position.x, option.position.y);\n                //this.x = option.position.x;\n                //this.y = option.position.y;\n\n            }\n        } else {\n            this.positionType = PositionType.Center;\n            this.__cx = 0;\n            this.__cy = 0;\n\n        }\n    }\n    */\n    /*\n    public assignOption(option: ZVertexOptionReteral) {\n        GOptions.setClassAndStyle(this._svgGroup, option.class, option.style);\n\n        if(option.id !== undefined){\n            this.svgGroup.setAttribute(\"id\", option.id);\n        }\n        if (this.svgSurface !== null) {\n            GOptions.setClassAndStyle(this.svgSurface, option.surfaceOption.class, option.surfaceOption.style)\n        }\n        this.width = option.width !== undefined ? option.width : 25;\n        this.height = option.height !== undefined ? option.height : 25;\n\n\n        if (option.positionType !== undefined) {\n            if (option.positionType == \"center\") {\n                this.positionType = PositionType.Center;\n                this.cx = option.cx ?? 0;\n                this.cy = option.cy ?? 0;\n            } else {\n                const x = option.x ?? 0;\n                const y = option.y ?? 0;\n                this.positionType = PositionType.UpperLeft;\n                this.setVirtualXY(x, y);\n                //this.x = option.position.x;\n                //this.y = option.position.y;\n            }\n        } else {\n            this.positionType = PositionType.Center;\n            this.__cx = 0;\n            this.__cy = 0;\n\n        }\n    }\n    */\n    get stableFlag() {\n        return this.svgGroup.getAttribute(GObserver.ObjectStableFlagName) == \"true\";\n    }\n    get syncXTargetObject() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncXTarget);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return ZObject.getObjectFromIDOrObjectID(p);\n        }\n    }\n    get syncYTargetObject() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncYTarget);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return ZObject.getObjectFromIDOrObjectID(p);\n        }\n    }\n    get syncXSourcePosition() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncXSourcePosition);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return enums_1.HorizontalAnchor.toHorizontalAnchor(p);\n        }\n    }\n    get syncXTargetPosition() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncXTargetPosition);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return enums_1.HorizontalAnchor.toHorizontalAnchor(p);\n        }\n    }\n    get syncYSourcePosition() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncYSourcePosition);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return enums_1.VerticalAnchor.toVerticalAnchor(p);\n        }\n    }\n    get syncYTargetPosition() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncYTargetPosition);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return enums_1.VerticalAnchor.toVerticalAnchor(p);\n        }\n    }\n    set stableFlag(b) {\n        this.svgGroup.setAttribute(GObserver.ObjectStableFlagName, b ? \"true\" : \"false\");\n    }\n    get childrenStableFlag() {\n        return true;\n    }\n    updateSurfaceWithoutSVGText() {\n        this.update();\n        return true;\n    }\n    updateObjectLocation() {\n        this.joint();\n    }\n    joint() {\n        const objRegion = this.getRegion();\n        if (this.syncXTargetObject != null) {\n            const jointRegion = this.syncXTargetObject.getRegion();\n            let diffX = 0;\n            if (this.syncXSourcePosition == \"left\" || this.syncXSourcePosition == null) {\n                if (this.syncXTargetPosition == \"left\" || this.syncXTargetPosition == null) {\n                    diffX = jointRegion.x - objRegion.x;\n                }\n                else if (this.syncXTargetPosition == \"center\") {\n                    diffX = jointRegion.x + (jointRegion.width / 2) - objRegion.x;\n                }\n                else {\n                    diffX = jointRegion.right - objRegion.x;\n                }\n            }\n            else if (this.syncXSourcePosition == \"center\") {\n                if (this.syncXTargetPosition == \"left\" || this.syncXTargetPosition == null) {\n                    diffX = jointRegion.x - objRegion.x - (objRegion.width / 2);\n                }\n                else if (this.syncXTargetPosition == \"center\") {\n                    diffX = jointRegion.x + (jointRegion.width / 2) - objRegion.x - (objRegion.width / 2);\n                }\n                else {\n                    diffX = jointRegion.right - objRegion.x - (objRegion.width / 2);\n                }\n            }\n            else {\n                if (this.syncXTargetPosition == \"left\" || this.syncXTargetPosition == null) {\n                    diffX = jointRegion.x - objRegion.right;\n                }\n                else if (this.syncXTargetPosition == \"center\") {\n                    diffX = jointRegion.x + (jointRegion.width / 2) - objRegion.right;\n                }\n                else {\n                    diffX = jointRegion.right - objRegion.right;\n                }\n            }\n            this.x = this.x + diffX;\n        }\n        if (this.syncYTargetObject != null) {\n            const jointRegion = this.syncYTargetObject.getRegion();\n            let diffy = 0;\n            if (this.syncYSourcePosition == \"top\" || this.syncYSourcePosition == null) {\n                if (this.syncYTargetPosition == \"top\" || this.syncYTargetPosition == null) {\n                    diffy = jointRegion.y - objRegion.y;\n                }\n                else if (this.syncYTargetPosition == \"middle\") {\n                    diffy = jointRegion.y + (jointRegion.height / 2) - objRegion.y;\n                }\n                else {\n                    diffy = jointRegion.bottom - objRegion.y;\n                }\n            }\n            else if (this.syncYSourcePosition == \"middle\") {\n                if (this.syncYTargetPosition == \"top\" || this.syncYTargetPosition == null) {\n                    diffy = jointRegion.y - objRegion.y - (objRegion.height / 2);\n                }\n                else if (this.syncYTargetPosition == \"middle\") {\n                    diffy = jointRegion.y + (jointRegion.height / 2) - objRegion.y - (objRegion.height / 2);\n                }\n                else {\n                    diffy = jointRegion.bottom - objRegion.y - (objRegion.height / 2);\n                }\n            }\n            else {\n                if (this.syncYTargetPosition == \"top\" || this.syncYTargetPosition == null) {\n                    diffy = jointRegion.y - objRegion.bottom;\n                }\n                else if (this.syncYTargetPosition == \"middle\") {\n                    diffy = jointRegion.y + (jointRegion.height / 2) - objRegion.bottom;\n                }\n                else {\n                    diffy = jointRegion.bottom - objRegion.bottom;\n                }\n            }\n            this.y = this.y + diffy;\n        }\n    }\n    disconnectObserverFunction() {\n        this._observer.disconnect();\n    }\n    connectObserverFunction() {\n        this._observer.observe(this.svgGroup, this._observerOption);\n    }\n    get hasConnectedObserverFunction() {\n        return this._hasConnectedObserverFunction;\n    }\n    set hasConnectedObserverFunction(b) {\n        if (this._hasConnectedObserverFunction != b) {\n            if (b) {\n                this.connectObserverFunction();\n            }\n            else {\n                this.disconnectObserverFunction();\n            }\n            this._hasConnectedObserverFunction = b;\n        }\n    }\n    get coordinateType() {\n        return \"object-center\";\n    }\n    get defaultClassName() {\n        return undefined;\n    }\n    get isInitialized() {\n        return this._isInitialized;\n    }\n    firstFunctionAfterInitialized() {\n        if (this._isInitialized) {\n            throw new Error(\"This function is already called\");\n        }\n        this._isInitialized = true;\n        //this.update();\n        //this.resetUnstableCounter();\n        if (this.__cx !== undefined)\n            this.cx = this.__cx;\n        if (this.__cy !== undefined)\n            this.cy = this.__cy;\n        if (this.__x !== undefined)\n            this.x = this.__x;\n        if (this.__y !== undefined)\n            this.y = this.__y;\n    }\n    removeResizeEvent() {\n        this.svgGroup.removeEventListener(AttributeNames.resizeName, this.pUpdateFunc);\n    }\n    addResizeEvent() {\n        this.svgGroup.addEventListener(AttributeNames.resizeName, this.pUpdateFunc);\n    }\n    /*\n    private addOnLoadEvent() {\n        this.svgGroup.onload = this.onLoadFunction;\n        //this.svgGroup.addEventListener(\"load\", this.onLoadFunction);\n    }\n\n    private removeOnLoadEvent() {\n        \n        this.svgGroup.removeEventListener(\"load\", this.onLoadFunction);\n    }\n    protected onLoadFunction = () => {\n    }\n    */\n    firstResizeUpdate() {\n    }\n    /*\n    protected _isLoaded = false;\n    public get isLoaded(){\n        return this._isLoaded;\n    }\n    */\n    /*\n    static constructAttributes(e: Element,\n        removeAttributes: boolean = false, output: GOptions.ZObjectAttributes = {}, defaultPositionType : \"center\" | \"upper-left\" ): GOptions.ZObjectAttributes {\n        output.class = ElementExtension.gtGetAttributeStringWithUndefined(e, AttributeNames.className);\n        if (output.class === undefined) ElementExtension.gtGetAttributeStringWithUndefined(e, AttributeNames.className);\n        output.surfaceClass = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.surfaceClassName);\n        output.surfaceStyle = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.surfaceStyle);\n\n        output.style = ElementExtension.gtGetAttributeStringWithUndefined(e, AttributeNames.style);\n        if (e.hasAttribute(AttributeNames.style)) output.style = ElementExtension.gtGetAttributeStringWithUndefined(e, AttributeNames.style);\n\n        const cx = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.cx);\n        const cy = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.cy);\n        const x = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.x);\n        const y = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.y);\n        if (cx !== undefined || cy !== undefined) {\n            output.position = { type: \"center\", x: cx !== undefined ? cx : 0, y: cy !== undefined ? cy : 0 }\n        } else if (x !== undefined || y !== undefined) {\n            output.position = { type: \"upper-left\", x: x !== undefined ? x : 0, y: y !== undefined ? y : 0 }\n        } else {\n            output.position = { type: defaultPositionType, x: 0, y: 0 }\n        }\n        //const cx =\n        output.width = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.width);\n        output.height = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.height);\n\n        if (removeAttributes) {\n            e.removeAttribute(AttributeNames.cx);\n            e.removeAttribute(AttributeNames.cy);\n            e.removeAttribute(AttributeNames.x);\n            e.removeAttribute(AttributeNames.y);\n            e.removeAttribute(AttributeNames.className);\n            e.removeAttribute(AttributeNames.surfaceClassName);\n            //e.removeAttribute(AttributeNames.groupClassName);\n            e.removeAttribute(AttributeNames.surfaceStyle);\n            //e.removeAttribute(AttributeNames.groupStyle);\n            e.removeAttribute(AttributeNames.style);\n\n            e.removeAttribute(AttributeNames.width);\n            e.removeAttribute(AttributeNames.height);\n        }\n        return output;\n    }\n    */\n    get tag() {\n        return this._tag;\n    }\n    set tag(v) {\n        this._tag = v;\n    }\n    get isShown() {\n        return HTMLFunctions.isShow(this.svgGroup);\n    }\n    /**\n    SVGGElement\n    */\n    get svgGroup() {\n        return this._svgGroup;\n    }\n    get isLocated() {\n        return CommonFunctions.IsDescendantOfBody(this.svgGroup);\n    }\n    get svgSurface() {\n        return this._svgSurface;\n    }\n    /**\nVertexX\n*/\n    get cx() {\n        if (this.isCenterBased) {\n            return SVGGExtension.getX(this.svgGroup);\n        }\n        else {\n            return SVGGExtension.getX(this.svgGroup) + (this.width / 2);\n        }\n    }\n    set cx(value) {\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            //throw Error(\"This object does not support set cx!\" + this.type);\n        }\n        else {\n            if (this.isCenterBased) {\n                if (SVGGExtension.getX(this.svgGroup) != value) {\n                    SVGGExtension.setX(this.svgGroup, value);\n                }\n            }\n            else {\n                SVGGExtension.setX(this.svgGroup, value - (this.width / 2));\n            }\n        }\n    }\n    /**\n    VertexY\n    */\n    get cy() {\n        if (this.isCenterBased) {\n            return SVGGExtension.getY(this.svgGroup);\n        }\n        else {\n            return SVGGExtension.getY(this.svgGroup) + (this.height / 2);\n        }\n    }\n    set cy(value) {\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            //throw Error(\"This object does not support set cy!\");\n        }\n        else {\n            if (this.isCenterBased) {\n                if (SVGGExtension.getY(this.svgGroup) != value) {\n                    SVGGExtension.setY(this.svgGroup, value);\n                }\n            }\n            else {\n                SVGGExtension.setY(this.svgGroup, value - (this.height / 2));\n            }\n        }\n    }\n    get upperHeight() {\n        return (this.height / 2);\n    }\n    get leftWidth() {\n        return (this.width / 2);\n    }\n    get surfaceRegion() {\n        return new vline_1.Rectangle();\n    }\n    get x() {\n        if (this.isCenterBased) {\n            return SVGGExtension.getX(this.svgGroup) + this.surfaceRegion.x;\n        }\n        else {\n            return SVGGExtension.getX(this.svgGroup);\n        }\n    }\n    get y() {\n        if (this.isCenterBased) {\n            return SVGGExtension.getY(this.svgGroup) + this.surfaceRegion.y;\n        }\n        else {\n            return SVGGExtension.getY(this.svgGroup);\n        }\n    }\n    set x(v) {\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            throw Error(\"This object does not support set x!\");\n        }\n        else {\n            if (this.isCenterBased) {\n                SVGGExtension.setX(this.svgGroup, v - this.surfaceRegion.x);\n            }\n            else {\n                SVGGExtension.setX(this.svgGroup, v);\n            }\n        }\n    }\n    set y(v) {\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            throw Error(\"This object does not support set y!\");\n        }\n        else {\n            if (this.isCenterBased) {\n                SVGGExtension.setY(this.svgGroup, v - this.surfaceRegion.y);\n            }\n            else {\n                SVGGExtension.setY(this.svgGroup, v);\n            }\n        }\n    }\n    setVirtualXY(x, y) {\n        const rect = this.getVirtualRegion();\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            throw Error(\"This object does not support set x!\");\n        }\n        else {\n            if (this.isCenterBased) {\n                SVGGExtension.setX(this.svgGroup, x - rect.x);\n            }\n            else {\n                SVGGExtension.setX(this.svgGroup, x);\n            }\n        }\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            throw Error(\"This object does not support set y!\");\n        }\n        else {\n            if (this.isCenterBased) {\n                SVGGExtension.setY(this.svgGroup, y - rect.y);\n            }\n            else {\n                SVGGExtension.setY(this.svgGroup, y);\n            }\n        }\n    }\n    /*\n    public set virtualX(v: number) {\n        if(this.coordinateType == CoodinateType.Group00){\n            throw Error(\"This object does not support set x!\");\n        }else{\n            if (this.isCenterBased) {\n                SVGGExtension.setX(this.svgGroup,v - this.getVirtualRegion().x );\n            } else {\n                SVGGExtension.setX(this.svgGroup, v);\n            }\n        }\n\n    }\n    */\n    /*\n    public set virtualY(v: number) {\n        if(this.coordinateType == CoodinateType.Group00){\n            throw Error(\"This object does not support set y!\");\n        }else{\n            if (this.isCenterBased) {\n                SVGGExtension.setY(this.svgGroup, v + (this.getVirtualHeight() / 2));\n            } else {\n                SVGGExtension.setY(this.svgGroup, v);\n            }\n        }\n\n    }\n    */\n    /**\n    \n    */\n    get width() {\n        if (this.hasSize) {\n            return (0, vline_1.round100)(ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-width\", 0));\n        }\n        else {\n            return 0;\n        }\n    }\n    set width(value) {\n        const newValue = (0, vline_1.round100)(value);\n        if (this.hasSize) {\n            if (!(0, vline_1.nearlyEqual)(this.width, newValue)) {\n                ElementExtension.setAttributeNumber(this.svgGroup, \"data-width\", newValue);\n            }\n            //this.svgGroup.setAttribute(\"data-width\", value.toString());\n        }\n    }\n    /*\n    protected setWidthWithoutUpdate(value: number) {\n        this.width = value;\n\n    }\n    protected setHeightWithoutUpdate(value: number) {\n        this.height = value;\n    }\n    */\n    /**\n    \n    */\n    get height() {\n        if (this.hasSize) {\n            return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-height\", 0);\n        }\n        else {\n            return 0;\n        }\n    }\n    set height(value) {\n        const newValue = (0, vline_1.round100)(value);\n        if (this.hasSize) {\n            if (!(0, vline_1.nearlyEqual)(this.height, newValue)) {\n                ElementExtension.setAttributeNumber(this.svgGroup, \"data-height\", newValue);\n            }\n            //this.svgGroup.setAttribute(\"data-height\", value.toString());\n        }\n    }\n    /*\n    public get fixedX(): number | null {\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-fixedX\", null);\n    }\n    public set fixedX(v: number | null) {\n        if (v == null) {\n            this.svgGroup.removeAttribute(\"data-fixedX\");\n        } else {\n            this.svgGroup.setAttribute(\"data-fixedX\", v.toString());\n        }\n    }\n    \n    public get fixedY(): number | null {\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-fixedY\", null);\n    }\n    public set fixedY(v: number | null) {\n        if (v == null) {\n            this.svgGroup.removeAttribute(\"data-fixedY\");\n        } else {\n            this.svgGroup.setAttribute(\"data-fixedY\", v.toString());\n        }\n    }\n    */\n    get isCenterBased() {\n        return true;\n    }\n    get positionType() {\n        const str = this.svgGroup.getAttribute(\"data-position-type\");\n        if (str !== undefined) {\n            if (str == vline_1.PositionType.Center) {\n                return vline_1.PositionType.Center;\n            }\n            else {\n                return vline_1.PositionType.UpperLeft;\n            }\n        }\n        else {\n            return vline_1.PositionType.Center;\n        }\n    }\n    set positionType(value) {\n        this.svgGroup.setAttribute(\"data-position-type\", value);\n    }\n    get isProhibitionOutOfRange() {\n        const p = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.prohibitionOutOfRange, \"true\");\n        return p == \"true\";\n    }\n    set isProhibitionOutOfRange(v) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.prohibitionOutOfRange, v.toString());\n    }\n    moveInCanvas() {\n        this.x = (this.width / 2) + 10;\n        this.y = (this.height / 2) + 10;\n    }\n    get type() {\n        return enums_2.ShapeObjectType.Object;\n    }\n    createSurface(svgbox) {\n    }\n    setClassNameOfSVGGroup() {\n    }\n    observerFunction(x) {\n        //throw Error(\"error1\");\n        if (!this.isShown)\n            return;\n        let b = false;\n        if (!this.isLocated)\n            return;\n        for (let i = 0; i < x.length; i++) {\n            const p = x[i];\n            if (this.updateAttributes.some((v) => v == p.attributeName)) {\n                b = true;\n            }\n            if (p.target == this.svgGroup) {\n                if (p.attributeName == \"x\" || p.attributeName == \"y\") {\n                    this.dispatchConnectPositionChangedEvent();\n                }\n            }\n            if (p.attributeName == \"transform\") {\n                this.dispatchConnectPositionChangedEvent();\n            }\n        }\n        if (b) {\n            //this.resetUnstableCounter();\n            //this.update();\n        }\n    }\n    /**\n     * \n     */\n    dispose() {\n    }\n    /**\n    True\n    */\n    get isDisposed() {\n        return false;\n        //return this.graph == null;\n    }\n    /**\n    VertexObjectID\n    */\n    get objectID() {\n        const r = this.svgGroup.getAttribute(AttributeNames.objectIDName);\n        if (r == null) {\n            throw new Error();\n        }\n        else {\n            return r;\n        }\n    }\n    createVBACode(id) {\n        const lines = [];\n        lines.push(`Sub create${id}(createdSlide As slide)`);\n        lines.push(`End Sub`);\n        return lines;\n    }\n    get VBAObjectNum() {\n        return 1;\n    }\n    dispatchObjectCreatedEvent() {\n        var event = document.createEvent(\"HTMLEvents\");\n        event.initEvent(AttributeNames.objectCreatedEventName, true, true);\n        this.svgGroup.dispatchEvent(event);\n    }\n    get isDynamic() {\n        const p = this.svgGroup.getAttribute(\"data-is-dynamic\");\n        return p == \"true\";\n    }\n    set isDynamic(value) {\n        this.svgGroup.setAttribute(\"data-is-dynamic\", value == true ? \"true\" : \"false\");\n    }\n    getUpdateFlag() {\n        return false;\n    }\n    update() {\n        if (!this._isInitialized) {\n            //throw new Error(\"This instance have not been initialized!\");\n            //return true;\n        }\n        else {\n            this._isUpdating = true;\n            this._isUpdating = false;\n            //return true;\n        }\n    }\n    dispatchConnectPositionChangedEvent() {\n        if (this.svgSurface != null) {\n            var event = document.createEvent(\"HTMLEvents\");\n            event.initEvent(AttributeNames.connectPositionChangedEventName, false, true);\n            this.svgGroup.dispatchEvent(event);\n        }\n    }\n    get hasSize() {\n        return false;\n    }\n    static getObjectFromIDOrObjectID(id) {\n        if (id instanceof SVGElement) {\n            if (id.hasAttribute(AttributeNames.objectIDName)) {\n                const _id = id.getAttribute(AttributeNames.objectIDName);\n                return ZObject.getObjectFromIDOrObjectID(_id);\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            if (id in this.objectDic) {\n                return this.objectDic[id];\n            }\n            else {\n                const element = document.getElementById(id);\n                if (element !== null && element.operator !== undefined && element.operator instanceof ZObject) {\n                    return element.operator;\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    }\n    static setObjectFromObjectID(obj) {\n        const id = obj.objectID;\n        this.objectDic[id] = obj;\n    }\n    static getObjectFromID(id) {\n        for (let key in this.objectDic) {\n            if (this.objectDic[key].svgGroup.id == id) {\n                return this.objectDic[key];\n            }\n        }\n        return null;\n    }\n    /**\n     * RectangleNode\n     */\n    getRegion() {\n        let rect = new vline_1.Rectangle();\n        rect.x = this.x;\n        rect.y = this.y;\n        rect.width = this.width;\n        rect.height = this.height;\n        return rect;\n    }\n    getVirtualWidth() {\n        return 0;\n    }\n    getVirtualHeight() {\n        return 0;\n    }\n    getVirtualRegion() {\n        let rect = new vline_1.Rectangle();\n        rect.x = this.x;\n        rect.y = this.y;\n        rect.width = this.width;\n        rect.height = this.height;\n        return rect;\n    }\n    movable() {\n        draggable_object_1.DraggableObjectFunctions.appendDragFunctionsToDocument();\n        draggable_object_1.DraggableObjectFunctions.draggable(this.svgSurface, this.svgGroup);\n    }\n    get allowHover() {\n        return this.svgGroup.getAttribute(AttributeNames.allowHoverName) == \"true\";\n    }\n    set allowHover(value) {\n        if (value) {\n            this.svgGroup.setAttribute(AttributeNames.allowHoverName, \"true\");\n        }\n        else {\n            this.svgGroup.setAttribute(AttributeNames.allowHoverName, \"false\");\n        }\n    }\n}\nexports.ZObject = ZObject;\nZObject.objectDic = {};\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_object.ts?");

/***/ }),

/***/ "./src/objects/z_observer.ts":
/*!***********************************!*\
  !*** ./src/objects/z_observer.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.updateTextByTimer = exports.updatePathByTimer = exports.ObjectStableFlagName = exports.svgPathLenName = exports.svgTextBBoxHeightName = exports.svgTextBBoxWidthName = exports.timerInterval = void 0;\nconst attribute_names_1 = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nexports.timerInterval = 100;\n//export const unstableCounterDefault = 10;\n//export const unstableCounterName = \"data-unstable-counter\";\nconst timerDic = new Map();\nexports.svgTextBBoxWidthName = \"data-bbox-width\";\nexports.svgTextBBoxHeightName = \"data-bbox-height\";\nexports.svgPathLenName = \"data-path-length\";\nexports.ObjectStableFlagName = \"data-stable-flag\";\nfunction bubbleFalse(obj) {\n    const objectID = obj.getAttribute(attribute_names_1.objectIDName);\n    if (objectID != null) {\n        const attr = obj.getAttribute(exports.ObjectStableFlagName);\n        if (attr != \"false\") {\n            obj.setAttribute(exports.ObjectStableFlagName, \"false\");\n        }\n    }\n    const parent = obj.parentElement;\n    if (parent instanceof SVGElement) {\n        if (!(parent instanceof SVGSVGElement)) {\n            bubbleFalse(parent);\n        }\n    }\n}\nfunction updatePathByTimer(svgPath) {\n    const pathLen = (0, vline_1.round100)(svgPath.getTotalLength());\n    let b = false;\n    let prevPathLen = 0;\n    if (svgPath.hasAttribute(exports.svgPathLenName)) {\n        prevPathLen = Number.parseFloat(svgPath.getAttribute(exports.svgPathLenName));\n        if (!(0, vline_1.nearlyEqual)(prevPathLen, pathLen)) {\n            svgPath.setAttribute(exports.svgPathLenName, pathLen.toString());\n            b = true;\n        }\n    }\n    else {\n        svgPath.setAttribute(exports.svgPathLenName, pathLen.toString());\n        b = true;\n    }\n    const stableFlag = svgPath.getAttribute(exports.ObjectStableFlagName);\n    if (b) {\n        bubbleFalse(svgPath);\n    }\n    else {\n        if (stableFlag == \"false\") {\n            svgPath.setAttribute(exports.ObjectStableFlagName, \"true\");\n        }\n    }\n    return b;\n}\nexports.updatePathByTimer = updatePathByTimer;\nfunction updateTextByTimer(svgText) {\n    const bbox = svgText.getBBox();\n    const width = (0, vline_1.round100)(bbox.width);\n    const height = (0, vline_1.round100)(bbox.height);\n    let b = false;\n    let prevWidth = 0;\n    let prevHeight = 0;\n    if (svgText.hasAttribute(exports.svgTextBBoxWidthName)) {\n        prevWidth = Number.parseFloat(svgText.getAttribute(exports.svgTextBBoxWidthName));\n        if (!(0, vline_1.nearlyEqual)(prevWidth, width)) {\n            svgText.setAttribute(exports.svgTextBBoxWidthName, width.toString());\n            b = true;\n        }\n    }\n    else {\n        svgText.setAttribute(exports.svgTextBBoxWidthName, width.toString());\n        b = true;\n    }\n    if (svgText.hasAttribute(exports.svgTextBBoxHeightName)) {\n        prevHeight = Number.parseFloat(svgText.getAttribute(exports.svgTextBBoxHeightName));\n        if (!(0, vline_1.nearlyEqual)(prevHeight, height)) {\n            svgText.setAttribute(exports.svgTextBBoxHeightName, height.toString());\n            b = true;\n        }\n    }\n    else {\n        svgText.setAttribute(exports.svgTextBBoxHeightName, height.toString());\n        b = true;\n    }\n    const stableFlag = svgText.getAttribute(exports.ObjectStableFlagName);\n    if (b) {\n        bubbleFalse(svgText);\n    }\n    else {\n        if (stableFlag == \"false\") {\n            svgText.setAttribute(exports.ObjectStableFlagName, \"true\");\n        }\n    }\n}\nexports.updateTextByTimer = updateTextByTimer;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_observer.ts?");

/***/ }),

/***/ "./src/objects/z_options.ts":
/*!**********************************!*\
  !*** ./src/objects/z_options.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setClassAndStyle = void 0;\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nfunction setClassAndStyle(svg, className, style) {\n    if (typeof (className) == \"string\") {\n        svg.setAttribute(\"class\", className);\n    }\n    else if (className === undefined) {\n    }\n    else if (className === null) {\n        svg.removeAttribute(\"class\");\n    }\n    else {\n        svg.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\n    }\n    if (typeof (style) == \"string\") {\n        svg.setAttribute(\"style\", style);\n    }\n    else if (style === undefined) {\n    }\n    else if (style === null) {\n        svg.removeAttribute(\"style\");\n    }\n    else {\n        const cssString = CSS.createCSSString(style);\n        svg.setAttribute(\"style\", cssString === undefined ? \"\" : cssString);\n    }\n}\nexports.setClassAndStyle = setClassAndStyle;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_options.ts?");

/***/ }),

/***/ "./src/objects/z_path_textbox.ts":
/*!***************************************!*\
  !*** ./src/objects/z_path_textbox.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/// <reference path=\"z_vertex.ts\"/>\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZPathTextBox = void 0;\n//namespace GraphTableSVG {\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nclass ZPathTextBox extends z_textbox_1.ZTextBox {\n    //private _svgPath: SVGPathElement;\n    get svgPath() {\n        return this.svgSurface;\n    }\n    constructor(svgbox) {\n        super(svgbox);\n        if (this.type == enums_1.ShapeObjectType.PathTextBox)\n            this.firstFunctionAfterInitialized();\n    }\n    createSurface(svgbox) {\n        this._svgSurface = ZPathTextBox.createSurfacePath(this.svgGroup, 0, 0, 0, 0, DefaultClassNames.defaultTextboxPathClass, undefined);\n        this.svgGroup.insertBefore(this.svgPath, this.svgText);\n    }\n    static createSurfacePath(parent, x, y, x2, y2, className, style) {\n        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n        parent.appendChild(path);\n        path.setAttribute(\"d\", `M ${x} ${y} L ${x2} ${y2}`);\n        GOptions.setClassAndStyle(path, className, style);\n        return path;\n    }\n    get type() {\n        return enums_1.ShapeObjectType.PathTextBox;\n    }\n    /**\n    * \n    * @param type\n    * @param x\n    * @param y\n    */\n    getContactPosition(type, x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        switch (type) {\n            case enums_1.ConnectorType.Top:\n                return [this.cx, this.cy - hr];\n            case enums_1.ConnectorType.TopRight:\n            case enums_1.ConnectorType.Right:\n            case enums_1.ConnectorType.BottomRight:\n                return [this.cx + wr, this.cy];\n            case enums_1.ConnectorType.Bottom:\n                return [this.cx, this.cy + hr];\n            case enums_1.ConnectorType.BottomLeft:\n            case enums_1.ConnectorType.Left:\n            case enums_1.ConnectorType.TopLeft:\n                return [this.cx - wr, this.cy];\n            default:\n                const autoType = this.getContactAutoPosition(x, y);\n                return this.getContactPosition(autoType, x, y);\n        }\n    }\n    getContactAutoPosition(x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        const line1 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy + hr);\n        const line2 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy - hr);\n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n        if (b1) {\n            if (b2) {\n                return enums_1.ConnectorType.Top;\n            }\n            else {\n                return enums_1.ConnectorType.Right;\n            }\n        }\n        else {\n            if (b2) {\n                return enums_1.ConnectorType.Left;\n            }\n            else {\n                return enums_1.ConnectorType.Bottom;\n            }\n        }\n    }\n}\nexports.ZPathTextBox = ZPathTextBox;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_path_textbox.ts?");

/***/ }),

/***/ "./src/objects/z_rect.ts":
/*!*******************************!*\
  !*** ./src/objects/z_rect.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZRect = void 0;\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\n/**\n * ZRect\n * <template data-path=\"sutoring.Factorizations\" data-module=\"LZ78\"></template>\n*/\nclass ZRect extends z_textbox_1.ZTextBox {\n    get svgRectangle() {\n        return this._svgSurface;\n    }\n    constructor(svgbox, option = null) {\n        super(svgbox);\n        this.updateAttributes.push(\"width\");\n        this.updateAttributes.push(\"height\");\n        //throw Error(\"error2\");\n        //this.update();\n        if (this.type == enums_1.ShapeObjectType.Rect)\n            this.firstFunctionAfterInitialized();\n    }\n    createSurface(svgbox) {\n        this._svgSurface = ZRect.createRectangle(this.svgGroup, DefaultClassNames.defaultSurfaceClass, undefined);\n        this.svgGroup.insertBefore(this.svgRectangle, this.svgText);\n    }\n    /**\n     * SVGRectElement\n     * @param parent SVG\n     * @param className SVG\n     * @returns SVGRectElement\n     */\n    static createRectangle(parent, className, style) {\n        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        rect.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Surface);\n        parent.appendChild(rect);\n        rect.width.baseVal.value = 30;\n        rect.height.baseVal.value = 30;\n        if (style !== undefined) {\n            if (typeof (style) == \"string\") {\n                rect.setAttribute(\"style\", style);\n            }\n            else {\n                rect.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\n            }\n        }\n        //if(style !== undefined) rect.setAttribute(\"style\", style);\n        if (className == null) {\n            if (rect.style.stroke == null || rect.style.stroke == \"\")\n                rect.style.stroke = \"black\";\n            if (rect.style.fill == null || rect.style.fill == \"\")\n                rect.style.fill = \"white\";\n            if (rect.style.strokeWidth == null || rect.style.strokeWidth == \"\")\n                rect.style.strokeWidth = \"1pt\";\n        }\n        else {\n            if (typeof (className) == \"string\") {\n                rect.setAttribute(\"class\", className);\n            }\n            else {\n                rect.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\n            }\n            //const dashStyle = rect.getPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName);\n            //if (dashStyle != null) msoDashStyle.setStyle(rect, dashStyle);\n            const width = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultWidth, null);\n            if (width != null) {\n                rect.width.baseVal.value = width;\n            }\n            const height = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultHeight, null);\n            if (height != null) {\n                rect.height.baseVal.value = height;\n            }\n        }\n        return rect;\n    }\n    /*\n    static constructAttributes(e: Element, removeAttributes: boolean = false, output: GOptions.ZTextBoxAttributes = {}): GOptions.ZTextBoxAttributes {\n        ZTextBox.constructAttributes(e, removeAttributes, output);\n\n        return output;\n    }\n    */\n    get type() {\n        return enums_1.ShapeObjectType.Rect;\n    }\n    /*\n     get innerRectangle(): Rectangle {\n         const rect = new Rectangle();\n         rect.width = this.width;\n         rect.height = this.height;\n         rect.x = (-this.width / 2);\n         rect.y = (-this.height / 2);\n\n         return rect;\n     }\n     */\n    /**\n    \n    */\n    get width() {\n        return (0, vline_1.round100)(this.svgRectangle.width.baseVal.value);\n    }\n    set width(value) {\n        //const value100 = round100(value);\n        //if (this.width != value100) this.svgRectangle.setAttribute(\"width\", value100.toString());\n        this.setWidthWithoutUpdate(value);\n        //this.update();\n    }\n    setWidthWithoutUpdate(value) {\n        const value100 = (0, vline_1.round100)(value);\n        if (this.width != value100) {\n            this.svgRectangle.setAttribute(\"width\", value100.toString());\n        }\n    }\n    /**\n    \n    */\n    get height() {\n        return (0, vline_1.round100)(this.svgRectangle.height.baseVal.value);\n    }\n    set height(value) {\n        this.setHeightWithoutUpdate(value);\n        //this.update();\n    }\n    setHeightWithoutUpdate(value) {\n        const value100 = (0, vline_1.round100)(value);\n        if (this.height != value100)\n            this.svgRectangle.setAttribute(\"height\", value100.toString());\n    }\n    get surfaceRegion() {\n        const x = this.svgRectangle.x.baseVal.value;\n        const y = this.svgRectangle.y.baseVal.value;\n        const w = this.width;\n        const h = this.height;\n        return new vline_1.Rectangle(x, y, w, h);\n    }\n    updateSurfaceLocation() {\n        const virtualRegion = this.getVirtualRegion();\n        this.svgRectangle.x.baseVal.value = -virtualRegion.width / 2;\n        this.svgRectangle.y.baseVal.value = -virtualRegion.height / 2;\n        return false;\n    }\n    /*\n    protected updateSurface() {\n        this.hasConnectedObserverFunction = false;\n        const dashStyle = this.msoDashStyle;\n        if (dashStyle != null) {\n            setComputedDashArray(this.svgRectangle);\n        }\n        this.hasConnectedObserverFunction = true;\n        //this._observer.observe(this.svgGroup, this._observerOption);\n    }\n    */\n    /**\n            * \n            * @param type\n            * @param x\n            * @param y\n            */\n    getContactPosition(type, x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        switch (type) {\n            case enums_1.ConnectorType.Top:\n                return [this.cx, this.cy - hr];\n            case enums_1.ConnectorType.TopRight:\n            case enums_1.ConnectorType.Right:\n            case enums_1.ConnectorType.BottomRight:\n                return [this.cx + wr, this.cy];\n            case enums_1.ConnectorType.Bottom:\n                return [this.cx, this.cy + hr];\n            case enums_1.ConnectorType.BottomLeft:\n            case enums_1.ConnectorType.Left:\n            case enums_1.ConnectorType.TopLeft:\n                return [this.cx - wr, this.cy];\n            default:\n                const autoType = this.getContactAutoPosition(x, y);\n                return this.getContactPosition(autoType, x, y);\n        }\n    }\n    getContactAutoPosition(x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        const line1 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy + hr);\n        const line2 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy - hr);\n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n        if (b1) {\n            if (b2) {\n                return enums_1.ConnectorType.Top;\n            }\n            else {\n                return enums_1.ConnectorType.Right;\n            }\n        }\n        else {\n            if (b2) {\n                return enums_1.ConnectorType.Left;\n            }\n            else {\n                return enums_1.ConnectorType.Bottom;\n            }\n        }\n    }\n    get shape() {\n        return enums_1.VBAShapeType.Rectangle;\n    }\n}\nexports.ZRect = ZRect;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_rect.ts?");

/***/ }),

/***/ "./src/objects/z_rect_button.ts":
/*!**************************************!*\
  !*** ./src/objects/z_rect_button.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZRectButton = void 0;\n//namespace GraphTableSVG {\nconst z_rect_1 = __webpack_require__(/*! ./z_rect */ \"./src/objects/z_rect.ts\");\n//import {ZTextBoxAttributes, ZObjectAttributes} from \"../options/attributes_option\"\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common/index.ts\");\n/**\n * ZRectButton\n */\nclass ZRectButton extends z_rect_1.ZRect {\n    constructor(svgbox) {\n        super(svgbox);\n        this.svgGroup.setAttribute(\"class\", common_1.DefaultClassNames.defaultRectButtonClass);\n        this.svgGroup.setAttribute(\"cursor\", \"pointer\");\n        //this.update();\n        if (this.type == enums_1.ShapeObjectType.RectButton)\n            this.firstFunctionAfterInitialized();\n    }\n    get defaultClassName() {\n        return undefined;\n        //return GraphTableSVG.AttributeNames.StyleValue.defaultRectButtonClass;\n    }\n    get type() {\n        return enums_1.ShapeObjectType.RectButton;\n    }\n}\nexports.ZRectButton = ZRectButton;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_rect_button.ts?");

/***/ }),

/***/ "./src/objects/z_table.ts":
/*!********************************!*\
  !*** ./src/objects/z_table.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZTable = void 0;\nconst Color = __webpack_require__(/*! ../common/color */ \"./src/common/color.ts\");\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\n//import {GTableOption} from \"../options/attributes_option\"\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst gobject_functions_1 = __webpack_require__(/*! ../logics/gobject_functions */ \"./src/logics/gobject_functions.ts\");\nconst row_1 = __webpack_require__(/*! ./table_helpers/row */ \"./src/objects/table_helpers/row.ts\");\nconst column_1 = __webpack_require__(/*! ./table_helpers/column */ \"./src/objects/table_helpers/column.ts\");\nconst border_row_1 = __webpack_require__(/*! ./table_helpers/border_row */ \"./src/objects/table_helpers/border_row.ts\");\nconst border_column_1 = __webpack_require__(/*! ./table_helpers/border_column */ \"./src/objects/table_helpers/border_column.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./src/common/vba_functions.ts\");\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nconst update_table_1 = __webpack_require__(/*! ./table_helpers/update_table */ \"./src/objects/table_helpers/update_table.ts\");\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common/index.ts\");\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\n/**\n\n*/\nclass ZTable extends z_vertex_1.ZVertex {\n    /**\n     * \n     */\n    constructor(svgbox) {\n        super(svgbox);\n        this._cellMap = new Map();\n        /*\n        protected setBasicOption(option: ZTableOption): void {\n            super.setBasicOption(option);\n            const columnCount = option.columnCount !== undefined ? option.columnCount : 5;\n            const rowCount = option.rowCount !== undefined ? option.rowCount : 5;\n            this.setSize(columnCount, rowCount);\n    \n        }\n        */\n        /*\n        protected setOptionalSize(option: ZTableOption) {\n            super.setOptionalSize(option);\n            if (option.rowHeight !== undefined) {\n                this.rows.forEach((v) => v.height = <number>option.rowHeight);\n            }\n            if (option.columnWidth !== undefined) {\n                this.columns.forEach((v) => v.width = <number>option.columnWidth);\n            }\n        }\n        */\n        /*\n         public setOption(option: ZTableOption) {\n             super.setOption(option);\n         }\n         */\n        /*\n         public assignOption(option : TableOptionReteral){\n             super.assignOption(option);\n     \n         }\n         */\n        this._isNoneMode = false;\n        /**\n        \n        */\n        this._rows = new Array(0);\n        /**\n        \n        */\n        this._columns = new Array(0);\n        this._borderRows = new Array(0);\n        this._borderColumns = new Array(0);\n        //private _cells: Cell[][] = [];\n        this.isConstructing = false;\n        this._isDrawing = false;\n        this._isAutoResized = false;\n        this._cellTextObserverFunc = (x) => {\n            let b = false;\n            let b2 = false;\n            for (let i = 0; i < x.length; i++) {\n                const p = x[i];\n                if (p.type == \"childList\") {\n                    b = true;\n                    b2 = true;\n                }\n                for (let j = 0; j < p.addedNodes.length; j++) {\n                    const item = p.addedNodes.item(j);\n                    if (item != null && item.nodeName.toLowerCase() == \"#text\") {\n                        b = true;\n                        b2 = true;\n                    }\n                }\n            }\n            if (b2 && !this.isConstructing) {\n                //if(this.cellArray.some((v)=>v.isErrorCell)) throw new Error(\"err!\");\n                //this.fitSizeToOriginalCells(false);\n                //this.fitSizeToOriginalCells(true);\n            }\n            if (b) {\n                //this.resetUnstableCounter();\n                //this.update();\n            }\n        };\n        // #endregion\n        this._isTextObserved = false;\n        this.isSetSize = false;\n        CSS.setGraphTableCSS();\n        this._svgHiddenGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        this._svgRowBorderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        this._svgRowBorderGroup.setAttribute(\"name\", \"rowBorderGroup\");\n        this._svgColumnBorderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        this._svgColumnBorderGroup.setAttribute(\"name\", \"columnBorderGroup\");\n        this._svgColumnInfo = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');\n        this._svgColumnInfo.setAttribute(\"name\", \"columnInfo\");\n        this._svgHiddenGroup.style.visibility = \"hidden\";\n        this._svgHiddenGroup.setAttribute(\"name\", \"hidden\");\n        this.svgGroup.appendChild(this.svgRowBorderGroup);\n        this.svgGroup.appendChild(this.svgColumnBorderGroup);\n        this.svgGroup.appendChild(this.svgHiddenGroup);\n        this.svgGroup.appendChild(this.svgColumnInfo);\n        this._cellTextObserver = new MutationObserver(this._cellTextObserverFunc);\n        this.updateAttributes = [];\n        this.isConstructing = true;\n        this.firstSetSize();\n        this.setSize(1, 1);\n        /*\n        if (option.table === undefined) {\n\n            //this.update();\n\n        } else {\n\n            this.svgGroup.style.display = \"none\"\n            this._isNoneMode = true;\n\n            this.buildFromLogicTable(option.table);\n\n            this._isNoneMode = false;\n\n            this.svgGroup.style.removeProperty(\"display\");\n            this.isTextObserved = true;\n\n        }\n        */\n        //if (option.cx !== undefined) this.cx = option.cx;\n        //if (option.cy !== undefined) this.cy = option.cy;\n        //this.setOptionInGTable(option)\n        this.isConstructing = false;\n        //this.update();\n        if (this.type == enums_1.ShapeObjectType.Table)\n            this.firstFunctionAfterInitialized();\n    }\n    getCellFromObjectID(id) {\n        const cell = this._cellMap.get(id);\n        if (cell == undefined) {\n            return null;\n        }\n        else {\n            return cell;\n        }\n    }\n    get isNoneMode() {\n        return this._isNoneMode;\n    }\n    get isCenterBased() {\n        return false;\n    }\n    updateSurfaceWithoutSVGText() {\n        const withUpdate = true;\n        this.hasConnectedObserverFunction = false;\n        const xb = HTMLFunctions.isShow(this.svgGroup);\n        if (!xb) {\n            return false;\n        }\n        this._isDrawing = true;\n        const b1 = update_table_1.UpdateTable.tryUpdateRowHeightAndColumnWidthWithUpdateFlag(this.rows, this.columns, true, withUpdate);\n        const b2 = update_table_1.UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns(this.rows, this.columns, withUpdate);\n        const b3 = update_table_1.UpdateTable.relocateCellsAfterUpdatingCellSize(this.rows, this.columns, withUpdate);\n        const b4 = update_table_1.UpdateTable.tryUpdateBorders(this.createCellArray(), withUpdate);\n        this._isDrawing = false;\n        this.hasConnectedObserverFunction = true;\n        return b1 || b2 || b3 || b4;\n        //this.prevShow = false;\n        //b = this.tryResizeWithUpdateFlag(withUpdate) || b;\n    }\n    get svgRowBorderGroup() {\n        return this._svgRowBorderGroup;\n    }\n    get svgColumnBorderGroup() {\n        return this._svgColumnBorderGroup;\n    }\n    get svgColumnInfo() {\n        return this._svgColumnInfo;\n    }\n    get borderRows() {\n        return this._borderRows;\n    }\n    get borderColumns() {\n        return this._borderColumns;\n    }\n    get shape() {\n        return enums_1.VBAShapeType.Table;\n    }\n    get width() {\n        if (this.columns === undefined) {\n            return 0;\n        }\n        else {\n            let width = 0;\n            this.columns.forEach((v) => width += v.width);\n            return width;\n        }\n    }\n    set width(value) {\n    }\n    get height() {\n        if (this.rows === undefined) {\n            return 0;\n        }\n        else {\n            let height = 0;\n            this.rows.forEach((v) => height += v.height);\n            return height;\n        }\n    }\n    set height(value) {\n    }\n    /**\n     * mergeBorderSVGGElement\n     */\n    get svgHiddenGroup() {\n        return this._svgHiddenGroup;\n    }\n    get type() {\n        return enums_1.ShapeObjectType.Table;\n    }\n    /**\n    \n    */\n    get rows() {\n        return this._rows;\n    }\n    /**\n    \n    */\n    get columns() {\n        return this._columns;\n    }\n    /**\n    \n    */\n    get cells() {\n        return this.rows.map((v) => v.cells);\n    }\n    get isDrawing() {\n        return this._isDrawing;\n    }\n    get isAutoResized() {\n        return this._isAutoResized;\n    }\n    set isAutoResized(value) {\n        this._isAutoResized = value;\n        if (value) {\n            //this.resetUnstableCounter();\n            //this.update();\n        }\n    }\n    get cellTextObserver() {\n        return this._cellTextObserver;\n    }\n    /**\n    * \n    * @returns \n    */\n    get columnCount() {\n        if (this.cells.length == 0) {\n            return 0;\n        }\n        else {\n            if (this.rows.length > 2 && (this.rows[0].length != this.rows[1].length))\n                throw new Error(\"Invalid length error\");\n            return this.rows[0].length;\n        }\n    }\n    /**\n    * \n    * @returns \n    */\n    get rowCount() {\n        return this.cells.length;\n    }\n    // #endregion\n    // #region property\n    /*\n     get defaultCellClass(): string | null {\n         return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultCellClass);\n     }\n     */\n    /*\n     get defaultBorderClass(): string | null {\n         return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultBorderClass);\n     }\n     */\n    /**\n    \n    \n    */\n    createCellArray() {\n        const arr = new Array(0);\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                arr.push(this.cells[y][x]);\n            }\n        }\n        return arr;\n    }\n    /**\n    \n    \n    \n    */\n    get borders() {\n        const arr = new Array(0);\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                if (arr.indexOf(this.cells[y][x].svgTopBorder) == -1) {\n                    arr.push(this.cells[y][x].svgTopBorder);\n                }\n                if (arr.indexOf(this.cells[y][x].svgLeftBorder) == -1) {\n                    arr.push(this.cells[y][x].svgLeftBorder);\n                }\n                if (arr.indexOf(this.cells[y][x].svgRightBorder) == -1) {\n                    arr.push(this.cells[y][x].svgRightBorder);\n                }\n                if (arr.indexOf(this.cells[y][x].svgBottomBorder) == -1) {\n                    arr.push(this.cells[y][x].svgBottomBorder);\n                }\n            }\n        }\n        return arr;\n    }\n    // #endregion\n    /*\n    public fitSizeToOriginalCellsWithUpdateFlag(allowShrink: boolean, withUpdate : boolean) : boolean {\n        let b = false;\n        for(let i = 0;i<this.rows.length;i++){\n            b = this.rows[i].tryUpdateHeightWithUpdateFlag(allowShrink, withUpdate) || b;\n            if(!withUpdate && b){\n                return b;\n            }\n        }\n        for(let i = 0;i<this.columns.length;i++){\n            b = this.columns[i].tryUpdateWidthWithUpdateFlag(allowShrink, withUpdate) || b;\n            if(!withUpdate && b){\n                return b;\n            }\n        }\n        return b;\n    }\n    */\n    // #region method\n    /**\n     * \n     * @param allowShrink \n     */\n    // public fitSizeToOriginalCells(allowShrink: boolean) {\n    //    this.fitSizeToOriginalCellsWithUpdateFlag(allowShrink, true);\n    //}\n    /**\n     * null\n     * @param x \n     * @param y \n     */\n    getTryCell(x, y) {\n        if (x < 0 || x >= this.columnCount || y < 0 || y >= this.rowCount) {\n            return null;\n        }\n        else {\n            return this.cells[y][x];\n        }\n    }\n    /**\n     * \n     * @param x \n     * @param y \n     * @param width \n     * @param height \n     */\n    getRangeCells(x, y, width, height) {\n        let cells = new Array(height);\n        for (let i = 0; i < cells.length; i++) {\n            cells[i] = new Array(0);\n            for (let j = 0; j < width; j++) {\n                cells[i].push(this.cells[y + i][x + j]);\n            }\n        }\n        return cells;\n    }\n    /**\n     * \n     * @param x \n     * @param y \n     * @param width \n     * @param height \n     */\n    getRangeCellArray(x, y, width, height) {\n        let cells = new Array();\n        this.getRangeCells(x, y, width, height).forEach((v) => { v.forEach((w) => { cells.push(w); }); });\n        return cells;\n    }\n    /**\n    SVGRectangle\n    */\n    getRegion() {\n        let rect = new vline_1.Rectangle();\n        rect.x = SVGGExtension.getX(this.svgGroup);\n        rect.y = SVGGExtension.getY(this.svgGroup);\n        rect.width = this.width;\n        rect.height = this.height;\n        return rect;\n        /*\n        const regions = this.cellArray.map((v) => v.region);\n        const rect = Rectangle.merge(regions);\n        rect.addOffset(this.svgGroup.getX(), this.svgGroup.getY());\n        return rect;\n        */\n    }\n    /**\n    * \n    */\n    getEmphasizedCells() {\n        return this.createCellArray().filter((v) => v.isEmphasized);\n    }\n    /**\n    * \n    */\n    toPlainText() {\n        const plainTable = this.cells.map((v) => v.map((w) => w.toPlainText()));\n        const widtharr = new Array(this.columnCount);\n        for (let x = 0; x < this.columnCount; x++) {\n            widtharr[x] = 0;\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const width = plainTable[y][x].length;\n                if (widtharr[x] < width)\n                    widtharr[x] = width;\n            }\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                plainTable[y][x] = CommonFunctions.paddingLeft(plainTable[y][x], widtharr[x], \" \");\n            }\n        }\n        return plainTable.map((v) => v.join(\",\")).join(\"\\n\");\n    }\n    get isTextObserved() {\n        return this._isTextObserved;\n    }\n    set isTextObserved(b) {\n        if (this._isTextObserved != b) {\n            if (this._isTextObserved) {\n                this.cellTextObserver.disconnect();\n            }\n            else {\n                const option1 = { childList: true, subtree: true };\n                this.createCellArray().forEach((v) => {\n                    this.cellTextObserver.observe(v.svgText, option1);\n                });\n            }\n        }\n    }\n    // #region construct2\n    updateCellByLogicCell(logicTable, x, y) {\n        const cell = this.cells[y][x];\n        //const isShow = HTMLFunctions.(this.svgGroup);\n        if (logicTable != null) {\n            const cellInfo = logicTable.cells[y][x];\n            if (cellInfo != null) {\n                //CSS.setCSSClass(cell.svgGroup, cellInfo.cellClass);\n                GOptions.setClassAndStyle(cell.svgGroup, cellInfo.option.class, cellInfo.option.style);\n                GOptions.setClassAndStyle(cell.svgSurface, cellInfo.backgroundOption.class, cellInfo.backgroundOption.style);\n                (0, gobject_functions_1.createTextElementFromLogicCell)(cellInfo, cell.svgText);\n                GOptions.setClassAndStyle(cell.svgTopBorder, cellInfo.topBorderOption.class, cellInfo.topBorderOption.style);\n                GOptions.setClassAndStyle(cell.svgLeftBorder, cellInfo.leftBorderOption.class, cellInfo.leftBorderOption.style);\n                GOptions.setClassAndStyle(cell.svgRightBorder, cellInfo.rightBorderOption.class, cellInfo.rightBorderOption.style);\n                GOptions.setClassAndStyle(cell.svgBottomBorder, cellInfo.bottomBorderOption.class, cellInfo.bottomBorderOption.style);\n            }\n        }\n    }\n    updateCell(sourceCell, x, y) {\n        const cell = this.cells[y][x];\n        /*\n        GOptions.setClassAndStyle(cell.svgGroup, cellInfo.option.class, cellInfo.option.style);\n        GOptions.setClassAndStyle(cell.svgBackground, cellInfo.backgroundOption.class, cellInfo.backgroundOption.style);\n        */\n        z_object_1.ZObject.setSubAttributes(cell.svgSurface, sourceCell);\n        z_object_1.ZObject.setSubAttributes(cell.svgText, sourceCell);\n        z_textbox_1.ZTextBox.importTextFromSource(cell.svgText, null, sourceCell);\n        z_object_1.ZObject.setSubAttributesWithObjName(cell.svgTopBorder, \"topborder\", sourceCell);\n        z_object_1.ZObject.setSubAttributesWithObjName(cell.svgLeftBorder, \"leftborder\", sourceCell);\n        z_object_1.ZObject.setSubAttributesWithObjName(cell.svgRightBorder, \"rightborder\", sourceCell);\n        z_object_1.ZObject.setSubAttributesWithObjName(cell.svgBottomBorder, \"bottomborder\", sourceCell);\n        /*\n        GOptions.setClassAndStyle(cell.svgTopBorder, cellInfo.topBorderOption.class, cellInfo.topBorderOption.style);\n        GOptions.setClassAndStyle(cell.svgLeftBorder, cellInfo.leftBorderOption.class, cellInfo.leftBorderOption.style);\n        GOptions.setClassAndStyle(cell.svgRightBorder, cellInfo.rightBorderOption.class, cellInfo.rightBorderOption.style);\n        GOptions.setClassAndStyle(cell.svgBottomBorder, cellInfo.bottomBorderOption.class, cellInfo.bottomBorderOption.style);\n        */\n        while (sourceCell.attributes.length > 0) {\n            const attr = sourceCell.attributes.item(0);\n            if (attr != null) {\n                cell.svgGroup.setAttribute(attr.name, attr.value);\n                sourceCell.removeAttribute(attr.name);\n            }\n        }\n    }\n    getRowCountAndColumnCount(source) {\n        const rows = HTMLFunctions.getChildren(source).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"row\").map((v) => v);\n        const cells = new Array(rows.length);\n        let columnSize = 0;\n        rows.forEach((v, i) => {\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"cell\");\n            cells[i] = cellArray;\n            if (columnSize < cellArray.length)\n                columnSize = cellArray.length;\n        });\n        return [rows.length, columnSize];\n    }\n    getRowHeightAndColumnWidth(source, rowCount, columnCount) {\n        const rArray = new Array(rowCount);\n        for (let i = 0; i < rowCount; i++) {\n            rArray[i] = 0;\n        }\n        const cArray = new Array(columnCount);\n        for (let i = 0; i < columnCount; i++) {\n            cArray[i] = 0;\n        }\n        const rows = HTMLFunctions.getChildren(source).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"row\").map((v) => v);\n        rows.forEach((v, y) => {\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"cell\");\n            cellArray.forEach((w, x) => {\n                const attr_w = HTMLFunctions.getAttributeFromAncestors(w, \"column::width\");\n                if (attr_w != null) {\n                    const attr_nw = Number.parseInt(attr_w);\n                    cArray[x] = Math.max(cArray[x], attr_nw);\n                }\n                const attr_h = HTMLFunctions.getAttributeFromAncestors(w, \"row::height\");\n                if (attr_h != null) {\n                    const attr_nh = Number.parseInt(attr_h);\n                    rArray[y] = Math.max(rArray[y], attr_nh);\n                }\n            });\n        });\n        return [rArray, cArray];\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        const [rowCount, columnCount] = this.getRowCountAndColumnCount(source);\n        this.setSize(columnCount, rowCount);\n        const [rArray, cArray] = this.getRowHeightAndColumnWidth(source, rowCount, columnCount);\n        rArray.forEach((minimumHeight, y) => {\n            if (minimumHeight != 0) {\n                this.rows[y].minimumHeight = minimumHeight;\n            }\n        });\n        cArray.forEach((minimumWidth, x) => {\n            if (minimumWidth != 0) {\n                this.columns[x].minimumWidth = minimumWidth;\n            }\n        });\n        const rows = HTMLFunctions.getChildren(source).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"row\").map((v) => v);\n        rows.forEach((v, y) => {\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"cell\");\n            cellArray.forEach((w, x) => {\n                if (w instanceof SVGElement) {\n                    this.updateCell(w, x, y);\n                }\n            });\n        });\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const cell = this.cells[y][x];\n                const merge_w = ElementExtension._getAttributeNumber(cell.svgGroup, common_1.AttributeNames.w, true);\n                const merge_h = ElementExtension._getAttributeNumber(cell.svgGroup, common_1.AttributeNames.h, true);\n                const mw = merge_w == null ? 1 : (merge_w < 1 ? 1 : merge_w);\n                const mh = merge_h == null ? 1 : (merge_h < 1 ? 1 : merge_h);\n                if (mw > 1 || mh > 1) {\n                    if (cell.canMerge(mw, mh)) {\n                        cell.merge(mw, mh);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * LogicTableTable\n     * @param logicTable LogicTable\n     */\n    buildFromLogicTable(logicTable) {\n        var _a, _b;\n        const option = Object.assign({}, logicTable.option);\n        option.rowCount = logicTable.rowCount;\n        option.columnCount = logicTable.columnCount;\n        const columnCount = (_a = option.columnCount) !== null && _a !== void 0 ? _a : 5;\n        const rowCount = (_b = option.rowCount) !== null && _b !== void 0 ? _b : 5;\n        this.setSize(columnCount, rowCount);\n        if (option.rowHeight !== undefined) {\n            this.rows.forEach((v) => v.height = option.rowHeight);\n        }\n        if (option.columnWidth !== undefined) {\n            this.columns.forEach((v) => v.width = option.columnWidth);\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                this.updateCellByLogicCell(logicTable, x, y);\n            }\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const cell = this.cells[y][x];\n                const logicCell = logicTable.cells[y][x];\n                if (logicCell.connectedColumnCount > 1 || logicCell.connectedRowCount > 1) {\n                    if (cell.canMerge(logicCell.connectedColumnCount, logicCell.connectedRowCount)) {\n                        cell.merge(logicCell.connectedColumnCount, logicCell.connectedRowCount);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * \n     * @param table \n     * @param option \n     * @param option.x x\n     * @param option.y y\n     * @param option.rowHeight (px)\n     * @param option.columnWidth (px)\n     * @param option.tableClassName (svgGroup)\n     * @param option.isLatexMode TrueLatex\n     *\n     */\n    construct(table, option = {}) {\n        if (option.isLatexMode == undefined)\n            option.isLatexMode = false;\n        if (option.x == undefined)\n            option.x = 0;\n        if (option.y == undefined)\n            option.y = 0;\n        [this.cx, this.cy] = [option.x, option.y];\n        this.clear();\n        let width = 0;\n        table.forEach((v) => { if (v.length > width)\n            width = v.length; });\n        let height = table.length;\n        this.setSize(width, height);\n        table.forEach((v, y) => {\n            v.forEach((str, x) => {\n                SVGTextExtension.setTextContent(this.cells[y][x].svgText, str, option.isLatexMode);\n            });\n        });\n        if (option.rowHeight != undefined) {\n            this.rows.forEach((v) => v.height = option.rowHeight);\n        }\n        if (option.columnWidth != undefined) {\n            this.columns.forEach((v) => v.width = option.columnWidth);\n        }\n    }\n    // #endregion\n    // #region vba\n    /**\n     * VBA\n     * @param id\n     * @param slide\n     */\n    createVBACode(id) {\n        const lines = new Array(0);\n        lines.push(`Sub create${id}(createdSlide As slide)`);\n        const [main, sub] = this.createVBAMainCode(\"createdSlide\", id);\n        lines.push(main);\n        lines.push(`End Sub`);\n        lines.push(sub);\n        return lines;\n    }\n    /**\n     * VBA\n     */\n    createVBAMainCode(slideName, id) {\n        const fstLines = [];\n        const lines = new Array(0);\n        fstLines.push(` Dim tableS As shape`);\n        fstLines.push(` Dim table_ As table`);\n        //lines.push(` Set tableS = CreateTable(createdSlide, ${table.height}, ${table.width})`);\n        fstLines.push(` Set tableS = ${slideName}.Shapes.AddTable(${this.rowCount}, ${this.columnCount})`);\n        fstLines.push(` tableS.Left = ${SVGGExtension.getX(this.svgGroup)}`);\n        fstLines.push(` tableS.Top = ${SVGGExtension.getY(this.svgGroup)}`);\n        //const backColor = VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface!, \"fill\", \"gray\"));\n        //const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface!, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n        fstLines.push(` tableS.name = \"${this.objectID}\"`);\n        //page.Shapes.AddTable(row_, column_)\n        fstLines.push(` Set table_ = tableS.table`);\n        const tableName = \"table_\";\n        for (let y = 0; y < this.rowCount; y++) {\n            lines.push([` Call EditRow(${tableName}.Rows(${y + 1}), ${this.rows[y].height})`]);\n        }\n        for (let x = 0; x < this.columnCount; x++) {\n            lines.push([` Call EditColumn(${tableName}.Columns(${x + 1}), ${this.columns[x].width})`]);\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const cell = this.cells[y][x];\n                let color = Color.createRGBFromColorName(ElementExtension.getPropertyStyleValueWithDefault(cell.svgSurface, \"fill\", \"gray\"));\n                //const style = cell.svgBackground.style.fill != null ? VBATranslateFunctions.colorToVBA(cell.svgBackground.style.fill) : \"\";\n                vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement(lines, this.cells[y][x].svgText, `${tableName}.cell(${y + 1},${x + 1}).Shape.TextFrame.TextRange`);\n                lines.push([`${tableName}.cell(${y + 1},${x + 1}).Shape.Fill.ForeColor.RGB = RGB(CInt(${color.r}), CInt(${color.g}), CInt(${color.b}))`]);\n                //lines.push(` Call EditCell(${tableName}.cell(${y + 1},${x + 1}), \"${cell.svgText.textContent}\", ${color})`);\n            }\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const cell = this.cells[y][x];\n                const vAnchor = vba_functions_1.VBATranslateFunctions.ToVerticalAnchor(cell.verticalAnchor);\n                const hAnchor = vba_functions_1.VBATranslateFunctions.ToHorizontalAnchor(cell.horizontalAnchor);\n                lines.push([` Call EditCellTextFrame(${tableName}.cell(${y + 1},${x + 1}).Shape.TextFrame, ${cell.paddingTop}, ${cell.paddingBottom}, ${cell.paddingLeft}, ${cell.paddingRight}, ${vAnchor}, ${hAnchor})`]);\n            }\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const cell = this.cells[y][x];\n                const upLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgTopBorder, \"stroke\", \"gray\"));\n                const upLineStrokeWidth = cell.svgTopBorder.style.strokeWidth != null ? (0, vba_functions_1.parseInteger)(cell.svgTopBorder.style.strokeWidth) : \"\";\n                const upLineVisibility = cell.svgTopBorder.style.visibility != null ? (0, vba_functions_1.styleVisible)(cell.svgTopBorder.style) : \"\";\n                lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderTop), ${upLineStyle}, ${upLineStrokeWidth}, ${upLineVisibility})`]);\n                const leftLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgLeftBorder, \"stroke\", \"gray\"));\n                const leftLineStrokeWidth = cell.svgLeftBorder.style.strokeWidth != null ? (0, vba_functions_1.parseInteger)(cell.svgLeftBorder.style.strokeWidth) : \"\";\n                const leftLineVisibility = cell.svgLeftBorder.style.visibility != null ? (0, vba_functions_1.styleVisible)(cell.svgLeftBorder.style) : \"\";\n                lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderLeft), ${leftLineStyle}, ${leftLineStrokeWidth}, ${leftLineVisibility})`]);\n                if (x + 1 == this.columnCount) {\n                    const rightLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgRightBorder, \"stroke\", \"gray\"));\n                    const rightLineStrokeWidth = cell.svgRightBorder.style.strokeWidth != null ? (0, vba_functions_1.parseInteger)(cell.svgRightBorder.style.strokeWidth) : \"\";\n                    const rightLineVisibility = cell.svgRightBorder.style.visibility != null ? (0, vba_functions_1.styleVisible)(cell.svgRightBorder.style) : \"\";\n                    lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderRight), ${rightLineStyle}, ${rightLineStrokeWidth}, ${rightLineVisibility})`]);\n                }\n                if (y + 1 == this.rowCount) {\n                    const bottomLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgBottomBorder, \"stroke\", \"gray\"));\n                    const bottomLineStrokeWidth = cell.svgBottomBorder.style.strokeWidth != null ? (0, vba_functions_1.parseInteger)(cell.svgBottomBorder.style.strokeWidth) : \"\";\n                    const bottomLineVisibility = cell.svgBottomBorder.style.visibility != null ? (0, vba_functions_1.styleVisible)(cell.svgBottomBorder.style) : \"\";\n                    lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderBottom), ${bottomLineStyle}, ${bottomLineStrokeWidth}, ${bottomLineVisibility})`]);\n                }\n            }\n        }\n        this.createCellArray().forEach((v) => {\n            if (v.isMaster) {\n                const cells = v.cellsInGroup;\n                for (let y = 0; y < cells.length; y++) {\n                    for (let x = 1; x < cells[y].length; x++) {\n                        lines.push([` ${tableName}.Cell(${cells[y][0].cellY + 1}, ${cells[y][0].cellX + 1}).Merge MergeTo := ${tableName}.Cell(${cells[y][x].cellY + 1}, ${cells[y][x].cellX + 1})`]);\n                    }\n                }\n                for (let y = 1; y < cells.length; y++) {\n                    lines.push([` ${tableName}.Cell(${cells[0][0].cellY + 1}, ${cells[0][0].cellX + 1}).Merge MergeTo := ${tableName}.Cell(${cells[y][0].cellY + 1}, ${cells[y][0].cellX + 1})`]);\n                }\n            }\n        });\n        const x0 = vba_functions_1.VBATranslateFunctions.joinLines(fstLines);\n        const [x1, y1] = vba_functions_1.VBATranslateFunctions.splitCode(lines, `${tableName} as Table`, `${tableName}`, id);\n        return [vba_functions_1.VBATranslateFunctions.joinLines([x0, x1]), y1];\n    }\n    // #endregion\n    //private _updateCounter = 0;\n    // #region dynamic\n    /**\n     * \n     */\n    /*\n    private createCell(cellX: number, cellY: number): Cell {\n        const cellClass = this.defaultCellClass == null ? undefined : this.defaultCellClass;\n        const borderClass = this.defaultBorderClass == null ? undefined : this.defaultBorderClass;\n\n        const option: CellOption = { cellClass: cellClass, borderClass: borderClass };\n        return new Cell(this, cellX, cellY, option);\n    }\n    */\n    /*\n    Dynamic Method\n    */\n    /**\n     * \n     * @param svg SVG\n     */\n    removeTable(svg) {\n        if (svg.contains(this.svgGroup)) {\n            svg.removeChild(this.svgGroup);\n        }\n    }\n    firstSetSize() {\n        this.createRowBorder(0, 1);\n        this.createRowBorder(1, 1);\n        this.createColumnBorder(0, 1);\n        this.createColumnBorder(1, 1);\n        this._rows.splice(0, 0, new row_1.CellRow(this, 0, undefined));\n        this._rows[0]._appendCell(this._cellMap);\n        this._columns.splice(0, 0, new column_1.CellColumn(this, 0));\n    }\n    borderSizeCheck(_w, _h) {\n        const w = this.borderRows[0].borders.length;\n        const h = this.borderColumns[0].borders.length;\n        if (w != _w)\n            throw Error(`error ${_w} ${_h} ${w} ${h}`);\n        if (h != _h)\n            throw Error(`error ${_w} ${_h} ${w} ${h}`);\n        this.borderRows.forEach((v, i) => {\n            if (w != v.borders.length)\n                throw Error(\"border rows error\");\n        });\n        this.borderColumns.forEach((v, i) => {\n            if (h != v.borders.length)\n                throw Error(`border column error ${h} ${v.borders.length} ${i}`);\n        });\n        //return [w, h];\n    }\n    /**\n     * \n     * @param columnCount \n     * @param rowCount \n     */\n    setSize(columnCount, rowCount) {\n        this.clear();\n        this.isSetSize = true;\n        const borderRowCount = rowCount + 1;\n        const borderColumnCount = columnCount + 1;\n        if (this.rowCount == 0 || this.columnCount == 0)\n            throw Error(\"Table Empty Error\");\n        /*\n        while (this._borderRows.length < rowCount + 1) {\n            const i = this._borderRows.length;\n            this.createRowBorder(i);\n            this.insertLineIntoColumns(i)\n            //this.createRow(i-1);\n        }\n        */\n        while (this.rowCount < rowCount) {\n            this.primitiveInsertRow(this.rowCount, false);\n        }\n        while (this.columnCount < columnCount) {\n            this.primitiveInsertColumn(this.columnCount, false);\n        }\n        /*\n        this.borderSizeCheck(1, rowCount);\n        while (this._borderColumns.length < columnCount + 1) {\n            const i = this._borderColumns.length + 1;\n            this.createColumnBorder(i);\n            this.insertLineIntoRows(i);\n        }\n        this.borderSizeCheck(columnCount, rowCount);\n\n        while (this.columnCount < columnCount) {\n            this.createColumn(this.columnCount);\n        }\n        */\n        /*\n        while (this.rowCount < rowCount) {\n            this.createRow(this.rowCount);\n        }\n        */\n        this.updateNodeRelations();\n        this.isSetSize = false;\n        /*\n        this.renumbering();\n        this.update();\n        */\n    }\n    primitiveInsertRow(ithRow, insertTopBorders) {\n        let ithRowBorder = insertTopBorders ? ithRow : ithRow + 1;\n        if (ithRow < 0 || ithRow > this.rowCount)\n            throw new Error(\"primitive insert row error\");\n        if (ithRow == 0)\n            ithRowBorder = 0;\n        if (ithRow == this.rowCount)\n            ithRowBorder = this.borderRows.length;\n        this.createRowBorder(ithRowBorder);\n        this.insertYVerticalBorders(ithRow);\n        this.createRow(ithRow);\n    }\n    primitiveInsertColumn(ithColumn, insertLeftBorders) {\n        let ithColumnBorder = insertLeftBorders ? ithColumn : ithColumn + 1;\n        if (ithColumn < 0 || ithColumn > this.columnCount)\n            throw new Error(\"primitive insert column error\");\n        if (ithColumn == 0)\n            ithColumnBorder = 0;\n        if (ithColumn == this.columnCount)\n            ithColumnBorder = this.borderColumns.length;\n        this.createColumnBorder(ithColumnBorder);\n        this.insertXHorizontalBorders(ithColumn);\n        this.createColumn(ithColumn);\n    }\n    get borderColumnCount() {\n        return this.columnCount + 1;\n    }\n    get borderRowCount() {\n        return this.rowCount + 1;\n    }\n    /**\n     * rowCount = 0, columnCount = 0\n     */\n    clear() {\n        if (this.rowCount == 0 || this.columnCount == 0)\n            throw Error(\"Table Empty Error\");\n        if (this.columnCount != this.columns.length)\n            throw Error(\"clear error\");\n        while (this.rowCount > 1) {\n            this.primitiveRemoveRow(1, false);\n        }\n        while (this.columnCount > 1) {\n            this.primitiveRemoveColumn(1, false);\n        }\n        this.updateNodeRelations();\n    }\n    /*\n    public removeCell(i: number) {\n        this.cells[i].removeFromTable(false);\n        //this.cells.forEach((v) => v.removeFromTable(false));\n        this.cells.splice(i, 1);\n    }\n    */\n    removeCellRow(i) {\n        this.rows[i]._dispose();\n        this.rows.splice(i, 1);\n    }\n    removeCellColumn(i) {\n        this.columns[i]._dispose();\n        this.columns.splice(i, 1);\n    }\n    primitiveRemoveRow(ithRow, removeTopBorders) {\n        const ithBorderRow = removeTopBorders ? ithRow : ithRow + 1;\n        if (ithRow < 0 || ithRow >= this.rowCount)\n            throw new Error(\"error\");\n        //this.removeRow(rowi);\n        this.removeCellRow(ithRow);\n        ;\n        this.removeRowBorder(ithBorderRow);\n        this.deleteYVerticalBorders(ithRow);\n    }\n    primitiveRemoveColumn(ithColumn, removeLeftBorders) {\n        const ithborderColumn = removeLeftBorders ? ithColumn : ithColumn + 1;\n        if (ithColumn < 0 || ithColumn >= this.columnCount)\n            throw new Error(\"primitive insert column error\");\n        this.removeCellColumn(ithColumn);\n        //this.columns[ithColumn].remove(true);\n        //this.table.columns.splice(x, 1);\n        this.removeColumnBorder(ithborderColumn);\n        this.deleteXHorizontalBorders(ithColumn);\n    }\n    removeColumnBorder(i) {\n        //this._borderRows.forEach((v) => v.removeBorder(i));\n        this._borderColumns[i].remove();\n        this._borderColumns.splice(i, 1);\n    }\n    removeRowBorder(i) {\n        //this._borderColumns.forEach((v) => v.removeBorder(i));\n        this._borderRows[i].remove();\n        this._borderRows.splice(i, 1);\n    }\n    removeRow(ithRow) {\n        this.primitiveRemoveRow(ithRow, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n    }\n    removeColumn(ithColumn) {\n        this.primitiveRemoveColumn(ithColumn, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n    }\n    deleteXHorizontalBorders(i) {\n        this._borderRows.forEach((v) => {\n            v.removeBorder(i);\n        });\n    }\n    deleteYVerticalBorders(i) {\n        this._borderColumns.forEach((v) => {\n            v.removeBorder(i);\n        });\n    }\n    createColumnBorder(i, borderRowCount = this.borderRows.length - 1) {\n        const column = new border_column_1.BorderColumn(this, i, borderRowCount, undefined);\n        this._borderColumns.splice(i, 0, column);\n    }\n    createRowBorder(i, borderColumnCount = this.borderColumns.length - 1) {\n        const row = new border_row_1.BorderRow(this, i, borderColumnCount, undefined);\n        this._borderRows.splice(i, 0, row);\n    }\n    createRow(i) {\n        //const cell: Cell[] = [];\n        //this.cells.splice(i, 0, cell);\n        const columnCount = this.columnCount;\n        const row = new row_1.CellRow(this, i, undefined);\n        this._rows.splice(i, 0, row);\n        row._appendCell(this._cellMap, columnCount);\n        /*\n        for (let x = 0; x < this.columnCount; x++) {\n            cell[x] = this.createCell(x, i);\n            if (this._columns.length <= x) this._columns.push(new Column(this, 0));\n        }\n        */\n    }\n    createColumn(i) {\n        for (let y = 0; y < this.rowCount; y++) {\n            this.rows[y]._insertCell(i, this._cellMap);\n            //const cell = this.createCell(i, y);\n            //this.cells[y].splice(i, 0, cell);\n        }\n        this._columns.splice(i, 0, new column_1.CellColumn(this, i));\n    }\n    insertXHorizontalBorders(i) {\n        this._borderRows.forEach((v) => {\n            v.insertBorder(i, undefined);\n        });\n    }\n    insertYVerticalBorders(i) {\n        this._borderColumns.forEach((v) => {\n            v.insertBorder(i, undefined);\n        });\n    }\n    /**\n    * i\n    * @param \n    */\n    insertRow(ithRow) {\n        this.primitiveInsertRow(ithRow, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n    }\n    /**\n    * i\n    * @param ithColumn \n    */\n    insertColumn(ithColumn) {\n        this.primitiveInsertColumn(ithColumn, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n    }\n    /**\n     * \n     * @param i \n     * @param columnCount \n     */\n    /*\n    private insertRowFunction(i: number, columnCount: number = this.columnCount) {\n        const cell: Cell[] = [];\n\n        this.cells.splice(i, 0, cell);\n        this._rows.splice(i, 0, new Row(this, i));\n        for (let x = 0; x < columnCount; x++) {\n            cell[x] = this.createCell(x, i);\n            if (this._columns.length <= x) this._columns.push(new Column(this, 0));\n        }\n\n    }\n    */\n    /**\n    \n    */\n    appendColumn() {\n        //this.insertColumn(this.columnCount);\n        this.primitiveInsertColumn(this.columnCount, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n    }\n    /**\n    \n    */\n    appendRow() {\n        //this.insertRow(this.rowCount);\n        this.primitiveInsertRow(this.rowCount, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n        //this.update();\n    }\n    // #endregion\n    // #region update\n    //private prevShow: boolean = false;\n    /*\n    private tryUpdateWithUpdateFlag(withUpdate : boolean) : boolean{\n        let b = super.getUpdateFlag();\n\n        this.hasConnectedObserverFunction = false;\n\n\n        const xb = HTMLFunctions.isShow(this.svgGroup);\n        if (!xb) {\n            return false;\n        }\n\n        this._isDrawing = true;\n\n\n        const cells = this.cellArray;\n        for(let i =0;i<cells.length;i++){\n            b = cells[i].tryUpdateWithUpdateFlag(withUpdate) || b;\n            if(!withUpdate && b){\n                \n                Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag,`${cells[i].tryUpdateWithUpdateFlag.name}`);\n                this._isDrawing = false;\n                this.hasConnectedObserverFunction = true;\n                return b;\n            }\n        }\n\n\n        b = this.fitSizeToOriginalCellsWithUpdateFlag(true, withUpdate) || b;\n        if(!withUpdate && b){\n            Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag,`${this.fitSizeToOriginalCellsWithUpdateFlag.name}`);\n\n            this._isDrawing = false;\n            this.hasConnectedObserverFunction = true;\n            return b;\n        }\n    \n        this.prevShow = false;\n\n\n        b = this.tryResizeWithUpdateFlag(withUpdate) || b;\n\n        if(!withUpdate && b){\n            Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag,this.tryResizeWithUpdateFlag.name);\n\n\n            this._isDrawing = false;\n            this.hasConnectedObserverFunction = true;\n            return b;\n        }\n\n\n        b = this.relocateWithUpdate(withUpdate) || b;\n\n        if(!withUpdate && b){\n            Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag,this.relocateWithUpdate.name);\n\n        }\n\n        this._isDrawing = false;\n        this.hasConnectedObserverFunction = true;\n        return b;\n    }\n    /*\n\n    public getUpdateFlag(): boolean {\n        return this.tryUpdateWithUpdateFlag(false);\n        \n    }\n\n\n    /**\n    \n    */\n    update() {\n        super.update();\n        //this.tryUpdateWithUpdateFlag(true);\n    }\n    connectObserverFunction() {\n        this._observer.observe(this.svgGroup, this.groupObserverOption);\n    }\n    /**\n     * \n     */\n    /*\n    private renumbering() {\n\n        this.rows.forEach((v, i) => v.cellY = i);\n        this.columns.forEach((v, i) => v.cellX = i);\n        //this.cellArray.forEach((v) => v.updateBorderAttributes());\n\n    }\n    */\n    updateNodeRelations() {\n        this.rows.forEach((v, i) => v.cellY = i);\n        this.columns.forEach((v, i) => v.cellX = i);\n        this.borderRows.forEach((v, i) => {\n            if (v.borders.length != this.columnCount) {\n                throw new Error(`error row ${i} ${v.borders.length} ${this.columnCount}`);\n            }\n        });\n        this.borderColumns.forEach((v, i) => {\n            if (v.borders.length != this.rowCount) {\n                throw new Error(`error column ${i} ${v.borders.length} ${this.rowCount}`);\n            }\n        });\n        this.createCellArray().forEach((v) => v.updateNodeRelations());\n    }\n    /*\n    private tryResizeWithUpdateFlag(withUpdate : boolean) : boolean {\n        let b = false;\n        for(let i = 0;i<this.rows.length;i++){\n            //b = this.rows[i].tryResizeWithUpdateFlag(withUpdate) || b;\n            b = this.rows[i].setHeightToCellsWithUpdateFlag(withUpdate) || b;\n\n            if(!withUpdate && b){\n                return b;\n            }\n        }\n\n        for(let i = 0;i<this.columns.length;i++){\n            b = this.columns[i].setWidthToCellsWithUpdateFlag(withUpdate) || b;\n            if(!withUpdate && b){\n                return b;\n            }\n        }\n        return b;\n\n    }\n    */\n    /*\n    private updateBorders() : boolean{\n        const withUpdate = true;\n        let b  = false;\n\n        const date1 = new Date();\n        (this.createCellArray()).forEach((v) =>{\n            if(v.isMaster){\n                b = UpdateBorder.tryUpdateBordersWithUpdateFlag(v, withUpdate) || b;\n            }\n        })\n        const date2 = new Date();\n        Debugger.showTime(date1, date2, `Table: ${this.objectID}`, \"updateBorders\")\n\n        return b;\n    }\n    */\n    /**\n     * \n     */\n    /*\n    private resize() {\n        this.tryResizeWithUpdateFlag(true);\n\n    }\n    */\n    get childrenStableFlag() {\n        let b = true;\n        for (let i = 0; i < this.rows.length; i++) {\n            if (!this.rows[i].stableFlag) {\n                b = false;\n                break;\n            }\n        }\n        return b;\n    }\n    /*\n    private relocation() {\n        this.relocateWithUpdate(true);\n    }\n    */\n    // #endregion\n    /*\n    public deleteLastRow() {\n        this.rows[this.rowCount - 1].remove(true);\n    }\n    public deleteLastColumn() {\n        this.deleteColumn(this.columnCount - 1);\n    }\n    */\n    /*\n    public deleteColumn(i: number) {\n        const [b,e] = this.columns[i].groupColumnRange;\n        for (let x = e; x >= b; x--) {\n            this.columns[x].remove();\n        }\n    }\n    */\n    /*\n    public deleteRow(i: number) {\n        \n        const [b, e] = this.rows[i].groupRowRange;\n        for (let y = e; y >= b; y--) {\n            this.rows[y].remove();\n        }\n    }\n    */\n    /*\n    private splitCode(tableName: string, codes: string[], id: number): [string, string] {\n        const functions: string[] = [];\n\n        const p = VBATranslateFunctions.grouping80(codes);\n        p.forEach(function (x, i, arr) {\n            functions.push(`Call SubFunction${id}_${i}(${tableName})`);\n            const begin = `Sub SubFunction${id}_${i}(${tableName} As Table)`;\n            const end = `End Sub`;\n            p[i] = VBATranslateFunctions.joinLines([begin, x, end]);\n        });\n        return [VBATranslateFunctions.joinLines(functions), VBATranslateFunctions.joinLines(p)];\n    }\n    */\n    /*\n    public constructFromLogicCell(table: LogicCell[][], isLatexMode: boolean = false) {\n\n    }\n    */\n    /*\n    public get x() : number {\n        return this.svgGroup.getX();\n    }\n    public set x(value :number) {\n        this.svgGroup.setX(value);\n    }\n    public get y() : number {\n        return this.svgGroup.getY();\n    }\n    public set y(value :number) {\n        this.svgGroup.setY(value);\n    }\n    */\n    /**\n            * \n            * @param type\n            * @param x\n            * @param y\n            */\n    getContactPosition(type, x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        switch (type) {\n            case enums_1.ConnectorType.Top:\n                return [this.cx, this.cy - hr];\n            case enums_1.ConnectorType.TopRight:\n            case enums_1.ConnectorType.Right:\n            case enums_1.ConnectorType.BottomRight:\n                return [this.cx + wr, this.cy];\n            case enums_1.ConnectorType.Bottom:\n                return [this.cx, this.cy + hr];\n            case enums_1.ConnectorType.BottomLeft:\n            case enums_1.ConnectorType.Left:\n            case enums_1.ConnectorType.TopLeft:\n                return [this.cx - wr, this.cy];\n            default:\n                const autoType = this.getContactAutoPosition(x, y);\n                return this.getContactPosition(autoType, x, y);\n        }\n    }\n    getContactAutoPosition(x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        const line1 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy + hr);\n        const line2 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy - hr);\n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n        if (b1) {\n            if (b2) {\n                return enums_1.ConnectorType.Top;\n            }\n            else {\n                return enums_1.ConnectorType.Right;\n            }\n        }\n        else {\n            if (b2) {\n                return enums_1.ConnectorType.Left;\n            }\n            else {\n                return enums_1.ConnectorType.Bottom;\n            }\n        }\n    }\n    getVirtualWidth() {\n        return this.columns.reduce((w, v) => w + v.getVirtualSize().width, 0);\n    }\n    getVirtualHeight() {\n        return this.rows.reduce((w, v) => w + v.getVirtualSize().height, 0);\n    }\n}\nexports.ZTable = ZTable;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_table.ts?");

/***/ }),

/***/ "./src/objects/z_textbox.ts":
/*!**********************************!*\
  !*** ./src/objects/z_textbox.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZTextBox = void 0;\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./src/common/vba_functions.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nconst Extensions = __webpack_require__(/*! ../interfaces/extensions */ \"./src/interfaces/extensions.ts\");\nconst enums_2 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./src/html/enum_extension.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGElementExtension = __webpack_require__(/*! ../interfaces/svg_element_extension */ \"./src/interfaces/svg_element_extension.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nconst virtual_text_1 = __webpack_require__(/*! ../interfaces/virtual_text */ \"./src/interfaces/virtual_text.ts\");\nconst element_builder_1 = __webpack_require__(/*! ./element_builder */ \"./src/objects/element_builder.ts\");\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\n//namespace GraphTableSVG {\nclass ZTextBox extends z_vertex_1.ZVertex {\n    constructor(svgbox) {\n        super(svgbox);\n        //private isFixTextSize: boolean = false;\n        this.surfaceAttributes = [];\n        //protected _isSpecialTextBox: boolean = false;\n        this._minimumWidth = 10;\n        this._minimumHeight = 10;\n        this.textObserverFunc = (x) => {\n            if (!this.isLocated)\n                return;\n            let b = false;\n            for (let i = 0; i < x.length; i++) {\n                const p = x[i];\n                if (ZTextBox.updateTextAttributes.some((v) => v == p.attributeName)) {\n                    b = true;\n                }\n                if (p.attributeName == null) {\n                    b = true;\n                }\n            }\n            if (b) {\n                //this.resetUnstableCounter();\n                //this.update();\n            }\n        };\n        this.op = 0;\n        this._svgText = (0, element_builder_1.createSVGText)(undefined, undefined, enums_1.DataName.Text);\n        this.svgGroup.appendChild(this.svgText);\n        this._textObserver = new MutationObserver(this.textObserverFunc);\n        const option2 = { childList: true, attributes: true, subtree: true };\n        this._textObserver.observe(this.svgText, option2);\n        if (this.type == enums_1.ShapeObjectType.Object)\n            this.firstFunctionAfterInitialized();\n        /*\n        this.svgText!.onclick = (e) => {\n            const textRect = this.getVirtualRegion();\n\n            this.svgText!.style.border = \"black\"\n\n        }\n        */\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZTextBoxAttributes) {\n        super.setBasicOption(option)\n        const textClass = CSS.createCSSClass(option.textClass);\n        const styleClass = CSS.createCSSClass(option.textStyle);\n        GOptions.setClassAndStyle(this.svgText, textClass, styleClass);\n\n        if (typeof option.text == \"string\") {\n            SVGTextExtension.setTextContent(this.svgText, option.text);\n        } else if (Array.isArray(option.text)) {\n            SVGTextBox.constructSVGTextByHTMLElements(this.svgText, option.text, false);\n            SVGTextBox.sortText(this.svgText, this.horizontalAnchor, false);\n\n\n        } else {\n\n        }\n\n        const b = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.autoSizeShapeToFitText);\n        if (b === undefined && typeof (option.style) == \"object\") {\n            const style: GOptions.ZTextBoxCSS = option.style;\n            if (style.autoSizeShapeToFitText !== undefined) {\n                this.isAutoSizeShapeToFitText = style.autoSizeShapeToFitText;\n            }\n        }\n\n    }\n\n    public setOption(option: GOptions.ZTextBoxAttributes) {\n        super.setOption(option);\n        //this.setBasicOption(option);\n    }\n    */\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        ZTextBox.importTextFromSource(this.svgText, this.horizontalAnchor, source);\n        if (this.svgText != null) {\n            z_object_1.ZObject.setSubAttributes(this.svgText, source);\n        }\n    }\n    static importTextFromSource(svgText, horizontalAnchor, source) {\n        if (source.children.length > 0) {\n            const tNodes = HTMLFunctions.getTNodes(source);\n            if (tNodes != null) {\n                tNodes.forEach((v) => v.remove());\n                SVGTextBox.constructSVGTextByHTMLElements(svgText, tNodes, false);\n                if (horizontalAnchor != null && svgText instanceof SVGTextElement) {\n                    SVGTextBox.sortText(svgText, horizontalAnchor, false);\n                }\n            }\n        }\n        else if (source.innerHTML.length > 0) {\n            if (svgText instanceof SVGTextElement) {\n                SVGTextExtension.setTextContent(svgText, source.textContent);\n            }\n            else {\n                Extensions.setTextContent(svgText, source.textContent);\n            }\n            source.innerHTML = \"\";\n        }\n    }\n    /*\n    static constructAttributes(e: Element,\n        removeAttributes: boolean = false, output: GOptions.ZTextBoxAttributes = {}): GOptions.ZTextBoxAttributes {\n\n        ZObject.constructAttributes(e, removeAttributes, output, \"center\");\n        //output.isAutoSizeShapeToFitText = e.gtGetStyleBooleanWithUndefined(AttributeNames.Style.autoSizeShapeToFitText);\n        //const textChild = HTMLFunctions.getChildByNodeName(e, AttributeNames.text);\n        output.textClass = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.textClass);\n        output.textStyle = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.textStyle);\n\n        if (e.children.length > 0) {\n            const tNodes = HTMLFunctions.getTNodes(e);\n            if (tNodes != null) {\n                tNodes.forEach((v) => v.remove())\n                output.text = tNodes;\n            }\n        } else if (e.innerHTML.length > 0) {\n            output.text = e.innerHTML;\n        }\n\n\n        if (removeAttributes) {\n            //e.removeAttribute(AttributeNames.text);\n            e.removeAttribute(AttributeNames.className);\n            e.removeAttribute(AttributeNames.textStyle);\n\n            (<any>e).style.removeProperty(StyleNames.autoSizeShapeToFitText);\n        }\n        return output;\n    }\n    */\n    get svgText() {\n        return this._svgText;\n    }\n    get horizontalAnchor() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.horizontalAnchor, \"center\");\n        return enums_1.HorizontalAnchor.toHorizontalAnchor(b);\n    }\n    /**\n    \n    */\n    set horizontalAnchor(value) {\n        if (this.horizontalAnchor != value)\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.horizontalAnchor, value);\n    }\n    /**\n    \n    */\n    get verticalAnchor() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.verticalAnchor, \"middle\");\n        return enums_1.VerticalAnchor.toVerticalAnchor(b);\n    }\n    /**\n    \n    */\n    set verticalAnchor(value) {\n        if (this.verticalAnchor != value)\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.verticalAnchor, value);\n    }\n    /**\n     * VertexTrue\n     */\n    get isAutoSizeShapeToFitText() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.autoSizeShapeToFitText, enums_1.ShapeToFitType.SemiAuto);\n        if (b == enums_1.ShapeToFitType.Auto) {\n            return enums_1.ShapeToFitType.Auto;\n        }\n        else if (b == enums_1.ShapeToFitType.SemiAuto) {\n            return enums_1.ShapeToFitType.SemiAuto;\n        }\n        else {\n            return enums_1.ShapeToFitType.None;\n        }\n        /*\n        if (b == undefined) {\n            return false;\n        } else {\n            return b;\n        }\n        */\n    }\n    set isAutoSizeShapeToFitText(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.autoSizeShapeToFitText, value);\n        //this.svgGroup.setPropertyStyleValue(AttributeNames.Style.autoSizeShapeToFitText, value ? \"true\" : \"false\");\n    }\n    updateStyleWithUpdateFlag(updateFlag) {\n        let b = false;\n        const dashStyle = this.msoDashStyle;\n        if (dashStyle != null && this.svgSurface != null) {\n            if (updateFlag) {\n                this.hasConnectedObserverFunction = false;\n                b = (0, enum_extension_1.updateAppropriateDashArray)(this.svgSurface);\n                this.hasConnectedObserverFunction = true;\n            }\n            else {\n                b = (0, enum_extension_1.getUpdateFlagAppropriateDashArray)(this.svgSurface);\n            }\n        }\n        return b;\n    }\n    /*\n    protected getUpdateFlagOfStyle(): boolean {\n        return this.updateStyleWithUpdateFlag(false);\n    }\n    protected updateStyle() : boolean {\n        return this.updateStyleWithUpdateFlag(true);\n    }\n    */\n    updateSurfaceSizeWithUpdateFlag(withUpdate) {\n        const region = this.getVirtualRegion();\n        let b = false;\n        const widthRound100 = (0, vline_1.round100)(region.width);\n        if (!(0, vline_1.nearlyEqual)(this.width, widthRound100)) {\n            if (withUpdate) {\n                this.width = widthRound100;\n            }\n            b = true;\n        }\n        const heightRound100 = (0, vline_1.round100)(region.height);\n        if (!(0, vline_1.nearlyEqual)(this.height, heightRound100)) {\n            if (withUpdate) {\n                this.height = heightRound100;\n            }\n            //this.height = region.height;        \n            b = true;\n        }\n        return b;\n    }\n    /*\n    protected updateTextLocationOrGetUpdateFlag(executeUpdate : boolean): boolean {\n        return SVGTextExtension.up(this.svgText, this.getVirtualTextLocationRegion(), this.verticalAnchor, this.horizontalAnchor, this.isAutoSizeShapeToFitText);\n    }\n    */\n    updateTextLocation() {\n        return SVGTextExtension.updateLocation(this.svgText, this.getVirtualTextLocationRegion(), this.verticalAnchor, this.horizontalAnchor, this.isAutoSizeShapeToFitText);\n    }\n    getUpdateFlagOfTextLocation() {\n        return SVGTextExtension.getUpdateFlagOfLocation(this.svgText, this.getVirtualTextLocationRegion(), this.verticalAnchor, this.horizontalAnchor, this.isAutoSizeShapeToFitText);\n    }\n    updateSurfaceLocation() {\n        return false;\n    }\n    getUpdateFlagOfSurfaceLocation() {\n        return false;\n    }\n    getUpdateFlag() {\n        const b1 = super.getUpdateFlag();\n        if (b1) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${super.getUpdateFlag.name}`);\n            return b1;\n        }\n        if (!this.isShown)\n            return b1;\n        if (this.svgText == null) {\n            throw new TypeError(\"svgText is null\");\n        }\n        const b2 = this.updateStyleWithUpdateFlag(false);\n        if (b2) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.updateStyleWithUpdateFlag.name}`);\n            return b2;\n        }\n        const b3 = this.getUpdateFlagOfTextLocation();\n        if (b3) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.getUpdateFlagOfTextLocation.name}`);\n            return b3;\n        }\n        const b4 = this.updateSurfaceSizeWithUpdateFlag(false);\n        if (b4) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.updateSurfaceSizeWithUpdateFlag.name}`);\n            return b3;\n        }\n        const b5 = this.getUpdateFlagOfSurfaceLocation();\n        if (b4) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.getUpdateFlagOfSurfaceLocation.name}`);\n            return b3;\n        }\n        const b = b1 || b2 || b3 || b4 || b5;\n        return b;\n    }\n    updateSub() {\n        super.update();\n        this._isUpdating = true;\n        if (!this.isShown)\n            return;\n        //this._observer.disconnect();\n        this.hasConnectedObserverFunction = false;\n        if (this.svgText == null) {\n            throw new TypeError(\"svgText is null\");\n        }\n        this.updateStyleWithUpdateFlag(true);\n        this.updateTextLocation();\n        this.updateSurfaceSizeWithUpdateFlag(true);\n        this.updateSurfaceLocation();\n        this.updateObjectLocation();\n        //this.joint();\n        this._isUpdating = false;\n        this.hasConnectedObserverFunction = true;\n    }\n    update() {\n        //let counter = 1;\n        this.updateSub();\n        /*\n        while(this.getUpdateFlag()){\n            if(counter > 10){\n                throw new Error(\"Update-Loop Error!\");\n            }\n            counter++;\n        }\n        */\n        //return counter > 1;\n    }\n    /*\n    protected updateToFitText(isWidth: boolean) {\n        //this.isFixTextSize = true;\n        //const box = this.svgText.getBBox();\n        const textRect = SVGTextExtension.getSize(this.svgText);\n\n        const textWidth = textRect.width < this._minimumWidth ? this._minimumWidth : textRect.width;\n        const textHeight = textRect.height < this._minimumHeight ? this._minimumHeight : textRect.height;\n\n        if (isWidth) {\n            this.width = textWidth + this.marginPaddingLeft + this.marginPaddingRight;\n        } else {\n            this.height = textHeight + this.marginPaddingTop + this.marginPaddingBottom;\n        }\n    }\n    */\n    get marginPaddingTop() {\n        return SVGTextExtension.getMarginTop(this.svgText) + SVGElementExtension.getPaddingTop(this.svgGroup);\n    }\n    get marginPaddingLeft() {\n        return SVGTextExtension.getMarginLeft(this.svgText) + SVGElementExtension.getPaddingLeft(this.svgGroup);\n    }\n    get marginPaddingRight() {\n        return SVGTextExtension.getMarginRight(this.svgText) + SVGElementExtension.getPaddingRight(this.svgGroup);\n    }\n    get marginPaddingBottom() {\n        return SVGTextExtension.getMarginBottom(this.svgText) + SVGElementExtension.getPaddingBottom(this.svgGroup);\n    }\n    get paddingTop() {\n        return SVGElementExtension.getPaddingTop(this.svgGroup);\n    }\n    set paddingTop(value) {\n        SVGElementExtension.setPaddingTop(this.svgGroup, value);\n    }\n    get paddingLeft() {\n        return SVGElementExtension.getPaddingLeft(this.svgGroup);\n    }\n    set paddingLeft(value) {\n        SVGElementExtension.setPaddingLeft(this.svgGroup, value);\n    }\n    get paddingRight() {\n        return SVGElementExtension.getPaddingRight(this.svgGroup);\n    }\n    set paddingRight(value) {\n        SVGElementExtension.setPaddingRight(this.svgGroup, value);\n    }\n    get paddingBottom() {\n        return SVGElementExtension.getPaddingBottom(this.svgGroup);\n    }\n    set paddingBottom(value) {\n        SVGElementExtension.setPaddingBottom(this.svgGroup, value);\n    }\n    get marginTop() {\n        return SVGTextExtension.getMarginTop(this.svgText);\n    }\n    set marginTop(value) {\n        SVGTextExtension.setMarginTop(this.svgText, value);\n    }\n    get marginLeft() {\n        return SVGTextExtension.getMarginLeft(this.svgText);\n    }\n    set marginLeft(value) {\n        SVGTextExtension.setMarginLeft(this.svgText, value);\n    }\n    get marginRight() {\n        return SVGTextExtension.getMarginRight(this.svgText);\n    }\n    set marginRight(value) {\n        SVGTextExtension.setMarginRight(this.svgText, value);\n    }\n    get marginBottom() {\n        return SVGTextExtension.getMarginBottom(this.svgText);\n    }\n    set marginBottom(value) {\n        SVGTextExtension.setMarginBottom(this.svgText, value);\n    }\n    /*\n    private get innerRectangleWithoutMargin(): Rectangle {\n        const rect = this.innerRectangle;\n        rect.width = rect.width - this.marginPaddingLeft - this.marginPaddingRight;\n        rect.height = rect.height - this.marginPaddingTop - this.marginPaddingBottom;\n        rect.x = rect.x + this.marginPaddingLeft;\n        rect.y = rect.y + this.marginPaddingTop;\n        return rect;\n    }\n    */\n    /*\n    get marginLeft(): number {\n        return this.svgText.getPropertyStyleNumberValue(\"--margin-left\", 0);\n    }\n    set marginLeft(value: number) {\n        this.svgText.setPropertyStyleValue(\"--margin-left\", value.toString());\n    }\n    get marginTop(): number {\n        return this.svgText.getPropertyStyleNumberValue(\"--margin-top\", 0);\n    }\n    set marginTop(value: number) {\n        this.svgText.setPropertyStyleValue(\"--margin-top\", value.toString());\n    }\n    */\n    get svgElements() {\n        const r = [];\n        r.push(this.svgGroup);\n        r.push(this.svgText);\n        return r;\n    }\n    hasDescendant(obj) {\n        const ids = this.svgElements.map((v) => v.getAttribute(AttributeNames.objectIDName)).filter((v) => v != null);\n        const id = obj.getAttribute(AttributeNames.objectIDName);\n        return ids.some((v) => v == id);\n    }\n    get hasSize() {\n        return true;\n    }\n    get msoDashStyle() {\n        if (this.svgSurface != null) {\n            const dashStyle = ElementExtension.getPropertyStyleValue(this.svgSurface, StyleNames.msoDashStyleName);\n            if (dashStyle != null) {\n                return enums_1.msoDashStyle.toMSODashStyle(dashStyle);\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    set msoDashStyle(value) {\n        if (this.svgSurface != null) {\n            if (enums_1.msoDashStyle == null) {\n                this.svgSurface.style.removeProperty(StyleNames.msoDashStyleName);\n            }\n            else {\n                ElementExtension.setPropertyStyleValue(this.svgSurface, StyleNames.msoDashStyleName, value);\n            }\n        }\n    }\n    createVBACode(id) {\n        const lines = [];\n        const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"fill\", \"gray\"));\n        const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n        const vAnchor = vba_functions_1.VBATranslateFunctions.ToVerticalAnchor(this.verticalAnchor);\n        const hAnchor = vba_functions_1.VBATranslateFunctions.ToHorizontalAnchor(this.horizontalAnchor);\n        lines.push(`Sub create${id}(createdSlide As slide)`);\n        lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n        lines.push(` Dim obj As Shape`);\n        lines.push(` Set obj = shapes_.AddShape(${this.shape}, ${this.globalX}, ${this.globalY}, ${this.width}, ${this.height})`);\n        lines.push(` Call EditTextFrame(obj.TextFrame, ${this.marginPaddingTop}, ${this.marginPaddingBottom}, ${this.marginPaddingLeft}, ${this.marginPaddingRight}, false, ppAutoSizeNone)`);\n        lines.push(` Call EditAnchor(obj.TextFrame, ${vAnchor}, ${hAnchor})`);\n        vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement2(this.svgText, `obj.TextFrame.TextRange`).forEach((v) => lines.push(v));\n        lines.push(this.getVBAEditLine());\n        lines.push(` Call EditCallOut(obj, \"${this.objectID}\", ${visible}, ${backColor})`);\n        this.VBAAdjustments.forEach((v, i) => {\n            lines.push(` obj.Adjustments.Item(${i + 1}) = ${v}`);\n        });\n        lines.push(`End Sub`);\n        return lines;\n    }\n    getVirtualWidth() {\n        return this.getVirtualRegion().width;\n    }\n    getVirtualHeight() {\n        return this.getVirtualRegion().height;\n    }\n    getVirtualExtraRegion() {\n        const textRect = (0, virtual_text_1.getVirtualRegion)(this.svgText);\n        //const textRect = SVGTextExtension.getRegion(this.svgText);\n        const w = textRect.width + this.leftExtraLength + this.rightExtraLength;\n        const h = textRect.height + this.topExtraLength + this.bottomExtraLength;\n        const x = -w / 2;\n        const y = -h / 2;\n        return new vline_1.Rectangle(x, y, w, h);\n    }\n    getVirtualTextLocationRegion() {\n        const rect = this.getVirtualRegion();\n        rect.x += this.leftExtraLength;\n        rect.y += this.topExtraLength;\n        rect.width -= this.leftExtraLength + this.rightExtraLength;\n        rect.height -= this.topExtraLength + this.bottomExtraLength;\n        return rect;\n        /*\n        const rect = this.ExtraRegion;\n        const w = rect.width - this.leftExtraLength - this.rightExtraLength;\n        const h = rect.height - this.topExtraLength - this.bottomExtraLength;\n        const x =rect.x + this.leftExtraLength;\n        const y = rect.y + this.topExtraLength;\n        return new Rectangle(x, y, w, h);\n        */\n    }\n    getVirtualRegion() {\n        if (this.svgText === undefined) {\n            throw new exceptions_1.UndefinedError();\n            //return new Rectangle(this.cx, this.cy, 0, 0);\n        }\n        const marginRect = this.getVirtualExtraRegion();\n        if (this.isAutoSizeShapeToFitText == enums_2.AutoSizeShapeToFitText.Auto) {\n            return marginRect;\n        }\n        else if (this.isAutoSizeShapeToFitText == enums_2.AutoSizeShapeToFitText.SemiAuto) {\n            let [x, y] = [0, 0];\n            let [newWidth, newHeight] = [0, 0];\n            if (this.width < marginRect.width) {\n                newWidth = marginRect.width;\n                x = marginRect.x;\n            }\n            else {\n                //const surface_x = this.svgSurface != null ? SVGElementExtension.getX(this.svgSurface) : 0;\n                newWidth = this.width;\n                x = -this.width / 2;\n            }\n            if (this.height < marginRect.height) {\n                newHeight = marginRect.height;\n                y = marginRect.y;\n            }\n            else {\n                //const surface_y = this.svgSurface != null ? SVGElementExtension.getY(this.svgSurface) : 0;\n                newHeight = this.height;\n                y = -this.height / 2;\n            }\n            //const newWidth = this.width < width ? width : this.width;\n            //const newHeigth = this.height < height ? height : this.height;\n            return new vline_1.Rectangle((0, vline_1.round100)(x), (0, vline_1.round100)(y), (0, vline_1.round100)(newWidth), (0, vline_1.round100)(newHeight));\n        }\n        else {\n            return new vline_1.Rectangle(-(this.width / 2), -(this.height / 2), this.width, this.height);\n            //return new Rectangle(this.x, this.y, this.width, this.height);\n        }\n    }\n    get topExtraLength() {\n        return this.marginPaddingTop;\n    }\n    get leftExtraLength() {\n        return this.marginPaddingLeft;\n    }\n    get rightExtraLength() {\n        return this.marginPaddingRight;\n    }\n    get bottomExtraLength() {\n        return this.marginPaddingBottom;\n    }\n}\nexports.ZTextBox = ZTextBox;\nZTextBox.updateTextAttributes = [\"style\"];\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_textbox.ts?");

/***/ }),

/***/ "./src/objects/z_vertex.ts":
/*!*********************************!*\
  !*** ./src/objects/z_vertex.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZVertex = void 0;\n/// <reference path=\"z_textbox.ts\"/>\n//namespace GraphTableSVG {\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./src/common/vba_functions.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\n//import { ZGraph } from \"./g_graph\"\nconst virtual_tree_1 = __webpack_require__(/*! ./graph_helpers/virtual_tree */ \"./src/objects/graph_helpers/virtual_tree.ts\");\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./src/html/enum_extension.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst common_functions_1 = __webpack_require__(/*! ./graph_helpers/common_functions */ \"./src/objects/graph_helpers/common_functions.ts\");\nconst html_1 = __webpack_require__(/*! ../html */ \"./src/html/index.ts\");\nclass ZVertex extends z_object_1.ZObject {\n    /*\n    protected setClassNameOfSVGGroup() {\n        const parent = this.svgGroup.parentElement;\n        if (parent instanceof SVGElement) {\n            const className = GraphTableSVG.AttributeNames.StyleValue.defaultVertexClass;\n            if (className != null && !this.svgGroup.hasAttribute(\"class\") ) {\n                this.svgGroup.setAttribute(\"class\", className);\n            }\n        }\n    }\n    */\n    get defaultClassName() {\n        return DefaultClassNames.defaultVertexClass;\n    }\n    /**\n    * XY\n    * @param type\n    * @param x\n    * @param y\n    */\n    getContactPosition(type, x, y) {\n        return [this.cx, this.cy];\n    }\n    /**\n     * \n     * @param type\n     * @param x\n     * @param y\n     */\n    getConnectorType(type, x, y) {\n        if (type == enums_1.ConnectorType.Auto) {\n            return this.getContactAutoPosition(x, y);\n        }\n        else {\n            return type;\n        }\n    }\n    /**\n     * Auto\n     * @param x\n     * @param y\n     */\n    getContactAutoPosition(x, y) {\n        return enums_1.ConnectorType.Top;\n    }\n    tryGetSVGText() {\n        return null;\n    }\n    update() {\n        /*\n        if(this.getUpdateFlag()){\n        }\n        */\n        /*\n         this.incomingEdges.forEach((v) =>{\n             v.resetUnstableCounter();\n         })\n         this.outcomingEdges.forEach((v) =>{\n             v.resetUnstableCounter();\n         })\n         */\n        super.update();\n    }\n    /**\n    \n    */\n    get outgoingEdges() {\n        const svgsvg = html_1.HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvg != null) {\n            const manager = svgsvg._manager;\n            if (manager != undefined) {\n                const arr = manager.getOutgoingEdges(this);\n                if (arr == null) {\n                    return new Array(0);\n                }\n                else {\n                    return arr.map((v) => v);\n                }\n            }\n        }\n        return new Array(0);\n    }\n    /*\n    set outcomingEdges(edges : PPEdge[]) {\n        const mes = edges.map((v)=>v.objectID).join(\",\");\n        this.svgGroup.setAttribute(\"outcoming-edges\", mes);\n    }\n    */\n    /**\n    \n    */\n    get incomingEdges() {\n        const svgsvg = html_1.HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvg != null) {\n            const manager = svgsvg._manager;\n            if (manager != undefined) {\n                const arr = manager.getIncmoingEdges(this);\n                if (arr == null) {\n                    return new Array(0);\n                }\n                else {\n                    return arr.map((v) => v);\n                }\n            }\n        }\n        return new Array(0);\n    }\n    /*\n    set incomingEdges(edges : PPEdge[]) {\n        const mes = edges.map((v)=>v.objectID).join(\",\");\n        this.svgGroup.setAttribute(\"incoming-edges\", mes);\n    }\n    */\n    /**\n     * \n     * @param edge\n     * @param insertIndex\n     */\n    /*\n    public insertOutcomingEdge(edge: ZAbstractEdge, insertIndex: number = this.outgoingEdges.length) {\n        return new Array(0);\n    }\n    */\n    dispose() {\n        /*\n        while (this.incomingEdges.length > 0) {\n            this.removeIncomingEdge(this.incomingEdges[0]);\n        }\n\n        while (this.outgoingEdges.length > 0) {\n            this.removeOutcomingEdge(this.outgoingEdges[0]);\n        }\n        */\n    }\n    /**\n    * Vertex\n    */\n    getParents() {\n        return this.incomingEdges.filter((v) => v.beginVertex != null).map((v) => v.beginVertex);\n    }\n    /**\n    \n    */\n    get parentEdge() {\n        if (this.incomingEdges.length == 0) {\n            return null;\n        }\n        else {\n            return this.incomingEdges[0];\n        }\n    }\n    /**\n    Vertex\n    */\n    get parent() {\n        if (this.parentEdge == null) {\n            return null;\n        }\n        else {\n            return this.parentEdge.beginVertex;\n        }\n    }\n    /**\n    VertexTrue\n    */\n    get isNoParent() {\n        return this.parent == null;\n    }\n    /**\n    \n    */\n    get children() {\n        return this.outgoingEdges.filter((v) => v.endVertex != null).map((v) => v.endVertex);\n    }\n    /**\n    VertexTrue\n    */\n    get isLeaf() {\n        return this.outgoingEdges.length == 0;\n    }\n    /**\n     * Vertex\n     */\n    //get tree(): VirtualTree {\n    //    return new VirtualTree(this);\n    //}\n    createVirtualTree(excludedEdgeDic) {\n        return new virtual_tree_1.VirtualTree(this, excludedEdgeDic);\n    }\n    /**\n    Vertex\n    */\n    get region() {\n        const p = new vline_1.Rectangle();\n        p.x = this.cx - (this.width / 2);\n        p.y = this.cy - (this.height / 2);\n        p.width = this.width;\n        p.height = this.height;\n        return p;\n    }\n    get globalX() {\n        if (this.graph != null) {\n            return this.graph.x + this.x;\n        }\n        else {\n            return this.x;\n        }\n    }\n    get globalY() {\n        if (this.graph != null) {\n            return this.graph.y + this.y;\n        }\n        else {\n            return this.y;\n        }\n    }\n    get shape() {\n        return enums_1.VBAShapeType.None;\n    }\n    /**\n             *\n             * @param id\n             */\n    createVBACode(id) {\n        const lines = [];\n        const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"fill\", \"gray\"));\n        const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n        lines.push(`Sub create${id}(createdSlide As slide)`);\n        lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n        lines.push(` Dim obj As Shape`);\n        lines.push(` Set obj = shapes_.AddShape(${this.shape}, ${this.globalX}, ${this.globalY}, ${this.width}, ${this.height})`);\n        const svgText = this.tryGetSVGText();\n        if (svgText != null)\n            vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement2(svgText, `obj.TextFrame.TextRange`).forEach((v) => lines.push(v));\n        lines.push(this.getVBAEditLine());\n        lines.push(` Call EditCallOut(obj, \"${this.objectID}\", ${visible}, ${backColor})`);\n        this.VBAAdjustments.forEach((v, i) => {\n            lines.push(` obj.Adjustments.Item(${i + 1}) = ${v}`);\n        });\n        lines.push(`End Sub`);\n        return lines;\n    }\n    /**\n     * VBAShapeVBAAdjustments\n     */\n    get VBAAdjustments() {\n        return [];\n    }\n    getVBAEditLine() {\n        const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"stroke\", \"gray\"));\n        const lineType = (0, enum_extension_1.getLineType)(this.svgSurface);\n        const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"stroke-width\", \"4\"));\n        const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n        return ` Call EditLine(obj.Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`;\n    }\n    get graph() {\n        return (0, common_functions_1.getGraph)(this);\n    }\n    updateSurfaceWithoutSVGText() {\n        super.updateSurfaceWithoutSVGText();\n        this.incomingEdges.forEach((e) => {\n            e.update();\n        });\n        this.outgoingEdges.forEach((e) => {\n            e.update();\n        });\n        return true;\n    }\n}\nexports.ZVertex = ZVertex;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_vertex.ts?");

/***/ }),

/***/ "./src/options/console.ts":
/*!********************************!*\
  !*** ./src/options/console.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.view = exports.textarea = exports.log = exports.graph = exports.clear = exports.table = exports.ConsoleLineElement = void 0;\nconst table_dictionary_1 = __webpack_require__(/*! ./table_dictionary */ \"./src/options/table_dictionary.ts\");\nconst logic_tree_1 = __webpack_require__(/*! ../logics/logic_tree */ \"./src/logics/logic_tree.ts\");\nconst logic_graph_1 = __webpack_require__(/*! ../logics/logic_graph */ \"./src/logics/logic_graph.ts\");\nconst logic_table_1 = __webpack_require__(/*! ../logics/logic_table */ \"./src/logics/logic_table.ts\");\n//import { CommonFunctions } from \"../common/common_functions\";\nconst create_g_object_1 = __webpack_require__(/*! ./create_g_object */ \"./src/options/create_g_object.ts\");\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst VBAMacroModal = __webpack_require__(/*! ./vba_macro_modal */ \"./src/options/vba_macro_modal.ts\");\nconst svg_to_vba_1 = __webpack_require__(/*! ./svg_to_vba */ \"./src/options/svg_to_vba.ts\");\nconst GUIObserver = __webpack_require__(/*! ../html/gui_observer */ \"./src/html/gui_observer.ts\");\nconst z_table_1 = __webpack_require__(/*! ../objects/z_table */ \"./src/objects/z_table.ts\");\nconst z_graph_1 = __webpack_require__(/*! ../objects/z_graph */ \"./src/objects/z_graph.ts\");\nconst ToJSON = __webpack_require__(/*! ./to_json */ \"./src/options/to_json.ts\");\nconst logics_1 = __webpack_require__(/*! ../logics */ \"./src/logics/index.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\n//export namespace Console {\nclass ConsoleLineElement {\n    constructor(parent, type, title = \"\", option = {}) {\n        this.canvas = null;\n        this.vbaObjects = new Array();\n        this.mainObject = null;\n        this.canvasContainer = document.createElement(\"div\");\n        if (parent.firstChild == null) {\n            parent.appendChild(this.canvasContainer);\n        }\n        else {\n            parent.insertBefore(this.canvasContainer, parent.firstChild);\n        }\n        this.fieldSetElement = document.createElement(\"fieldset\");\n        this.canvasContainer.appendChild(this.fieldSetElement);\n        this.legendElement = document.createElement(\"legend\");\n        this.fieldSetElement.appendChild(this.legendElement);\n        this.title = title;\n        const createCanvas = type == \"table\" || type == \"graph\" || type == \"log\" || type == \"group\";\n        const createVBAButton = type == \"table\" || type == \"graph\" || type == \"log\" || type == \"group\";\n        if (createCanvas) {\n            this.canvas = ConsoleLineElement.addSVGSVGElement(this.fieldSetElement);\n            GUIObserver.observeSVGSVG(this.canvas);\n        }\n        if (option.mainElement !== undefined) {\n            if (option.mainElement instanceof HTMLElement) {\n                this.fieldSetElement.appendChild(option.mainElement);\n            }\n        }\n        /*\n        this.pngButton = document.createElement(\"button\");\n        this.pngButton.textContent = \"PNG\";\n        const pngFunc = () =>{\n            const _canvas = PNG.createPNGFromSVGSVGElement(this.canvas);\n            this.canvasContainer.appendChild(_canvas);\n\n        }\n        this.pngButton.onclick = pngFunc;\n        */\n        //this.canvasContainer.appendChild(this.pngButton);\n        //this.pngButton.setAttribute(\"hidden\", \"1\");\n        this.removeButton = document.createElement(\"button\");\n        this.removeButton.textContent = \"remove\";\n        this.fieldSetElement.appendChild(this.removeButton);\n        const removeFunc = () => {\n            this.fieldSetElement.remove();\n        };\n        this.removeButton.onclick = removeFunc;\n        this.macroButton = document.createElement(\"button\");\n        this.macroButton.textContent = \"VBA\";\n        if (createVBAButton) {\n            this.fieldSetElement.appendChild(this.macroButton);\n        }\n        const vbaFunc = () => {\n            VBAMacroModal.createMacroModal(svg_to_vba_1.SVGToVBA.create(this.vbaObjects));\n        };\n        this.macroButton.onclick = vbaFunc;\n        const createCSVButton = type == \"table\";\n        this.csvButton = document.createElement(\"button\");\n        this.csvButton.textContent = \"csv\";\n        if (createCSVButton) {\n            this.fieldSetElement.appendChild(this.csvButton);\n        }\n        const csvFunc = () => {\n            if (this.mainObject instanceof z_table_1.ZTable) {\n                const str = this.mainObject.rows.map((v) => {\n                    return v.cells.map((w) => w.svgText.textContent).join(\",\");\n                }).join(\"\\n\");\n                textarea(str, this.title);\n            }\n        };\n        this.csvButton.onclick = csvFunc;\n    }\n    get title() {\n        return this.legendElement.textContent;\n    }\n    set title(value) {\n        this.legendElement.textContent = value;\n        this.legendElement.style.fontWeight = \"bold\";\n    }\n    addVBAObject(obj) {\n        this.vbaObjects.push(obj);\n        if (obj instanceof z_table_1.ZTable || obj instanceof z_graph_1.ZGraph) {\n            this.mainObject = obj;\n        }\n    }\n    static addSVGSVGElement(code) {\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        //const p = document.createElement(\"p\");\n        //code.appendChild(p);\n        //p.appendChild(svg);\n        code.appendChild(svg);\n        svg.setAttribute(\"style\", \"background:#e9e9e9;border:solid 1pt;padding:10px\");\n        //svg.setAttribute(\"style\", \"background:#e9e9e9;\");\n        //svg.setAttribute(\"width\", \"600px\");\n        //svg.setAttribute(\"height\", \"600px\");\n        svg.setAttribute(enums_1.OriginalSVGSVGAttributes.ShrinkAttributeName, \"true\");\n        if (svg instanceof SVGSVGElement) {\n            return svg;\n        }\n        else {\n            throw \"error\";\n        }\n    }\n}\nexports.ConsoleLineElement = ConsoleLineElement;\nconst defaultCodeBoxID = \"GraphTableSVG-CodeBox\";\n/*\nfunction getCodeTag(containerID : string = defaultCodeBoxID ): HTMLElement | null {\n    const box = document.getElementById(containerID);\n    return box;\n}\n*/\nfunction getOrCreateCodeElement(containerID = defaultCodeBoxID) {\n    CSS.setGraphTableCSS();\n    const code = document.getElementById(containerID);\n    //const code = getCodeTag(containerID);\n    if (code != null) {\n        return code;\n    }\n    else {\n        const element = document.createElement(\"code\");\n        document.body.appendChild(element);\n        element.setAttribute(\"id\", defaultCodeBoxID);\n        //document.body.appendChild(element);\n        //element.setAttribute(\"name\", codeTagName);\n        return element;\n    }\n}\n/*\nfunction initialize(): void {\n    const code = getCodeTag();\n    if (code == null) {\n        createCodeTag();\n    }\n}\n*/\nfunction table(item, title = \"\", canvasID_or_ContainerID = null) {\n    if (item instanceof logic_table_1.LogicTable) {\n        return view(item, title, canvasID_or_ContainerID);\n    }\n    else if (item instanceof Array && item.every((v) => v instanceof logics_1.LogicCell)) {\n        const tableItem = (0, logics_1.buildLogicTable)([item], { isRowLines: false });\n        return table(tableItem, title, canvasID_or_ContainerID);\n    }\n    else {\n        const tableDic = new table_dictionary_1.TableDictionary();\n        tableDic.construct(item);\n        const logicTable = tableDic.toLogicTable();\n        return table(logicTable, title, canvasID_or_ContainerID);\n    }\n}\nexports.table = table;\nfunction clear(containerID = defaultCodeBoxID) {\n    const code = getOrCreateCodeElement(containerID);\n    code.innerHTML = \"\";\n}\nexports.clear = clear;\nfunction graph(item, title = \"\", canvasID_or_ContainerID = null) {\n    if (item instanceof logic_tree_1.LogicTree || item instanceof logic_graph_1.LogicGraph) {\n        if (item instanceof logic_tree_1.LogicTree) {\n            return view(item, title, canvasID_or_ContainerID);\n        }\n        else {\n            return view(item, title, canvasID_or_ContainerID);\n        }\n    }\n    else {\n        const tableDic = new table_dictionary_1.TableDictionary();\n        tableDic.construct(item);\n        const logicGraph = tableDic.toLogicGraph();\n        return graph(logicGraph, title, canvasID_or_ContainerID);\n    }\n}\nexports.graph = graph;\nfunction log(message, title = \"\") {\n    const code = getOrCreateCodeElement();\n    const consoleLine = new ConsoleLineElement(code, \"log\", title);\n    const textClass = DefaultClassNames.defaultTextClass;\n    const textElement = SVG.createText(textClass);\n    //const text = document.createElementNS('http://www.w3.org/2000/svg', \"text\");\n    //text.textContent = message;\n    consoleLine.canvas.appendChild(textElement);\n    SVGTextBox.setTextToSVGText(textElement, message, false);\n    textElement.setAttribute(\"x\", \"0\");\n    const b2 = SVGTextExtension.getSize(textElement, true);\n    textElement.setAttribute(\"y\", b2.height.toString());\n    consoleLine.addVBAObject(textElement);\n    //table(message);\n    return consoleLine;\n}\nexports.log = log;\nfunction getRowCount(line, cols) {\n    return Math.ceil(line.length / cols);\n}\nfunction textarea(message, title = \"\", option) {\n    if (typeof (message) != \"string\") {\n        return textarea(ToJSON.stringify(message), title, option);\n    }\n    else {\n        const newOption = option === undefined ? {} : option;\n        const code = getOrCreateCodeElement(newOption.container === undefined ? defaultCodeBoxID : newOption.container);\n        const textArea = document.createElement(\"textarea\");\n        textArea.textContent = message;\n        const lines = message.split(\"\\n\");\n        let maxCols = 0;\n        lines.forEach((v) => {\n            if (v.length > maxCols) {\n                maxCols = v.length;\n            }\n        });\n        const defaultCols = maxCols < 240 ? maxCols + 5 : 245;\n        textArea.cols = newOption.cols === undefined ? defaultCols : newOption.cols;\n        let rowCount = 0;\n        lines.forEach((v) => rowCount += getRowCount(v, textArea.cols));\n        textArea.rows = newOption.rows === undefined ? rowCount : newOption.rows;\n        const consoleLine = new ConsoleLineElement(code, \"textarea\", title, { mainElement: textArea });\n        consoleLine.title = title;\n        //const canvasContainer = document.createElement(\"div\");\n        //code.appendChild(canvasContainer);                \n        //consoleLine.canvasContainer.appendChild(textArea);\n        return consoleLine;\n    }\n}\nexports.textarea = textarea;\nfunction view(item, title, canvasID = null) {\n    let isCanvasID = false;\n    if (canvasID != null) {\n        if (typeof (canvasID) == \"string\") {\n            isCanvasID = (document.getElementById(canvasID) instanceof SVGSVGElement);\n        }\n        else {\n            isCanvasID = canvasID instanceof SVGSVGElement;\n        }\n    }\n    if (item instanceof logic_table_1.LogicTable) {\n        if (isCanvasID) {\n            const canvasItem = canvasID;\n            const gtable = (0, create_g_object_1.createGObject)(canvasItem, enums_1.ShapeObjectType.Table);\n            gtable.buildFromLogicTable(item);\n            return [gtable, gtable.svgGroup.parentNode];\n        }\n        else {\n            const containerID = canvasID == null ? null : canvasID;\n            const code = containerID == null ? getOrCreateCodeElement() : getOrCreateCodeElement(containerID);\n            const consoleLine = new ConsoleLineElement(code, \"table\", title);\n            const gtable = (0, create_g_object_1.createGObject)(consoleLine.canvas, enums_1.ShapeObjectType.Table);\n            gtable.buildFromLogicTable(item);\n            gtable.x = 0;\n            gtable.y = 0;\n            consoleLine.addVBAObject(gtable);\n            return [gtable, consoleLine];\n        }\n    }\n    else if (item instanceof logic_tree_1.LogicTree || item instanceof logic_graph_1.LogicGraph) {\n        throw new Error(\"Error\");\n        /*\n        if(isCanvasID){\n            const canvasItem = <string | SVGElement>canvasID;\n            const ggraph = <ZGraph>createGObject(canvasItem, ShapeObjectType.Graph);\n            ggraph.build(item);\n            if (item.option.drawingFunction !== undefined) {\n                const drawingFunction = new Function(\"obj\", `${item.option.drawingFunction.functionName}(obj)`);\n                drawingFunction(ggraph);\n            }\n            return [ggraph, <SVGElement>ggraph.svgGroup.parentNode];\n        }\n        else {\n            const containerID : string | null = canvasID == null ? null : <string>canvasID;\n            const code = containerID == null ? getOrCreateCodeElement() : getOrCreateCodeElement(containerID);\n\n            //const code = getOrCreateCodeElement();\n            const consoleLine = new ConsoleLineElement(code, \"graph\", title);\n            //const svg = addSVGSVGElement(code);\n            const ggraph = <ZGraph>createGObject(consoleLine.canvas!, ShapeObjectType.Graph);\n            if(item.option ===undefined){\n                throw new Exceptions.UndefinedError();\n            }\n    \n            ggraph.build(item);\n            consoleLine.addVBAObject(ggraph);\n            if (item.option.drawingFunction !== undefined) {\n                const drawingFunction = new Function(\"obj\", `${item.option.drawingFunction.functionName}(obj)`);\n                drawingFunction(ggraph);\n            }\n\n            return [ggraph, consoleLine];\n        }\n        */\n        //graph(item);\n    }\n    else {\n        let gobject;\n        let svg;\n        if (canvasID != null) {\n            gobject = (0, create_g_object_1.createGObject)(canvasID, enums_1.ShapeObjectType.Object);\n            svg = gobject.svgGroup.parentNode;\n        }\n        else {\n            const code = getOrCreateCodeElement();\n            const consoleLine = new ConsoleLineElement(code, \"group\", title);\n            gobject = (0, create_g_object_1.createGObject)(consoleLine.canvas, enums_1.ShapeObjectType.Object);\n            svg = consoleLine;\n        }\n        let prevItem = null;\n        item.items.forEach((v) => {\n            if (item.itemOrder == \"row\") {\n                if (prevItem != null) {\n                    if (v instanceof logic_table_1.LogicTable) {\n                        v.option.x = 0;\n                        v.option.y = prevItem.getRegion().bottom + item.itemInterval;\n                        v.option.positionType = \"upper-left\";\n                    }\n                    else if (v instanceof logic_tree_1.LogicTree) {\n                        v.option.position = { x: 0, y: prevItem.getRegion().bottom + item.itemInterval, type: \"upper-left\" };\n                    }\n                }\n            }\n            const [tmp1, tmp2] = view(v, title, gobject.svgGroup);\n            prevItem = tmp1;\n        });\n        return [gobject, svg];\n    }\n}\nexports.view = view;\n/*\nexport function viewUsingObject(obj: any, title: string, canvasID: string | SVGElement | null = null) : [GObject, ConsoleLineElement | SVGElement] {\n    const item = LogicGroup.buildLogicObjectFromObject(obj);\n    return view(<any>item, title, canvasID);\n}\n*/\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/console.ts?");

/***/ }),

/***/ "./src/options/create_g_object.ts":
/*!****************************************!*\
  !*** ./src/options/create_g_object.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createGObject = void 0;\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nfunction createGObject(parent, type, option = {}) {\n    /*\n    let _parent: SVGElement;\n    if (parent instanceof ZObject) {\n        _parent = parent.svgGroup;\n    } else if (parent instanceof SVGElement) {\n        _parent = parent;\n    } else {\n        _parent = <any>document.getElementById(parent);\n    }\n\n    switch (type) {\n        case ShapeObjectType.Callout:\n            const call = new ZCallout(_parent);\n            call.setOption(option);\n            return call;\n        case ShapeObjectType.ArrowCallout:\n            const arr = new ZArrowCallout(_parent);\n            arr.setOption(option);\n        case ShapeObjectType.Ellipse:\n            const ell = new ZEllipse(_parent);\n            ell.setOption(option);\n            return ell;\n        case ShapeObjectType.Rect:\n            const rect = new ZRect(_parent);\n            rect.setOption(option);\n            return rect;\n        case ShapeObjectType.Edge:\n            const edge = new ZEdge(_parent);\n            edge.setOption(option);\n            return edge;\n        case ShapeObjectType.Graph:\n            const graph = new ZGraph(_parent);\n            graph.setOption(option);\n            return graph;\n        case ShapeObjectType.Table:\n            const table = new ZTable(_parent);\n            table.setOption(option);\n            return table;\n        case ShapeObjectType.RectButton:\n            const rectb = new ZRectButton(_parent);\n            rectb.setOption(option);\n            return rectb;\n        case ShapeObjectType.Circle:\n            const circle = new ZCircle(_parent);\n            circle.setOption(option);\n            return circle;\n        case ShapeObjectType.ForeignButton:\n            const button = new ZForeignButton(_parent);\n            button.setOption(option);\n            return button;\n\n        case ShapeObjectType.Object:\n            const obj = new ZObject(_parent);\n            obj.setOption(option);\n            return obj;\n    }\n    */\n    throw new exceptions_1.ArgumentOutOfRangeError();\n}\nexports.createGObject = createGObject;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/create_g_object.ts?");

/***/ }),

/***/ "./src/options/custom_tag_processors/intermediate_g_tag_preprocessor.ts":
/*!******************************************************************************!*\
  !*** ./src/options/custom_tag_processors/intermediate_g_tag_preprocessor.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.processIntermediateSVGGElements = exports.convertFromZTagToIntermediateSVGGTag = void 0;\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../../common/enums */ \"./src/common/enums.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../../html/html_functions */ \"./src/html/html_functions.ts\");\nconst z_callout_1 = __webpack_require__(/*! ../../objects/z_callout */ \"./src/objects/z_callout.ts\");\nconst z_arrow_callout_1 = __webpack_require__(/*! ../../objects/z_arrow_callout */ \"./src/objects/z_arrow_callout.ts\");\nconst z_ellipse_1 = __webpack_require__(/*! ../../objects/z_ellipse */ \"./src/objects/z_ellipse.ts\");\nconst z_rect_1 = __webpack_require__(/*! ../../objects/z_rect */ \"./src/objects/z_rect.ts\");\nconst z_edge_1 = __webpack_require__(/*! ../../objects/z_edge */ \"./src/objects/z_edge.ts\");\nconst z_table_1 = __webpack_require__(/*! ../../objects/z_table */ \"./src/objects/z_table.ts\");\nconst z_graph_1 = __webpack_require__(/*! ../../objects/z_graph */ \"./src/objects/z_graph.ts\");\nconst z_rect_button_1 = __webpack_require__(/*! ../../objects/z_rect_button */ \"./src/objects/z_rect_button.ts\");\nconst z_circle_1 = __webpack_require__(/*! ../../objects/z_circle */ \"./src/objects/z_circle.ts\");\nconst z_foreign_button_1 = __webpack_require__(/*! ../../objects/z_foreign_button */ \"./src/objects/z_foreign_button.ts\");\n/**\n * ZObjectCustomGElement\n * @param element\n * @returns\n */\nfunction convertFromZTagToIntermediateSVGGTagSub(e) {\n    const type = enums_1.ShapeObjectType.toShapeObjectTypeOrCustomTag(e.nodeName.toLowerCase());\n    if (type == null) {\n    }\n    else {\n        const ns = document.createElementNS('http://www.w3.org/2000/svg', \"g\");\n        ns.setAttribute(AttributeNames.customElement, e.nodeName.toLowerCase());\n        HTMLFunctions.copyAttributes(e, ns);\n        ns.innerHTML = e.innerHTML;\n        //HTMLFunctions.getChildren(e).forEach((v)=>ns.appendChild(v));\n        const p = e.parentElement;\n        if (p != null) {\n            p.insertBefore(ns, e);\n            e.remove();\n        }\n        const children = HTMLFunctions.getChildren(ns);\n        children.forEach((v) => convertFromZTagToIntermediateSVGGTagSub(v));\n    }\n}\nfunction convertFromZTagToIntermediateSVGGTag(svgsvg) {\n    HTMLFunctions.getDescendants(svgsvg).forEach(v => {\n        const shapeType = enums_1.ShapeObjectType.toShapeObjectType(v.nodeName.toLowerCase());\n        if (shapeType != null) {\n            convertFromZTagToIntermediateSVGGTagSub(v);\n        }\n    });\n}\nexports.convertFromZTagToIntermediateSVGGTag = convertFromZTagToIntermediateSVGGTag;\n/**\n * CustomGElement\n * @param element\n * @returns\n */\nfunction isIntermediateSVGGElement(element) {\n    const gObjectTypeAttr = element.getAttribute(AttributeNames.customElement);\n    if (gObjectTypeAttr != null) {\n        const gObjectType = enums_1.ShapeObjectType.toShapeObjectType(gObjectTypeAttr);\n        return gObjectType != null;\n    }\n    else {\n        return false;\n    }\n}\n/**\n * g-rectGObject\n * @param intermediateSVGGElement Element\n * @param type\n * @returns\n */\nfunction convertFromIntermediateGElementToZObject(intermediateSVGGElement, type) {\n    const parent = intermediateSVGGElement.parentElement;\n    if (parent instanceof SVGElement) {\n        let r;\n        //intermediateSVGGElement.removeAttribute(AttributeNames.customElement);\n        if (type == enums_1.ShapeObjectType.Callout) {\n            //const option = ZCallout.constructAttributes(intermediateSVGGElement, true);\n            r = new z_callout_1.ZCallout(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.ArrowCallout) {\n            //const option = ZArrowCallout.constructAttributes(intermediateSVGGElement, true);\n            r = new z_arrow_callout_1.ZArrowCallout(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.Ellipse) {\n            //const option = ZEllipse.constructAttributes(intermediateSVGGElement, true);\n            r = new z_ellipse_1.ZEllipse(parent);\n            r.initialize(intermediateSVGGElement);\n            // r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.Circle) {\n            //const option = ZCircle.constructAttributes(intermediateSVGGElement, true);\n            r = new z_circle_1.ZCircle(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.Rect) {\n            //const option = ZRect.constructAttributes(intermediateSVGGElement, true);\n            r = new z_rect_1.ZRect(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.Edge) {\n            //const option = ZEdge.constructAttributes(intermediateSVGGElement, true);\n            r = new z_edge_1.ZEdge(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.Graph) {\n            //const option = ZGraph.constructAttributes(intermediateSVGGElement, true, {}, \"center\");\n            r = new z_graph_1.ZGraph(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n            //(<ZGraph>r).relocate();\n        }\n        else if (type == enums_1.ShapeObjectType.Table) {\n            //const logicTable = LogicTable.constructLogicTable(intermediateSVGGElement);\n            const table = new z_table_1.ZTable(parent);\n            table.initialize(intermediateSVGGElement);\n            /*\n            if(logicTable != null){\n                //logicTable.option = convertAttributesIntoTableOption(node);\n                table.buildFromLogicTable(logicTable);\n            }else{\n                const option = convertAttributesIntoTableOption(intermediateSVGGElement);\n                table.assignOption(option);\n            }\n            */\n            r = table;\n        }\n        else if (type == enums_1.ShapeObjectType.RectButton) {\n            //const option = ZRectButton.constructAttributes(intermediateSVGGElement, true);\n            r = new z_rect_button_1.ZRectButton(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.ForeignButton) {\n            //const option = ZRectButton.constructAttributes(intermediateSVGGElement, true);\n            r = new z_foreign_button_1.ZForeignButton(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else {\n            return null;\n        }\n        //\n        /*\n        const attrs = ElementExtension.gtGetAttributes(intermediateSVGGElement);\n        HTMLFunctions.getChildren(intermediateSVGGElement).forEach((v) => r.svgGroup.appendChild(v));\n        intermediateSVGGElement.remove();\n        attrs.forEach((v) => {\n            var items = v.name.split(\":\");\n            if (items.length == 2 && items[0] == \"surface\") {\n                if (r.svgSurface != null) {\n                    r.svgSurface.setAttribute(items[1], v.value);\n                }\n            } else {\n                r.svgGroup.setAttribute(v.name, v.value)\n            }\n        }\n        );\n        */\n        if (r instanceof z_graph_1.ZGraph) {\n            r.relocate();\n        }\n        return r;\n    }\n    else {\n        throw Error(\"error!\");\n    }\n}\nfunction processIntermediateSVGGElements(svgsvg, output) {\n    HTMLFunctions.getDescendantsByPostorder(svgsvg).forEach((v) => {\n        if (v instanceof SVGElement) {\n            if (isIntermediateSVGGElement(v)) {\n                const p = convertFromIntermediateSVGGElementToZObject(v);\n                if (p != null && output != null) {\n                    output.push(p);\n                }\n            }\n        }\n    });\n}\nexports.processIntermediateSVGGElements = processIntermediateSVGGElements;\nfunction convertFromIntermediateSVGGElementToZObject(id) {\n    if (typeof id == \"string\") {\n        const item = document.getElementById(id);\n        if (item instanceof SVGElement) {\n            return convertFromIntermediateSVGGElementToZObject(item);\n        }\n        else {\n            return null;\n        }\n    }\n    else {\n        const element = id;\n        //const shapeType = GraphTableSVG.ShapeObjectType.toShapeObjectType(element.nodeName);\n        const gObjectTypeAttr = element.getAttribute(AttributeNames.customElement);\n        if (gObjectTypeAttr != null) {\n            const gObjectType = enums_1.ShapeObjectType.toShapeObjectType(gObjectTypeAttr);\n            if (gObjectType != null) {\n                return convertFromIntermediateGElementToZObject(element, gObjectType);\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            const type = enums_1.ShapeObjectType.toShapeObjectType(element.nodeName.toLowerCase());\n            if (type != null) {\n                return convertFromIntermediateGElementToZObject(element, type);\n            }\n            else {\n                return null;\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/custom_tag_processors/intermediate_g_tag_preprocessor.ts?");

/***/ }),

/***/ "./src/options/custom_tag_processors/macro_tag_preprocessor.ts":
/*!*********************************************************************!*\
  !*** ./src/options/custom_tag_processors/macro_tag_preprocessor.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.processMacroTag = void 0;\nconst common_1 = __webpack_require__(/*! ../../common */ \"./src/common/index.ts\");\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../../common/enums */ \"./src/common/enums.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../../html/html_functions */ \"./src/html/html_functions.ts\");\n/**\n * CustomGElement\n * @param element\n * @returns\n */\n/*\n export function isMacroTag(element: Element): MacroTagNames | null {\n    const gObjectTypeAttr = element.getAttribute(AttributeNames.customElement);\n\n    if (gObjectTypeAttr != null) {\n        const gObjectType = ShapeObjectType.toShapeObjectType(gObjectTypeAttr);\n        return gObjectType != null;\n    } else {\n        return false;\n    }\n\n}\n*/\nlet _id_count = 1;\nfunction getNewID(e) {\n    while (true) {\n        const id = `__${e.nodeName.toLowerCase()}_${_id_count++}`;\n        if (document.getElementById(id) == null) {\n            return id;\n        }\n    }\n}\nfunction isMacroVertex(e) {\n    if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Circle) {\n        return enums_1.MacroTagNames.Circle;\n    }\n    else if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Ellipse) {\n        return enums_1.MacroTagNames.Ellipse;\n    }\n    else if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Rect) {\n        return enums_1.MacroTagNames.Rect;\n    }\n    else {\n        return null;\n    }\n}\nfunction createUnknownElement(e) {\n    if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Circle) {\n        return document.createElement(enums_1.ShapeObjectType.Circle);\n    }\n    else if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Ellipse) {\n        return document.createElement(enums_1.ShapeObjectType.Ellipse);\n    }\n    else if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Rect) {\n        return document.createElement(enums_1.ShapeObjectType.Rect);\n    }\n    else {\n        return null;\n    }\n}\nfunction processMacroNodeTag(e, parent, depth, outputVertexes, outputEdges) {\n    const newNode = createUnknownElement(e);\n    //newNode.setAttribute(AttributeNames.customElement, ShapeObjectType.Ellipse);\n    HTMLFunctions.copyAttributes(e, newNode);\n    outputVertexes.push(newNode);\n    newNode.setAttribute(\"data-depth\", depth.toString());\n    newNode.setAttribute(\"data-x\", outputVertexes.length.toString());\n    newNode.setAttribute(\"cy\", ((depth + 1) * 50).toString());\n    newNode.setAttribute(\"id\", getNewID(newNode));\n    if (parent != null) {\n        const newEdge = document.createElement(enums_1.ShapeObjectType.Edge);\n        outputEdges.push(newEdge);\n        newEdge.setAttribute(\"id\", getNewID(newEdge));\n        newEdge.setAttribute(AttributeNames.beginVertex, parent.getAttribute(\"id\"));\n        newEdge.setAttribute(AttributeNames.endVertex, newNode.getAttribute(\"id\"));\n    }\n    while (e.children.length > 0) {\n        const child = e.children.item(0);\n        if (child != null) {\n            if (isMacroVertex(child) != null) {\n                processMacroNodeTag(child, newNode, depth + 1, outputVertexes, outputEdges);\n            }\n            else {\n                newNode.appendChild(child);\n            }\n        }\n    }\n    e.remove();\n}\nfunction processMacroTreeTag(e) {\n    const graphTag = document.createElement(enums_1.ShapeObjectType.Graph);\n    graphTag.setAttribute(AttributeNames.customElement, enums_1.ShapeObjectType.Graph);\n    HTMLFunctions.copyAttributes(e, graphTag);\n    if (graphTag.getAttribute(\"class\") == null) {\n        graphTag.setAttribute(\"class\", common_1.DefaultClassNames.defaultTreeClass);\n    }\n    const outputVertexes = new Array();\n    const outputEdges = new Array();\n    while (e.children.length > 0) {\n        const child = e.children.item(0);\n        if (child != null) {\n            if (isMacroVertex(child)) {\n                processMacroNodeTag(child, null, 0, outputVertexes, outputEdges);\n            }\n            else {\n                child.remove();\n            }\n        }\n    }\n    outputVertexes.forEach((v) => {\n        graphTag.appendChild(v);\n    });\n    outputEdges.forEach((v) => {\n        graphTag.appendChild(v);\n    });\n    return graphTag;\n}\nfunction processMacroTag(svgsvg) {\n    while (true) {\n        const trees = svgsvg.getElementsByTagName(enums_1.MacroTagNames.Tree);\n        if (trees.length > 0) {\n            const mtreeTag = trees.item(0);\n            if (mtreeTag != null) {\n                const intermediateGElement = processMacroTreeTag(mtreeTag);\n                svgsvg.insertBefore(intermediateGElement, mtreeTag);\n                mtreeTag.remove();\n            }\n        }\n        else {\n            break;\n        }\n    }\n}\nexports.processMacroTag = processMacroTag;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/custom_tag_processors/macro_tag_preprocessor.ts?");

/***/ }),

/***/ "./src/options/editor_helper.ts":
/*!**************************************!*\
  !*** ./src/options/editor_helper.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDisplayVertexObjectTypes = exports.DisplayObject = void 0;\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nvar DisplayObject;\n(function (DisplayObject) {\n    function create(key, displayName) {\n        return { key: key, displayName: displayName };\n    }\n    DisplayObject.create = create;\n})(DisplayObject || (exports.DisplayObject = DisplayObject = {}));\n//export function getObjects() : VertexObjectType[] {\n//    return [ \"g-callout\", \"g-arrow-callout\", \"g-ellipse\", \"g-circle\", \"g-rect\", \"g-path-textbox\", \"g-rect-button\", \"g-table\"];\n//}\nfunction getDisplayVertexObjectTypes() {\n    return [DisplayObject.create(enums_1.ShapeObjectType.Callout, \"ZCallout\"),\n        DisplayObject.create(enums_1.ShapeObjectType.ArrowCallout, \"ZArrowCallout\"),\n        DisplayObject.create(enums_1.ShapeObjectType.Ellipse, \"GEllipse\"),\n        DisplayObject.create(enums_1.ShapeObjectType.Circle, \"GCircle\"),\n        DisplayObject.create(enums_1.ShapeObjectType.Rect, \"GRect\"),\n        DisplayObject.create(enums_1.ShapeObjectType.PathTextBox, \"GPathTextbox\"),\n        DisplayObject.create(enums_1.ShapeObjectType.RectButton, \"GRectButton\"),\n        DisplayObject.create(enums_1.ShapeObjectType.Table, \"GTable\")];\n}\nexports.getDisplayVertexObjectTypes = getDisplayVertexObjectTypes;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/editor_helper.ts?");

/***/ }),

/***/ "./src/options/html_table.ts":
/*!***********************************!*\
  !*** ./src/options/html_table.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createHTMLTable = void 0;\nconst logic_table_1 = __webpack_require__(/*! ../logics/logic_table */ \"./src/logics/logic_table.ts\");\n//export namespace HTMLFunctions {\nfunction createHTMLTable(e) {\n    const table = logic_table_1.LogicTable.constructHTMLLogicTable(e);\n    const tableTag = document.createElement(\"table\");\n    tableTag.setAttribute(\"border\", \"1\");\n    tableTag.setAttribute(\"cellspacing\", \"0\");\n    tableTag.setAttribute(\"bordercolor\", \"black\");\n    if (table != null) {\n        const cellConnectChecker = new Array();\n        for (let y = 0; y < table.rowCount; y++) {\n            cellConnectChecker.push(new Array(table.columnCount));\n            for (let x = 0; x < table.columnCount; x++) {\n                cellConnectChecker[y][x] = true;\n            }\n        }\n        for (let y = 0; y < table.rowCount; y++) {\n            const tr = document.createElement(\"tr\");\n            tableTag.appendChild(tr);\n            for (let x = 0; x < table.columnCount; x++) {\n                if (cellConnectChecker[y][x]) {\n                    const td = document.createElement(\"td\");\n                    const cell = table.cells[y][x];\n                    if (cell.option.h != undefined && cell.option.h > 1) {\n                        td.setAttribute(\"rowspan\", cell.option.h.toString());\n                    }\n                    if (cell.option.w != undefined && cell.option.w > 1) {\n                        td.setAttribute(\"columnspan\", cell.option.w.toString());\n                    }\n                    for (let ty = 0; ty < cell.connectedRowCount; ty++) {\n                        for (let tx = 0; tx < cell.connectedColumnCount; tx++) {\n                            if (tx != 0 || ty != 0) {\n                                cellConnectChecker[ty + y][tx + x] = false;\n                            }\n                        }\n                    }\n                    const tTexts = cell.tTexts;\n                    //td.style.borderTopStyle = \"3px solid red\";\n                    if (tTexts != null) {\n                        tTexts.forEach((v) => {\n                            td.appendChild(v);\n                        });\n                    }\n                    else {\n                        const text = cell.text;\n                        if (typeof text == \"string\")\n                            td.innerHTML = text;\n                    }\n                    tr.appendChild(td);\n                }\n            }\n        }\n    }\n    return tableTag;\n}\nexports.createHTMLTable = createHTMLTable;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/html_table.ts?");

/***/ }),

/***/ "./src/options/index.ts":
/*!******************************!*\
  !*** ./src/options/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VBAObject = exports.processVBAButtonClickEvent = exports.stringify = exports.EditorHelper = exports.createMacroModalFromID = exports.SVGToVBA = exports.equalityCheck = exports.clearSVG = exports.createShape = exports.lazyOpenSVG = exports.openHTML = exports.openSVG = void 0;\nconst open_svg_1 = __webpack_require__(/*! ./open_svg */ \"./src/options/open_svg.ts\");\nObject.defineProperty(exports, \"openSVG\", ({ enumerable: true, get: function () { return open_svg_1.openSVG; } }));\nObject.defineProperty(exports, \"openHTML\", ({ enumerable: true, get: function () { return open_svg_1.openHTML; } }));\nObject.defineProperty(exports, \"lazyOpenSVG\", ({ enumerable: true, get: function () { return open_svg_1.lazyOpenSVG; } }));\nObject.defineProperty(exports, \"clearSVG\", ({ enumerable: true, get: function () { return open_svg_1.clearSVG; } }));\nconst create_g_object_1 = __webpack_require__(/*! ./create_g_object */ \"./src/options/create_g_object.ts\");\nObject.defineProperty(exports, \"createShape\", ({ enumerable: true, get: function () { return create_g_object_1.createGObject; } }));\nconst svg_equal_1 = __webpack_require__(/*! ./svg_equal */ \"./src/options/svg_equal.ts\");\nObject.defineProperty(exports, \"equalityCheck\", ({ enumerable: true, get: function () { return svg_equal_1.equalityCheck; } }));\nconst to_json_1 = __webpack_require__(/*! ./to_json */ \"./src/options/to_json.ts\");\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return to_json_1.stringify; } }));\n//import {convertFromIntermediateSVGGElementToZObject} from \"./custom_tag_processors/intermediate_g_tag_preprocessor\"\nconst svg_to_vba_1 = __webpack_require__(/*! ./svg_to_vba */ \"./src/options/svg_to_vba.ts\");\nObject.defineProperty(exports, \"SVGToVBA\", ({ enumerable: true, get: function () { return svg_to_vba_1.SVGToVBA; } }));\nconst VBAObject = __webpack_require__(/*! ./vba_object */ \"./src/options/vba_object.ts\");\nexports.VBAObject = VBAObject;\nconst vba_macro_modal_1 = __webpack_require__(/*! ./vba_macro_modal */ \"./src/options/vba_macro_modal.ts\");\nObject.defineProperty(exports, \"createMacroModalFromID\", ({ enumerable: true, get: function () { return vba_macro_modal_1.createMacroModalFromID; } }));\nObject.defineProperty(exports, \"processVBAButtonClickEvent\", ({ enumerable: true, get: function () { return vba_macro_modal_1.processVBAButtonClickEvent; } }));\nconst EditorHelper = __webpack_require__(/*! ./editor_helper */ \"./src/options/editor_helper.ts\");\nexports.EditorHelper = EditorHelper;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/index.ts?");

/***/ }),

/***/ "./src/options/open_svg.ts":
/*!*********************************!*\
  !*** ./src/options/open_svg.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.openHTML = exports.openSVG = exports.clearSVG = exports.lazyOpenSVG = exports.getGObjects = void 0;\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst HTMLTable = __webpack_require__(/*! ./html_table */ \"./src/options/html_table.ts\");\nconst GUIObserver = __webpack_require__(/*! ../html/gui_observer */ \"./src/html/gui_observer.ts\");\nconst z_object_1 = __webpack_require__(/*! ../objects/z_object */ \"./src/objects/z_object.ts\");\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nconst vba_macro_modal_1 = __webpack_require__(/*! ./vba_macro_modal */ \"./src/options/vba_macro_modal.ts\");\nconst intermediate_g_tag_preprocessor_1 = __webpack_require__(/*! ./custom_tag_processors/intermediate_g_tag_preprocessor */ \"./src/options/custom_tag_processors/intermediate_g_tag_preprocessor.ts\");\nconst macro_tag_preprocessor_1 = __webpack_require__(/*! ./custom_tag_processors/macro_tag_preprocessor */ \"./src/options/custom_tag_processors/macro_tag_preprocessor.ts\");\n//export namespace openSVGFunctions {\n//}\nlet timerInterval = 100;\nfunction getGObjectsSub(item) {\n    const arr = new Array();\n    const opr = item.operator;\n    if (opr != undefined && opr instanceof z_object_1.ZObject) {\n        arr.push(opr);\n    }\n    else {\n        for (let i = 0; i < item.children.length; i++) {\n            const child = item.children.item(i);\n            if (child != null) {\n                getGObjectsSub(child).forEach((v) => { arr.push(v); });\n            }\n        }\n    }\n    return arr;\n}\nfunction getGObjects(elementID) {\n    const svg = document.getElementById(elementID);\n    if (svg == null) {\n        throw new exceptions_1.NullError();\n    }\n    else {\n        return getGObjectsSub(svg);\n    }\n}\nexports.getGObjects = getGObjects;\nfunction lazyOpenSVG() {\n    const p = document.getElementsByTagName(\"svg\");\n    const svgElements = [];\n    for (let i = 0; i < p.length; i++) {\n        const svgNode = p.item(i);\n        if (svgNode instanceof SVGSVGElement)\n            svgElements.push(svgNode);\n    }\n    svgElements.forEach((svgsvg) => lazyElementDic.push(svgsvg));\n    if (lazyElementDic.length > 0)\n        setTimeout(observelazyElementTimer, timerInterval);\n}\nexports.lazyOpenSVG = lazyOpenSVG;\nlet lazyElementDic = [];\nfunction observelazyElementTimer() {\n    for (let i = 0; i < lazyElementDic.length; i++) {\n        const element = lazyElementDic[i];\n        if (HTMLFunctions.isInsideElement(element)) {\n            openSVG(element);\n            lazyElementDic.splice(i, 1);\n            i = -1;\n        }\n    }\n    if (lazyElementDic.length > 0)\n        setTimeout(observelazyElementTimer, timerInterval);\n}\nfunction clearSVG(id) {\n    const box = document.getElementById(id);\n    box.innerHTML = \"\";\n}\nexports.clearSVG = clearSVG;\nfunction openSVG(inputItem = null, output = []) {\n    if (typeof inputItem == \"string\") {\n        const item = document.getElementById(inputItem);\n        if (item != null && item instanceof SVGSVGElement) {\n            return openSVG(item, output);\n        }\n        else {\n            return [];\n        }\n    }\n    else if (inputItem === null) {\n        const p = document.getElementsByTagName(\"svg\");\n        const svgElements = [];\n        for (let i = 0; i < p.length; i++) {\n            const svgNode = p.item(i);\n            if (svgNode instanceof SVGSVGElement)\n                svgElements.push(svgNode);\n        }\n        svgElements.forEach((svgsvg) => openSVG(svgsvg, output));\n        return output;\n    }\n    else if (inputItem instanceof SVGSVGElement) {\n        const svgsvg = inputItem;\n        (0, macro_tag_preprocessor_1.processMacroTag)(svgsvg);\n        const vbaAttr = svgsvg.getAttribute(enums_1.OriginalSVGSVGAttributes.VBAAttributeName);\n        if (vbaAttr != null && vbaAttr == \"true\") {\n            (0, vba_macro_modal_1.appendVBAButton)(svgsvg);\n        }\n        (0, intermediate_g_tag_preprocessor_1.convertFromZTagToIntermediateSVGGTag)(svgsvg);\n        const startTime = performance.now();\n        (0, intermediate_g_tag_preprocessor_1.processIntermediateSVGGElements)(svgsvg, output);\n        const endTime = performance.now();\n        const time = endTime - startTime;\n        GUIObserver.observeSVGSVG(svgsvg);\n    }\n    else {\n        throw Error(\"errror\");\n    }\n    return output;\n}\nexports.openSVG = openSVG;\nfunction toDivElement(e) {\n    //const type = e.nodeName == \"G-TABLE\" ? \"g-table\" : e.nodeName == \"ROW\" ? \"row\" : e.nodeName == \"CELL\" ? \"cell\" : e.nodeName == \"T\" ? \"t\" : null;\n    const type = e.nodeName.toLowerCase() == enums_1.ShapeObjectType.Table ? enums_1.ShapeObjectType.Table : e.nodeName.toLowerCase() == \"row\" ? \"row\" : e.nodeName.toLowerCase() == \"cell\" ? \"cell\" : null;\n    if (type == null) {\n        return null;\n    }\n    else {\n        const ns = document.createElement(\"div\");\n        ns.setAttribute(AttributeNames.customElement, type);\n        for (let i = 0; i < e.attributes.length; i++) {\n            const attr = e.attributes.item(i);\n            ns.setAttribute(attr.name, attr.value);\n        }\n        ns.innerHTML = e.innerHTML;\n        //HTMLFunctions.getChildren(e).forEach((v)=>ns.appendChild(v));\n        const p = e.parentElement;\n        if (p != null) {\n            p.insertBefore(ns, e);\n            e.remove();\n        }\n        const children = HTMLFunctions.getChildren(ns);\n        children.forEach((v) => toDivElement(v));\n        return ns;\n    }\n}\nfunction isSVGElement(e) {\n    if (e.parentElement == null) {\n        return false;\n    }\n    else {\n        if (e.parentElement instanceof SVGSVGElement) {\n            return true;\n        }\n        else {\n            return isSVGElement(e.parentElement);\n        }\n    }\n}\nfunction openHTML(id = null) {\n    if (id == null) {\n        const p = document.getElementsByTagName(enums_1.ShapeObjectType.Table);\n        const svgElements = [];\n        for (let i = 0; i < p.length; i++) {\n            const svgNode = p.item(i);\n            if (svgNode != null) {\n                if (!isSVGElement(svgNode) && svgNode instanceof HTMLElement)\n                    svgElements.push(svgNode);\n            }\n        }\n        svgElements.forEach((e) => openHTML(e));\n    }\n    else if (typeof (id) == \"string\") {\n        const e = document.getElementById(id);\n        if (e instanceof HTMLElement) {\n            openHTML(e);\n        }\n    }\n    else {\n        const newE = toDivElement(id);\n        if (newE != null) {\n            const table = HTMLTable.createHTMLTable(newE);\n            newE.insertAdjacentElement('beforebegin', table);\n            newE.remove();\n        }\n    }\n}\nexports.openHTML = openHTML;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/open_svg.ts?");

/***/ }),

/***/ "./src/options/svg_equal.ts":
/*!**********************************!*\
  !*** ./src/options/svg_equal.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.equalityCheck = void 0;\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nfunction attributesToSet(obj1, obj2) {\n    const set = new Set();\n    for (let i = 0; i < obj1.attributes.length; i++) {\n        const attr = obj1.attributes.item(i);\n        if (attr != null) {\n            set.add(attr.name);\n        }\n    }\n    for (let i = 0; i < obj2.attributes.length; i++) {\n        const attr = obj2.attributes.item(i);\n        if (attr != null) {\n            set.add(attr.name);\n        }\n    }\n    return set;\n}\nfunction equal_attributes(obj1, obj2, attributeSet) {\n    Array.from(attributeSet.values()).forEach((v) => {\n        const value1 = obj1.getAttribute(v);\n        const value2 = obj2.getAttribute(v);\n        if (v == \"href\" || v == \"xlink:href\") {\n        }\n        else {\n            if (value1 != value2) {\n                throw new Error(`${v}/${value1}/${value2}`);\n            }\n        }\n    });\n    return true;\n}\nfunction equal_html(obj1, obj2, checkAttributes) {\n    if (checkAttributes) {\n        const attrNames = attributesToSet(obj1, obj2);\n        equal_attributes(obj1, obj2, attrNames);\n    }\n    const childsize1 = obj1.children.length;\n    const childsize2 = obj2.children.length;\n    if (childsize1 == childsize2) {\n        for (let i = 0; i < childsize1; i++) {\n            const node1 = obj1.children.item(i);\n            const node2 = obj2.children.item(i);\n            const b = equal_html(node1, node2, true);\n        }\n    }\n    else {\n        throw new Error(\"Children Size Error\");\n    }\n    return true;\n}\n/*\nfunction equal_svgsvg(obj1: HTMLElement, obj2: HTMLElement) {\n    const childsize1 = obj1.children.length;\n    const childsize2 = obj2.children.length;\n    if(childsize1 == childsize2){\n        for(let i=0;i<childsize1;i++){\n            const node1 = obj1.children.item(i)!;\n            const node2 = obj1.children.item(i)!;\n            if(node1 instanceof HTMLElement && node2 instanceof HTMLElement){\n                const b = equal_html(node1, node2);\n            }else{\n                throw new Error();\n            }\n        }\n    }else{\n        throw new Error();\n    }\n}\n*/\nfunction equal(obj1_id, obj2_id) {\n    const obj1 = document.getElementById(obj1_id);\n    const obj2 = document.getElementById(obj2_id);\n    if (obj1 != null && obj2 != null) {\n        let errorFlag = false;\n        try {\n            equal_html(obj1, obj2, false);\n        }\n        catch (e) {\n            errorFlag = true;\n            obj2.style.backgroundColor = \"red\";\n            throw e;\n        }\n        if (!errorFlag) {\n            obj2.style.backgroundColor = \"yellow\";\n        }\n        return true;\n    }\n    else {\n        throw new exceptions_1.NullError(`${obj1_id} / ${obj2_id}`);\n    }\n}\nfunction equalityCheck(test_id, correct_id_firefox, correct_id_edge, correct_id_chrome) {\n    const userAgent = window.navigator.userAgent.toLowerCase();\n    let correct_id = null;\n    let browser = window.navigator.userAgent;\n    if (userAgent.indexOf('edge') != -1) {\n        correct_id = correct_id_edge;\n    }\n    else if (userAgent.indexOf('firefox') != -1) {\n        correct_id = correct_id_firefox;\n    }\n    else if (userAgent.indexOf('chrome') != -1) {\n        correct_id = correct_id_chrome;\n    }\n    else {\n    }\n    //console.log(`Browser: ${browser}`)\n    if (correct_id != null) {\n        equal(test_id, correct_id);\n        //console.log(`Check OK!: ${test_id} / ${correct_id}`)\n    }\n    else {\n        //console.log(`NULL`);\n    }\n}\nexports.equalityCheck = equalityCheck;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/svg_equal.ts?");

/***/ }),

/***/ "./src/options/svg_to_vba.ts":
/*!***********************************!*\
  !*** ./src/options/svg_to_vba.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SVGToVBA = void 0;\n//namespace GraphTableSVG {\nconst z_object_1 = __webpack_require__(/*! ../objects/z_object */ \"./src/objects/z_object.ts\");\nconst z_table_1 = __webpack_require__(/*! ../objects/z_table */ \"./src/objects/z_table.ts\");\nconst z_graph_1 = __webpack_require__(/*! ../objects/z_graph */ \"./src/objects/z_graph.ts\");\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./src/common/vba_functions.ts\");\nconst vba_object_1 = __webpack_require__(/*! ./vba_object */ \"./src/options/vba_object.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst svg_element_extension_1 = __webpack_require__(/*! ../interfaces/svg_element_extension */ \"./src/interfaces/svg_element_extension.ts\");\nconst Parser = __webpack_require__(/*! svg-path-parser */ \"./node_modules/svg-path-parser/index.js\");\nclass SVGToVBA {\n    static convert(svgsvgID) {\n        if (svgsvgID instanceof SVGSVGElement) {\n            const types = (0, vba_object_1.collectVBAObjectTypes)(svgsvgID);\n            return this.create(types);\n        }\n        else {\n            const obj = document.getElementById(svgsvgID);\n            if (obj instanceof SVGSVGElement) {\n                return this.convert(obj);\n            }\n            else {\n                throw new ReferenceError(`${svgsvgID} is not the ID of an SVGSVGElement.`);\n            }\n        }\n    }\n    /**\n     * PowerpointVBA\n     * @param items\n     */\n    static create(items) {\n        //const id = 0;\n        if (items instanceof Array) {\n            const count = (0, vba_object_1.countVBSObjectNum)(items);\n            const s = new Array(0);\n            s.push(`Sub create()`);\n            s.push(` Dim createdSlide As slide`);\n            s.push(` Set createdSlide = ActivePresentation.Slides.Add(1, ppLayoutBlank)`);\n            for (let i = 0; i < count; i++) {\n                s.push(`Call create${i}(createdSlide)`);\n            }\n            s.push(`MsgBox \"created\"`);\n            s.push(`End Sub`);\n            let id = 0;\n            for (let i = 0; i < items.length; i++) {\n                const item = items[i];\n                if (item instanceof z_table_1.ZTable) {\n                    //const lines = item.createVBACode2(id++, \"createdSlide\");\n                    const lines = item.createVBACode(id);\n                    lines.forEach((v) => s.push(v));\n                    id++;\n                }\n                else if (item instanceof z_graph_1.ZGraph) {\n                    const lines = item.createVBACode(id);\n                    lines.forEach((v) => s.push(v));\n                    id += item.VBAObjectNum;\n                }\n                else if (item instanceof z_object_1.ZObject) {\n                    const lines = item.createVBACode(id);\n                    lines.forEach((v) => s.push(v));\n                    id += item.VBAObjectNum;\n                }\n                else if ((0, vba_object_1.isVBACodableSVG)(item)) {\n                    //const lines = SVGToVBA.createVBACodeOfSVGPath(item, id++);\n                    const lines = SVGToVBA.createVBACodeOfSVGElement(item, id);\n                    lines.forEach((v) => s.push(v));\n                    id++;\n                }\n            }\n            s.push(SVGToVBA.cellFunctionCode);\n            const r = vba_functions_1.VBATranslateFunctions.joinLines(s);\n            return r;\n        }\n        else if (typeof (items) == \"string\") {\n            const id = items;\n            const obj = document.getElementById(id);\n            if (obj != null && obj.operator instanceof z_object_1.ZObject) {\n                return SVGToVBA.create([obj.operator]);\n            }\n            else {\n                throw new Error();\n            }\n        }\n        else {\n            return SVGToVBA.create([items]);\n        }\n    }\n    static createVBACodeOfSVGElement(obj, id) {\n        const lines = new Array(0);\n        const backGroundvisible = (0, svg_element_extension_1.getBackgroundVisible)(obj) ? \"msoTrue\" : \"msoFalse\";\n        lines.push(`Sub create${id}(createdSlide As slide)`);\n        lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n        if (obj instanceof SVGTextElement) {\n            const sub = [];\n            lines.push(` Dim txt As Shape`);\n            lines.push(` Set txt = shapes_.AddTextbox(msoTextOrientationHorizontal, ${SVGTextExtension.getX(obj)}, ${SVGTextExtension.getY(obj)}, 0, 0)`);\n            const fontSize = parseInt(ElementExtension.getPropertyStyleValueWithDefault(obj, \"font-size\", \"24\"));\n            const fontFamily = vba_functions_1.VBATranslateFunctions.ToVBAFont(ElementExtension.getPropertyStyleValueWithDefault(obj, \"font-family\", \"MS PGothic\"));\n            const fontBold = vba_functions_1.VBATranslateFunctions.ToFontBold(ElementExtension.getPropertyStyleValueWithDefault(obj, \"font-weight\", \"none\"));\n            lines.push([` Call EditTextFrame(txt.TextFrame, ${0}, ${0}, ${0}, ${0}, false, ppAutoSizeShapeToFitText)`]);\n            vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement(sub, obj, `txt.TextFrame.TextRange`);\n            sub.forEach((v) => lines.push(v[0]));\n            lines.push([` Call EditTextEffect(txt.TextEffect, ${fontSize}, \"${fontFamily}\")`]);\n        }\n        else {\n            const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA((0, svg_element_extension_1.getStrokeColor)(obj));\n            const strokeWidth = (0, svg_element_extension_1.getStrokeWidth)(obj);\n            const lineColorValue = (0, svg_element_extension_1.getStrokeColor)(obj);\n            const lineVisible = lineColorValue != \"none\" ? \"msoTrue\" : \"msoFalse\";\n            if (obj instanceof SVGPathElement || obj instanceof SVGLineElement || obj instanceof SVGPolylineElement || obj instanceof SVGPolygonElement) {\n                if (obj instanceof SVGPathElement) {\n                    const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA((0, svg_element_extension_1.getBackgroundColor)(obj));\n                    lines.push(` Dim builder As FreeformBuilder`);\n                    const length = obj.getTotalLength();\n                    let d = 0;\n                    let p = obj.getPointAtLength(d);\n                    lines.push(` Set builder = shapes_.BuildFreeform(msoEditingCorner, ${p.x}, ${p.y}) `);\n                    d += 10;\n                    while (d < length) {\n                        p = obj.getPointAtLength(d);\n                        lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                        d += 10;\n                    }\n                    d = length;\n                    p = obj.getPointAtLength(d);\n                    lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                    const commandAttr = obj.getAttribute(\"d\");\n                    let hasClosePath = false;\n                    if (commandAttr != null) {\n                        const commandList = Parser.parseSVG(commandAttr);\n                        commandList.forEach((v) => {\n                            if (v.code == \"Z\" || v.code == \"z\") {\n                                hasClosePath = true;\n                            }\n                        });\n                    }\n                    if (hasClosePath) {\n                        p = obj.getPointAtLength(0);\n                        lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                    }\n                    lines.push(` Dim obj As Shape`);\n                    lines.push(`Set obj = builder.ConvertToShape`);\n                    lines.push(` Call EditLine(obj.Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${lineVisible})`);\n                    lines.push(` Call EditCallOut(obj, \"${id}\", ${backGroundvisible}, ${backColor})`);\n                    /*\n                    const pos = Extensions.getPathLocations(obj);\n                    lines.push(` Dim edges${id}(${pos.length - 1}) As Shape`);\n    \n                    for (let i = 0; i < pos.length - 1; i++) {\n                        lines.push(` Set edges${id}(${i}) = shapes_.AddConnector(msoConnectorStraight, ${pos[i][0]}, ${pos[i][1]}, ${pos[i + 1][0]}, ${pos[i + 1][1]})`);\n                        lines.push(` Call EditLine(edges${id}(${i}).Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${visible})`);\n                    }\n                    */\n                }\n                else if (obj instanceof SVGPolylineElement) {\n                    lines.push(` Dim builder As FreeformBuilder`);\n                    const list = obj.points;\n                    let p = list.getItem(0);\n                    lines.push(` Set builder = shapes_.BuildFreeform(msoEditingCorner, ${p.x}, ${p.y}) `);\n                    for (let i = 0; i < list.length; i++) {\n                        p = list.getItem(i);\n                        lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                    }\n                    lines.push(` Dim obj As Shape`);\n                    lines.push(`Set obj = builder.ConvertToShape`);\n                    lines.push(` Call EditLine(obj.Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${lineVisible})`);\n                }\n                else if (obj instanceof SVGPolygonElement) {\n                    const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA((0, svg_element_extension_1.getBackgroundColor)(obj));\n                    lines.push(` Dim builder As FreeformBuilder`);\n                    const list = obj.points;\n                    let p = list.getItem(0);\n                    lines.push(` Set builder = shapes_.BuildFreeform(msoEditingCorner, ${p.x}, ${p.y}) `);\n                    for (let i = 0; i < list.length; i++) {\n                        p = list.getItem(i);\n                        lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                    }\n                    p = list.getItem(0);\n                    lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                    lines.push(` Dim obj As Shape`);\n                    lines.push(`Set obj = builder.ConvertToShape`);\n                    lines.push(` Call EditLine(obj.Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${lineVisible})`);\n                    lines.push(` Call EditCallOut(obj, \"${id}\", ${backGroundvisible}, ${backColor})`);\n                }\n                else {\n                    const x1 = obj.x1.baseVal.value;\n                    const y1 = obj.y1.baseVal.value;\n                    const x2 = obj.x2.baseVal.value;\n                    const y2 = obj.y2.baseVal.value;\n                    lines.push(` Dim obj As Shape`);\n                    lines.push(` Set obj = shapes_.AddConnector(msoConnectorStraight, ${x1}, ${y1}, ${x2}, ${y2})`);\n                    lines.push(` Call EditLine(obj.Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${lineVisible})`);\n                }\n            }\n            else {\n                const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA((0, svg_element_extension_1.getBackgroundColor)(obj));\n                lines.push(` Dim obj As Shape`);\n                if (obj instanceof SVGRectElement) {\n                    const rx = obj.getAttribute(\"rx\") == null ? 0 : parseInt(obj.getAttribute(\"rx\"));\n                    const ry = obj.getAttribute(\"ry\") == null ? 0 : parseInt(obj.getAttribute(\"ry\"));\n                    const maxr = Math.max(rx, ry);\n                    const shape = maxr == 0 ? \"msoShapeRectangle\" : \"msoShapeRoundedRectangle\";\n                    const width = obj.width.baseVal.value;\n                    const height = obj.height.baseVal.value;\n                    const x = obj.x.baseVal.value;\n                    const y = obj.y.baseVal.value;\n                    lines.push(` Set obj = shapes_.AddShape(${shape}, ${x}, ${y}, ${width}, ${height})`);\n                    if (maxr > 0) {\n                        const ratio = maxr / width;\n                        lines.push(` obj.Adjustments.Item(1) = ${ratio}`);\n                    }\n                }\n                else if (obj instanceof SVGEllipseElement) {\n                    const shape = \"msoShapeOval\";\n                    const width = obj.rx.baseVal.value * 2;\n                    const height = obj.ry.baseVal.value * 2;\n                    const x = obj.cx.baseVal.value - obj.rx.baseVal.value;\n                    const y = obj.cy.baseVal.value - obj.ry.baseVal.value;\n                    lines.push(` Set obj = shapes_.AddShape(${shape}, ${x}, ${y}, ${width}, ${height})`);\n                }\n                else {\n                    const shape = \"msoShapeOval\";\n                    const width = obj.r.baseVal.value * 2;\n                    const height = obj.r.baseVal.value * 2;\n                    const x = obj.cx.baseVal.value - obj.r.baseVal.value;\n                    const y = obj.cy.baseVal.value - obj.r.baseVal.value;\n                    lines.push(` Set obj = shapes_.AddShape(${shape}, ${x}, ${y}, ${width}, ${height})`);\n                }\n                lines.push(` Call EditLine(obj.Line, ${lineColor}, ${enums_1.msoDashStyle.msoLineSolid}, ${0}, ${strokeWidth}, ${lineVisible})`);\n                lines.push(` Call EditCallOut(obj, \"${id}\", ${backGroundvisible}, ${backColor})`);\n            }\n        }\n        lines.push(`End Sub`);\n        return lines;\n    }\n}\nexports.SVGToVBA = SVGToVBA;\n/*\nprivate static createVBACodeOfSVGPath(path: SVGPathElement, id: number): string[] {\n    const lines = new Array(0);\n    const pos = Extensions.getPathLocations(path);\n    lines.push(`Sub create${id}(createdSlide As slide)`);\n    lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n    lines.push(` Dim edges${id}(${pos.length - 1}) As Shape`);\n\n\n    for (let i = 0; i < pos.length - 1; i++) {\n        lines.push(` Set edges${id}(${i}) = shapes_.AddConnector(msoConnectorStraight, ${pos[i][0]}, ${pos[i][1]}, ${pos[i + 1][0]}, ${pos[i + 1][1]})`);\n        const lineColor = VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(path, \"stroke\", \"gray\"));\n        const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(path,\"stroke-width\", \"4\"));\n        const visible = ElementExtension.getPropertyStyleValueWithDefault(path, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n        lines.push(` Call EditLine(edges${id}(${i}).Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${visible})`);\n    }\n\n    lines.push(`End Sub`);\n    return lines;\n}\n*/\n/*\n private static createVBACodeOfTextElement(element: SVGTextElement, id: number): string[] {\n     const lines = new Array(0);\n     const sub: string[][] = [];\n     lines.push(`Sub create${id}(createdSlide As slide)`);\n     lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n     lines.push(` Dim txt As Shape`);\n     lines.push(` Set txt = shapes_.AddTextbox(msoTextOrientationHorizontal, ${SVGTextExtension.getX(element)}, ${SVGTextExtension.getY(element)}, 0, 0)`);\n     const fontSize = parseInt(ElementExtension.getPropertyStyleValueWithDefault(element, \"font-size\", \"24\"));\n     const fontFamily = VBATranslateFunctions.ToVBAFont(ElementExtension.getPropertyStyleValueWithDefault(element,\"font-family\", \"MS PGothic\"));\n     const fontBold = VBATranslateFunctions.ToFontBold(ElementExtension.getPropertyStyleValueWithDefault(element, \"font-weight\", \"none\"));\n     lines.push([` Call EditTextFrame(txt.TextFrame, ${0}, ${0}, ${0}, ${0}, false, ppAutoSizeShapeToFitText)`]);\n     VBATranslateFunctions.TranslateSVGTextElement(sub, element, `txt.TextFrame.TextRange`);\n     sub.forEach((v) => lines.push(v[0]));\n     lines.push([` Call EditTextEffect(txt.TextEffect, ${fontSize}, \"${fontFamily}\")`]);\n\n\n     lines.push(`End Sub`);\n     return lines;\n }\n */\nSVGToVBA.cellFunctionCode = `\r\nSub EditTable(table_ As table, cellInfo_() As Variant)\r\n    Dim x As Integer\r\n    Dim y As Integer\r\n    \r\n    For x = 1 To UBound(cellInfo_, 1)\r\n        For y = 1 To UBound(cellInfo_, 2)\r\n         Call EditCell(table_.cell(x, y), CStr(cellInfo_(x, y)(0)))\r\n        Next\r\n    Next\r\nEnd Sub\r\n\r\nSub EditCell(cell_ As cell, text_ As String, backColor As Variant)\r\n    cell_.Shape.TextFrame.TextRange.text = text_\r\n    cell_.Shape.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\nSub EditCellFont(frame_ As TextFrame, fontSize As Double, fontName As String, color As Variant, fontBold As Integer)\r\n    frame_.TextRange.Font.Size = fontSize\r\n    frame_.TextRange.Font.name = fontName\r\n    frame_.TextRange.Font.color.RGB = RGB(CInt(color(0)), CInt(color(1)), CInt(color(2)))\r\n    frame_.TextRange.Font.Bold = fontBold\r\nEnd Sub\r\n\r\n\r\n\r\n\r\nSub EditRow(row_ As Row, height As Integer)\r\n    row_.height = height\r\nEnd Sub\r\nSub EditColumn(column_ As Column, width As Integer)\r\n    column_.width = width\r\nEnd Sub\r\n\r\nSub EditCellTextFrame(frame_ As TextFrame, marginTop As Double, marginBottom As Double, marginLeft As Double, marginRight As Double, vAnchor As Integer, hAnchor As Integer)\r\n    frame_.marginLeft = marginLeft\r\n    frame_.marginRight = marginRight\r\n    frame_.marginTop = marginTop\r\n    frame_.marginBottom = marginBottom\r\n    frame_.VerticalAnchor = vAnchor\r\n    frame_.TextRange.ParagraphFormat.Alignment = hAnchor\r\nEnd Sub\r\n\r\nSub EditTextRange(range_ As TextRange, text As String)\r\n    range_.text = text\r\nEnd Sub\r\nSub EditTextRangeSub(range_ As TextRange, subBeg As Integer, subLen As Integer, script As String, color As Variant, fontName As String, fontSize As Double, fontBold As Integer)\r\n    range_.Characters(subBeg, subLen).Font.color.RGB = RGB(CInt(color(0)), CInt(color(1)), CInt(color(2)))\r\n    range_.Characters(subBeg, subLen).Font.Size = fontSize\r\n    range_.Characters(subBeg, subLen).Font.name = fontName\r\n    range_.Characters(subBeg, subLen).Font.Bold = fontBold\r\n    If script = \"subscript\" Then\r\n    range_.Characters(subBeg, subLen).Font.Subscript = True\r\n    End If\r\n    If script = \"superscript\" Then\r\n    range_.Characters(subBeg, subLen).Font.Superscript = True\r\n    End If\r\nEnd Sub\r\n\r\n\r\n\r\nSub EditShape(shape_ As Shape, name As String, visible As Integer, backColor As Variant)\r\n    shape_.name = name\r\n    shape_.Fill.visible = visible\r\n    shape_.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\nSub EditCellBorder(line_ As LineFormat, foreColor As Variant, weight As Integer, transparent As Double)\r\n    line_.foreColor.RGB = RGB(CInt(foreColor(0)), CInt(foreColor(1)), CInt(foreColor(2)))\r\n    line_.weight = weight\r\n    line_.Transparency = transparent\r\nEnd Sub\r\n\r\nSub EditConnector(connector_ As ConnectorFormat, begShape As Shape, endShape As Shape, begPos As Integer, endPos As Integer)\r\n    Call connector_.BeginConnect(begShape, begPos)\r\n    Call connector_.EndConnect(endShape, endPos)\r\nEnd Sub\r\n\r\nSub EditTextFrame(frame_ As TextFrame, marginTop As Double, marginBottom As Double, marginLeft As Double, marginRight As Double, wordWrap As Boolean, autoSize As Integer)\r\n    frame_.autoSize = autoSize\r\n    frame_.wordWrap = wordWrap\r\n    frame_.marginLeft = marginLeft\r\n    frame_.marginRight = marginRight\r\n    frame_.marginTop = marginTop\r\n    frame_.marginBottom = marginBottom\r\nEnd Sub\r\nSub EditAnchor(frame_ As TextFrame, vAnchor As Integer, hAnchor As Integer)\r\n    frame_.VerticalAnchor = vAnchor\r\n    frame_.TextRange.ParagraphFormat.Alignment = hAnchor\r\nEnd Sub\r\n\r\nSub EditTextEffect(effect_ As TextEffectFormat, fontSize As Double, fontName As String)\r\n effect_.fontSize = fontSize\r\n effect_.fontName = fontName\r\nEnd Sub\r\n\r\nSub EditVertexShape(shape_ As Shape, name As String, visible As Integer, backColor As Variant)\r\n    shape_.name = name\r\n    shape_.Fill.visible = visible\r\n    shape_.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\n\r\nSub EditLine(line_ As LineFormat, foreColor As Variant, dashStyle As Integer, transparent As Double, weight As Integer, visible As Integer)\r\n    line_.foreColor.RGB = RGB(CInt(foreColor(0)), CInt(foreColor(1)), CInt(foreColor(2)))\r\n    line_.dashStyle = dashStyle\r\n    line_.Transparency = transparent\r\n    line_.weight = weight\r\n    line_.visible = visible\r\nEnd Sub\r\n\r\nSub EditCallOut(shape_ As Shape, name As String, visible As Integer, backColor As Variant)\r\n    shape_.name = name\r\n    shape_.Fill.visible = visible\r\n    shape_.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\n\r\n`;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/svg_to_vba.ts?");

/***/ }),

/***/ "./src/options/table_dictionary.ts":
/*!*****************************************!*\
  !*** ./src/options/table_dictionary.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TableDictionary = void 0;\n// tslint:disable-next-line: no-namespace\nconst logic_graph_1 = __webpack_require__(/*! ../logics/logic_graph */ \"./src/logics/logic_graph.ts\");\nconst logic_table_1 = __webpack_require__(/*! ../logics/logic_table */ \"./src/logics/logic_table.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst logic_text_1 = __webpack_require__(/*! ../logics/logic_text */ \"./src/logics/logic_text.ts\");\nclass TableDictionary {\n    // columnValues: Map<string, (string|undefined)[]>= new Map();\n    // itemCount : number = 0;\n    constructor() {\n        this.columnMapper = new Map();\n        this.rows = new Array();\n        this.objects = new Array();\n        this.columnMapper.set(TableDictionary.IndexName, 0);\n        // this.columnValues.set(\"index\", []);\n    }\n    construct(item) {\n        if (item instanceof Array) {\n            item.forEach((v) => {\n                this.add(v);\n            });\n        }\n        else {\n            this.add(item);\n        }\n    }\n    addValue(i, key, value) {\n        const column = this.columnMapper.get(key);\n        if (column === undefined) {\n            this.columnMapper.set(key, this.columnMapper.size);\n        }\n        this.rows[i].set(key, value);\n    }\n    add(item) {\n        this.rows.push(new Map());\n        this.objects.push(item);\n        const x = this.rows.length - 1;\n        this.addValue(x, TableDictionary.IndexName, x.toString());\n        if (item instanceof Array) {\n            for (let i = 0; i < item.length; i++) {\n                const cell = item[i];\n                if (cell != undefined) {\n                    this.addValue(x, i.toString(), cell);\n                }\n            }\n        }\n        else {\n            if (typeof item === \"string\" || typeof item === \"number\" || typeof item === \"boolean\") {\n                this.addValue(x, TableDictionary.ValueName, item.toString());\n            }\n            else if (typeof item === \"object\") {\n                Object.keys(item).forEach((key) => {\n                    const value = item[key];\n                    this.addValue(x, key.toString(), value);\n                });\n            }\n        }\n    }\n    toLogicTable() {\n        const table = new logic_table_1.LogicTable({ columnCount: this.columnMapper.size, rowCount: this.rows.length + 1 });\n        this.columnMapper.forEach((value, key) => {\n            const logicText = new logic_text_1.LogicText();\n            logicText.class = DefaultClassNames.defaultConsoleColumnTitleCellTextClass;\n            //table.cells[0][value].textClass = DefaultClassNames.defaultConsoleColumnTitleCellTextClass;\n            table.cells[0][value].backgroundOption.class = DefaultClassNames.defaultConsoleColumnTitleCellBackgroundClass;\n            if (key == TableDictionary.IndexName) {\n                logicText.textContent = \"(index)\";\n            }\n            else if (key == TableDictionary.ValueName) {\n                logicText.textContent = \"(value)\";\n            }\n            else {\n                logicText.textContent = key;\n            }\n            table.cells[0][value].text = logicText;\n        });\n        this.rows.forEach((map, index) => {\n            const tableIndex = index + 1;\n            for (let i = 0; i < this.columnMapper.size; i++) {\n                table.cells[tableIndex][i].text.textContent = \"undefined\";\n                table.cells[tableIndex][i].text.textContent = DefaultClassNames.defaultConsoleColumnTitleCellUndefinedTextClass;\n            }\n            map.forEach((value, key) => {\n                const columnIndex = this.columnMapper.get(key);\n                if (columnIndex != undefined) {\n                    const cell = this.rows[index].get(key);\n                    if (cell == null) {\n                        table.cells[tableIndex][columnIndex].text.textContent = \"null\";\n                    }\n                    else if (cell != undefined) {\n                        table.cells[tableIndex][columnIndex].text.textContent = cell.toString();\n                        table.cells[tableIndex][columnIndex].text.class = DefaultClassNames.defaultTextClass;\n                    }\n                }\n            });\n        });\n        return table;\n    }\n    createNode(item, graph, dic) {\n        if (typeof item === \"object\") {\n            let node = dic.get(item);\n            if (node !== undefined) {\n                return node;\n            }\n            else {\n                node = graph.addNode();\n                if (item !== undefined && item != null) {\n                    dic.set(item, node);\n                    Object.keys(item).forEach((key) => {\n                        const value = item[key];\n                        const child = this.createNode(value, graph, dic);\n                        const edge = graph.createEdge();\n                        edge.endNodeIndex = graph.getIndex(child);\n                        edge.text = key.toString();\n                        node.addEdge(edge);\n                    });\n                }\n                else {\n                    node.text = \"null\";\n                }\n                return node;\n            }\n        }\n        else {\n            const node = graph.addNode();\n            if (typeof item === \"undefined\") {\n                node.text = \"undefined\";\n            }\n            else {\n                node.text = item.toString();\n            }\n            return node;\n        }\n    }\n    toLogicGraph() {\n        const dic = new Map();\n        const graph = new logic_graph_1.LogicGraph();\n        this.rows.forEach((v, i) => {\n            const obj = this.objects[i];\n            this.createNode(obj, graph, dic);\n        });\n        return graph;\n    }\n}\nexports.TableDictionary = TableDictionary;\nTableDictionary.IndexName = \"___GraphTableSVG_Console_Index\";\nTableDictionary.ValueName = \"___GraphTableSVG_Console_Value\";\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/table_dictionary.ts?");

/***/ }),

/***/ "./src/options/to_json.ts":
/*!********************************!*\
  !*** ./src/options/to_json.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringify = exports.isPrimitiveObject = exports.spacePadding = void 0;\nfunction spacePadding(len) {\n    let s = \"\";\n    for (let i = 0; i < len; i++) {\n        s += \" \";\n    }\n    return s;\n}\nexports.spacePadding = spacePadding;\nfunction isPrimitiveObject(item) {\n    if (item == null) {\n        return true;\n    }\n    else if (item instanceof Array) {\n        return item.every((v) => (typeof v === \"string\" || typeof v === \"number\" || typeof v === \"boolean\"));\n    }\n    else {\n        return Object.keys(item).every((key) => {\n            const value = item[key];\n            return (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\");\n        });\n    }\n}\nexports.isPrimitiveObject = isPrimitiveObject;\nfunction toStringLineArray(item, name, padding) {\n    const r = new Array();\n    if (item instanceof Array) {\n        if (isPrimitiveObject(item)) {\n            const center = item.map((v) => v.toString()).join(\", \");\n            const s = name == null ? `[ ${center} ]` : `${name} = [ ${center} ]`;\n            r.push(spacePadding(padding) + s);\n        }\n        else {\n            let left = name == null ? (spacePadding(padding) + \"[\") : (spacePadding(padding) + `${name} = [`);\n            r.push(left);\n            for (let i = 0; i < item.length; i++) {\n                const center = toStringLineArray(item[i], null, padding + 1);\n                center.forEach((v) => r.push(v));\n            }\n            let right = spacePadding(padding) + \"[\";\n            r.push(right);\n        }\n    }\n    else {\n        if (typeof item === \"string\" || typeof item === \"number\" || typeof item === \"boolean\") {\n            if (name == null) {\n                const s = spacePadding(padding) + item.toString();\n                r.push(s);\n            }\n            else {\n                const s = `${spacePadding(padding)}${name} = ${item.toString()}`;\n                r.push(s);\n            }\n        }\n        else if (item instanceof Map) {\n            const arr = [];\n            item.forEach((value, key) => {\n                arr.push({ \"key\": key, \"value\": value });\n            });\n            const center = toStringLineArray(arr, name, padding);\n            center.forEach((v) => r.push(v));\n        }\n        else if (typeof item === \"object\") {\n            if (isPrimitiveObject(item)) {\n                if (item == null) {\n                    const s = name == null ? `null` : `${name} = null`;\n                    r.push(spacePadding(padding) + s);\n                }\n                else {\n                    const center = Object.keys(item).map((key) => `${key} = ${(item[key]).toString()}`).join(\", \");\n                    const s = name == null ? `{ ${center} }` : `${name} = { ${center} }`;\n                    r.push(spacePadding(padding) + s);\n                }\n            }\n            else {\n                let left = name == null ? (spacePadding(padding) + \"{\") : (spacePadding(padding) + `${name} = {`);\n                r.push(left);\n                Object.keys(item).forEach((key) => {\n                    const value = item[key];\n                    const center = toStringLineArray(value, key.toString(), padding + 1);\n                    center.forEach((v) => r.push(v));\n                });\n                let right = spacePadding(padding) + \"}\";\n                r.push(right);\n            }\n        }\n    }\n    return r;\n}\nfunction stringify(item) {\n    const r = toStringLineArray(item, null, 0);\n    return r.join(\"\\n\");\n}\nexports.stringify = stringify;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/to_json.ts?");

/***/ }),

/***/ "./src/options/vba_macro_modal.ts":
/*!****************************************!*\
  !*** ./src/options/vba_macro_modal.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.copyAndCloseMacroModal = exports.removeMacroModal = exports.createMacroModal = exports.createMacroModalFromID = exports.showMacroModal = exports.appendVBAButton = exports.processVBAButtonClickEvent = void 0;\n//namespace GraphTableSVG {\n//import { Padding, Rectangle } from \"../common/vline\";\nconst svg_to_vba_1 = __webpack_require__(/*! ./svg_to_vba */ \"./src/options/svg_to_vba.ts\");\nconst z_object_1 = __webpack_require__(/*! ../objects/z_object */ \"./src/objects/z_object.ts\");\nconst open_svg_1 = __webpack_require__(/*! ./open_svg */ \"./src/options/open_svg.ts\");\nconst vba_object_1 = __webpack_require__(/*! ./vba_object */ \"./src/options/vba_object.ts\");\nconst svg_1 = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\n//export namespace VBAMacroModal {\nfunction processVBAButtonClickEvent(e) {\n    const target = e.target;\n    if (target instanceof SVGElement) {\n        const svgsvg = (0, svg_1.getSVGSVG)(target);\n        const types = (0, vba_object_1.collectVBAObjectTypes)(svgsvg);\n        const vbaCode = svg_to_vba_1.SVGToVBA.create(types);\n        createMacroModal(vbaCode);\n    }\n    else {\n        alert(\"Error!\");\n    }\n}\nexports.processVBAButtonClickEvent = processVBAButtonClickEvent;\nfunction appendVBAButton(svgsvg) {\n    const p = document.createElementNS('http://www.w3.org/2000/svg', enums_1.ShapeObjectType.RectButton);\n    p.textContent = \"VBA\";\n    const rect = svgsvg.getBoundingClientRect();\n    p.setAttribute(\"x\", (rect.width - 100).toString());\n    p.setAttribute(\"y\", (rect.height - 50).toString());\n    p.setAttribute(\"data-vba\", \"false\");\n    p.setAttribute(\"onclick\", `GraphTableSVG.Options.processVBAButtonClickEvent(event)`);\n    svgsvg.appendChild(p);\n}\nexports.appendVBAButton = appendVBAButton;\nfunction showMacroModal(id) {\n    if (id instanceof z_object_1.ZObject) {\n        const p = svg_to_vba_1.SVGToVBA.create(id);\n        createMacroModal(p);\n    }\n    else {\n    }\n}\nexports.showMacroModal = showMacroModal;\nfunction createMacroModalFromID(id) {\n    const objects = (0, open_svg_1.getGObjects)(id);\n    const code = svg_to_vba_1.SVGToVBA.create(objects);\n    return createMacroModal(code);\n}\nexports.createMacroModalFromID = createMacroModalFromID;\n/**\n * \n * @param vbaCode VBA\n */\nfunction createMacroModal(vbaCode) {\n    if (vbaCode instanceof z_object_1.ZObject) {\n        const p = svg_to_vba_1.SVGToVBA.create(vbaCode);\n        createMacroModal(p);\n    }\n    else {\n        const mainDiv = document.createElement(\"div\");\n        mainDiv.id = \"macro-modal\";\n        mainDiv.innerHTML = `\r\nPowerpoint 2013<br>\r\n    <br>\r\n    <br>\r\n    <br>\r\n    F5 or <br>\r\n    <br>\r\n    SVG\r\n    <br>\r\n    <textarea id=\"codeBox\" rows=\"8\" cols=\"100\" style=\"overflow:auto;\"></textarea>\r\n`;\n        const button = document.createElement(\"button\");\n        button.setAttribute(\"class\", \"btn\");\n        button.textContent = \"\";\n        button.onclick = () => {\n            copyAndCloseMacroModal();\n        };\n        mainDiv.appendChild(button);\n        mainDiv.style.position = \"fixed\";\n        mainDiv.style.zIndex = \"16\";\n        mainDiv.style.width = \"900px\";\n        mainDiv.style.height = \"400px\";\n        mainDiv.style.left = `${((window.outerWidth - parseInt(mainDiv.style.width)) / 2)}px`;\n        //mainDiv.style.top = `${((window.outerHeight - parseInt(mainDiv.style.height)) / 2)}px`;\n        mainDiv.style.top = `${((window.outerHeight - parseInt(mainDiv.style.height)) / 16)}px`;\n        mainDiv.style.display = \"inline\";\n        mainDiv.style.backgroundColor = \"#ffffff\";\n        document.body.appendChild(mainDiv);\n        const cnt = document.getElementById(\"codeBox\");\n        cnt.value = vbaCode;\n        const bgDiv = document.createElement(\"div\");\n        document.body.appendChild(bgDiv);\n        bgDiv.style.width = \"100%\";\n        bgDiv.style.height = \"100%\";\n        bgDiv.style.backgroundColor = \"rgba(0,0,0,0.5)\";\n        bgDiv.style.position = \"fixed\";\n        bgDiv.style.top = \"0\";\n        bgDiv.style.left = \"0\";\n        bgDiv.id = \"modal-bg\";\n        bgDiv.style.zIndex = \"5\";\n        bgDiv.style.display = \"inline\";\n        bgDiv.onclick = removeMacroModal;\n        //$(\"body\").append('<div id=\"modal-bg\" style=\"z-index:5\"></div>');\n    }\n}\nexports.createMacroModal = createMacroModal;\n/**\n * \n */\nfunction removeMacroModal() {\n    const div1 = document.getElementById(\"macro-modal\");\n    const div2 = document.getElementById(\"modal-bg\");\n    if (div1 != null)\n        document.body.removeChild(div1);\n    if (div2 != null)\n        document.body.removeChild(div2);\n}\nexports.removeMacroModal = removeMacroModal;\n/**\n * \n */\nfunction copyAndCloseMacroModal() {\n    const cnt = document.getElementById(\"codeBox\");\n    cnt.select();\n    window.document.execCommand('copy');\n    alert('');\n    removeMacroModal();\n}\nexports.copyAndCloseMacroModal = copyAndCloseMacroModal;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/vba_macro_modal.ts?");

/***/ }),

/***/ "./src/options/vba_object.ts":
/*!***********************************!*\
  !*** ./src/options/vba_object.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clearGraphTables = exports.getRegion = exports.isVBAObject = exports.isVBACodableSVG = exports.collectVBAObjectTypes = exports.countVBSObjectNum = void 0;\n//namespace GraphTableSVG {\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst z_graph_1 = __webpack_require__(/*! ../objects/z_graph */ \"./src/objects/z_graph.ts\");\nconst z_table_1 = __webpack_require__(/*! ../objects/z_table */ \"./src/objects/z_table.ts\");\nconst z_object_1 = __webpack_require__(/*! ../objects/z_object */ \"./src/objects/z_object.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nfunction collectVBAObjectTypesSub(svg, output) {\n    const dataVBA = svg.getAttribute(\"data-vba\");\n    if (dataVBA == \"false\") {\n        return;\n    }\n    if (svg instanceof SVGGElement) {\n        const dataType = svg.getAttribute(\"data-type\");\n        if (dataType == null) {\n            for (let i = 0; i < svg.children.length; i++) {\n                const item = svg.children.item(i);\n                if (item != null && item instanceof SVGElement) {\n                    collectVBAObjectTypesSub(item, output);\n                }\n            }\n        }\n        else {\n            const type = enums_1.ShapeObjectType.toShapeObjectType(dataType);\n            if (type != null) {\n                const gObject = svg.operator;\n                output.push(gObject);\n            }\n        }\n    }\n    else if (isVBAObject(svg)) {\n        output.push(svg);\n    }\n    else {\n    }\n}\nfunction countVBSObjectNum(items) {\n    //const id = 0;\n    if (items instanceof Array) {\n        let c = 0;\n        for (let i = 0; i < items.length; i++) {\n            const item = items[i];\n            if (item instanceof z_table_1.ZTable) {\n                c++;\n            }\n            else if (item instanceof z_graph_1.ZGraph) {\n                c += item.VBAObjectNum;\n            }\n            else if (item instanceof z_object_1.ZObject) {\n                c += item.VBAObjectNum;\n            }\n            else {\n                c++;\n            }\n        }\n        return c;\n    }\n    else {\n        return countVBSObjectNum([items]);\n    }\n}\nexports.countVBSObjectNum = countVBSObjectNum;\nfunction collectVBAObjectTypes(svgsvg) {\n    const r = new Array();\n    for (let i = 0; i < svgsvg.children.length; i++) {\n        const item = svgsvg.children.item(i);\n        if (item != null && item instanceof SVGElement) {\n            collectVBAObjectTypesSub(item, r);\n        }\n    }\n    return r;\n}\nexports.collectVBAObjectTypes = collectVBAObjectTypes;\nfunction isVBACodableSVG(svg) {\n    if (svg instanceof SVGPathElement || svg instanceof SVGTextElement ||\n        svg instanceof SVGRectElement || svg instanceof SVGCircleElement || svg instanceof SVGEllipseElement ||\n        svg instanceof SVGLineElement || svg instanceof SVGPolylineElement || svg instanceof SVGPolygonElement) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexports.isVBACodableSVG = isVBACodableSVG;\nfunction isVBAObject(svg) {\n    if (svg instanceof SVGGElement) {\n        const dataType = svg.getAttribute(\"data-type\");\n        if (dataType == null) {\n            return false;\n        }\n        else {\n            const type = enums_1.ShapeObjectType.toShapeObjectType(dataType);\n            if (type != null) {\n                return true;\n            }\n        }\n    }\n    else if (isVBACodableSVG(svg)) {\n        return true;\n    }\n    return false;\n}\nexports.isVBAObject = isVBAObject;\n//export namespace VBAObject{\n/**\n * \n * @param items\n */\nfunction getRegion(items) {\n    const rects = items.map((v) => {\n        if (v instanceof z_object_1.ZObject) {\n            return v.getRegion();\n        }\n        else if (v instanceof SVGPathElement || v instanceof SVGTextElement) {\n            const rect = v.getBBox();\n            return new vline_1.Rectangle(rect.x, rect.y, rect.width, rect.height);\n        }\n        else {\n            return new vline_1.Rectangle();\n        }\n    });\n    if (rects.length > 0) {\n        return vline_1.Rectangle.merge(rects);\n    }\n    else {\n        return new vline_1.Rectangle();\n    }\n}\nexports.getRegion = getRegion;\n/**\n * \n * @param svg\n * @param items\n */\nfunction clearGraphTables(svg, items) {\n    for (let i = 0; i < items.length; i++) {\n        var item = items[i];\n        if (item instanceof z_graph_1.ZGraph) {\n            item.removeGraph(svg);\n        }\n        else if (item instanceof z_table_1.ZTable) {\n            item.removeTable(svg);\n        }\n    }\n}\nexports.clearGraphTables = clearGraphTables;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/vba_object.ts?");

/***/ }),

/***/ "./src/typedoc/index.ts":
/*!******************************!*\
  !*** ./src/typedoc/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hello = void 0;\nfunction hello() {\n    console.log(\"hello\");\n}\nexports.hello = hello;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/typedoc/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	GraphTableSVG = __webpack_exports__;
/******/ 	
/******/ })()
;