/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var GraphTableSVG;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/svg-path-parser/index.js":
/*!***********************************************!*\
  !*** ./node_modules/svg-path-parser/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// v1.0 exported just the parser function. To maintain backwards compatibility,\n// we export additional named features as properties of that function.\nvar parserFunction = (__webpack_require__(/*! ./parser.js */ \"./node_modules/svg-path-parser/parser.js\").parse);\nparserFunction.parseSVG = parserFunction;\nparserFunction.makeAbsolute = makeSVGPathCommandsAbsolute;\nmodule.exports = parserFunction;\n\nfunction makeSVGPathCommandsAbsolute(commands) {\n\tvar subpathStart, prevCmd={x:0,y:0};\n\tvar attr = {x:'x0',y:'y0',x1:'x0',y1:'y0',x2:'x0',y2:'y0'};\n\tcommands.forEach(function(cmd) {\n\t\tif (cmd.command==='moveto') subpathStart=cmd;\n\t\tcmd.x0=prevCmd.x; cmd.y0=prevCmd.y;\n\t\tfor (var a in attr) if (a in cmd) cmd[a] += cmd.relative ? cmd[attr[a]] : 0;\n\t\tif (!('x' in cmd)) cmd.x = prevCmd.x; // V\n\t\tif (!('y' in cmd)) cmd.y = prevCmd.y; // X\n\t\tcmd.relative = false;\n\t\tcmd.code = cmd.code.toUpperCase();\n\t\tif (cmd.command=='closepath') {\n\t\t\tcmd.x = subpathStart.x;\n\t\t\tcmd.y = subpathStart.y;\n\t\t}\n\t\tprevCmd = cmd;\n\t});\n\treturn commands;\n}\n\n\n//# sourceURL=webpack://GraphTableSVG/./node_modules/svg-path-parser/index.js?");

/***/ }),

/***/ "./node_modules/svg-path-parser/parser.js":
/*!************************************************!*\
  !*** ./node_modules/svg-path-parser/parser.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { svg_path: peg$parsesvg_path },\n      peg$startRuleFunction  = peg$parsesvg_path,\n\n      peg$c0 = function(data) {\n          if (!data) return [];\n          for (var cmds=[],i=0;i<data.length;i++) cmds=cmds.concat.apply(cmds,data[i]);\n          var first=cmds[0];\n          if (first && first.code=='m'){ // Per spec, first moveto is never relative\n            delete first.relative;\n            first.code = 'M';\n          }\n          return cmds;\n        },\n      peg$c1 = function(first, more) { return merge(first,more) },\n      peg$c2 = /^[Mm]/,\n      peg$c3 = peg$classExpectation([\"M\", \"m\"], false, false),\n      peg$c4 = function(c, first, more) {\n          var move = commands(c,[first]);\n          if (more) move = move.concat(commands(c=='M' ? 'L' : 'l',more[1]));\n          return move;\n        },\n      peg$c5 = /^[Zz]/,\n      peg$c6 = peg$classExpectation([\"Z\", \"z\"], false, false),\n      peg$c7 = function() { return commands('Z') },\n      peg$c8 = /^[Ll]/,\n      peg$c9 = peg$classExpectation([\"L\", \"l\"], false, false),\n      peg$c10 = function(c, args) { return commands(c,args) },\n      peg$c11 = /^[Hh]/,\n      peg$c12 = peg$classExpectation([\"H\", \"h\"], false, false),\n      peg$c13 = function(c, args) { return commands(c,args.map(function(x){ return {x:x}})) },\n      peg$c14 = /^[Vv]/,\n      peg$c15 = peg$classExpectation([\"V\", \"v\"], false, false),\n      peg$c16 = function(c, args) { return commands(c,args.map(function(y){ return {y:y}})) },\n      peg$c17 = /^[Cc]/,\n      peg$c18 = peg$classExpectation([\"C\", \"c\"], false, false),\n      peg$c19 = function(a, b, c) { return { x1:a.x, y1:a.y, x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c20 = /^[Ss]/,\n      peg$c21 = peg$classExpectation([\"S\", \"s\"], false, false),\n      peg$c22 = function(b, c) { return { x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c23 = /^[Qq]/,\n      peg$c24 = peg$classExpectation([\"Q\", \"q\"], false, false),\n      peg$c25 = function(a, b) { return { x1:a.x, y1:a.y, x:b.x, y:b.y } },\n      peg$c26 = /^[Tt]/,\n      peg$c27 = peg$classExpectation([\"T\", \"t\"], false, false),\n      peg$c28 = /^[Aa]/,\n      peg$c29 = peg$classExpectation([\"A\", \"a\"], false, false),\n      peg$c30 = function(rx, ry, xrot, large, sweep, xy) { return { rx:rx, ry:ry, xAxisRotation:xrot, largeArc:large, sweep:sweep, x:xy.x, y:xy.y } },\n      peg$c31 = function(x, y) { return { x:x, y:y } },\n      peg$c32 = function(n) { return n*1 },\n      peg$c33 = function(parts) { return parts.join('')*1 },\n      peg$c34 = /^[01]/,\n      peg$c35 = peg$classExpectation([\"0\", \"1\"], false, false),\n      peg$c36 = function(bit) { return bit=='1' },\n      peg$c37 = function() { return '' },\n      peg$c38 = \",\",\n      peg$c39 = peg$literalExpectation(\",\", false),\n      peg$c40 = function(parts) { return parts.join('') },\n      peg$c41 = \".\",\n      peg$c42 = peg$literalExpectation(\".\", false),\n      peg$c43 = /^[eE]/,\n      peg$c44 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c45 = /^[+\\-]/,\n      peg$c46 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c47 = /^[0-9]/,\n      peg$c48 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c49 = function(digits) { return digits.join('') },\n      peg$c50 = /^[ \\t\\n\\r]/,\n      peg$c51 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsesvg_path() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewsp();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsemoveTo_drawTo_commandGroups();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroups() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveTo_drawTo_commandGroup();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsemoveTo_drawTo_commandGroup();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemoveTo_drawTo_commandGroup();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroup() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveto();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsedrawto_command();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsedrawto_command();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedrawto_command() {\n    var s0;\n\n    s0 = peg$parseclosepath();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parselineto();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsehorizontal_lineto();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsevertical_lineto();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsecurveto();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsesmooth_curveto();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsequadratic_bezier_curveto();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsesmooth_quadratic_bezier_curveto();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseelliptical_arc();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveto() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    if (peg$c2.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsecomma_wsp();\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parselineto_argument_sequence();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c4(s1, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseclosepath() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c5.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c7();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parselineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c8.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parselineto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselineto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsehorizontal_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c11.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c12); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsenumber();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevertical_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c14.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c15); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c16(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c17.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c18); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecurveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecurveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecurveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecurveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecoordinate_pair();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c19(s1, s3, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c20.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsesmooth_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsesmooth_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesmooth_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c23.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c24); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsequadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsequadratic_bezier_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsequadratic_bezier_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsequadratic_bezier_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c26.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c27); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c28.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseelliptical_arc_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseelliptical_arc_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseelliptical_arc_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseelliptical_arc_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenonnegative_number();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenonnegative_number();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsenumber();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecomma_wsp();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseflag();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsecomma_wsp();\n                  if (s8 === peg$FAILED) {\n                    s8 = null;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseflag();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsecomma_wsp();\n                      if (s10 === peg$FAILED) {\n                        s10 = null;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parsecoordinate_pair();\n                        if (s11 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c30(s1, s3, s5, s7, s9, s11);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_pair() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c31(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenonnegative_number() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefloating_point_constant();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsedigit_sequence();\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsesign();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsefloating_point_constant();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedigit_sequence();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c33(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseflag() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c34.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c35); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c36(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsecomma_wsp() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewsp();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecomma();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c37();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c38;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c39); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloating_point_constant() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsefractional_constant();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseexponent();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseexponent();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsefractional_constant() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedigit_sequence();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c41;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c41;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseexponent() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c43.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsesign();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    var s0;\n\n    if (peg$c45.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c46); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit_sequence() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c47.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c49(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsewsp() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c50.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c51); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c37();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n\n    function merge(first,more){\n      if (!more) return [first];\n      for (var a=[first],i=0,l=more.length;i<l;i++) a[i+1]=more[i][1];\n      return a;\n    }\n\n    var cmds = {m:'moveto',l:'lineto',h:'horizontal lineto',v:'vertical lineto',c:'curveto',s:'smooth curveto',q:'quadratic curveto',t:'smooth quadratic curveto',a:'elliptical arc',z:'closepath'};\n    for (var code in cmds) cmds[code.toUpperCase()]=cmds[code];\n    function commands(code,args){\n      if (!args) args=[{}];\n      for (var i=args.length;i--;){\n        var cmd={code:code,command:cmds[code]};\n        if (code==code.toLowerCase()) cmd.relative=true;\n        for (var k in args[i]) cmd[k]=args[i][k];\n        args[i] = cmd;\n      }\n      return args;\n    }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n\n//# sourceURL=webpack://GraphTableSVG/./node_modules/svg-path-parser/parser.js?");

/***/ }),

/***/ "./src/common/attribute_names.ts":
/*!***************************************!*\
  !*** ./src/common/attribute_names.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.direction = exports.arrowHeadHeight = exports.arrowHeadWidth = exports.arrowNeckHeight = exports.arrowNeckWidth = exports.endVertex = exports.beginVertex = exports.columnWidth = exports.rowHeight = exports.height = exports.width = exports.h = exports.w = exports.y3 = exports.x3 = exports.y2 = exports.x2 = exports.y1 = exports.x1 = exports.cy = exports.cx = exports.y = exports.x = exports.syncYTargetPosition = exports.syncYSourcePosition = exports.syncYTarget = exports.syncXTargetPosition = exports.syncXSourcePosition = exports.syncXTarget = exports.id = exports.style = exports.className = exports.defaultCircleRadius = exports.defaultCellClass = exports.cellTemporaryBorderClass = exports.cellEmphasisBorderClass = exports.cellEmphasisCellClass = exports.customElement = exports.dataNameAttribute = exports.objectIDName = exports.GroupAttribute = exports.objectCreatedEventName = exports.vertexCreatedEventName = exports.resizeName = exports.connectPositionChangedEventName = exports.allowHoverName = exports.controlPointName = exports.isAppropriatelyReverseTextMode = exports.endNodeName = exports.beginNodeName = void 0;\nexports.speakerY = exports.speakerX = void 0;\nexports.beginNodeName = \"data-begin-node\";\nexports.endNodeName = \"data-end-node\";\nexports.isAppropriatelyReverseTextMode = \"data-appropriately-reverse-text\";\nexports.controlPointName = \"data-control-point\";\nexports.allowHoverName = \"data-allow-hover\";\nexports.connectPositionChangedEventName = \"connect_position_changed\";\nexports.resizeName = \"resized\";\nexports.vertexCreatedEventName = \"vertex_created\";\nexports.objectCreatedEventName = \"object_created\";\nexports.GroupAttribute = \"data-type\";\nexports.objectIDName = \"data-object-id\";\nexports.dataNameAttribute = \"data-name\";\nexports.customElement = \"data-custom\";\nexports.cellEmphasisCellClass = \"___cell-emphasis\";\nexports.cellEmphasisBorderClass = \"___border-emphasis\";\nexports.cellTemporaryBorderClass = \"___temporary-class\";\nexports.defaultCellClass = \"___cell-default\";\nexports.defaultCircleRadius = 15;\nexports.className = \"class\";\nexports.style = \"style\";\nexports.id = \"id\";\n//export const joint : string = \"joint\";\n//export const jointPosition : string = \"joint-position\";\nexports.syncXTarget = \"sync-x-target\";\nexports.syncXSourcePosition = \"sync-x-source-position\";\nexports.syncXTargetPosition = \"sync-x-target-position\";\nexports.syncYTarget = \"sync-y-target\";\nexports.syncYSourcePosition = \"sync-y-source-position\";\nexports.syncYTargetPosition = \"sync-y-target-position\";\n//export const beginConnectorTypeAttribute: string = \"begin-connector-type\";\n//export const endConnectorTypeAttribute: string = \"end-connector-type\";\n//export const groupClassName : string = \"group:class\";\n//export const groupStyle : string = \"group:style\";\n/*\nexport const surfaceClassName : string = \"surface:class\";\nexport const surfaceStyle : string = \"surface:style\";\n\n\nexport const backgroundClassName : string = \"background:class\";\nexport const backgroundStyle : string = \"background:style\";\n\nexport const topBorderClassName : string = \"topborder:class\";\nexport const topBorderStyle : string = \"topborder:style\";\n\nexport const leftBorderClassName : string = \"leftborder:class\";\nexport const leftBorderStyle : string = \"leftborder:style\";\n\nexport const rightBorderClassName : string = \"rightborder:class\";\nexport const rightBorderStyle : string = \"rightborder:style\";\n\nexport const bottomBorderClassName : string = \"bottomborder:class\";\nexport const bottomBorderStyle : string = \"bottomborder:style\";\n\nexport const textClass : string = \"text:class\";\nexport const textStyle : string = \"text:style\";\n*/\nexports.x = \"x\";\nexports.y = \"y\";\nexports.cx = \"cx\";\nexports.cy = \"cy\";\nexports.x1 = \"x1\";\nexports.y1 = \"y1\";\nexports.x2 = \"x2\";\nexports.y2 = \"y2\";\nexports.x3 = \"x3\";\nexports.y3 = \"y3\";\nexports.w = \"w\";\nexports.h = \"h\";\nexports.width = \"width\";\nexports.height = \"height\";\nexports.rowHeight = \"row-height\";\nexports.columnWidth = \"column-width\";\nexports.beginVertex = \"begin-vertex\";\nexports.endVertex = \"end-vertex\";\nexports.arrowNeckWidth = \"arrow-neck-width\";\nexports.arrowNeckHeight = \"arrow-neck-height\";\nexports.arrowHeadWidth = \"arrow-head-width\";\nexports.arrowHeadHeight = \"arrow-head-height\";\nexports.direction = \"direction\";\nexports.speakerX = \"speaker-x\";\nexports.speakerY = \"speaker-y\";\n//export const speakerY : string = \"speaker-y\";\n//export const elementTypeName = \"data-element-type\";\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/attribute_names.ts?");

/***/ }),

/***/ "./src/common/character.ts":
/*!*********************************!*\
  !*** ./src/common/character.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.recoverFromEscapeCharacter = void 0;\nvar characters = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    '\\'': '&#39;'\n};\nfunction recoverFromEscapeCharacter(text) {\n    text = text.replace(/&lt;/g, \"<\");\n    text = text.replace(/&gt;/g, \">\");\n    text = text.replace(/&amp;/g, \"&\");\n    text = text.replace(/&quot;/g, `\"`);\n    text = text.replace(/&#39;/g, `'`);\n    return text;\n}\nexports.recoverFromEscapeCharacter = recoverFromEscapeCharacter;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/character.ts?");

/***/ }),

/***/ "./src/common/color.ts":
/*!*****************************!*\
  !*** ./src/common/color.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRGBFromColorName = exports.createRGBCodeFromColorName = exports.createHexFromColorName = exports.createHexCodeFromColorName = void 0;\n// tslint:disable-next-line: no-namespace\n//namespace GraphTableSVG {\n/**\n * 色に関する名前空間です。\n */\n//export namespace Color {\nconst colorNameArray = new Array(\"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\", \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\", \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\", \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\", \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\", \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\", \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\", \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\", \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\", \"gold\", \"goldenrod\", \"gray\", \"green\", \"greenyellow\", \"honeydew\", \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\", \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\", \"lightcyan\", \"lightgoldenrodyellow\", \"lightgreen\", \"lightgrey\", \"lightpink\", \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\", \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\", \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\", \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\", \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\", \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\", \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\", \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\", \"purple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\", \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\", \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\", \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\", \"whitesmoke\", \"yellow\", \"yellowgreen\");\nlet colorDic;\n// redの16進数の配列\nconst rValue = new Array(\"F0\", \"FA\", \"00\", \"7F\", \"F0\", \"F5\", \"FF\", \"00\", \"FF\", \"00\", \"8A\", \"A5\", \"DE\", \"5F\", \"7F\", \"D2\", \"FF\", \"64\", \"FF\", \"DC\", \"00\", \"00\", \"00\", \"B8\", \"A9\", \"00\", \"BD\", \"8B\", \"55\", \"FF\", \"99\", \"8B\", \"E9\", \"8F\", \"48\", \"2F\", \"00\", \"94\", \"FF\", \"00\", \"69\", \"1E\", \"B2\", \"FF\", \"22\", \"FF\", \"DC\", \"F8\", \"FF\", \"DA\", \"80\", \"00\", \"AD\", \"F0\", \"FF\", \"CD\", \"4B\", \"FF\", \"F0\", \"E6\", \"FF\", \"7C\", \"FF\", \"AD\", \"F0\", \"E0\", \"FA\", \"90\", \"D3\", \"FF\", \"FF\", \"20\", \"87\", \"77\", \"B0\", \"FF\", \"00\", \"32\", \"FA\", \"FF\", \"80\", \"66\", \"00\", \"BA\", \"93\", \"3C\", \"7B\", \"00\", \"48\", \"C7\", \"19\", \"F5\", \"FF\", \"FF\", \"FF\", \"00\", \"FD\", \"80\", \"6B\", \"FF\", \"FF\", \"DA\", \"EE\", \"98\", \"AF\", \"DB\", \"FF\", \"FF\", \"CD\", \"FF\", \"DD\", \"B0\", \"80\", \"FF\", \"BC\", \"41\", \"8B\", \"FA\", \"F4\", \"2E\", \"FF\", \"A0\", \"C0\", \"87\", \"6A\", \"70\", \"FF\", \"00\", \"46\", \"D2\", \"00\", \"D8\", \"FF\", \"40\", \"EE\", \"F5\", \"FF\", \"F5\", \"FF\", \"9A\");\n// greenの16進数の配列\nconst gValue = new Array(\"F8\", \"EB\", \"FF\", \"FF\", \"FF\", \"F5\", \"E4\", \"00\", \"EB\", \"00\", \"2B\", \"2A\", \"B8\", \"9E\", \"FF\", \"69\", \"7F\", \"95\", \"F8\", \"14\", \"FF\", \"00\", \"8B\", \"86\", \"A9\", \"64\", \"B7\", \"00\", \"6B\", \"8C\", \"32\", \"00\", \"96\", \"BC\", \"3D\", \"4F\", \"CE\", \"00\", \"14\", \"BF\", \"69\", \"90\", \"22\", \"FA\", \"8B\", \"00\", \"DC\", \"F8\", \"D7\", \"A5\", \"80\", \"80\", \"FF\", \"FF\", \"69\", \"5C\", \"00\", \"FF\", \"E6\", \"E6\", \"F0\", \"FC\", \"FA\", \"D8\", \"80\", \"FF\", \"FA\", \"EE\", \"D3\", \"B6\", \"A0\", \"B2\", \"CE\", \"88\", \"C4\", \"FF\", \"FF\", \"CD\", \"F0\", \"00\", \"00\", \"CD\", \"00\", \"55\", \"70\", \"B3\", \"68\", \"FA\", \"D1\", \"15\", \"19\", \"FF\", \"E4\", \"E4\", \"DE\", \"00\", \"F5\", \"80\", \"8E\", \"A5\", \"45\", \"70\", \"E8\", \"FB\", \"EE\", \"70\", \"EF\", \"DA\", \"85\", \"C0\", \"A0\", \"E0\", \"00\", \"00\", \"8F\", \"69\", \"45\", \"80\", \"A4\", \"8B\", \"F5\", \"52\", \"C0\", \"CE\", \"5A\", \"80\", \"FA\", \"FF\", \"82\", \"B4\", \"80\", \"BF\", \"63\", \"E0\", \"82\", \"DE\", \"FF\", \"F5\", \"FF\", \"CD\");\n// blueの16進数の配列\nconst bValue = new Array(\"FF\", \"D7\", \"FF\", \"D4\", \"FF\", \"DC\", \"C4\", \"00\", \"CD\", \"FF\", \"E2\", \"2A\", \"87\", \"A0\", \"00\", \"1E\", \"50\", \"ED\", \"DC\", \"3C\", \"FF\", \"8B\", \"8B\", \"0B\", \"A9\", \"00\", \"6B\", \"8B\", \"2F\", \"00\", \"CC\", \"00\", \"7A\", \"8F\", \"8B\", \"4F\", \"D1\", \"D3\", \"93\", \"FF\", \"69\", \"FF\", \"22\", \"F0\", \"22\", \"FF\", \"DC\", \"FF\", \"00\", \"20\", \"80\", \"00\", \"2F\", \"F0\", \"B4\", \"5C\", \"82\", \"F0\", \"8C\", \"FA\", \"F5\", \"00\", \"CD\", \"E6\", \"80\", \"FF\", \"D2\", \"90\", \"D3\", \"C1\", \"7A\", \"AA\", \"FA\", \"99\", \"DE\", \"E0\", \"00\", \"32\", \"E6\", \"FF\", \"00\", \"AA\", \"CD\", \"D3\", \"DB\", \"71\", \"EE\", \"9A\", \"CC\", \"85\", \"70\", \"FA\", \"E1\", \"B5\", \"AD\", \"80\", \"E6\", \"00\", \"23\", \"00\", \"00\", \"D6\", \"AA\", \"98\", \"EE\", \"93\", \"D5\", \"B9\", \"3F\", \"CB\", \"DD\", \"E6\", \"80\", \"00\", \"8F\", \"E1\", \"13\", \"72\", \"60\", \"57\", \"EE\", \"2D\", \"C0\", \"EB\", \"CD\", \"90\", \"FA\", \"7F\", \"B4\", \"8C\", \"80\", \"D8\", \"47\", \"D0\", \"EE\", \"B3\", \"FF\", \"F5\", \"00\", \"32\");\n/**\n * 色名から16進コードを生成します。\n * @param colorName\n */\nfunction createHexCodeFromColorName(colorName) {\n    if (!colorDic) {\n        colorDic = {};\n        for (let i = 0; i < colorNameArray.length; i++) {\n            colorDic[colorNameArray[i]] = i;\n        }\n    }\n    if (colorName in colorDic) {\n        const i = colorDic[colorName];\n        return rValue[i] + gValue[i] + bValue[i];\n    }\n    else {\n        return colorName;\n    }\n}\nexports.createHexCodeFromColorName = createHexCodeFromColorName;\n/**\n * 色名を16進表現に変換します。\n * @param colorName\n */\nfunction createHexFromColorName(colorName) {\n    if (!colorDic) {\n        colorDic = {};\n        for (let i = 0; i < colorNameArray.length; i++) {\n            colorDic[colorNameArray[i]] = i;\n        }\n    }\n    if (colorName in colorDic) {\n        const i = colorDic[colorName];\n        // return r_value[i] + g_value[i] + b_value[i];\n        return { r: parseInt(rValue[i], 16), g: parseInt(gValue[i], 16), b: parseInt(bValue[i], 16) };\n    }\n    else {\n        return null;\n    }\n}\nexports.createHexFromColorName = createHexFromColorName;\n/**\n * 色名をRGBコードに変換します。\n * @param colorName\n */\nfunction createRGBCodeFromColorName(colorName) {\n    const newColorName = createHexCodeFromColorName(colorName);\n    if (newColorName.substr(0, 3) === \"rgb\") {\n        return newColorName;\n    }\n    else {\n        if (colorName[0] == \"#\") {\n            return createRGBCodeFromColorName(colorName.substr(1));\n        }\n        else if (newColorName.length === 6) {\n            const r = newColorName.substr(0, 2);\n            const g = newColorName.substr(2, 2);\n            const b = newColorName.substr(4, 2);\n            return `rgb(${parseInt(r, 16)}, ${parseInt(g, 16)}, ${parseInt(b, 16)})`;\n        }\n        else {\n            return `rgb(${80}, ${80}, ${80})`;\n        }\n    }\n}\nexports.createRGBCodeFromColorName = createRGBCodeFromColorName;\n/**\n * 色名をRGB表現に変換します。\n * @param str\n */\nfunction createRGBFromColorName(str) {\n    const v = createHexFromColorName(str);\n    const def = { r: 80, g: 80, b: 80 };\n    if (v != null) {\n        return v;\n    }\n    else {\n        if (str.substr(0, 3) === \"rgb\") {\n            str = str.replace(\"rgb(\", \"\");\n            str = str.replace(\")\", \"\");\n            const values = str.split(\",\");\n            if (values.length === 3) {\n                return { b: parseInt(values[2], undefined), g: parseInt(values[1], undefined),\n                    r: parseInt(values[0], undefined) };\n            }\n            else {\n                return def;\n            }\n        }\n        else if (str.length === 6) {\n            const r = str.substr(0, 2);\n            const g = str.substr(2, 2);\n            const b = str.substr(4, 2);\n            return { g: parseInt(g, undefined), b: parseInt(b, undefined), r: parseInt(r, undefined) };\n        }\n        else {\n            return def;\n        }\n    }\n}\nexports.createRGBFromColorName = createRGBFromColorName;\n//}\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/color.ts?");

/***/ }),

/***/ "./src/common/common_functions.ts":
/*!****************************************!*\
  !*** ./src/common/common_functions.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n//namespace GraphTableSVG {\n//import { Rectangle } from \"./vline\";\n//import * as CSS from \"../svghtml/css\"\n//import {GGraph} from \"../object/g_graph\"\n//import {GTable} from \"../object/g_table\"\n//import {GObject} from \"../object/z_object\"\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bezierLocation = exports.toPX = exports.parseUnit = exports.paddingLeft = exports.IsDescendantOfBody = void 0;\n//import {VBAObjectType} from \"../object/table/vba\"\n//export namespace CommonFunctions {\n/**\n * 入力要素がdocument.bodyの孫であるときに限りTrueを返します。\n * @param node 判定する要素\n */\nfunction IsDescendantOfBody(node) {\n    const parent = node.parentNode;\n    if (parent == null) {\n        return false;\n    }\n    else if (parent == document.body) {\n        return true;\n    }\n    else {\n        return IsDescendantOfBody(parent);\n    }\n}\nexports.IsDescendantOfBody = IsDescendantOfBody;\n/**\n * 指定された文字数になるまで指定された文字を左に加えます\n * @param text 文字を追加する文字列\n * @param length 計算後のtextの文字数\n * @param leftChar 左に追加する文字\n */\nfunction paddingLeft(text, length, leftChar) {\n    while (text.length < length) {\n        text = leftChar + text;\n    }\n    return text;\n}\nexports.paddingLeft = paddingLeft;\n//export function setCellCSS(){\n//}\n/**\n * 単位付きの値を値部分と単位部分に分割します。\n * @param text 単位付きの値\n */\nfunction parseUnit(text) {\n    let str1 = \"\", str2 = \"\";\n    for (let i = 0; i < text.length; i++) {\n        if (isNaN(text[i]) && text[i] != \".\") {\n            str2 += text[i];\n        }\n        else {\n            str1 += text[i];\n        }\n    }\n    return [Number(str1), str2];\n}\nexports.parseUnit = parseUnit;\n/**\n * 入力値をピクセル単位の値に変換します。\n * @param value\n */\nfunction toPX(value) {\n    const [val, unit] = parseUnit(value);\n    if (unit == \"px\") {\n        return val;\n    }\n    else if (unit == \"em\") {\n        return val * 16;\n    }\n    else if (unit == \"pt\") {\n        return (val / 72) * 96;\n    }\n    else {\n        return val;\n    }\n}\nexports.toPX = toPX;\n/**\n * 二次ベジエ曲線上の座標を計算します。\n * @param param0 [x,y] ベジエ曲線の開始座標\n * @param param1 [x,y] ベジエ曲線の制御点\n * @param param2 [x,y] ベジエ曲線の終了座標\n * @param t 曲線上の位置 0が曲線の開始座標で1が曲線の終了座標、0.5が曲線の中間点を表します\n * @returns 指定された座標\n */\nfunction bezierLocation([px1, py1], [px2, py2], [px3, py3], t) {\n    const x = px1 * (1 - t) * (1 - t) + 2 * px2 * t * (1 - t) + px3 * t * t;\n    const y = py1 * (1 - t) * (1 - t) + 2 * py2 * t * (1 - t) + py3 * t * t;\n    return [x, y];\n}\nexports.bezierLocation = bezierLocation;\n//}\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/common_functions.ts?");

/***/ }),

/***/ "./src/common/debugger.ts":
/*!********************************!*\
  !*** ./src/common/debugger.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Debugger = void 0;\nconst debugMode = \"None\";\nlet objID = null;\nlet updateObjID = null;\nlet counter = 0;\nclass Debugger {\n    static getDebugMode() {\n        return debugMode;\n    }\n    static getStopWatchFlag() {\n        return false;\n    }\n    static getStableFlagWatchFlag() {\n        return false;\n    }\n    static getNodePathFlag() {\n        return false;\n    }\n    static getObserveUpdateFlag() {\n        return false;\n    }\n    static showTime(oldTime, newTime, name, msg) {\n        const diffx = newTime.getTime() - oldTime.getTime();\n        const styles = 'color: black; background-color: lightgreen;';\n        console.log(`%c Timer: name = ${name}: UpdateTime = ${Math.abs(diffx) / 1000}s`, styles);\n    }\n    static updateUnstableFlagLog(obj, func, msg) {\n        if (this.getStableFlagWatchFlag()) {\n            const type = obj.constructor.name;\n            let id = null;\n            let name = func.name;\n            const xid = (obj.objectID);\n            if (xid != undefined) {\n                id = xid;\n            }\n            else {\n                id = null;\n            }\n            const styles = 'color: yellow; background-color: black;';\n            let s = \"\";\n            if (objID == id) {\n                for (let i = 0; i < counter; i++) {\n                    s += \"\\t\";\n                }\n                counter++;\n            }\n            else {\n                objID = id;\n                counter = 1;\n            }\n            console.log(`${s} %c (ID = ${id}) object = ${type}, function = ${name}(${msg})`, styles);\n        }\n    }\n    static updateFlagLog(obj, func, msg) {\n        if (Debugger.getObserveUpdateFlag()) {\n            const type = obj.constructor.name;\n            let id = null;\n            let name = func.name;\n            const xid = (obj.objectID);\n            if (xid != undefined) {\n                id = xid;\n            }\n            else {\n                id = null;\n            }\n            const styles = 'color: yellow; background-color: black;';\n            let s = \"\";\n            if (objID == id) {\n                for (let i = 0; i < counter; i++) {\n                    s += \"\\t\";\n                }\n                counter++;\n            }\n            else {\n                objID = id;\n                counter = 1;\n            }\n            console.log(`${s} %c (ID = ${id}) object = ${type}, function = ${name}(${msg})`, styles);\n            //console.trace(obj);\n            if (name == \"updateSVGSVGTimer\") {\n                objID = null;\n                counter = 0;\n            }\n        }\n    }\n    static updateLog(obj, func, msg) {\n        if (Debugger.getObserveUpdateFlag()) {\n            const type = obj.constructor.name;\n            let id = null;\n            let name = func.name;\n            const xid = (obj.objectID);\n            if (xid != undefined) {\n                id = xid;\n            }\n            else {\n                id = null;\n            }\n            const styles = 'color: black; background-color: aqua;';\n            let s = \"\";\n            if (updateObjID == id) {\n                for (let i = 0; i < counter; i++) {\n                    s += \"\\t\";\n                }\n                counter++;\n            }\n            else {\n                updateObjID = id;\n                counter = 1;\n            }\n            console.log(`${s} %c (ID = ${id}) object = ${type}, function = ${name}(${msg})`, styles);\n            //console.trace(obj);\n            if (name == \"updateSVGSVGTimer\") {\n                updateObjID = null;\n                counter = 0;\n            }\n        }\n    }\n}\nexports.Debugger = Debugger;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/debugger.ts?");

/***/ }),

/***/ "./src/common/default_class_names.ts":
/*!*******************************************!*\
  !*** ./src/common/default_class_names.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultConsoleColumnTitleCellBackgroundClass = exports.defaultConsoleColumnTitleCellUndefinedTextClass = exports.defaultConsoleColumnTitleCellTextClass = exports.defaultConsoleColumnTitleCellClass = exports.defaultTreeClass = exports.defaultVertexClass = exports.defaultEdgeClass = exports.defaultRectButtonClass = exports.defaultRectButtonSurfaceClass = exports.defaultCellBorderClass = exports.defaultCellBackgroungClass = exports.defaultCircleLogicTreeCircleSVGGroup = exports.defaultTextboxPathClass = exports.defaultEdgePathClass = exports.defaultPathSurfaceClass = exports.defaultSurfaceClass = exports.defaultCellClass = exports.defaultTextClass = void 0;\nexports.defaultTextClass = \"___text-default\";\nexports.defaultCellClass = \"___cell-default\";\nexports.defaultSurfaceClass = \"___surface-default\";\nexports.defaultPathSurfaceClass = \"___path-surface-default\";\nexports.defaultEdgePathClass = \"___default-edge-path\";\nexports.defaultTextboxPathClass = \"___default-textbox-path\";\nexports.defaultCircleLogicTreeCircleSVGGroup = \"___default-logic-tree-circle-svgGroup\";\nexports.defaultCellBackgroungClass = \"___cell-background-default\";\nexports.defaultCellBorderClass = \"___cell-border-default\";\nexports.defaultRectButtonSurfaceClass = \"___rect-button-surface-default\";\nexports.defaultRectButtonClass = \"___rect-button-default\";\nexports.defaultEdgeClass = \"__default-edge\";\nexports.defaultVertexClass = \"__default-vertex\";\nexports.defaultTreeClass = \"__default-tree\";\nexports.defaultConsoleColumnTitleCellClass = \"___column_title_cell\";\nexports.defaultConsoleColumnTitleCellTextClass = \"___column_title_text_cell\";\nexports.defaultConsoleColumnTitleCellUndefinedTextClass = \"___column_title_undefined_text_cell\";\nexports.defaultConsoleColumnTitleCellBackgroundClass = \"___column_title_background_cell\";\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/default_class_names.ts?");

/***/ }),

/***/ "./src/common/enums.ts":
/*!*****************************!*\
  !*** ./src/common/enums.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parsePXString = exports.HorizontalAnchor = exports.VerticalAnchor = exports.ConnectorType = exports.ShapeToFitType = exports.AutoSizeShapeToFitText = exports.DataName = exports.Direction = exports.msoDashStyle = exports.PathTextAlighnment = exports.ShapeObjectType = exports.OriginalSVGSVGAttributes = exports.MacroTagNames = exports.VBAShapeType = exports.CoodinateType = exports.VertexOrder = void 0;\nvar VertexOrder;\n(function (VertexOrder) {\n    VertexOrder.Preorder = \"preorder\";\n    VertexOrder.Postorder = \"postorder\";\n})(VertexOrder || (exports.VertexOrder = VertexOrder = {}));\nvar CoodinateType;\n(function (CoodinateType) {\n    CoodinateType.ObjectCenter = \"object-center\";\n    CoodinateType.Group00 = \"group00\";\n})(CoodinateType || (exports.CoodinateType = CoodinateType = {}));\nvar VBAShapeType;\n(function (VBAShapeType) {\n    VBAShapeType.None = \"NONE\";\n    VBAShapeType.Table = \"--table\";\n    VBAShapeType.Oval = \"msoShapeOval\";\n    VBAShapeType.Rectangle = \"msoShapeRectangle\";\n    VBAShapeType.Callout = \"msoShapeRectangularCallout\";\n    VBAShapeType.UpArrowCallout = \"msoShapeUpArrowCallout\";\n    VBAShapeType.LeftArrowCallout = \"msoShapeLeftArrowCallout\";\n    VBAShapeType.RightArrowCallout = \"msoShapeRightArrowCallout\";\n    VBAShapeType.DownArrowCallout = \"msoShapeDownArrowCallout\";\n})(VBAShapeType || (exports.VBAShapeType = VBAShapeType = {}));\nvar MacroTagNames;\n(function (MacroTagNames) {\n    MacroTagNames.Tree = \"m-tree\";\n    MacroTagNames.Ellipse = \"m-ellipse\";\n    MacroTagNames.Circle = \"m-circle\";\n    MacroTagNames.Rect = \"m-rect\";\n})(MacroTagNames || (exports.MacroTagNames = MacroTagNames = {}));\nvar OriginalSVGSVGAttributes;\n(function (OriginalSVGSVGAttributes) {\n    OriginalSVGSVGAttributes.VBAAttributeName = \"z-vba\";\n    OriginalSVGSVGAttributes.ShrinkAttributeName = \"z-shrink\";\n    OriginalSVGSVGAttributes.Edit = \"z-edit\";\n})(OriginalSVGSVGAttributes || (exports.OriginalSVGSVGAttributes = OriginalSVGSVGAttributes = {}));\nvar ShapeObjectType;\n(function (ShapeObjectType) {\n    ShapeObjectType.Callout = \"z-callout\";\n    ShapeObjectType.ArrowCallout = \"z-arrow-callout\";\n    ShapeObjectType.Ellipse = \"z-ellipse\";\n    ShapeObjectType.Circle = \"z-circle\";\n    ShapeObjectType.Rect = \"z-rect\";\n    ShapeObjectType.PathTextBox = \"z-path-textbox\";\n    ShapeObjectType.RectButton = \"z-rect-button\";\n    ShapeObjectType.Graph = \"z-graph\";\n    ShapeObjectType.Table = \"z-table\";\n    ShapeObjectType.Object = \"z-object\";\n    ShapeObjectType.Edge = \"z-edge\";\n    ShapeObjectType.ForeignObject = \"z-foreign-object\";\n    ShapeObjectType.ForeignButton = \"z-foreign-button\";\n    const typeDic = {\n        \"z-callout\": true,\n        \"z-arrow-callout\": true,\n        \"z-ellipse\": true,\n        \"z-circle\": true,\n        \"z-rect\": true,\n        \"z-edge\": true,\n        \"z-graph\": true,\n        \"z-table\": true,\n        \"z-object\": true,\n        \"z-path-textbox\": true,\n        \"z-rect-button\": true,\n        \"z-foreign-button\": true\n    };\n    const customTypeDic = {\n        \"row\": true,\n        \"cell\": true,\n        \"t\": true\n    };\n    function toShapeObjectType(value) {\n        if (value in typeDic) {\n            return value;\n        }\n        else {\n            return null;\n        }\n    }\n    ShapeObjectType.toShapeObjectType = toShapeObjectType;\n    function toShapeObjectTypeOrCustomTag(value) {\n        const lowerValue = value.toLowerCase();\n        const value1 = toShapeObjectType(lowerValue);\n        if (value1 != null) {\n            return value1;\n        }\n        else {\n            if (value in customTypeDic) {\n                return lowerValue;\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    ShapeObjectType.toShapeObjectTypeOrCustomTag = toShapeObjectTypeOrCustomTag;\n})(ShapeObjectType || (exports.ShapeObjectType = ShapeObjectType = {}));\nvar PathTextAlighnment;\n(function (PathTextAlighnment) {\n    PathTextAlighnment.regularInterval = \"regularInterval\";\n    PathTextAlighnment.begin = \"begin\";\n    PathTextAlighnment.end = \"end\";\n    PathTextAlighnment.center = \"center\";\n    const typeDic = {\n        \"none\": \"none\",\n        \"begin\": \"begin\",\n        \"end\": \"end\",\n        \"center\": \"center\",\n        \"regularInterval\": \"regularInterval\",\n    };\n    function toPathTextAlighnment(value) {\n        if (value in typeDic) {\n            return typeDic[value];\n        }\n        else {\n            return \"none\";\n        }\n    }\n    PathTextAlighnment.toPathTextAlighnment = toPathTextAlighnment;\n})(PathTextAlighnment || (exports.PathTextAlighnment = PathTextAlighnment = {}));\nvar msoDashStyle;\n(function (msoDashStyle) {\n    //export const styleName : string = \"--mso-dash-style\"\n    msoDashStyle.msoLineDash = \"msoLineDash\";\n    msoDashStyle.msoLineDashDot = \"msoLineDashDot\";\n    msoDashStyle.msoLineDashDotDot = \"msoLineDashDotDot\";\n    //export const msoLineDashStyleMixed: msoDashStyle = \"msoLineDashStyleMixed\"\n    msoDashStyle.msoLineLongDash = \"msoLineLongDash\";\n    msoDashStyle.msoLineLongDashDot = \"msoLineLongDashDot\";\n    msoDashStyle.msoLineRoundDot = \"msoLineRoundDot\";\n    msoDashStyle.msoLineSolid = \"msoLineSolid\";\n    msoDashStyle.msoLineSquareDot = \"msoLineSquareDot\";\n    msoDashStyle.dashArrayDic = {\n        \"msoLineDash\": [4, 3],\n        \"msoLineDashDot\": [4, 3, 1, 3],\n        \"msoLineDashDotDot\": [3, 1, 1, 1, 1, 1],\n        //\"msoLineDashStyleMixed\" : \"6,3\",\n        \"msoLineLongDash\": [9, 3],\n        \"msoLineLongDashDot\": [9, 3, 1, 3],\n        \"msoLineRoundDot\": [0.25, 2],\n        \"msoLineSolid\": [],\n        \"msoLineSquareDot\": [1, 1]\n    };\n    msoDashStyle.lineCapDic = {\n        \"msoLineDash\": \"butt\",\n        \"msoLineDashDot\": \"butt\",\n        \"msoLineDashDotDot\": \"butt\",\n        //\"msoLineDashStyleMixed\" : \"butt\",\n        \"msoLineLongDash\": \"butt\",\n        \"msoLineLongDashDot\": \"butt\",\n        \"msoLineRoundDot\": \"round\",\n        \"msoLineSolid\": \"butt\",\n        \"msoLineSquareDot\": \"butt\"\n    };\n    const typeDic = {\n        \"msoLineDash\": msoDashStyle.msoLineDash,\n        \"msoLineDashDot\": msoDashStyle.msoLineDashDot,\n        \"msoLineDashDotDot\": msoDashStyle.msoLineDashDotDot,\n        //\"msoLineDashStyleMixed\" : msoDashStyle.msoLineDashStyleMixed,\n        \"msoLineLongDash\": msoDashStyle.msoLineLongDash,\n        \"msoLineLongDashDot\": msoDashStyle.msoLineLongDashDot,\n        \"msoLineRoundDot\": msoDashStyle.msoLineRoundDot,\n        \"msoLineSquareDot\": msoDashStyle.msoLineSquareDot,\n        \"msoLineSolid\": msoDashStyle.msoLineSolid\n    };\n    function toMSODashStyle(value) {\n        if (value in typeDic) {\n            return typeDic[value];\n        }\n        else {\n            return msoDashStyle.msoLineSolid;\n        }\n    }\n    msoDashStyle.toMSODashStyle = toMSODashStyle;\n    /*\n    function setStyle(svgLine: SVGLineElement | SVGPathElement | SVGElement, type: string): void {\n        if (toMSODashStyle(type) != null) {\n            const width = <number>svgLine.getPropertyStyleNumberValue(\"stroke-width\", 2);\n            svgLine.setPropertyStyleValue(\"stroke-dasharray\", computeDashArray(toMSODashStyle(type), width));\n            svgLine.setPropertyStyleValue(\"stroke-linecap\", lineCapDic[type]);\n            svgLine.setPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName, type);\n        } else {\n\n        }\n    }\n    */\n    /*\n    export function getLineType(svgLine: SVGLineElement | SVGPathElement | SVGElement): msoDashStyle {\n        const typeName = svgLine.getPropertyStyleValue(StyleNames.msoDashStyleName);\n        if (typeName != null) {\n            const type = toMSODashStyle(typeName);\n            if (type != null) {\n                return type;\n            }\n        }\n        const dashArray = svgLine.getPropertyStyleValue(\"stroke-dasharray\");\n        if (dashArray != null) {\n            return msoDashStyle.msoLineDash;\n        } else {\n            return msoDashStyle.msoLineSolid;\n        }\n    }\n    */\n})(msoDashStyle || (exports.msoDashStyle = msoDashStyle = {}));\nvar Direction;\n(function (Direction) {\n    function toDirection(value) {\n        if (value == \"up\") {\n            return \"up\";\n        }\n        else if (value == \"left\") {\n            return \"left\";\n        }\n        else if (value == \"right\") {\n            return \"right\";\n        }\n        else {\n            return \"down\";\n        }\n    }\n    Direction.toDirection = toDirection;\n})(Direction || (exports.Direction = Direction = {}));\nvar DataName;\n(function (DataName) {\n    DataName.Surface = \"surface\";\n    DataName.Text = \"text\";\n    DataName.TopBorder = \"topborder\";\n    DataName.LeftBorder = \"leftborder\";\n    DataName.RightBorder = \"rightborder\";\n    DataName.BottomBorder = \"bottomborder\";\n})(DataName || (exports.DataName = DataName = {}));\nvar AutoSizeShapeToFitText;\n(function (AutoSizeShapeToFitText) {\n    AutoSizeShapeToFitText.Auto = \"auto\";\n    AutoSizeShapeToFitText.SemiAuto = \"semi-auto\";\n    AutoSizeShapeToFitText.None = \"none\";\n})(AutoSizeShapeToFitText || (exports.AutoSizeShapeToFitText = AutoSizeShapeToFitText = {}));\nvar ShapeToFitType;\n(function (ShapeToFitType) {\n    ShapeToFitType.None = \"none\";\n    ShapeToFitType.Auto = \"auto\";\n    ShapeToFitType.SemiAuto = \"semi-auto\";\n})(ShapeToFitType || (exports.ShapeToFitType = ShapeToFitType = {}));\nvar ConnectorType;\n(function (ConnectorType) {\n    ConnectorType.Top = \"top\";\n    ConnectorType.TopLeft = \"topleft\";\n    ConnectorType.Left = \"left\";\n    ConnectorType.BottomLeft = \"bottomleft\";\n    ConnectorType.Bottom = \"bottom\";\n    ConnectorType.BottomRight = \"bottomright\";\n    ConnectorType.Right = \"right\";\n    ConnectorType.TopRight = \"topright\";\n    ConnectorType.Auto = \"auto\";\n    function ToConnectorPosition(str) {\n        if (str == null) {\n            return ConnectorType.Auto;\n        }\n        else {\n            return str;\n            /*\n            switch (str) {\n                case \"top\": return ConnectorPosition.Top;\n                case \"topleft\": return ConnectorPosition.TopLeft;\n                case \"left\": return ConnectorPosition.Left;\n                case \"bottomleft\": return ConnectorPosition.BottomLeft;\n                case \"bottom\": return ConnectorPosition.Bottom;\n                case \"bottomright\": return ConnectorPosition.BottomRight;\n                case \"right\": return ConnectorPosition.Right;\n                case \"topright\": return ConnectorPosition.TopRight;\n                case \"auto\": return ConnectorPosition.Auto;\n                default: return ConnectorPosition.Auto;\n            }\n            */\n        }\n    }\n    ConnectorType.ToConnectorPosition = ToConnectorPosition;\n    function ToVBAConnectorPosition(shapeType, str) {\n        if (shapeType == \"circle\") {\n            switch (str) {\n                case \"top\": return 1;\n                case \"topleft\": return 2;\n                case \"left\": return 3;\n                case \"bottomleft\": return 4;\n                case \"bottom\": return 5;\n                case \"bottomright\": return 6;\n                case \"right\": return 7;\n                case \"topright\": return 8;\n                case \"auto\": return 9;\n                default: return 1;\n            }\n        }\n        else if (shapeType == \"rectangle\") {\n            switch (str) {\n                case \"top\": return 1;\n                case \"left\": return 2;\n                case \"bottom\": return 3;\n                case \"right\": return 4;\n                case \"auto\": return 9;\n                default: return 1;\n            }\n        }\n        else {\n            return 1;\n        }\n    }\n    ConnectorType.ToVBAConnectorPosition = ToVBAConnectorPosition;\n    function ToVBAConnectorPosition2(shapeType, str) {\n        switch (shapeType) {\n            case VBAShapeType.Oval:\n            case VBAShapeType.UpArrowCallout:\n            case VBAShapeType.LeftArrowCallout:\n            case VBAShapeType.RightArrowCallout:\n            case VBAShapeType.DownArrowCallout:\n                switch (str) {\n                    case \"top\": return 1;\n                    case \"topleft\": return 2;\n                    case \"left\": return 3;\n                    case \"bottomleft\": return 4;\n                    case \"bottom\": return 5;\n                    case \"bottomright\": return 6;\n                    case \"right\": return 7;\n                    case \"topright\": return 8;\n                    case \"auto\": return 9;\n                    default: return 1;\n                }\n            case VBAShapeType.Rectangle:\n            case VBAShapeType.Table:\n                switch (str) {\n                    case \"top\": return 1;\n                    case \"left\": return 2;\n                    case \"bottom\": return 3;\n                    case \"right\": return 4;\n                    case \"auto\": return 9;\n                    default: return 1;\n                }\n            default: return 1;\n        }\n        /*\n        if (shapeType == VBAShapeType.Oval) {\n            switch (str) {\n                case \"top\": return 1;\n                case \"topleft\": return 2;\n                case \"left\": return 3;\n                case \"bottomleft\": return 4;\n                case \"bottom\": return 5;\n                case \"bottomright\": return 6;\n                case \"right\": return 7;\n                case \"topright\": return 8;\n                case \"auto\": return 9;\n                default: return 1;\n            }\n        } else if (shapeType == VBAShapeType.Rectangle) {\n            switch (str) {\n                case \"top\": return 1;\n                case \"left\": return 2;\n                case \"bottom\": return 3;\n                case \"right\": return 4;\n                case \"auto\": return 9;\n                default: return 1;\n            }\n\n        } else if (){\n\n        }\n        else {\n            return 1;\n        }\n        */\n    }\n    ConnectorType.ToVBAConnectorPosition2 = ToVBAConnectorPosition2;\n})(ConnectorType || (exports.ConnectorType = ConnectorType = {}));\nvar VerticalAnchor;\n(function (VerticalAnchor) {\n    /**\n     * 上を表します。\n     */\n    VerticalAnchor.Top = \"top\";\n    /**\n     * 真ん中を表します。\n     */\n    VerticalAnchor.Middle = \"middle\";\n    /**\n     * 底を表します。\n     */\n    VerticalAnchor.Bottom = \"bottom\";\n    function toVerticalAnchor(value) {\n        if (value == \"top\") {\n            return \"top\";\n        }\n        else if (value == \"bottom\") {\n            return \"bottom\";\n        }\n        else {\n            return \"middle\";\n        }\n    }\n    VerticalAnchor.toVerticalAnchor = toVerticalAnchor;\n})(VerticalAnchor || (exports.VerticalAnchor = VerticalAnchor = {}));\nvar HorizontalAnchor;\n(function (HorizontalAnchor) {\n    /**\n     * 左を表します。\n     */\n    HorizontalAnchor.Left = \"left\";\n    /**\n     * 中央を表します。\n     */\n    HorizontalAnchor.Center = \"center\";\n    /**\n    * 右を表します。\n    */\n    HorizontalAnchor.Right = \"right\";\n    function toHorizontalAnchor(value) {\n        if (value == \"center\") {\n            return \"center\";\n        }\n        else if (value == \"right\") {\n            return \"right\";\n        }\n        else {\n            return \"left\";\n        }\n    }\n    HorizontalAnchor.toHorizontalAnchor = toHorizontalAnchor;\n})(HorizontalAnchor || (exports.HorizontalAnchor = HorizontalAnchor = {}));\nfunction parsePXString(item) {\n    if (item == null) {\n        return 0;\n    }\n    else {\n        if (item.length == 0) {\n            return 0;\n        }\n        else {\n            return parseInt(item);\n        }\n    }\n}\nexports.parsePXString = parsePXString;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/enums.ts?");

/***/ }),

/***/ "./src/common/exceptions.ts":
/*!**********************************!*\
  !*** ./src/common/exceptions.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NullError = exports.ArgumentOutOfRangeError = exports.NotSupportedError = exports.UndefinedError = void 0;\nclass UndefinedError extends Error {\n    constructor() {\n        super();\n        //this.message = \"Undefined Error:\";\n    }\n}\nexports.UndefinedError = UndefinedError;\nclass NotSupportedError extends Error {\n    constructor() {\n        super();\n        //this.message = \"Undefined Error:\";\n    }\n}\nexports.NotSupportedError = NotSupportedError;\nclass ArgumentOutOfRangeError extends Error {\n}\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\nclass NullError extends Error {\n}\nexports.NullError = NullError;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/exceptions.ts?");

/***/ }),

/***/ "./src/common/index.ts":
/*!*****************************!*\
  !*** ./src/common/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Exceptions = exports.StyleNames = exports.DefaultClassNames = exports.VLine = exports.VBAFunctions = exports.Enums = exports.AttributeNames = exports.CommonFunctions = exports.Color = void 0;\nconst Color = __webpack_require__(/*! ./color */ \"./src/common/color.ts\");\nexports.Color = Color;\nconst CommonFunctions = __webpack_require__(/*! ./common_functions */ \"./src/common/common_functions.ts\");\nexports.CommonFunctions = CommonFunctions;\nconst AttributeNames = __webpack_require__(/*! ./attribute_names */ \"./src/common/attribute_names.ts\");\nexports.AttributeNames = AttributeNames;\nconst DefaultClassNames = __webpack_require__(/*! ./default_class_names */ \"./src/common/default_class_names.ts\");\nexports.DefaultClassNames = DefaultClassNames;\nconst StyleNames = __webpack_require__(/*! ./style_names */ \"./src/common/style_names.ts\");\nexports.StyleNames = StyleNames;\nconst Enums = __webpack_require__(/*! ./enums */ \"./src/common/enums.ts\");\nexports.Enums = Enums;\nconst VBAFunctions = __webpack_require__(/*! ./vba_functions */ \"./src/common/vba_functions.ts\");\nexports.VBAFunctions = VBAFunctions;\nconst VLine = __webpack_require__(/*! ./vline */ \"./src/common/vline.ts\");\nexports.VLine = VLine;\nconst Exceptions = __webpack_require__(/*! ./exceptions */ \"./src/common/exceptions.ts\");\nexports.Exceptions = Exceptions;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/index.ts?");

/***/ }),

/***/ "./src/common/style_names.ts":
/*!***********************************!*\
  !*** ./src/common/style_names.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EdgeStyleNames = exports.prohibitionOutOfRange = exports.relocateName = exports.msoDashStyleName = exports.horizontalAnchor = exports.verticalAnchor = exports.marginBottom = exports.marginRight = exports.marginLeft = exports.marginTop = exports.paddingBottom = exports.paddingRight = exports.paddingLeft = exports.paddingTop = exports.defaultSurfaceType = exports.defaultHeight = exports.defaultWidth = exports.defaultRadius = exports.GraphStyleNames = exports.autoSizeShapeToFitText = void 0;\nexports.autoSizeShapeToFitText = \"--autosize-shape-to-fit-text\";\nvar GraphStyleNames;\n(function (GraphStyleNames) {\n    GraphStyleNames.vertexXInterval = \"--vertex-x-interval\";\n    GraphStyleNames.vertexYInterval = \"--vertex-y-interval\";\n    GraphStyleNames.graphDirection = \"--direction\";\n})(GraphStyleNames || (exports.GraphStyleNames = GraphStyleNames = {}));\nexports.defaultRadius = \"--default-radius\";\nexports.defaultWidth = \"--default-width\";\nexports.defaultHeight = \"--default-height\";\nexports.defaultSurfaceType = \"--default-surface-type\";\nexports.paddingTop = \"--padding-top\";\nexports.paddingLeft = \"--padding-left\";\nexports.paddingRight = \"--padding-right\";\nexports.paddingBottom = \"--padding-bottom\";\nexports.marginTop = \"--margin-top\";\nexports.marginLeft = \"--margin-left\";\nexports.marginRight = \"--margin-right\";\nexports.marginBottom = \"--margin-bottom\";\nexports.verticalAnchor = \"--vertical-anchor\";\nexports.horizontalAnchor = \"--horizontal-anchor\";\nexports.msoDashStyleName = \"--stroke-style\";\nexports.relocateName = \"--relocate\";\nexports.prohibitionOutOfRange = \"--prohibition-out-of-range\";\nvar EdgeStyleNames;\n(function (EdgeStyleNames) {\n    EdgeStyleNames.edgeType = \"--edge-type\";\n    EdgeStyleNames.readableText = \"--readable-text\";\n    EdgeStyleNames.markerStart = \"--marker-start\";\n    EdgeStyleNames.markerEnd = \"--marker-end\";\n    EdgeStyleNames.beginConnectorType = \"--begin-connector-type\";\n    EdgeStyleNames.endConnectorType = \"--end-connector-type\";\n    EdgeStyleNames.pathTextAlignment = \"--path-text-alignment\";\n})(EdgeStyleNames || (exports.EdgeStyleNames = EdgeStyleNames = {}));\n//export const defaultLineClass: string = \"--default-line-class\";\n//export const defaultVertexClass: string = \"--default-vertex-class\";\n//export const defaultEdgeClass: string = \"--default-edge-class\";\n//export const defaultTextClass: string = \"--default-text-class\";\n//export const defaultPathClass: string = \"--default-path-class\";\n//export const defaulSurfaceClass: string = \"--default-surface-class\";\n//export const defaultCellClass: string = \"--default-cell-class\";\n//export const defaultBorderClass: string = \"--default-border-class\";\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/style_names.ts?");

/***/ }),

/***/ "./src/common/vba_functions.ts":
/*!*************************************!*\
  !*** ./src/common/vba_functions.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VBATranslateFunctions = exports.sanityze = exports.styleVisible = exports.parseInteger = void 0;\n//namespace GraphTableSVG {\nconst html_1 = __webpack_require__(/*! ../html */ \"./src/html/index.ts\");\nconst Color = __webpack_require__(/*! ./color */ \"./src/common/color.ts\");\nconst CommonFunctions = __webpack_require__(/*! ./common_functions */ \"./src/common/common_functions.ts\");\nfunction parseInteger(value) {\n    if (value == \"\") {\n        return 1;\n    }\n    else {\n        return parseInt(value);\n    }\n}\nexports.parseInteger = parseInteger;\n/*\nexport function visible(value: string): number {\n    if (value == \"hidden\") {\n        return 1.0;\n    } else {\n        return 0;\n    }\n}\n*/\nfunction styleVisible(value) {\n    if (value.visibility == \"hidden\") {\n        return 1.0;\n    }\n    else if (value.stroke == \"transparent\") {\n        return 1.0;\n    }\n    else {\n        return 0;\n    }\n}\nexports.styleVisible = styleVisible;\nfunction sanityze(text) {\n    return text.replace(/\"/g, '\"\"');\n    //return text.replace(`\"`, `\"\"`);\n}\nexports.sanityze = sanityze;\nclass VBATranslateFunctions {\n    static grouping80(codes) {\n        let r = [];\n        const result = [];\n        codes.forEach(function (x, i, arr) {\n            if (r.length + x.length >= 80) {\n                result.push(VBATranslateFunctions.joinLines(r));\n                r = [];\n            }\n            x.forEach((v) => r.push(v));\n        });\n        if (r.length > 0) {\n            result.push(VBATranslateFunctions.joinLines(r));\n            r = [];\n        }\n        return result;\n    }\n    static splitCode(codes, subArg, callArg, id) {\n        const functions = [];\n        const p = VBATranslateFunctions.grouping80(codes);\n        p.forEach(function (x, i, arr) {\n            functions.push(`Call SubFunction${id}_${i}(${callArg})`);\n            const begin = `Sub SubFunction${id}_${i}(${subArg})`;\n            const end = `End Sub`;\n            p[i] = VBATranslateFunctions.joinLines([begin, x, end]);\n        });\n        return [VBATranslateFunctions.joinLines(functions), VBATranslateFunctions.joinLines(p)];\n    }\n    static ToFontBold(bold) {\n        if (bold == \"bold\") {\n            return \"msotrue\";\n        }\n        else {\n            return \"msofalse\";\n        }\n    }\n    static ToVerticalAnchor(value) {\n        switch (value) {\n            case \"top\": return \"msoAnchorTop\";\n            case \"middle\": return \"msoAnchorMiddle\";\n            case \"bottom\": return \"msoAnchorBottom\";\n            default: return \"msoAnchorTop\";\n        }\n    }\n    static ToHorizontalAnchor(value) {\n        switch (value) {\n            case \"left\": return \"ppAlignLeft\";\n            case \"center\": return \"ppAlignCenter\";\n            case \"right\": return \"ppAlignRight\";\n            default: return \"ppAlignLeft\";\n        }\n    }\n    static createStringFunction(item) {\n        return item.length == 0 ? `\"\"` : `\"` + item + `\"`;\n    }\n    static createArrayFunction(items) {\n        let s = ``;\n        for (let i = 0; i < items.length; i++) {\n            s += items[i];\n            if (i + 1 != items.length) {\n                s += `, `;\n            }\n        }\n        return `Array(${s})`;\n    }\n    static createStringArrayFunction(items) {\n        let s = ``;\n        for (let i = 0; i < items.length; i++) {\n            s += `\"${items[i]}\"`;\n            if (i + 1 != items.length) {\n                s += `, `;\n            }\n        }\n        return `Array(${s})`;\n    }\n    static createJagArrayFunction(items) {\n        let s = ``;\n        for (let i = 0; i < items.length; i++) {\n            s += VBATranslateFunctions.createArrayFunction(items[i]);\n            if (i + 1 != items.length)\n                s += `, `;\n        }\n        return `Array(${s})`;\n    }\n    static joinLines(lines) {\n        let s = ``;\n        for (let i = 0; i < lines.length; i++) {\n            s += lines[i];\n            if (i + 1 != lines.length)\n                s += `\\n`;\n        }\n        return s;\n    }\n    static colorToVBA(color) {\n        color = Color.createRGBCodeFromColorName(color);\n        if (color.indexOf(\"rgb\") != -1) {\n            return color.replace(\"rgb\", \"Array\");\n        }\n        else {\n            return \"Array(0, 0, 0)\";\n        }\n    }\n    static ToVBAFont(font) {\n        font = font.replace(/\"/g, \"\");\n        font = font.replace(/'/g, \"\");\n        return font;\n    }\n    static TranslateSVGTextElement(sub, item, range) {\n        const text = item.textContent == null ? \"\" : item.textContent;\n        sub.push([`${range}.text = \"${item.textContent}\"`]);\n        if (item.children.length > 0) {\n            let pos = 1;\n            for (let i = 0; i < item.children.length; i++) {\n                const child = item.children.item(i);\n                if (child != null && child.textContent != null && child.textContent.length > 0) {\n                    const css = getComputedStyle(child);\n                    const childColor = Color.createRGBFromColorName(css.fill == null ? \"black\" : css.fill);\n                    const fontName = this.getFont(css);\n                    const fontSize = CommonFunctions.toPX(css.fontSize == null ? \"14pt\" : css.fontSize);\n                    const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\n                    const len = child.textContent.length;\n                    let f = child.getAttribute(\"data-script\");\n                    if (f == null) {\n                        f = \"\";\n                    }\n                    sub.push([`Call EditTextRangeSub(${range},${pos}, ${len}, \"${f}\", Array(${childColor.r}, ${childColor.g}, ${childColor.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`]);\n                    pos += len;\n                }\n            }\n        }\n        else if (item.textContent != null && item.textContent.length > 0) {\n            const css = getComputedStyle(item);\n            if (css.fontSize == null)\n                throw Error(\"error\");\n            if (css.fill == null)\n                throw Error(\"error\");\n            const color = Color.createRGBFromColorName(css.fill);\n            const fontName = this.getFont(css);\n            const fontSize = CommonFunctions.toPX(css.fontSize);\n            const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\n            sub.push([`Call EditTextRangeSub(${range},${1}, ${item.textContent.length}, \"\", Array(${color.r}, ${color.g}, ${color.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`]);\n        }\n    }\n    static getFont(css) {\n        if (css.fontFamily == null)\n            throw Error(\"error\");\n        const arr = css.fontFamily.split(\",\");\n        if (arr.length > 0) {\n            let name = arr[0];\n            name = name.replace(/\\\"/g, \"\");\n            name = name.replace(/\\'/g, \"\");\n            return name;\n        }\n        else {\n            return \"\";\n        }\n    }\n    static TranslateSVGTextElement2(item, range) {\n        const lines = [];\n        //const text = item.textContent == null ? \"\" : item.textContent;\n        if (item.children.length > 0) {\n            let textCode = \"\";\n            for (let i = 0; i < item.children.length; i++) {\n                const child = item.children.item(i);\n                if (child != null && child.textContent != null && child.textContent.length > 0) {\n                    const newLine = child.getAttribute(\"newline\");\n                    if (newLine != null && newLine == \"true\") {\n                        textCode += `& vbCrLf `;\n                    }\n                    const text = sanityze(html_1.HTMLFunctions.removeInvisibleCharacters(child.textContent));\n                    if (textCode.length > 0) {\n                        textCode += `& \"${text}\"`;\n                    }\n                    else {\n                        textCode = `\"${text}\"`;\n                    }\n                }\n            }\n            lines.push(`${range}.text = ${textCode}`);\n            let pos = 1;\n            for (let i = 0; i < item.children.length; i++) {\n                const child = item.children.item(i);\n                if (child != null && child.textContent != null && child.textContent.length > 0) {\n                    const newLine = child.getAttribute(\"newline\");\n                    if (newLine != null && newLine == \"true\") {\n                        pos++;\n                    }\n                    for (let j = 0; j < child.childNodes.length; j++) {\n                        const child2 = child.childNodes.item(j);\n                        const node = child2 instanceof SVGTSpanElement ? child2 : child;\n                        const textContent = html_1.HTMLFunctions.removeInvisibleCharacters(child2.textContent);\n                        const css = getComputedStyle(node);\n                        if (css.fontSize == null)\n                            throw Error(\"error\");\n                        if (css.fill == null)\n                            throw Error(\"error\");\n                        const childColor = Color.createRGBFromColorName(css.fill);\n                        const fontName = this.getFont(css);\n                        const fontSize = CommonFunctions.toPX(css.fontSize);\n                        const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\n                        const len = textContent.length;\n                        let f = node.getAttribute(\"data-script\");\n                        if (f == null) {\n                            f = \"\";\n                        }\n                        lines.push(`Call EditTextRangeSub(${range},${pos}, ${len}, \"${f}\", Array(${childColor.r}, ${childColor.g}, ${childColor.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`);\n                        pos += len;\n                    }\n                }\n            }\n        }\n        else if (item.textContent != null && item.textContent.length > 0) {\n            const vbaText = sanityze(html_1.HTMLFunctions.removeInvisibleCharacters(item.textContent));\n            lines.push(`${range}.text = \"${vbaText}\"`);\n            const css = getComputedStyle(item);\n            if (css.fontSize == null)\n                throw Error(\"error\");\n            if (css.fill == null)\n                throw Error(\"error\");\n            const color = Color.createRGBFromColorName(css.fill);\n            const fontName = this.getFont(css);\n            const fontSize = CommonFunctions.toPX(css.fontSize);\n            const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\n            lines.push(`Call EditTextRangeSub(${range},${1}, ${vbaText.length}, \"\", Array(${color.r}, ${color.g}, ${color.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`);\n        }\n        return lines;\n    }\n}\nexports.VBATranslateFunctions = VBATranslateFunctions;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/vba_functions.ts?");

/***/ }),

/***/ "./src/common/vline.ts":
/*!*****************************!*\
  !*** ./src/common/vline.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n//namespace GraphTableSVG {\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Rectangle = exports.escapeWithRound100 = exports.nearlyEqual = exports.round100 = exports.Size = exports.Padding = exports.VLine = exports.PositionType = void 0;\nvar PositionType;\n(function (PositionType) {\n    PositionType.Center = \"center\";\n    PositionType.UpperLeft = \"upper-left\";\n})(PositionType || (exports.PositionType = PositionType = {}));\n/**\n * 傾きや切片を計算できる線です。\n */\nclass VLine {\n    get smallPoint() {\n        if (this.x1 < this.x2) {\n            return [this.x1, this.y1];\n        }\n        else {\n            return [this.x2, this.y2];\n        }\n    }\n    get largePoint() {\n        if (this.x1 < this.x2) {\n            return [this.x2, this.y2];\n        }\n        else {\n            return [this.x1, this.y1];\n        }\n    }\n    constructor(x1, y1, x2, y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n    distance() {\n        const l = Math.abs(this.x1 - this.x2);\n        const r = Math.abs(this.y1 - this.y2);\n        return Math.sqrt(l * l) + Math.sqrt(r * r);\n    }\n    contains(x, y) {\n        const lineY = this.getY(x);\n        if (lineY == null) {\n            return x < this.x1;\n        }\n        else {\n            return y < lineY;\n        }\n    }\n    getY(x) {\n        const intercept = this.intercept;\n        if (intercept == null) {\n            return null;\n        }\n        else {\n            if (this.slope == null) {\n                return null;\n            }\n            else {\n                return (this.slope * x) + intercept;\n            }\n        }\n    }\n    get slope() {\n        const [x1, y1] = this.smallPoint;\n        const [x2, y2] = this.largePoint;\n        if (x2 - x1 == 0) {\n            return null;\n        }\n        else {\n            return (y2 - y1) / (x2 - x1);\n        }\n    }\n    get intercept() {\n        const [x1, y1] = this.smallPoint;\n        const [x2, y2] = this.largePoint;\n        if (this.slope == null) {\n            return null;\n        }\n        else {\n            return y1 - x1 * this.slope;\n        }\n    }\n    get inverseSlope() {\n        if (this.slope == 0) {\n            return null;\n        }\n        else {\n            if (this.slope == null) {\n                return null;\n            }\n            else {\n                return -1 / this.slope;\n            }\n        }\n    }\n    inverseIntercept(x, y) {\n        if (this.slope == 0) {\n            return null;\n        }\n        else {\n            if (this.inverseSlope == null) {\n                return null;\n            }\n            else {\n                return y - (this.inverseSlope * x);\n            }\n        }\n    }\n}\nexports.VLine = VLine;\nclass Padding {\n    constructor(top = 0, left = 0, right = 0, bottom = 0) {\n        this.top = top;\n        this.left = left;\n        this.right = right;\n        this.bottom = bottom;\n    }\n}\nexports.Padding = Padding;\nclass Size {\n    constructor(width = 0, height = 0) {\n        this.width = width;\n        this.height = height;\n    }\n}\nexports.Size = Size;\nfunction round100(value) {\n    return Math.round(value * 100) / 100;\n}\nexports.round100 = round100;\nfunction nearlyEqual(value1, value2) {\n    const abs = Math.abs(value1 - value2);\n    return abs < 0.1;\n}\nexports.nearlyEqual = nearlyEqual;\nfunction escapeWithRound100(literals, ...placeholders) {\n    let result = \"\";\n    // interleave the literals with the placeholders\n    for (let i = 0; i < placeholders.length; i++) {\n        result += literals[i];\n        const p = placeholders[i];\n        result += typeof (p) === \"string\" ? p : round100(p).toString();\n    }\n    // add the last literal\n    result += literals[literals.length - 1];\n    return result;\n}\nexports.escapeWithRound100 = escapeWithRound100;\n/**\n * 四角形を表します。\n */\nclass Rectangle {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    /**\n    右端のX座標を返します。\n    */\n    get right() {\n        return this.x + this.width;\n    }\n    /**\n    底のY座標を返します。\n    */\n    get bottom() {\n        return this.y + this.height;\n    }\n    /**\n     * X座標とY座標に値を加えます。\n     * @param x\n     * @param y\n     */\n    addOffset(x, y) {\n        this.x += x;\n        this.y += y;\n    }\n    /**\n     * 引数の四角形を内包する最小の四角形を返します。\n     * @param rects\n     */\n    static merge(rects) {\n        if (rects.length > 0) {\n            let x1 = rects[0].x;\n            let y1 = rects[0].y;\n            let x2 = rects[0].right;\n            let y2 = rects[0].bottom;\n            rects.forEach((v) => {\n                if (x1 > v.x)\n                    x1 = v.x;\n                if (y1 > v.y)\n                    y1 = v.y;\n                if (x2 < v.right)\n                    x2 = v.right;\n                if (y2 < v.bottom)\n                    y2 = v.bottom;\n            });\n            const rect = new Rectangle();\n            rect.x = x1;\n            rect.y = y1;\n            rect.width = x2 - x1;\n            rect.height = y2 - y1;\n            return rect;\n        }\n        else {\n            return new Rectangle(0, 0, 0, 0);\n        }\n    }\n}\nexports.Rectangle = Rectangle;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/common/vline.ts?");

/***/ }),

/***/ "./src/debug/debug.ts":
/*!****************************!*\
  !*** ./src/debug/debug.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBinaryTrie = exports.randomLabeledTree = exports.randomTrie = exports.randomBinaryTree = exports.randomTree = void 0;\nconst logic_tree_1 = __webpack_require__(/*! ../logics/logic_tree */ \"./src/logics/logic_tree.ts\");\n//export namespace Debug {\nfunction randomTreeArray(node_num, max_degree) {\n    const nodes = new Array(0);\n    const graph = new logic_tree_1.LogicTree();\n    const root = new logic_tree_1.LogicTreeNode();\n    nodes.push(root);\n    while (nodes.length < node_num) {\n        var random = Math.floor(Math.random() * nodes.length);\n        const parent = nodes[random];\n        if (parent.children.length < max_degree) {\n            const child = new logic_tree_1.LogicTreeNode();\n            parent.children.push(child);\n            nodes.push(child);\n        }\n    }\n    graph.root = root;\n    return [graph, nodes];\n}\n/*\nfunction randomBinaryTreeArray(node_num : number) : BinaryLogicTree[] {\n    const nodes : BinaryLogicTree[] = new Array(0);\n    const root = new BinaryLogicTree();\n    nodes.push(root);\n\n    while(nodes.length < node_num){\n        var random = Math.floor( Math.random()*nodes.length );\n        var leftOrRight = Math.floor( Math.random()*2 );\n\n        const parent = nodes[random];\n\n        if(leftOrRight == 0 && parent.left == null){\n            const child = new BinaryLogicTree();\n            parent.left = child;\n            nodes.push(child);\n        }else if(leftOrRight == 1 && parent.right == null){\n            const child = new BinaryLogicTree();\n            parent.right = child;\n            nodes.push(child);\n\n        }\n    }\n    return nodes;\n}\n*/\nfunction randomTree(node_num, max_degree) {\n    return randomTreeArray(node_num, max_degree)[0];\n}\nexports.randomTree = randomTree;\nfunction randomBinaryTree(node_num) {\n    return randomTree(node_num, 2);\n}\nexports.randomBinaryTree = randomBinaryTree;\nconst labels = [\"a\", \"b\", \"c\", \"あ\", \"e\", \"f\", \"g\"];\nfunction randomTrie(node_num, max_degree) {\n    const [graph, nodes] = randomTreeArray(node_num, max_degree);\n    for (let i = 1; i < nodes.length; i++) {\n        var randomLabelNumber = Math.floor(Math.random() * labels.length);\n        nodes[i].edgeOption.text = labels[randomLabelNumber];\n    }\n    return graph;\n}\nexports.randomTrie = randomTrie;\nfunction randomLabeledTree(node_num, max_degree, max_string_length) {\n    const [graph, nodes] = randomTreeArray(node_num, max_degree);\n    for (let i = 1; i < nodes.length; i++) {\n        var strLen = Math.floor(Math.random() * max_string_length);\n        let s = \"\";\n        for (let x = 0; x < strLen; x++) {\n            var randomLabelNumber = Math.floor(Math.random() * labels.length);\n            if (randomLabelNumber < 4) {\n                s += labels[randomLabelNumber];\n            }\n        }\n        nodes[i].edgeOption.text = s;\n    }\n    return graph;\n}\nexports.randomLabeledTree = randomLabeledTree;\nfunction randomBinaryTrie(node_num) {\n    const node = randomTrie(node_num, 2);\n    return node;\n}\nexports.randomBinaryTrie = randomBinaryTrie;\n/*\nexport function randomTrie(node_num : number, max_degree : number) : LogicTree {\n    const nodes = randomTreeArray(node_num, max_degree);\n    for(let i=1;i<nodes.length;i++){\n        var randomLabelNumber = Math.floor( Math.random()* labels.length );\n        nodes[i].parentEdgeText = labels[randomLabelNumber];\n        \n    }\n    return nodes[0];\n}\n*/\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/debug/debug.ts?");

/***/ }),

/***/ "./src/html/css.ts":
/*!*************************!*\
  !*** ./src/html/css.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.writeDownCSSToStyleAttributes = exports.setCSSToStyle = exports.setCSSStyle = exports.setCSSClass = exports.createCSSClass = exports.createCSSString = exports.createCSS = exports.getOrCreateClassName = exports.toRuleMap = exports.getRuleContentString = exports.getGraphTableStyleSheet = exports.getGraphTableCSS = exports.setGraphTableCSS = exports.buildClassNameFromSurfaceClassCSS = void 0;\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ./html_functions */ \"./src/html/html_functions.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\n//export namespace CSS {\n/*\ninterface IPoint2D {\n    x: number;\n    y: number;\n  }\n  */\nfunction buildClassNameFromSurfaceClassCSS(rule) {\n    const _rule = toRuleMap(rule);\n    return getOrCreateClassName(_rule);\n}\nexports.buildClassNameFromSurfaceClassCSS = buildClassNameFromSurfaceClassCSS;\nconst CSSName = \"___GraphTableCSS\";\nlet createdGraphTableCSS = false;\nconst replaceMapper = new Map();\nfunction setupReplaceMapper() {\n    replaceMapper.set(\"fontSize\", \"font-size\");\n    replaceMapper.set(\"fontFamily\", \"font-family\");\n    replaceMapper.set(\"autoSizeShapeToFitText\", StyleNames.autoSizeShapeToFitText);\n    replaceMapper.set(\"verticalAnchor\", StyleNames.verticalAnchor);\n    replaceMapper.set(\"horizontalAnchor\", StyleNames.horizontalAnchor);\n    replaceMapper.set(\"beginConnectorType\", StyleNames.EdgeStyleNames.beginConnectorType);\n    replaceMapper.set(\"endConnectorType\", StyleNames.EdgeStyleNames.endConnectorType);\n    replaceMapper.set(\"startMarker\", StyleNames.EdgeStyleNames.markerStart);\n    replaceMapper.set(\"endMarker\", StyleNames.EdgeStyleNames.markerEnd);\n    replaceMapper.set(\"edgeType\", StyleNames.EdgeStyleNames.edgeType);\n    replaceMapper.set(\"pathTextAlignment\", StyleNames.EdgeStyleNames.pathTextAlignment);\n    replaceMapper.set(\"paddingTop\", StyleNames.paddingTop);\n    replaceMapper.set(\"paddingLeft\", StyleNames.paddingLeft);\n    replaceMapper.set(\"paddingRight\", StyleNames.paddingRight);\n    replaceMapper.set(\"paddingBottom\", StyleNames.paddingBottom);\n    replaceMapper.set(\"strokeWidth\", \"stroke-width\");\n}\nfunction setGraphTableCSS() {\n    if (createdGraphTableCSS)\n        return;\n    const item = document.head.getElementsByClassName(CSSName);\n    if (item.length > 0) {\n        document.head.removeChild(item[0]);\n    }\n    var blankStyle = document.createElement('style');\n    blankStyle.innerHTML = createCSS();\n    blankStyle.type = \"text/css\";\n    blankStyle.setAttribute(\"class\", CSSName);\n    blankStyle.title = CSSName;\n    const head = document.getElementsByTagName('head');\n    const fstItem = head.item(0).firstChild;\n    if (fstItem == null) {\n        head.item(0).appendChild(blankStyle);\n    }\n    else {\n        head.item(0).insertBefore(blankStyle, fstItem);\n    }\n    createdGraphTableCSS = true;\n}\nexports.setGraphTableCSS = setGraphTableCSS;\nfunction getGraphTableCSS() {\n    const item = document.getElementById(CSSName);\n    if (item instanceof HTMLStyleElement) {\n        return item;\n    }\n    else {\n        return null;\n    }\n}\nexports.getGraphTableCSS = getGraphTableCSS;\nfunction getGraphTableStyleSheet() {\n    if (!createdGraphTableCSS)\n        setGraphTableCSS();\n    for (let i = 0; i < document.styleSheets.length; i++) {\n        const css = document.styleSheets.item(i);\n        if (css.title == CSSName && css instanceof CSSStyleSheet) {\n            return css;\n        }\n    }\n    return null;\n}\nexports.getGraphTableStyleSheet = getGraphTableStyleSheet;\nfunction getRuleContentString(rule) {\n    const arr = new Array();\n    rule.forEach((value, key) => {\n        arr.push(key);\n    });\n    arr.sort();\n    const content = arr.map((key) => {\n        return `${key}: ${rule.get(key)};`;\n    }).join(\"\\n\");\n    return content;\n}\nexports.getRuleContentString = getRuleContentString;\nfunction toRuleMap(rule) {\n    if (replaceMapper.size == 0)\n        setupReplaceMapper();\n    const _rule = new Map();\n    Object.keys(rule).forEach((v) => {\n        if (replaceMapper.has(v)) {\n            _rule.set(replaceMapper.get(v), rule[v]);\n        }\n        else {\n            _rule.set(v, rule[v]);\n        }\n        /*\n        if(v == \"fontSize\"){\n            _rule.set(\"font-size\", value);\n        }else if(v == \"fontFamily\"){\n            _rule.set(\"font-family\", value);\n        }else{\n            _rule.set(v, (<any>rule)[v]);\n        }\n        */\n    });\n    return _rule;\n}\nexports.toRuleMap = toRuleMap;\nconst ruleInverseMap = new Map();\nlet createdCSSRuleCount = 0;\nconst generatedCSSRuleName = \"--g-class-\";\nfunction getOrCreateClassName(rule) {\n    if (rule instanceof Map) {\n        const ruleContentString = getRuleContentString(rule);\n        if (ruleInverseMap.has(ruleContentString)) {\n            return ruleInverseMap.get(ruleContentString);\n        }\n        else {\n            const css = getGraphTableStyleSheet();\n            const className = `${generatedCSSRuleName}${createdCSSRuleCount++}`;\n            const cssRule = `.${className}{${ruleContentString}}`;\n            css.insertRule(cssRule, css.cssRules.length);\n            ruleInverseMap.set(ruleContentString, className);\n            return className;\n        }\n    }\n    else {\n        const _rule = toRuleMap(rule);\n        return getOrCreateClassName(_rule);\n    }\n}\nexports.getOrCreateClassName = getOrCreateClassName;\nfunction createCSS() {\n    const r = `\r\n            .${AttributeNames.cellEmphasisCellClass}{\r\n            fill : yellow !important;\r\n            }\r\n            .${AttributeNames.cellEmphasisBorderClass}{\r\n            stroke : red !important;\r\n            }\r\n            .${DefaultClassNames.defaultCellClass}{\r\n                ${StyleNames.paddingTop} : 0px;\r\n                ${StyleNames.paddingLeft} : 0px;\r\n                ${StyleNames.paddingRight} : 0px;\r\n                ${StyleNames.paddingBottom} : 0px;\r\n                ${StyleNames.verticalAnchor} : ${enums_1.VerticalAnchor.Middle};\r\n                ${StyleNames.horizontalAnchor} : ${enums_1.HorizontalAnchor.Center};\r\n            }\r\n            .${DefaultClassNames.defaultTextClass}{\r\n                fill : black;\r\n                font-size: 20px;\r\n                font-family: \"Times New Roman\";\r\n            }\r\n            .${DefaultClassNames.defaultCellBackgroungClass}{\r\n                fill : white;\r\n            }\r\n            .${DefaultClassNames.defaultCellBorderClass}{\r\n                stroke : black;\r\n            }\r\n            .${DefaultClassNames.defaultVertexClass}{\r\n\r\n            }\r\n            .${DefaultClassNames.defaultEdgeClass}{\r\n                ${StyleNames.EdgeStyleNames.pathTextAlignment}: center;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultSurfaceClass}{\r\n                stroke: black;\r\n                stroke-width: 1px;\r\n                fill : white;\r\n            }\r\n            .${DefaultClassNames.defaultPathSurfaceClass}{\r\n                stroke: black;\r\n                stroke-width: 1px;\r\n                fill : transparent;\r\n            }\r\n            .${DefaultClassNames.defaultCircleLogicTreeCircleSVGGroup}{\r\n                ${StyleNames.autoSizeShapeToFitText}: false;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultEdgePathClass}{\r\n                stroke: black;\r\n                fill: none;\r\n                stroke-width: 1px;\r\n            }\r\n            .${DefaultClassNames.defaultTextboxPathClass}{\r\n                stroke: black;\r\n                fill: white;\r\n                stroke-width: 1px;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultRectButtonClass}{\r\n                --padding-top: 5;\r\n                --padding-left: 15;\r\n                --padding-right: 15;\r\n                --padding-bottom: 5;\r\n            }\r\n\r\n            .___column_title_cellaa{\r\n                --default-text-class : table-text;\r\n                --default-background-class : background;    \r\n                --horizontal-anchor: center;\r\n                --vertical-anchor: middle;\r\n                --padding-top: 0px;\r\n                --padding-left: 0px;\r\n                --padding-right: 0px;\r\n                --padding-bottom: 0px;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultConsoleColumnTitleCellTextClass} {\r\n                fill : black;\r\n                font-size: 18px;\r\n                font-weight: bold;\r\n                font-family: \"'Times New Roman'\";\r\n            }\r\n            .${DefaultClassNames.defaultConsoleColumnTitleCellUndefinedTextClass} {\r\n                fill : pink;\r\n                font-size: 18px;\r\n                font-style: italic;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultConsoleColumnTitleCellBackgroundClass}{\r\n                fill: #8EB8FF; \r\n                stroke: black;\r\n            }\r\n            .${DefaultClassNames.defaultTreeClass}{\r\n                ${StyleNames.relocateName}: standard;\r\n            }\r\n\r\n\r\n            g[data-type=\"z-rect-button\"] > rect {\r\n                fill:#69c; \r\n                stroke: #444444;\r\n                stroke-width: 3px;\r\n                transition-duration: 0.2s;\r\n            }\r\n\r\n            g[data-type=\"z-rect-button\"] > rect[disabled]{\r\n                stroke-width: 5px;\r\n            }\r\n            g[data-type=\"z-rect-button\"] > rect:not([disabled]):hover {\r\n                stroke-width: 1px;\r\n                fill: #79acdf;\r\n                stroke: white;\r\n\r\n            }\r\n            g[data-type=\"z-rect-button\"] > rect:not([disabled]):active {\r\n                stroke-width: 5px;\r\n                stroke: black;\r\n\r\n            }\r\n            g[data-type=\"z-rect-button\"] > text {\r\n                pointer-events: none;\r\n                fill: white;\r\n                font-family: \"'Arial'\";\r\n            }\r\n\r\n            g[data-allow-hover=\"true\"] > rect, g[data-allow-hover=\"true\"] > circle, g[data-allow-hover=\"true\"] > ellipse, g[data-allow-hover=\"true\"] > path {\r\n                transition-duration: 0.2s;\r\n            }\r\n            g[data-allow-hover=\"true\"] > rect:not([disabled]):hover, g[data-allow-hover=\"true\"] > circle:not([disabled]):hover, g[data-allow-hover=\"true\"] > ellipse:not([disabled]):hover, g[data-allow-hover=\"true\"] > path:not([disabled]):hover {\r\n                stroke-width: 1px;\r\n            }\r\n\r\n            .graphtablesvg_wrapper{\r\n                min-height: 100vh;\r\n                position: relative;\r\n                padding-bottom: 120px;\r\n                box-sizing: border-box;\r\n            }\r\n            \r\n            .graphtablesvg_footer{\r\n                width: 100%;\r\n                background-color: #89c7de;\r\n                color: #fff;\r\n                text-align: center;\r\n                padding: 30px 0;\r\n            \r\n             position: absolute;\r\n                bottom: 0;\r\n            }\r\n\r\n            `;\n    return r;\n}\nexports.createCSS = createCSS;\nfunction createCSSString(obj) {\n    if (typeof obj == \"string\") {\n        return obj;\n    }\n    else if (typeof obj == \"object\") {\n        const styleContent = getRuleContentString(toRuleMap(obj));\n        return styleContent;\n    }\n    else {\n        return undefined;\n    }\n}\nexports.createCSSString = createCSSString;\nfunction createCSSClass(obj) {\n    if (typeof obj == \"string\") {\n        return obj;\n    }\n    else if (typeof obj == \"object\") {\n        const styleClass = getOrCreateClassName(obj);\n        return styleClass;\n    }\n    else {\n        return undefined;\n    }\n}\nexports.createCSSClass = createCSSClass;\nfunction setCSSClass(e, style) {\n    if (style !== undefined) {\n        //SVG.resetStyle(e.style);\n        if (style == null) {\n            e.removeAttribute(\"class\");\n        }\n        else {\n            const styleClass = createCSSClass(style);\n            if (styleClass !== undefined) {\n                e.setAttribute(\"class\", styleClass);\n            }\n        }\n    }\n}\nexports.setCSSClass = setCSSClass;\nfunction setCSSStyle(e, style) {\n    if (style !== undefined) {\n        //SVG.resetStyle(e.style);\n        const styleClass = createCSSString(style);\n        if (styleClass !== undefined) {\n            e.setAttribute(\"style\", styleClass);\n        }\n    }\n}\nexports.setCSSStyle = setCSSStyle;\nconst exceptionStyleNames = [\"marker-start\", \"marker-mid\", \"marker-end\", \"width\", \"height\"];\nconst cssPropertyNames = [\"font-size\", \"fill\", \"stroke\",\n    \"font-family\", \"font-weight\", \"stroke-width\", \"background\", \"border\", \"background-color\", \"border-bottom-color\", \"border-bottom-style\", \"border-bottom-width\",\n    \"border-left-color\", \"border-left-style\", \"border-left-width\", \"border-right-color\", \"border-right-style\", \"border-right-width\", \"border-top-color\", \"border-top-style\", \"border-top-width\"];\nfunction getPropertyStyleValue(item, name) {\n    const p = item.style.getPropertyValue(name).trim();\n    if (p.length == 0) {\n        const r = item.getAttribute(\"class\");\n        if (r == null) {\n            return null;\n        }\n        else {\n            const css = getComputedStyle(item);\n            //const css = getComputedStyle(item);\n            const p2 = css.getPropertyValue(name).trim();\n            if (p2.length == 0) {\n                return null;\n            }\n            else {\n                return p2;\n            }\n        }\n    }\n    else {\n        return p;\n    }\n}\n/**\n         * SVG要素のクラス属性名から取得できるCSSStyleDeclarationを要素のスタイル属性にセットします。\n         * @param svg 適用されるSVG要素\n         */\nfunction setCSSToStyle(svg, isComplete = true) {\n    if (isComplete) {\n        const css = getComputedStyle(svg);\n        if (css != null) {\n            for (let i = 0; i < css.length; i++) {\n                const name = css.item(i);\n                const value = css.getPropertyValue(name);\n                if (value.length > 0) {\n                    if (!exceptionStyleNames.some((v) => v == name)) {\n                        svg.style.setProperty(name, value);\n                    }\n                }\n            }\n        }\n    }\n    else {\n        cssPropertyNames.forEach((v) => {\n            const value = getPropertyStyleValue(svg, v);\n            if (value != null) {\n                svg.style.setProperty(v, value);\n            }\n        });\n    }\n    /*\n    const css = getCSSStyle(svg);\n    if (css != null) {\n        let css2: CSSStyleDeclaration = css;\n        cssPropertyNames.forEach((v) => {\n            const value = css2.getPropertyValue(v).trim();\n            if (value.length > 0) {\n                svg.style.setProperty(v, value);\n            }\n        });\n    }\n    */\n}\nexports.setCSSToStyle = setCSSToStyle;\nfunction writeDownCSSToStyleAttributes(element) {\n    if (element instanceof SVGSVGElement || element instanceof SVGGElement) {\n        const elements = HTMLFunctions.getDescendantsByPostorder(element);\n        elements.forEach((v) => {\n            if (v instanceof SVGGeometryElement) {\n                setCSSToStyle(v, false);\n            }\n            else if (v instanceof SVGTextElement) {\n                setCSSToStyle(v, false);\n            }\n        });\n    }\n    else {\n        const id = element;\n        const v = document.getElementById(id);\n        if (v instanceof SVGSVGElement || v instanceof SVGGElement) {\n            writeDownCSSToStyleAttributes(v);\n        }\n        else {\n            throw new Error(\"Not found!\");\n        }\n    }\n}\nexports.writeDownCSSToStyleAttributes = writeDownCSSToStyleAttributes;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/css.ts?");

/***/ }),

/***/ "./src/html/draggable_object.ts":
/*!**************************************!*\
  !*** ./src/html/draggable_object.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DraggableObjectFunctions = void 0;\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\nvar DraggableObjectFunctions;\n(function (DraggableObjectFunctions) {\n    let drag = null;\n    function draggable(element, g) {\n        element.addEventListener('mousedown', function (e) {\n            e.preventDefault();\n            //const rect = getContainerRect(g);\n            const parent = SVG.getLeastContainer(g);\n            if (parent != null) {\n                const rect = SVG.getAbsolutePosition(g);\n                drag = {\n                    offsetX: e.clientX - rect.x,\n                    offsetY: e.clientY - rect.y,\n                    target: element,\n                    g: g,\n                    gParentG: parent\n                };\n            }\n            return false;\n        });\n    }\n    DraggableObjectFunctions.draggable = draggable;\n    /*\n    function getContainerRect(e: SVGElement) {\n        const container = SVG.getLeastContainer(e)!;\n        const containerRect = container.getBoundingClientRect();\n        return containerRect;\n    }\n    */\n    function appendDragFunctionsToDocument() {\n        document.onmouseup = function () {\n            drag = null;\n        };\n        document.onmousemove = function (e) {\n            if (drag != null) {\n                if (drag.target != null && drag.target instanceof SVGElement) {\n                    const g = drag.g;\n                    const containerRect = SVG.getAbsolutePosition(drag.gParentG);\n                    const refx = (e.clientX - containerRect.x) - drag.offsetX;\n                    const refy = (e.clientY - containerRect.y) - drag.offsetY;\n                    SVGGExtension.setX(g, refx);\n                    SVGGExtension.setY(g, refy);\n                    //drag.target.x.baseVal.value = e.clientX - drag.offsetx;\n                    //drag.target.y.baseVal.value = e.clientY - drag.offsety;\n                }\n            }\n        };\n    }\n    DraggableObjectFunctions.appendDragFunctionsToDocument = appendDragFunctionsToDocument;\n})(DraggableObjectFunctions || (exports.DraggableObjectFunctions = DraggableObjectFunctions = {}));\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/draggable_object.ts?");

/***/ }),

/***/ "./src/html/enum_extension.ts":
/*!************************************!*\
  !*** ./src/html/enum_extension.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUpdateFlagAppropriateDashArray = exports.updateAppropriateDashArray = exports.tryUpdateAppropriateDashArrayWithUpdateFlag = exports.getLineType = void 0;\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nfunction getLineType(svgLine) {\n    const typeName = ElementExtension.getPropertyStyleValue(svgLine, StyleNames.msoDashStyleName);\n    if (typeName != null) {\n        const type = enums_1.msoDashStyle.toMSODashStyle(typeName);\n        if (type != null) {\n            return type;\n        }\n    }\n    const dashArray = ElementExtension.getPropertyStyleValue(svgLine, \"stroke-dasharray\");\n    if (dashArray != null && dashArray != \"none\") {\n        return enums_1.msoDashStyle.msoLineDash;\n    }\n    else {\n        return enums_1.msoDashStyle.msoLineSolid;\n    }\n}\nexports.getLineType = getLineType;\nfunction computeDashArray(type, width) {\n    const r = [];\n    for (let i = 0; i < enums_1.msoDashStyle.dashArrayDic[type].length; i++) {\n        r.push(`${enums_1.msoDashStyle.dashArrayDic[type][i] * width}px`);\n    }\n    if (r.length == 0) {\n        return \"none\";\n    }\n    else {\n        return r.join(\", \");\n    }\n}\nfunction tryUpdateAppropriateDashArrayWithUpdateFlag(svgLine, updateFlag) {\n    const type = ElementExtension.getPropertyStyleValue(svgLine, StyleNames.msoDashStyleName);\n    if (type == null) {\n        return false;\n    }\n    else if (enums_1.msoDashStyle.toMSODashStyle(type) != null) {\n        const width = ElementExtension.getPropertyStyleNumberValue(svgLine, \"stroke-width\", 2);\n        const newDashArray = computeDashArray(enums_1.msoDashStyle.toMSODashStyle(type), width);\n        const newLineCap = enums_1.msoDashStyle.lineCapDic[type];\n        const oldDashArray = ElementExtension.getPropertyStyleValue(svgLine, \"stroke-dasharray\");\n        const b1 = !(newDashArray == oldDashArray);\n        if (b1) {\n            if (updateFlag) {\n                ElementExtension.setPropertyStyleValue2(svgLine, \"stroke-dasharray\", newDashArray);\n            }\n            else {\n                debugger_1.Debugger.updateFlagLog(svgLine, tryUpdateAppropriateDashArrayWithUpdateFlag, \"!(newDashArray == oldDashArray)\");\n                return true;\n            }\n        }\n        const oldLineCap = ElementExtension.getPropertyStyleValue(svgLine, \"stroke-linecap\");\n        const b2 = !(newLineCap == oldLineCap);\n        if (b2) {\n            if (updateFlag) {\n                ElementExtension.setPropertyStyleValue2(svgLine, \"stroke-linecap\", newLineCap);\n            }\n            else {\n                debugger_1.Debugger.updateFlagLog(svgLine, tryUpdateAppropriateDashArrayWithUpdateFlag, \"!(newLineCap == oldLineCap)\");\n                return true;\n            }\n        }\n        return b1 || b2;\n    }\n    else {\n        return false;\n    }\n}\nexports.tryUpdateAppropriateDashArrayWithUpdateFlag = tryUpdateAppropriateDashArrayWithUpdateFlag;\nfunction updateAppropriateDashArray(svgLine) {\n    return tryUpdateAppropriateDashArrayWithUpdateFlag(svgLine, true);\n}\nexports.updateAppropriateDashArray = updateAppropriateDashArray;\nfunction getUpdateFlagAppropriateDashArray(svgLine) {\n    return tryUpdateAppropriateDashArrayWithUpdateFlag(svgLine, false);\n}\nexports.getUpdateFlagAppropriateDashArray = getUpdateFlagAppropriateDashArray;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/enum_extension.ts?");

/***/ }),

/***/ "./src/html/gui.ts":
/*!*************************!*\
  !*** ./src/html/gui.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getClientRectangle = exports.getNonNullElementById = exports.getInputText = exports.setURLParametersToHTMLElements = exports.getURLParameters = exports.setSVGBoxSize = void 0;\n//namespace GraphTableSVG {\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nfunction setSVGBoxSize(box, item1, item2) {\n    if (item1 instanceof vline_1.Rectangle) {\n        if (item2 instanceof vline_1.Padding) {\n            const w = item1.right + item2.left + item2.right;\n            const h = item1.bottom + item2.top + item2.bottom;\n            setSVGBoxSize(box, w, h);\n        }\n        else {\n            throw new Error();\n        }\n    }\n    else {\n        if (item2 instanceof vline_1.Padding) {\n            throw new Error();\n        }\n        else {\n            const width = `${item1}px`;\n            const height = `${item2}px`;\n            if (box.style.width != width || box.style.height != height) {\n                box.style.width = width;\n                box.style.height = height;\n                box.setAttribute(\"width\", width);\n                box.setAttribute(\"height\", height);\n                box.setAttribute(`viewBox`, `0 0 ${item1} ${item2}`);\n            }\n        }\n    }\n}\nexports.setSVGBoxSize = setSVGBoxSize;\n/**\n * URLのパラメータを表す連想配列を生成します。\n */\nfunction getURLParameters() {\n    const arg = {};\n    const pair = location.search.substring(1).split('&');\n    for (let i = 0; pair[i]; i++) {\n        const kv = pair[i].split('=');\n        arg[kv[0]] = kv[1];\n    }\n    return arg;\n}\nexports.getURLParameters = getURLParameters;\n/**\n * URLのパラメータをパースしてHTML内の適切な要素に代入します。\n */\nfunction setURLParametersToHTMLElements() {\n    const parameters = getURLParameters();\n    Object.keys(parameters).forEach((key) => {\n        const val = parameters[key]; // this は obj\n        const element = document.getElementById(key);\n        if (element != null) {\n            if (element instanceof HTMLTextAreaElement) {\n                element.value = val;\n            }\n        }\n    }, parameters);\n}\nexports.setURLParametersToHTMLElements = setURLParametersToHTMLElements;\n/**\n * HTMLTextAreaElementのテキストを取得します。\n * @param elementID HTMLTextAreaElementのID\n */\nfunction getInputText(elementID) {\n    const textbox = document.getElementById(elementID);\n    return textbox.value;\n}\nexports.getInputText = getInputText;\n/**\n * HTMLTextAreaElementを取得します。\n * @param id HTMLTextAreaElementのID\n */\nfunction getNonNullElementById(id) {\n    const tmp = document.getElementById(id);\n    if (tmp == null) {\n        throw Error(\"Null Error\");\n    }\n    else {\n        return tmp;\n    }\n}\nexports.getNonNullElementById = getNonNullElementById;\nfunction getClientRectangle() {\n    const x = window.pageXOffset;\n    const y = window.pageYOffset;\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    return new vline_1.Rectangle(x, y, width, height);\n}\nexports.getClientRectangle = getClientRectangle;\n//}\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/gui.ts?");

/***/ }),

/***/ "./src/html/gui_observer.ts":
/*!**********************************!*\
  !*** ./src/html/gui_observer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.observeSVGSVG = exports.isObserved = exports.observeChangeElement = exports.observeSVGBox = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst GUI = __webpack_require__(/*! ./gui */ \"./src/html/gui.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ./html_functions */ \"./src/html/html_functions.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\n/**\n *\n * @param svgBox\n * @param sizeFunc\n * @param padding\n */\nfunction observeSVGBox(svgBox, sizeFunc, padding = new vline_1.Padding(5, 5, 5, 5)) {\n    let _observer;\n    let observeFunction = (x) => {\n        let b = false;\n        for (let i = 0; i < x.length; i++) {\n            const item = x[i];\n            if (svgBox != item.target) {\n                b = true;\n            }\n        }\n        if (b)\n            GUI.setSVGBoxSize(svgBox, sizeFunc(), padding);\n    };\n    _observer = new MutationObserver(observeFunction);\n    const option = {\n        subtree: true, attributes: true\n    };\n    _observer.observe(svgBox, option);\n}\nexports.observeSVGBox = observeSVGBox;\nfunction dispatchResizeEvent(e) {\n    const children = HTMLFunctions.getChildren(e);\n    children.forEach((v) => {\n        dispatchResizeEvent(v);\n    });\n    if (e instanceof SVGGElement) {\n        var event = document.createEvent(\"HTMLEvents\");\n        event.initEvent(AttributeNames.resizeName, false, true);\n        e.dispatchEvent(event);\n    }\n}\nlet changeElementDic = [];\nlet timerInterval = 100;\nfunction observeChangeElement() {\n    var result = document.evaluate(\"//iframe[@g-src]\", document, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);\n    for (var i = 0; i < result.snapshotLength; i++) {\n        var node = result.snapshotItem(i);\n        changeElementDic.push(node);\n    }\n    if (changeElementDic.length > 0)\n        setTimeout(observeChangeElementTimer, timerInterval);\n}\nexports.observeChangeElement = observeChangeElement;\nfunction observeChangeElementTimer() {\n    for (let i = 0; i < changeElementDic.length; i++) {\n        const element = changeElementDic[i];\n        if (HTMLFunctions.isInsideElement(element)) {\n            const url = element.getAttribute(\"g-src\");\n            element.setAttribute(\"src\", url);\n            element.removeAttribute(\"g-src\");\n            changeElementDic.splice(i, 1);\n            i = -1;\n        }\n    }\n    if (changeElementDic.length > 0)\n        setTimeout(observeChangeElementTimer, timerInterval);\n}\nlet dic = [];\nlet createdObserveSVGSVGTimer = false;\nfunction resizeSVGSVG(svgBox, padding) {\n    //GraphTableSVG.GUI.setSVGBoxSize(svgBox, new Rectangle(0,0,1000,1000), padding);\n    const rect = SVG.getRegion2(svgBox);\n    if (rect.width == 0)\n        rect.width = 1;\n    if (rect.height == 0)\n        rect.height = 1;\n    GUI.setSVGBoxSize(svgBox, rect, padding);\n}\nfunction isObserved(svgBox) {\n    for (let i = 0; i < dic.length; i++) {\n        if (dic[i].svgsvg === svgBox) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.isObserved = isObserved;\nfunction observeSVGSVG(svgBox, padding = new vline_1.Padding(0, 0, 0, 0)) {\n    if (isObserved(svgBox)) {\n        return;\n    }\n    let _observer;\n    let observeFunction = (x) => {\n        const gShrink = ElementExtension.gtGetAttributeBooleanWithUndefined(svgBox, enums_1.OriginalSVGSVGAttributes.ShrinkAttributeName);\n        let b = false;\n        for (let i = 0; i < x.length; i++) {\n            const item = x[i];\n            if (svgBox != item.target) {\n                b = true;\n            }\n        }\n        if (gShrink === true && b) {\n            resizeSVGSVG(svgBox, padding);\n        }\n    };\n    _observer = new MutationObserver(observeFunction);\n    const option = {\n        subtree: true, attributes: true\n    };\n    _observer.observe(svgBox, option);\n    dic.push({ svgsvg: svgBox, visible: false, padding: padding });\n    if (!createdObserveSVGSVGTimer) {\n        createdObserveSVGSVGTimer = true;\n        setTimeout(observeSVGSVGTimer, timerInterval);\n    }\n}\nexports.observeSVGSVG = observeSVGSVG;\n/**\n * SVGSVGElemenを定期的に監視する関数です。\n */\nfunction observeSVGSVGTimer() {\n    dic.forEach((v, i) => {\n        const nowVisible = !SVG.isSVGSVGHidden(v.svgsvg);\n        if (v.visible) {\n            if (!nowVisible) {\n                v.visible = false;\n            }\n        }\n        else {\n            if (nowVisible) {\n                dispatchResizeEvent(v.svgsvg);\n                const b = ElementExtension.gtGetAttributeBooleanWithUndefined(v.svgsvg, enums_1.OriginalSVGSVGAttributes.ShrinkAttributeName);\n                if (b !== undefined && b === true)\n                    resizeSVGSVG(v.svgsvg, v.padding);\n                v.visible = true;\n            }\n        }\n    });\n    setTimeout(observeSVGSVGTimer, timerInterval);\n}\n//}\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/gui_observer.ts?");

/***/ }),

/***/ "./src/html/html_functions.ts":
/*!************************************!*\
  !*** ./src/html/html_functions.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAttributeFromAncestors = exports.getSubAttributeFromAncestors = exports.getSVGSVGAncestor = exports.removeInvisibleCharacters = exports.isInsideElement = exports.getChildByNodeName = exports.getChildren = exports.getDescendants = exports.getDescendantsByPostorder = exports.getDescendantsByPreorder = exports.isShow = exports.copyAttributes = exports.getAncestorAttribute = exports.getTNodes = exports.NodeOrder = void 0;\nconst GUI = __webpack_require__(/*! ./gui */ \"./src/html/gui.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\n//export namespace HTMLFunctions {\nvar NodeOrder;\n(function (NodeOrder) {\n    NodeOrder[NodeOrder[\"Preorder\"] = 0] = \"Preorder\";\n    NodeOrder[NodeOrder[\"Postorder\"] = 1] = \"Postorder\";\n})(NodeOrder || (exports.NodeOrder = NodeOrder = {}));\nfunction getTNodes(e) {\n    const tNodes = getChildren(e).filter((v) => v.getAttribute(AttributeNames.customElement) == \"t\");\n    if (tNodes.length > 0) {\n        tNodes.forEach((v, i) => {\n            v.removeAttribute(AttributeNames.customElement);\n            if (i > 0 && !v.hasAttribute(\"newline\"))\n                v.setAttribute(\"newline\", \"true\");\n        });\n        return tNodes;\n    }\n    else {\n        return null;\n    }\n}\nexports.getTNodes = getTNodes;\nfunction getAncestorAttribute(e, attr) {\n    if (e.hasAttribute(attr)) {\n        return e.getAttribute(attr);\n    }\n    else {\n        if (e.parentElement == null) {\n            return null;\n        }\n        else {\n            return getAncestorAttribute(e.parentElement, attr);\n        }\n    }\n}\nexports.getAncestorAttribute = getAncestorAttribute;\nfunction copyAttributes(from, to) {\n    for (let i = 0; i < from.attributes.length; i++) {\n        const attr = from.attributes.item(i);\n        to.setAttribute(attr.name, attr.value);\n    }\n}\nexports.copyAttributes = copyAttributes;\n/*\nfunction isShow2(e: HTMLElement | SVGElement, isParentWindow : boolean = false): boolean {\n    \n    const p = isParentWindow ? window.parent.getComputedStyle(e) : window.getComputedStyle(e);\n    const disp = p.display;\n    const vis = p.visibility;\n    if (disp == \"none\" || vis == \"hidden\") {\n        return false;\n    } else {\n        const parent = e.parentElement;\n        if (parent == null) {\n            if(isParentWindow){\n                return true;\n            }else{\n                if(window == window.parent){\n                    return true;\n                }else{\n                    return isShow2(<HTMLElement>window.frameElement, true);\n                }\n            }\n        } else {\n            return isShow2(parent, isParentWindow);\n        }\n    }\n\n}\n*/\nfunction isShow(e) {\n    const p = e.getBoundingClientRect();\n    return !(p.top == 0 && p.left == 0 && p.width == 0 && p.height == 0);\n    //return isShow2(e);\n}\nexports.isShow = isShow;\nfunction getDescendantsByPreorder(e) {\n    const r = [];\n    r.push(e);\n    for (let i = 0; i < e.children.length; i++) {\n        const p = e.children.item(i);\n        if (p instanceof Element) {\n            getDescendantsByPreorder(p).forEach((v) => r.push(v));\n        }\n    }\n    return r;\n}\nexports.getDescendantsByPreorder = getDescendantsByPreorder;\nfunction getDescendantsByPostorder(e) {\n    const r = [];\n    for (let i = 0; i < e.children.length; i++) {\n        const p = e.children.item(i);\n        if (p instanceof Element) {\n            getDescendantsByPostorder(p).forEach((v) => r.push(v));\n        }\n    }\n    r.push(e);\n    return r;\n}\nexports.getDescendantsByPostorder = getDescendantsByPostorder;\nfunction getDescendants(e, order = NodeOrder.Preorder) {\n    if (order == NodeOrder.Preorder) {\n        return getDescendantsByPreorder(e);\n    }\n    else {\n        return getDescendantsByPostorder(e);\n    }\n}\nexports.getDescendants = getDescendants;\nfunction getChildren(e) {\n    const r = [];\n    for (let i = 0; i < e.children.length; i++) {\n        const p = e.children.item(i);\n        if (p instanceof Element) {\n            r.push(p);\n        }\n    }\n    return r;\n}\nexports.getChildren = getChildren;\nfunction getChildByNodeName(e, name) {\n    const p = getChildren(e).filter((v) => v.nodeName.toLowerCase() == name.toLowerCase());\n    if (p.length > 0) {\n        return p[0];\n    }\n    else {\n        return null;\n    }\n}\nexports.getChildByNodeName = getChildByNodeName;\nfunction isInsideElement(element) {\n    const win = GUI.getClientRectangle();\n    const ele = element.getBoundingClientRect();\n    const b1 = ele.left <= win.width && ele.top <= win.height;\n    const b2 = ele.right <= win.width && ele.top <= win.height;\n    const b3 = ele.left <= win.width && ele.bottom <= win.height;\n    const b4 = ele.right <= win.width && ele.bottom <= win.height;\n    return b1 || b2 || b3 || b4;\n}\nexports.isInsideElement = isInsideElement;\nfunction removeInvisibleCharacters(text) {\n    let prevSpace = true;\n    var l = text.split(\"\\n\");\n    var newContent = l.join('');\n    let s = \"\";\n    for (let j = 0; j < newContent.length; j++) {\n        const character = newContent[j];\n        const value = character.charCodeAt(0);\n        if (value >= 32 && !(prevSpace && value == 32)) {\n            s += character;\n        }\n        if (value == 32) {\n            prevSpace = true;\n        }\n        else {\n            prevSpace = false;\n        }\n    }\n    return s;\n}\nexports.removeInvisibleCharacters = removeInvisibleCharacters;\nfunction getSVGSVGAncestor(e) {\n    const parent = e.parentElement;\n    if (parent == null) {\n        return null;\n    }\n    else {\n        if (parent instanceof SVGSVGElement) {\n            return parent;\n        }\n        else {\n            return getSVGSVGAncestor(parent);\n        }\n    }\n}\nexports.getSVGSVGAncestor = getSVGSVGAncestor;\nfunction getSubAttributeFromAncestorsSub(e, subName, output) {\n    const attrs = e.attributes;\n    for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs.item(i);\n        const ps = attr.name.split(\"::\");\n        if (ps.length == 2 && ps[0] == subName) {\n            if (!output.has(ps[1])) {\n                output.set(ps[1], attr.value);\n            }\n        }\n    }\n    if (e.parentElement != null) {\n        getSubAttributeFromAncestorsSub(e.parentElement, subName, output);\n    }\n}\nfunction getSubAttributeFromAncestors(e, subName) {\n    const output = new Map();\n    getSubAttributeFromAncestorsSub(e, subName, output);\n    return output;\n}\nexports.getSubAttributeFromAncestors = getSubAttributeFromAncestors;\nfunction getAttributeFromAncestors(e, attrName) {\n    const attr = e.getAttribute(attrName);\n    if (attr != null) {\n        return attr;\n    }\n    else {\n        if (e.parentElement != null) {\n            return getAttributeFromAncestors(e.parentElement, attrName);\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.getAttributeFromAncestors = getAttributeFromAncestors;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/html_functions.ts?");

/***/ }),

/***/ "./src/html/index.ts":
/*!***************************!*\
  !*** ./src/html/index.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GUI = exports.DraggableObject = exports.GUIObserver = exports.HTMLFunctions = exports.CSS = void 0;\nconst GUIObserver = __webpack_require__(/*! ./gui_observer */ \"./src/html/gui_observer.ts\");\nexports.GUIObserver = GUIObserver;\n//import * as SVG from \"../interface/svg\"\nconst CSS = __webpack_require__(/*! ./css */ \"./src/html/css.ts\");\nexports.CSS = CSS;\nconst HTMLFunctions = __webpack_require__(/*! ./html_functions */ \"./src/html/html_functions.ts\");\nexports.HTMLFunctions = HTMLFunctions;\nconst DraggableObject = __webpack_require__(/*! ./draggable_object */ \"./src/html/draggable_object.ts\");\nexports.DraggableObject = DraggableObject;\nconst GUI = __webpack_require__(/*! ./gui */ \"./src/html/gui.ts\");\nexports.GUI = GUI;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/html/index.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TypeDoc = exports.Interfaces = exports.Debug = exports.Console = exports.Options = exports.Logics = exports.Objects = exports.Common = exports.HTML = void 0;\nconst HTML = __webpack_require__(/*! ./html/index */ \"./src/html/index.ts\");\nexports.HTML = HTML;\nconst Common = __webpack_require__(/*! ./common/index */ \"./src/common/index.ts\");\nexports.Common = Common;\nconst Objects = __webpack_require__(/*! ./objects/index */ \"./src/objects/index.ts\");\nexports.Objects = Objects;\nconst Options = __webpack_require__(/*! ./options/index */ \"./src/options/index.ts\");\nexports.Options = Options;\nconst Logics = __webpack_require__(/*! ./logics/index */ \"./src/logics/index.ts\");\nexports.Logics = Logics;\nconst Console = __webpack_require__(/*! ./options/console */ \"./src/options/console.ts\");\nexports.Console = Console;\nconst Debug = __webpack_require__(/*! ./debug/debug */ \"./src/debug/debug.ts\");\nexports.Debug = Debug;\nconst Interfaces = __webpack_require__(/*! ./interfaces/index */ \"./src/interfaces/index.ts\");\nexports.Interfaces = Interfaces;\nconst TypeDoc = __webpack_require__(/*! ./typedoc/index */ \"./src/typedoc/index.ts\");\nexports.TypeDoc = TypeDoc;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/index.ts?");

/***/ }),

/***/ "./src/interfaces/element_extension.ts":
/*!*********************************************!*\
  !*** ./src/interfaces/element_extension.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.collectAttributesByPrefix = exports.hasStyleAttribute = exports.setIsLoaded = exports.getIsLoaded = exports.gtGetAttributes = exports.setAttributeNumber = exports.gtGetAttribute = exports.gtGetAttributeBooleanWithUndefined = exports.gtGetInheritedAttributeString = exports.gtGetAttributeStringWithUndefined = exports._getAttribute = exports._getAttributeNumber = exports.gtGetAttributeNumberWithUndefined = exports.gtGetAttributeNumberWithoutNull = exports.gtGetAttributeNumber = exports.setPropertyStyleValue2 = exports.setPropertyStyleValue = exports.getActiveStyle = exports.getPropertyStyleNumberValue = exports.getInheritedPropertyStyleValueWithDefault = exports.getPropertyStyleValueWithDefault = exports.gtGetStyleBooleanWithUndefined = exports.getInheritedPropertyStyleValue = exports.getPropertyStyleValue = void 0;\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nfunction getPropertyStyleValue(item, name) {\n    const p = item.style.getPropertyValue(name).trim();\n    if (p.length == 0) {\n        const r = item.getAttribute(\"class\");\n        if (r == null) {\n            return null;\n        }\n        else {\n            const css = getComputedStyle(item);\n            //let css = GraphTableSVG.SVG.getStyleSheet(r);\n            //if (css == null) css = getComputedStyle(item);\n            const p2 = css.getPropertyValue(name).trim();\n            if (p2.length == 0) {\n                return null;\n            }\n            else {\n                return p2;\n            }\n        }\n    }\n    else {\n        return p;\n    }\n}\nexports.getPropertyStyleValue = getPropertyStyleValue;\nfunction getInheritedPropertyStyleValue(item, name) {\n    const p = item.style.getPropertyValue(name).trim();\n    if (p.length == 0) {\n        const r = item.getAttribute(\"class\");\n        const css = getComputedStyle(item);\n        const p2 = css.getPropertyValue(name).trim();\n        if (p2.length == 0) {\n            return null;\n        }\n        else {\n            return p2;\n        }\n    }\n    else {\n        return p;\n    }\n}\nexports.getInheritedPropertyStyleValue = getInheritedPropertyStyleValue;\nfunction gtGetStyleBooleanWithUndefined(item, name) {\n    const value = getPropertyStyleValue(item, name);\n    if (value != null) {\n        return value == \"true\";\n    }\n    else {\n        return undefined;\n    }\n}\nexports.gtGetStyleBooleanWithUndefined = gtGetStyleBooleanWithUndefined;\nfunction getPropertyStyleValueWithDefault(item, name, defaultValue) {\n    const p = getPropertyStyleValue(item, name);\n    if (p == null) {\n        return defaultValue;\n    }\n    else {\n        return p;\n    }\n}\nexports.getPropertyStyleValueWithDefault = getPropertyStyleValueWithDefault;\nfunction getInheritedPropertyStyleValueWithDefault(item, name, defaultValue) {\n    const p = getInheritedPropertyStyleValue(item, name);\n    if (p == null) {\n        return defaultValue;\n    }\n    else {\n        return p;\n    }\n}\nexports.getInheritedPropertyStyleValueWithDefault = getInheritedPropertyStyleValueWithDefault;\nfunction getPropertyStyleNumberValue(item, name, defaultValue) {\n    const p = getPropertyStyleValue(item, name);\n    if (p != null) {\n        return CommonFunctions.toPX(p);\n    }\n    else {\n        return defaultValue;\n    }\n}\nexports.getPropertyStyleNumberValue = getPropertyStyleNumberValue;\nfunction getActiveStyle(item) {\n    //const p: Element = this;\n    const r = item.getAttribute(\"class\");\n    if (r == null) {\n        return item.style;\n    }\n    else {\n        return getComputedStyle(item);\n    }\n}\nexports.getActiveStyle = getActiveStyle;\nfunction setPropertyStyleValue(item, name, value) {\n    item.style.setProperty(name, value);\n}\nexports.setPropertyStyleValue = setPropertyStyleValue;\nfunction setPropertyStyleValue2(item, name, value) {\n    const style = getComputedStyle(item);\n    const oldValue = style.getPropertyValue(name);\n    if (oldValue == value) {\n        return false;\n    }\n    else {\n        item.style.setProperty(name, value);\n        return true;\n    }\n}\nexports.setPropertyStyleValue2 = setPropertyStyleValue2;\nfunction gtGetAttributeNumber(item, name, defaultValue) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return Number(value);\n    }\n    else {\n        return defaultValue;\n    }\n}\nexports.gtGetAttributeNumber = gtGetAttributeNumber;\nfunction gtGetAttributeNumberWithoutNull(item, name, defaultValue) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return Number(value);\n    }\n    else {\n        return defaultValue;\n    }\n}\nexports.gtGetAttributeNumberWithoutNull = gtGetAttributeNumberWithoutNull;\nfunction gtGetAttributeNumberWithUndefined(item, name) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return Number(value);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.gtGetAttributeNumberWithUndefined = gtGetAttributeNumberWithUndefined;\nfunction _getAttributeNumber(item, name, remove) {\n    const value = item.getAttribute(name);\n    if (remove) {\n        item.removeAttribute(name);\n    }\n    if (value != null) {\n        return Number(value);\n    }\n    else {\n        return null;\n    }\n}\nexports._getAttributeNumber = _getAttributeNumber;\nfunction _getAttribute(item, name, remove) {\n    const value = item.getAttribute(name);\n    if (remove) {\n        item.removeAttribute(name);\n    }\n    return value;\n}\nexports._getAttribute = _getAttribute;\nfunction gtGetAttributeStringWithUndefined(item, name) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return value;\n    }\n    else {\n        return undefined;\n    }\n}\nexports.gtGetAttributeStringWithUndefined = gtGetAttributeStringWithUndefined;\nfunction gtGetInheritedAttributeString(item, name) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return value;\n    }\n    else {\n        if (item.parentElement == null) {\n            return undefined;\n        }\n        else {\n            return gtGetInheritedAttributeString(item.parentElement, name);\n        }\n    }\n}\nexports.gtGetInheritedAttributeString = gtGetInheritedAttributeString;\nfunction gtGetAttributeBooleanWithUndefined(item, name) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return value == \"true\";\n    }\n    else {\n        return undefined;\n    }\n}\nexports.gtGetAttributeBooleanWithUndefined = gtGetAttributeBooleanWithUndefined;\nfunction gtGetAttribute(item, name, defaultValue) {\n    const value = item.getAttribute(name);\n    if (value != null) {\n        return value;\n    }\n    else {\n        return defaultValue;\n    }\n}\nexports.gtGetAttribute = gtGetAttribute;\nfunction setAttributeNumber(item, name, value) {\n    item.setAttribute(name, (0, vline_1.round100)(value).toString());\n}\nexports.setAttributeNumber = setAttributeNumber;\nfunction gtGetAttributes(item) {\n    //const p: Element = this;\n    const r = [];\n    for (let i = 0; i < item.attributes.length; i++) {\n        const subitem = item.attributes.item(i);\n        if (subitem != null) {\n            r.push({ name: subitem.name, value: subitem.value });\n        }\n    }\n    return r;\n}\nexports.gtGetAttributes = gtGetAttributes;\nfunction getIsLoaded(item) {\n    const item2 = item;\n    if (item2.__isLoaded === undefined) {\n        return undefined;\n    }\n    else {\n        return item2.__isLoaded;\n    }\n}\nexports.getIsLoaded = getIsLoaded;\nfunction setIsLoaded(item, b) {\n    const item2 = item;\n    item2.__isLoaded = b;\n}\nexports.setIsLoaded = setIsLoaded;\nfunction hasStyleAttribute(item, name) {\n    const p = getPropertyStyleValue(item, name);\n    return p !== null;\n}\nexports.hasStyleAttribute = hasStyleAttribute;\nfunction collectAttributesByPrefix(e, prefix) {\n    const r = new Map();\n    for (let i = 0; i < e.attributes.length; i++) {\n        const attr = e.attributes.item(i);\n        if (attr != null && attr.name.length > prefix.length) {\n            const attrNames = attr.name.split(\":\");\n            if (attrNames.length == 2 && attrNames[0] == prefix) {\n                r.set(attrNames[1], attr.value);\n            }\n        }\n    }\n    return r;\n}\nexports.collectAttributesByPrefix = collectAttributesByPrefix;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/element_extension.ts?");

/***/ }),

/***/ "./src/interfaces/extensions.ts":
/*!**************************************!*\
  !*** ./src/interfaces/extensions.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getPathLocations = exports.setPathLocations = exports.getEmphasis = exports.setEmphasis = exports.setTextContent = exports.tryGetPropertyValue = void 0;\nconst SVGTextBox = __webpack_require__(/*! ./svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nfunction tryGetPropertyValue(item, name) {\n    //const p: CSSStyleDeclaration = this;\n    const r = item.getPropertyValue(name).trim();\n    if (r.length == 0) {\n        return null;\n    }\n    else {\n        return r;\n    }\n}\nexports.tryGetPropertyValue = tryGetPropertyValue;\n/**\n * SVGTextElementのテキストを設定します。\n * @param text 設定するテキスト\n * @param isLatexMode TrueのときLatex表記を使用します。\n */\nfunction setTextContent(item, text, isLatexMode = false) {\n    SVGTextBox.setTextToTextPath(item, text, isLatexMode);\n}\nexports.setTextContent = setTextContent;\n/**\n * SVGLineElementを強調するかどうかを設定します。\n * @param b Trueなら強調。Falseなら強調しません。\n */\nfunction setEmphasis(item, value) {\n    CSS.setGraphTableCSS();\n    if (getEmphasis(item) && !value) {\n        const tmp = item.getAttribute(AttributeNames.cellTemporaryBorderClass);\n        if (tmp != null) {\n            item.setAttribute(\"class\", tmp);\n            item.removeAttribute(AttributeNames.cellTemporaryBorderClass);\n        }\n        else {\n            item.removeAttribute(\"class\");\n            item.removeAttribute(AttributeNames.cellTemporaryBorderClass);\n        }\n    }\n    else if (!getEmphasis(item) && value) {\n        const lineClass = item.getAttribute(\"class\");\n        item.setAttribute(\"class\", AttributeNames.cellTemporaryBorderClass);\n        if (lineClass != null) {\n            item.setAttribute(AttributeNames.cellTemporaryBorderClass, lineClass);\n        }\n    }\n}\nexports.setEmphasis = setEmphasis;\nfunction getEmphasis(item) {\n    const emp = item.getAttribute(\"class\");\n    if (emp != null) {\n        return emp == AttributeNames.cellEmphasisBorderClass;\n    }\n    else {\n        return false;\n    }\n}\nexports.getEmphasis = getEmphasis;\n/**\n * SVGPathElementの位置を設定します。\n * @param points\n */\nfunction setPathLocations(item, points) {\n    let s = \"\";\n    for (let i = 0; i < points.length; i++) {\n        s += `${i == 0 ? \"M\" : \"L\"} ${points[i][0]} ${points[i][1]} `;\n    }\n    //points.forEach((x, y) => s += `M ${x} ${y} `);\n    item.setAttribute(\"d\", s);\n}\nexports.setPathLocations = setPathLocations;\n/**\n * SVGPathElementの位置を取得します。\n */\nfunction getPathLocations(item) {\n    const info = item.getAttribute(\"d\");\n    if (info == null)\n        return [];\n    const r = [];\n    let pos = [0, 0];\n    let pathType = \"\";\n    info.split(\" \").forEach((v, i) => {\n        if (i % 3 == 0) {\n            pathType = v;\n        }\n        else if (i % 3 == 1) {\n            pos[0] = parseInt(v);\n        }\n        else {\n            pos[1] = parseInt(v);\n            r.push(pos);\n            pos = [0, 0];\n        }\n    });\n    return r;\n}\nexports.getPathLocations = getPathLocations;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/extensions.ts?");

/***/ }),

/***/ "./src/interfaces/index.ts":
/*!*********************************!*\
  !*** ./src/interfaces/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SVG = void 0;\nconst SVG = __webpack_require__(/*! ./svg */ \"./src/interfaces/svg.ts\");\nexports.SVG = SVG;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/index.ts?");

/***/ }),

/***/ "./src/interfaces/svg.ts":
/*!*******************************!*\
  !*** ./src/interfaces/svg.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSVGHidden = exports.isSVGSVGHidden = exports.getAbsolutePosition = exports.getLeastContainer = exports.getSVGSVG = exports.getRegion2 = exports.getStyleSheet = exports.setClass = exports.createTextPath2 = exports.createTextPath = exports.createMarker = exports.createCircle = exports.resetStyle = exports.createGroup = exports.createCellRectangle = exports.createRectangle = exports.createText = exports.createLine = exports.getNewID = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\n//import * as CSS from \"./css\";\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGGExtension = __webpack_require__(/*! ./svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\n//export namespace SVG {\nlet idCounter = 0;\nfunction getNewID() {\n    return idCounter++;\n}\nexports.getNewID = getNewID;\n/**\n * SVGLineElementを生成します。\n * @param x 開始位置のX座標\n * @param y 開始位置のY座標\n * @param x2 終了位置のX座標\n * @param y2 終了位置のY座標\n * @param className SVGLineElementのクラス属性名\n * @returns 生成されたSVGLineElement\n */\nfunction createLine(x, y, x2, y2, className) {\n    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n    line1.x1.baseVal.value = x;\n    line1.x2.baseVal.value = x2;\n    line1.y1.baseVal.value = y;\n    line1.y2.baseVal.value = y2;\n    //line1.style.color = \"black\";\n    line1.setAttribute(\"class\", className);\n    /*\n    if (className != null) {\n    } else {\n        line1.style.stroke = \"black\";\n    }\n    */\n    //line1.style.visibility = \"hidden\";\n    //line1.style.strokeWidth = `${5}`\n    //line1.setAttribute('stroke', 'black');\n    return line1;\n}\nexports.createLine = createLine;\n/**\n * SVGTextElementを生成します。\n * @param className 生成するSVG要素のクラス属性名\n * @returns 生成されたSVGTextElement\n */\nfunction createText(className) {\n    const _svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    _svgText.setAttribute(AttributeNames.objectIDName, (idCounter++).toString());\n    //_svgText.style.textAnchor = \"middle\";\n    _svgText.setAttribute(\"class\", className);\n    /*\n    if (className == null) {\n        \n    } else {\n    }\n    */\n    return _svgText;\n}\nexports.createText = createText;\n/**\n * SVGRectElementを生成します。\n * @param parent 生成したSVG要素を子に追加する要素\n * @param className 生成するSVG要素のクラス属性名\n * @returns 生成されたSVGRectElement\n */\nfunction createRectangle(parent, className = null) {\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    parent.appendChild(rect);\n    rect.width.baseVal.value = 30;\n    rect.height.baseVal.value = 30;\n    if (className == null) {\n        rect.style.fill = \"white\";\n        rect.style.stroke = \"black\";\n        rect.style.strokeWidth = \"1pt\";\n    }\n    else {\n        rect.setAttribute(\"class\", className);\n        //const dashStyle = rect.getPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName);\n        //if (dashStyle != null) msoDashStyle.setStyle(rect, dashStyle);\n        const width = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultWidth, null);\n        if (width != null) {\n            rect.width.baseVal.value = width;\n        }\n        const height = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultHeight, null);\n        if (height != null) {\n            rect.height.baseVal.value = height;\n        }\n    }\n    return rect;\n}\nexports.createRectangle = createRectangle;\n/**\n * SVGRectElementを生成します。\n * @param parent 生成したSVG要素を子に追加する要素\n * @param className 生成するSVG要素のクラス属性名\n * @returns 生成されたSVGRectElement\n */\nfunction createCellRectangle(parent, className = null) {\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    rect.width.baseVal.value = 0;\n    parent.appendChild(rect);\n    if (className != null) {\n        rect.setAttribute(\"class\", className);\n    }\n    return rect;\n}\nexports.createCellRectangle = createCellRectangle;\n/**\n * SVGGElementを生成します。\n * @param className 生成するSVG要素のクラス属性名\n * @returns 生成されたSVGGElement\n */\nfunction createGroup(parent) {\n    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    g.setAttribute(AttributeNames.objectIDName, (idCounter++).toString());\n    /*\n    if (className != null) {\n        g.setAttribute(\"class\", className);\n    }\n    */\n    if (parent != null)\n        parent.appendChild(g);\n    return g;\n}\nexports.createGroup = createGroup;\n/**\n * Styleの設定を消去します。\n * @param style 消去するStyle\n */\nfunction resetStyle(style) {\n    style.stroke = null;\n    style.strokeWidth = null;\n    style.fill = null;\n    style.fontSize = null;\n    style.fontWeight = null;\n    style.fontFamily = null;\n    /*\n    style.removeProperty(AttributeNames.Style.paddingTop);\n    style.removeProperty(AttributeNames.Style.paddingLeft);\n    style.removeProperty(AttributeNames.Style.paddingRight);\n    style.removeProperty(AttributeNames.Style.paddingBottom);\n    */\n}\nexports.resetStyle = resetStyle;\n/**\n * SVGCircleElementを生成します。\n * @param parent 生成したSVG要素を子に追加する要素\n * @param className 生成するSVG要素のクラス属性名\n * @returns 生成されたSVGCircleElement\n */\nfunction createCircle(parent, className = null) {\n    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    parent.appendChild(circle);\n    circle.r.baseVal.value = AttributeNames.defaultCircleRadius;\n    if (className == null) {\n        circle.style.stroke = \"black\";\n        circle.style.strokeWidth = \"1pt\";\n        circle.style.fill = \"white\";\n    }\n    else {\n        circle.setAttribute(\"class\", className);\n        const radius = ElementExtension.getPropertyStyleNumberValue(circle, StyleNames.defaultRadius, null);\n        if (radius != null) {\n            circle.r.baseVal.value = radius;\n        }\n        //const dashStyle = circle.getPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName);\n        //if (dashStyle != null) msoDashStyle.setStyle(circle, dashStyle);\n    }\n    //circle.style.fill = \"#ffffff\";\n    circle.cx.baseVal.value = 0;\n    circle.cy.baseVal.value = 0;\n    //circle.r.baseVal.value = r;\n    return circle;\n}\nexports.createCircle = createCircle;\n/**\n * Edgeの矢じりとして使うSVGMarkerElementを作成します。\n * @param className 生成するSVG要素のクラス属性名\n * @returns 生成されたSVGMarkerElement\n */\nfunction createMarker(option = {}) {\n    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');\n    //const poly = <SVGPolygonElement>document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    poly.setAttribute(\"d\", \"M 0 0 L 10 5 L 0 10 z\");\n    //poly.setAttribute(\"points\", \"0,0 0,10 10,5\");\n    if (option.color != undefined) {\n        ElementExtension.setPropertyStyleValue(poly, \"stroke\", option.color);\n        ElementExtension.setPropertyStyleValue(marker, \"fill\", option.color);\n    }\n    else {\n        ElementExtension.setPropertyStyleValue(poly, \"stroke\", \"black\");\n        ElementExtension.setPropertyStyleValue(marker, \"fill\", \"black\");\n    }\n    ElementExtension.setPropertyStyleValue(poly, \"stroke-width\", \"1px\");\n    //poly.setAttribute(\"data-skip\", \"1\");\n    marker.setAttribute(\"markerUnits\", \"userSpaceOnUse\");\n    marker.setAttribute(\"markerHeight\", \"15\");\n    marker.setAttribute(\"markerWidth\", \"15\");\n    marker.setAttribute(\"refX\", \"10\");\n    marker.setAttribute(\"refY\", \"5\");\n    //marker.setAttribute(\"data-skip\", \"1\");\n    //marker.refX.baseVal.value = 10;\n    //marker.refY.baseVal.value = 5;\n    marker.setAttribute(\"preserveAspectRatio\", \"none\");\n    marker.setAttribute(\"orient\", \"auto\");\n    marker.setAttribute(\"viewBox\", \"0 0 10 10\");\n    //marker.setAttribute(\"stroke-width\", \"1px\");\n    marker.appendChild(poly);\n    if (option.className != null) {\n        //marker.setAttribute(\"class\", option.className);\n        //poly.setAttribute(\"class\", className);\n    }\n    else {\n    }\n    return [marker, poly];\n}\nexports.createMarker = createMarker;\n/**\n * SVGTextElementを子に持つSVGTextPathElementを作成します。\n * @param className 生成するSVGTextPathElementのクラス属性名\n * @returns 生成されたSVGTextElementとSVGTextPathElement\n */\nfunction createTextPath(className = null) {\n    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    ;\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');\n    text.appendChild(path);\n    if (className == null) {\n        path.style.fill = \"black\";\n        path.style.fontSize = \"14px\";\n        path.style.fontWeight = \"bold\";\n        path.style.fontFamily = 'Times New Roman';\n    }\n    else {\n        path.setAttribute(\"class\", className);\n    }\n    return [text, path];\n}\nexports.createTextPath = createTextPath;\n/**\n* SVGTextElementを子に持つSVGTextPathElementを作成します。\n* @param className 生成するSVGTextPathElementのクラス属性名\n* @returns 生成されたSVGTextElementとSVGTextPathElement\n*/\nfunction createTextPath2(className) {\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');\n    if (className !== undefined) {\n        path.setAttribute(\"class\", className);\n    }\n    return path;\n}\nexports.createTextPath2 = createTextPath2;\n/**\n * SVG要素にクラス属性をセットします。\n * @param svg 適用されるSVG要素\n * @param className クラス属性名\n */\nfunction setClass(svg, className = null) {\n    if (className == null) {\n        svg.removeAttribute(\"class\");\n    }\n    else {\n        resetStyle(svg.style);\n        svg.setAttribute(\"class\", className);\n    }\n}\nexports.setClass = setClass;\n/**\n * 未使用。\n * @param name\n */\nfunction getStyleSheet(name) {\n    const name2 = \".\" + name;\n    for (let i = 0; i < document.styleSheets.length; i++) {\n        const sheet = document.styleSheets.item(i);\n        const rules = sheet.cssRules || sheet.rules;\n        if (rules != null) {\n            for (let j = 0; j < rules.length; j++) {\n                const rule = rules.item(j);\n                if (rule.selectorText == name2) {\n                    return rule.style;\n                }\n            }\n        }\n    }\n    return null;\n}\nexports.getStyleSheet = getStyleSheet;\nfunction getRegion2(e) {\n    if (e instanceof SVGSVGElement) {\n        const elements = HTMLFunctions.getChildren(e).filter((v) => v instanceof SVGElement);\n        const rectangles = elements.map((v) => getRegion2(v));\n        const parentRect = e.getBoundingClientRect();\n        const rect = vline_1.Rectangle.merge(rectangles);\n        let r = new vline_1.Rectangle();\n        r.x = 0;\n        r.y = 0;\n        r.width = rect.width + (rect.x - parentRect.left);\n        r.height = rect.height + (rect.y - parentRect.top);\n        return r;\n    }\n    else if (e instanceof SVGGElement) {\n        /*\n        const elements = <SVGElement[]>HTMLFunctions.getChildren(e).filter((v) => v instanceof SVGElement);\n        const rectangles = elements.map((v) => getRegion2(v));\n        const region = Rectangle.merge(rectangles);\n                        \n        return region;\n        */\n        const rect = e.getBoundingClientRect();\n        let r = new vline_1.Rectangle(rect.left, rect.top, rect.width, rect.height);\n        return r;\n    }\n    else {\n        const rect = e.getBoundingClientRect();\n        let r = new vline_1.Rectangle(rect.left, rect.top, rect.width, rect.height);\n        return r;\n    }\n}\nexports.getRegion2 = getRegion2;\nfunction getSVGSVG(e) {\n    if (e instanceof SVGSVGElement) {\n        return e;\n    }\n    else {\n        const parent = e.parentElement;\n        if (parent instanceof SVGElement) {\n            return getSVGSVG(parent);\n        }\n        else {\n            throw Error(\"svgsvg\");\n        }\n    }\n}\nexports.getSVGSVG = getSVGSVG;\nfunction getLeastContainer(e) {\n    const parent = e.parentElement;\n    if (parent instanceof SVGSVGElement || parent instanceof SVGGElement) {\n        return parent;\n    }\n    else if (parent == null) {\n        return null;\n    }\n    else {\n        if (parent instanceof SVGElement) {\n            return getLeastContainer(parent);\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.getLeastContainer = getLeastContainer;\nfunction getAbsolutePosition(g) {\n    if (g instanceof SVGSVGElement) {\n        const rect = g.getBoundingClientRect();\n        return { x: rect.left, y: rect.top };\n    }\n    else {\n        const parent = getLeastContainer(g);\n        if (parent instanceof SVGSVGElement) {\n            const rect = parent.getBoundingClientRect();\n            const x = rect.left + SVGGExtension.getX(g);\n            const y = rect.top + SVGGExtension.getY(g);\n            return { x: x, y: y };\n        }\n        else if (parent instanceof SVGGElement) {\n            const rect = getAbsolutePosition(parent);\n            const x = rect.x + SVGGExtension.getX(g);\n            const y = rect.y + SVGGExtension.getY(g);\n            return { x: x, y: y };\n        }\n        else {\n            throw Error(\"error\");\n        }\n    }\n}\nexports.getAbsolutePosition = getAbsolutePosition;\nfunction isSVGSVGHidden(e) {\n    const svgsvg = getSVGSVG(e);\n    return !HTMLFunctions.isShow(svgsvg);\n}\nexports.isSVGSVGHidden = isSVGSVGHidden;\nfunction isSVGHidden(e) {\n    if (e instanceof SVGSVGElement) {\n        return false;\n    }\n    else {\n        const p = getComputedStyle(e);\n        const disp = p.display;\n        const vis = p.visibility;\n        if (disp == \"none\" || vis == \"hidden\") {\n            return true;\n        }\n        else {\n            const parent = e.parentElement;\n            if (parent instanceof SVGElement) {\n                return isSVGHidden(parent);\n            }\n            else {\n                throw Error(\"svg\");\n            }\n        }\n    }\n}\nexports.isSVGHidden = isSVGHidden;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/svg.ts?");

/***/ }),

/***/ "./src/interfaces/svg_element_extension.ts":
/*!*************************************************!*\
  !*** ./src/interfaces/svg_element_extension.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getBackgroundVisible = exports.getStrokeColor = exports.getStrokeWidth = exports.getBackgroundColor = exports.getY = exports.getX = exports.setPaddingBottom = exports.setPaddingRight = exports.setPaddingTop = exports.setPaddingLeft = exports.getPaddingBottom = exports.getPaddingRight = exports.getPaddingTop = exports.getPaddingLeft = void 0;\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./src/interfaces/element_extension.ts\");\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nfunction getPaddingLeft(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingLeft, 0);\n}\nexports.getPaddingLeft = getPaddingLeft;\nfunction getPaddingTop(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingTop, 0);\n}\nexports.getPaddingTop = getPaddingTop;\nfunction getPaddingRight(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingRight, 0);\n}\nexports.getPaddingRight = getPaddingRight;\nfunction getPaddingBottom(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingBottom, 0);\n}\nexports.getPaddingBottom = getPaddingBottom;\nfunction setPaddingLeft(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingLeft, value.toString());\n}\nexports.setPaddingLeft = setPaddingLeft;\nfunction setPaddingTop(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingTop, value.toString());\n}\nexports.setPaddingTop = setPaddingTop;\nfunction setPaddingRight(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingRight, value.toString());\n}\nexports.setPaddingRight = setPaddingRight;\nfunction setPaddingBottom(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingBottom, value.toString());\n}\nexports.setPaddingBottom = setPaddingBottom;\nfunction getX(item) {\n    if (item instanceof SVGElement) {\n        return Number.parseInt(item.getAttribute(\"x\"));\n    }\n    else {\n        throw new exceptions_1.NotSupportedError();\n    }\n}\nexports.getX = getX;\nfunction getY(item) {\n    if (item instanceof SVGElement) {\n        return Number.parseInt(item.getAttribute(\"y\"));\n    }\n    else {\n        throw new exceptions_1.NotSupportedError();\n    }\n}\nexports.getY = getY;\nfunction getBackgroundColor(obj) {\n    const attr = obj.getAttribute(\"fill\");\n    if (attr != null) {\n        return attr;\n    }\n    else {\n        const color = ElementExtension.getPropertyStyleValueWithDefault(obj, \"fill\", \"gray\");\n        return color;\n    }\n}\nexports.getBackgroundColor = getBackgroundColor;\nfunction getStrokeWidth(obj) {\n    const attr = obj.getAttribute(\"stroke-width\");\n    if (attr != null) {\n        return parseInt(attr);\n    }\n    else {\n        const strokeWidth = ElementExtension.getPropertyStyleValue(obj, \"stroke-width\");\n        if (strokeWidth == null) {\n            const css = getComputedStyle(obj);\n            return parseInt(css.strokeWidth);\n        }\n        else {\n            return parseInt(strokeWidth);\n        }\n    }\n}\nexports.getStrokeWidth = getStrokeWidth;\nfunction getStrokeColor(obj) {\n    const attr = obj.getAttribute(\"stroke\");\n    if (attr != null) {\n        return attr;\n    }\n    else {\n        const color = ElementExtension.getPropertyStyleValueWithDefault(obj, \"stroke\", \"NoColor\");\n        if (color == \"NoColor\") {\n            const css = getComputedStyle(obj);\n            return css.stroke;\n        }\n        else {\n            return color;\n        }\n    }\n}\nexports.getStrokeColor = getStrokeColor;\nfunction getBackgroundVisible(obj) {\n    const backGroundvisible = ElementExtension.getPropertyStyleValue(obj, \"visibility\");\n    if (backGroundvisible != null) {\n        return backGroundvisible == \"visible\";\n    }\n    else {\n        const attr = obj.getAttribute(\"fill\");\n        if (attr != null) {\n            return !(attr == \"none\");\n        }\n        else {\n            return true;\n        }\n    }\n}\nexports.getBackgroundVisible = getBackgroundVisible;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/svg_element_extension.ts?");

/***/ }),

/***/ "./src/interfaces/svg_g_extension.ts":
/*!*******************************************!*\
  !*** ./src/interfaces/svg_g_extension.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setY = exports.getY = exports.setX = exports.getX = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\n/**\n * X座標を取得します。\n */\nfunction getX(item) {\n    if (item.transform.baseVal.numberOfItems == 0) {\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\n    }\n    return (0, vline_1.round100)(item.transform.baseVal.getItem(0).matrix.e);\n}\nexports.getX = getX;\n/**\n * X座標を設定します。\n */\nfunction setX(item, value) {\n    if (item.transform.baseVal.numberOfItems == 0) {\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\n    }\n    const a = item.transform.baseVal.getItem(0).matrix.a;\n    const b = item.transform.baseVal.getItem(0).matrix.b;\n    const c = item.transform.baseVal.getItem(0).matrix.c;\n    const d = item.transform.baseVal.getItem(0).matrix.d;\n    const e = value;\n    const f = item.transform.baseVal.getItem(0).matrix.f;\n    item.setAttribute('transform', `matrix(${(0, vline_1.round100)(a)} ${(0, vline_1.round100)(b)} ${(0, vline_1.round100)(c)} ${(0, vline_1.round100)(d)} ${(0, vline_1.round100)(e)} ${(0, vline_1.round100)(f)})`);\n}\nexports.setX = setX;\n/**\n * Y座標を取得します。\n */\nfunction getY(item) {\n    if (item.transform.baseVal.numberOfItems == 0) {\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\n    }\n    return (0, vline_1.round100)(item.transform.baseVal.getItem(0).matrix.f);\n}\nexports.getY = getY;\n/**\n * Y座標を設定します。\n */\nfunction setY(item, value) {\n    if (item.transform.baseVal.numberOfItems == 0) {\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\n    }\n    const a = item.transform.baseVal.getItem(0).matrix.a;\n    const b = item.transform.baseVal.getItem(0).matrix.b;\n    const c = item.transform.baseVal.getItem(0).matrix.c;\n    const d = item.transform.baseVal.getItem(0).matrix.d;\n    const e = item.transform.baseVal.getItem(0).matrix.e;\n    const f = value;\n    item.setAttribute('transform', `matrix(${(0, vline_1.round100)(a)} ${(0, vline_1.round100)(b)} ${(0, vline_1.round100)(c)} ${(0, vline_1.round100)(d)} ${(0, vline_1.round100)(e)} ${(0, vline_1.round100)(f)})`);\n}\nexports.setY = setY;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/svg_g_extension.ts?");

/***/ }),

/***/ "./src/interfaces/svg_text_extension.ts":
/*!**********************************************!*\
  !*** ./src/interfaces/svg_text_extension.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRegion = exports.getSize = exports.getWidth = exports.getHeight = exports.getUpdateFlagOfLocation = exports.updateLocation = exports.updateLocationOrGetUpdateFlag = exports.setMarginBottom = exports.getMarginBottom = exports.setMarginRight = exports.getMarginRight = exports.setMarginTop = exports.getMarginTop = exports.setMarginLeft = exports.getMarginLeft = exports.setTextContent = exports.setY = exports.getY = exports.setX = exports.getX = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\n//import { CommonFunctions } from \"../common/common_functions\";\n//import { HTMLFunctions } from \"./html_functions\";\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst SVGTextBox = __webpack_require__(/*! ./svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\n//import * as AttributeNames from \"../common/attribute_names\"\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./src/interfaces/element_extension.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst virtual_text_1 = __webpack_require__(/*! ./virtual_text */ \"./src/interfaces/virtual_text.ts\");\n/**\n * X座標を取得します。\n */\nfunction getX(item) {\n    if (item.x.baseVal.numberOfItems == 0) {\n        item.setAttribute('x', \"0\");\n    }\n    return item.x.baseVal.getItem(0).value;\n}\nexports.getX = getX;\n/**\n * X座標を設定します。\n */\nfunction setX(item, value) {\n    if (item.x.baseVal.numberOfItems == 0) {\n        item.setAttribute('x', \"0\");\n    }\n    //p.setAttribute('x', value.toString());\n    item.x.baseVal.getItem(0).value = value;\n}\nexports.setX = setX;\n/**\n * Y座標を取得します。\n */\nfunction getY(item) {\n    if (item.y.baseVal.numberOfItems == 0) {\n        item.setAttribute('y', \"0\");\n    }\n    return item.y.baseVal.getItem(0).value;\n}\nexports.getY = getY;\n/**\n * Y座標を設定します。\n */\nfunction setY(item, value) {\n    if (item.y.baseVal.numberOfItems == 0) {\n        item.setAttribute('y', \"0\");\n    }\n    item.y.baseVal.getItem(0).value = value;\n}\nexports.setY = setY;\n/**\n* SVGTextElementのテキストを設定します。\n* @param text 設定するテキスト\n* @param isLatexMode TrueのときLatex表記を使用します。\n*/\nfunction setTextContent(item, text, isLatexMode = false) {\n    SVGTextBox.setTextToSVGText(item, text, isLatexMode);\n}\nexports.setTextContent = setTextContent;\n//setTextContent(text: string): void;\nfunction getMarginLeft(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginLeft, 0);\n}\nexports.getMarginLeft = getMarginLeft;\nfunction setMarginLeft(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginLeft, value.toString());\n}\nexports.setMarginLeft = setMarginLeft;\nfunction getMarginTop(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginTop, 0);\n}\nexports.getMarginTop = getMarginTop;\nfunction setMarginTop(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginTop, value.toString());\n}\nexports.setMarginTop = setMarginTop;\nfunction getMarginRight(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginRight, 0);\n}\nexports.getMarginRight = getMarginRight;\nfunction setMarginRight(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginRight, value.toString());\n}\nexports.setMarginRight = setMarginRight;\nfunction getMarginBottom(item) {\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginBottom, 0);\n}\nexports.getMarginBottom = getMarginBottom;\nfunction setMarginBottom(item, value) {\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginBottom, value.toString());\n}\nexports.setMarginBottom = setMarginBottom;\nfunction updateLocationOrGetUpdateFlag(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText, executeUpdate) {\n    const box = (0, virtual_text_1.getVirtualRegion)(text);\n    let y = rect.y - box.y;\n    let x = rect.x - box.x;\n    if (vAnchor == enums_1.VerticalAnchor.Middle) {\n        y += (rect.height - box.height) / 2;\n    }\n    else if (vAnchor == enums_1.VerticalAnchor.Bottom) {\n        y += rect.height - box.height;\n    }\n    if (hAnchor == enums_1.HorizontalAnchor.Center) {\n        x += (rect.width - box.width) / 2;\n    }\n    else if (hAnchor == enums_1.HorizontalAnchor.Right) {\n        x += rect.width - box.width;\n    }\n    const roundX = (0, vline_1.round100)(x);\n    const roundY = (0, vline_1.round100)(y);\n    const _x = text.getAttribute('x', x.toString());\n    const _y = text.getAttribute('y', y.toString());\n    let b = false;\n    if (_x != roundX) {\n        b = true;\n        if (executeUpdate) {\n            text.setAttribute('x', roundX.toString());\n        }\n    }\n    if (_y != roundY) {\n        b = true;\n        if (executeUpdate) {\n            text.setAttribute('y', roundY.toString());\n        }\n    }\n    return b;\n}\nexports.updateLocationOrGetUpdateFlag = updateLocationOrGetUpdateFlag;\nfunction updateLocation(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText) {\n    return updateLocationOrGetUpdateFlag(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText, true);\n}\nexports.updateLocation = updateLocation;\nfunction getUpdateFlagOfLocation(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText) {\n    return updateLocationOrGetUpdateFlag(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText, false);\n}\nexports.getUpdateFlagOfLocation = getUpdateFlagOfLocation;\nfunction getHeight(text) {\n    const b = HTMLFunctions.isShow(text);\n    if (b) {\n        return text.getBBox().height;\n    }\n    else {\n        throw Error(\"error!\");\n    }\n}\nexports.getHeight = getHeight;\nfunction getWidth(text) {\n    const b = HTMLFunctions.isShow(text);\n    if (b) {\n        return text.getBBox().width;\n    }\n    else {\n        throw Error(\"error!\");\n    }\n    /*\n    if (text instanceof SVGTSpanElement) {\n        const style = getComputedStyle(text);\n        const fontSize = CommonFunctions.toPX(style.fontSize!);\n        const fontFamily = style.fontFamily!;\n\n        return text.getBBox().width;\n        //return superComputeTextWidth(text.textContent!, fontSize, fontFamily, style.fontWeight);\n\n        //return superComputeTextWidth(text.textContent!, fontSize, fontFamily);\n        //return computeTextWidth(text.textContent!, fontSize, fontFamily);\n    } else {\n\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(text).filter((v) => v.nodeName == \"tspan\");\n        let len = 0;\n        tspans.forEach((v) => { len += getVirtualWidth(v) });\n        return len;\n    }\n    */\n}\nexports.getWidth = getWidth;\nfunction getSize(svgText, showChecked = false) {\n    let r = new vline_1.Rectangle();\n    const b = showChecked ? true : HTMLFunctions.isShow(svgText);\n    if (b) {\n        const rect = svgText.getBBox();\n        r.x = rect.x;\n        r.y = rect.y;\n        r.width = rect.width;\n        r.height = rect.height;\n        return r;\n    }\n    else {\n        return new vline_1.Rectangle();\n    }\n}\nexports.getSize = getSize;\n/*\nfunction getLines(text: SVGTextElement | SVGTSpanElement | SVGTextPathElement) : SVGTSpanElement[][] | SVGTextElement | SVGTSpanElement | SVGTextPathElement{\n    if (text instanceof SVGTSpanElement) {\n        return text;\n    } else {\n        const r : SVGTSpanElement[][] = new Array();\n\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(text).filter((v) => v.nodeName == \"tspan\");\n        tspans.forEach((v) =>{\n            \n        })\n        let len = 0;\n        tspans.forEach((v) => { len += getVirtualTextLineLength(v) });\n        return len;\n    }\n}\n*/\nfunction getRegion(svgText) {\n    const b = HTMLFunctions.isShow(svgText);\n    let r = new vline_1.Rectangle();\n    r.x = getX(svgText);\n    r.y = getY(svgText);\n    if (b) {\n        const box = svgText.getBBox();\n        r.width = box.width;\n        r.height = box.height;\n        return r;\n    }\n    else {\n        throw Error(\"error!\");\n    }\n    //const style = getComputedStyle(svgText);\n    //const fontSize = CommonFunctions.toPX(style.fontSize!);\n    /*\n    let r = new Rectangle();\n    r.x = getX(svgText);\n    r.y = getY(svgText);\n    r.width = getVirtualWidth(svgText);\n    r.height = fontSize;\n    */\n    //const rect = svgText.getBBox();\n    /*\n    r.x = rect.x;\n    r.y = rect.y;\n    r.width = rect.width;\n    r.height = rect.height;\n    */\n    return r;\n}\nexports.getRegion = getRegion;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/svg_text_extension.ts?");

/***/ }),

/***/ "./src/interfaces/svg_textbox.ts":
/*!***************************************!*\
  !*** ./src/interfaces/svg_textbox.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getComputedTextLengthsOfTSpans = exports.constructSVGTextByHTMLElements = exports.sortText = exports.setTextToTextPath = exports.setTextToSVGText = exports.getRepresentativeFontSize = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./src/interfaces/element_extension.ts\");\n//import { CSS } from \"./css\";\n//export namespace SVGTextBox {\nfunction getRepresentativeFontSize(text) {\n    if (text instanceof SVGTSpanElement) {\n        const style = getComputedStyle(text);\n        const fontSize = CommonFunctions.toPX(style.fontSize);\n        return fontSize;\n    }\n    else {\n        const tspans = HTMLFunctions.getChildren(text).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n        if (tspans.length > 0) {\n            return getRepresentativeFontSize(tspans[0]);\n        }\n        else {\n            const style = getComputedStyle(text);\n            const fontSize = CommonFunctions.toPX(style.fontSize);\n            return fontSize;\n        }\n    }\n}\nexports.getRepresentativeFontSize = getRepresentativeFontSize;\n/**\n * 入力テキストをLatex表記でパースした結果をSVGTSpanElement配列で返します。\n * @param text Latex表記のテキスト\n * @param className 生成したSVGTSpanElementのクラス属性名\n * @param fontsize 生成したSVGTSpanElementのフォントサイズ\n * @param dxOfFirstElement 生成した最初のSVGTSpanElementのdx\n * @param dyOfFirstElement 生成した最初のSVGTSpanElementのdy\n * @returns 入力テキストをLatex表記でパースした結果をSVGTSpanElement配列\n */\nfunction createTextSpans(text, className = null, fontsize = 12, dxOfFirstElement = null, dyOfFirstElement = null) {\n    let r = [];\n    text += \"_\";\n    //const p: SVGTextElement = this;\n    //p.textContent = \"\";\n    //const h = parseInt(p.getPropertyStyleValueWithDefault(\"font-size\", \"12\"));\n    let isFst = true;\n    let mode = \"\";\n    let tmp = \"\";\n    const char_dy = (1 * fontsize) / 3;\n    let lastMode = \"none\";\n    const smallFontSize = (2 * fontsize) / 3;\n    for (let i = 0; i < text.length; i++) {\n        const c = text[i];\n        if (c == \"_\" || c == \"{\" || c == \"^\" || c == \"}\") {\n            mode += c;\n            if (mode == \"_{}\") {\n                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                tspan.textContent = tmp;\n                tspan.setAttribute(\"dy\", `${char_dy}`);\n                tspan.setAttribute(\"data-script\", \"subscript\");\n                tspan.style.fontSize = `${smallFontSize}pt`;\n                r.push(tspan);\n                lastMode = \"down\";\n                mode = \"\";\n                tmp = \"\";\n            }\n            else if (mode == \"^{}\") {\n                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                tspan.textContent = tmp;\n                tspan.setAttribute(\"dy\", `-${char_dy}`);\n                tspan.style.fontSize = `${smallFontSize}pt`;\n                tspan.setAttribute(\"data-script\", \"superscript\");\n                r.push(tspan);\n                lastMode = \"up\";\n                mode = \"\";\n                tmp = \"\";\n            }\n            else if (mode == \"_\" || mode == \"^\") {\n                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                tspan.textContent = tmp;\n                const normaldy = lastMode == \"up\" ? char_dy : lastMode == \"down\" ? -char_dy : 0;\n                if (isFst) {\n                    if (dxOfFirstElement != null)\n                        tspan.setAttribute(\"dx\", `${dxOfFirstElement}`);\n                    if (dyOfFirstElement != null)\n                        tspan.setAttribute(\"dy\", `${dyOfFirstElement}`);\n                }\n                else {\n                    tspan.setAttribute(\"dy\", `${normaldy}`);\n                }\n                r.push(tspan);\n                lastMode = \"none\";\n                tmp = \"\";\n                isFst = false;\n            }\n        }\n        else {\n            tmp += c;\n        }\n    }\n    return r;\n}\n/*\nexport function getLength(svgText : SVGTextElement) : number{\n    const children = svgText.children;\n    let m = 0;\n    for(let i=0;i<children.length;i++){\n        const child = children.item(i);\n        if(child instanceof SVGTSpanElement){\n            m += child.getComputedTextLength();\n        }\n    }\n    return             svgText.getComputedTextLength            ;\n}\n*/\n/**\n * SVGTextElementにテキストをセットします。\n * @param svgText テキストをセットされるSVG要素\n * @param text SVG要素に適用するテキスト\n * @param isLatexMode Latex表記を使用するかどうか\n */\nfunction setTextToSVGText(svgText, text, isLatexMode) {\n    svgText.textContent = \"\";\n    const fontSize = ElementExtension.getPropertyStyleValueWithDefault(svgText, \"font-size\", \"12\");\n    const fs = parseInt(fontSize);\n    let dx = 0;\n    text.split(\"\\n\").forEach((lineText) => {\n        let dy = fs;\n        let width = 0;\n        if (isLatexMode) {\n            createTextSpans(lineText, null, fs, dx, dy).forEach((v) => {\n                svgText.appendChild(v);\n                const tLen = v.getComputedTextLength();\n                dx = 0;\n                dy = 0;\n                width += tLen;\n            });\n            dy += fs;\n        }\n        else {\n            svgText.appendChild(createSingleTextSpan(lineText, null));\n        }\n        dx = -(0, vline_1.round100)(width);\n    });\n    if (!HTMLFunctions.isShow(svgText)) {\n        throw new Error();\n    }\n}\nexports.setTextToSVGText = setTextToSVGText;\n/**\n* SVGTextPathElementにテキストをセットします。\n* @param path テキストをセットされるパス\n* @param text パスに適用するテキスト\n* @param isLatexMode Latex表記を使用するかどうか\n*/\nfunction setTextToTextPath(path, text, isLatexMode) {\n    path.textContent = \"\";\n    const fontSize = ElementExtension.getPropertyStyleValueWithDefault(path, \"font-size\", \"12\");\n    if (isLatexMode) {\n        createTextSpans(text, null, parseInt(fontSize)).forEach((v) => path.appendChild(v));\n    }\n    else {\n        path.appendChild(createSingleTextSpan(text, null));\n    }\n}\nexports.setTextToTextPath = setTextToTextPath;\n/**\n * 入力テキストからSVGTSpanElementを生成します。\n * @param text SVGTSpanElementのテキスト\n * @param className SVGTSpanElementのクラス属性名\n * @returns 生成されるSVGTSpanElement\n */\nfunction createSingleTextSpan(text, className = null) {\n    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n    tspan.textContent = text;\n    if (className != null) {\n        tspan.setAttribute(\"class\", className);\n    }\n    return tspan;\n}\nfunction copy(e, target) {\n    for (let i = 0; i < e.attributes.length; i++) {\n        const attr = e.attributes.item(i);\n        if (attr != null) {\n            const name = attr.name;\n            const value = attr.value;\n            target.setAttribute(name, value);\n        }\n    }\n}\nfunction getLines(svgText) {\n    const spans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n    let r = [];\n    if (spans.length == 0) {\n        return [];\n    }\n    else {\n        r.push([]);\n        let y = 0;\n        spans.forEach((v, i) => {\n            if (v.getAttribute(\"newline\") == \"true\") {\n                r.push([v]);\n                y++;\n            }\n            else {\n                r[y].push(v);\n            }\n        });\n        return r;\n    }\n}\nfunction alignTextByHorizontalAnchor(svgText, hAnchor) {\n    const lineSpans = getLines(svgText);\n    let dx = 0;\n    if (hAnchor == enums_1.HorizontalAnchor.Center) {\n        const tl = getComputedTextLengthsOfTSpans(svgText, true);\n        let p = 0;\n        let maxWidth = 0;\n        const widths = lineSpans.map((v) => {\n            let width = 0;\n            v.forEach((w) => {\n                width += tl[p++].width;\n            });\n            return width;\n        });\n        p = 0;\n        widths.forEach((v) => {\n            if (v > maxWidth)\n                maxWidth = v;\n        });\n        dx = 0;\n        if (widths.length > 0) {\n            for (let y = 0; y < lineSpans.length; y++) {\n                const offset = (maxWidth - widths[y]) / 2;\n                let width = offset;\n                for (let x = 0; x < lineSpans[y].length; x++) {\n                    const v = lineSpans[y][x];\n                    //const tLen = v.getComputedTextLength();\n                    const tLen = tl[p++].width;\n                    if (x == 0 && y != 0) {\n                        const new_dx = (0, vline_1.round100)(dx + offset);\n                        v.setAttribute(\"dx\", new_dx.toString());\n                    }\n                    width += tLen;\n                }\n                dx = -width;\n            }\n        }\n    }\n    else if (hAnchor == enums_1.HorizontalAnchor.Right) {\n    }\n}\nfunction alignTextAsText(svgText, showChecked) {\n    const lineSpans = getLines(svgText);\n    const fontSize = ElementExtension.getPropertyStyleValueWithDefault(svgText, \"font-size\", \"24\");\n    const fs = parseInt(fontSize);\n    let dx = 0;\n    //let dy = fs;\n    let c = 0;\n    const lengths = getComputedTextLengthsOfTSpans(svgText, showChecked);\n    for (let y = 0; y < lineSpans.length; y++) {\n        let width = 0;\n        let heightMax = fs;\n        let fstObj = null;\n        for (let x = 0; x < lineSpans[y].length; x++) {\n            const v = lineSpans[y][x];\n            //const tLen = v.getComputedTextLength();\n            const size = lengths[c++];\n            if (size.height > heightMax)\n                heightMax = size.height;\n            if (x == 0) {\n                dx = (0, vline_1.round100)(dx);\n                v.setAttribute(\"dx\", dx.toString());\n            }\n            if (x == 0)\n                fstObj = v;\n            width += size.width;\n        }\n        if (y != 0 && fstObj != null)\n            fstObj.setAttribute(\"dy\", heightMax.toString());\n        dx -= width;\n        //dy += fs;\n    }\n}\n/**\n * SVGTextElement\n * @param svgText\n * @param hAnchor\n */\nfunction sortText(svgText, hAnchor, showChecked) {\n    alignTextAsText(svgText, showChecked);\n    alignTextByHorizontalAnchor(svgText, hAnchor);\n}\nexports.sortText = sortText;\nfunction constructSVGTextByHTMLElements(svgText, text, isLatexMode) {\n    svgText.textContent = \"\";\n    const spans = text.map((v, i) => {\n        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n        tspan.innerHTML = v.innerHTML;\n        copy(v, tspan);\n        return tspan;\n    });\n    //let dy = 0;\n    spans.forEach((v, i) => {\n        svgText.appendChild(v);\n    });\n}\nexports.constructSVGTextByHTMLElements = constructSVGTextByHTMLElements;\nlet ura = null;\nfunction getComputedTextLengthsOfTSpans(svgText, showChecked) {\n    const b = showChecked ? true : HTMLFunctions.isShow(svgText);\n    if (b) {\n        const tspans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n        const r = tspans.map((v) => {\n            const w = v.getComputedTextLength();\n            //const h = v.getBoundingClientRect().height;\n            const fontSize = ElementExtension.getPropertyStyleValueWithDefault(v, \"font-size\", \"24\");\n            const fs = CommonFunctions.toPX(fontSize);\n            return new vline_1.Size(w, fs);\n        });\n        return r;\n    }\n    else {\n        const tspans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n        const r = tspans.map((v) => {\n            return new vline_1.Size(0, 0);\n        });\n        return r;\n        //return [];\n        /*\n        if(ura == null){\n            ura = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        }\n        document.body.appendChild(ura);\n        ura.innerHTML = svgText.outerHTML;\n        const fst = ura.firstChild;\n        if(fst instanceof SVGTextElement){\n\n            const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(fst).filter((v)=>v.nodeName==\"tspan\");\n            const r = tspans.map((v)=> {\n                const w = v.getComputedTextLength();\n            const fontSize = svgText.getPropertyStyleValueWithDefault(\"font-size\", \"24\");\n            const fs = CommonFunctions.toPX(fontSize);\n                return new Size(w, fs);\n            })\n            ura.removeChild(fst);\n            ura.remove();\n            return r;\n        }else if(fst != null){\n            ura.removeChild(fst);\n            ura.remove();\n            return [];\n        }else{\n            ura.remove();\n            return [];\n        }\n        */\n    }\n}\nexports.getComputedTextLengthsOfTSpans = getComputedTextLengthsOfTSpans;\n/*\nexport function getComputedTSpanLength(svgText:SVGTSpanElement) : number {\nif(HTMLFunctions.isShow(svgText)){\n    return svgText.getComputedTextLength();\n}else{\n    if(ura == null){\n        ura = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    }\n    document.body.appendChild(ura);\n    ura.innerHTML = svgText.outerHTML;\n    const fst = ura.firstChild;\n    if(fst instanceof SVGTextElement){\n\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(fst).filter((v)=>v.nodeName==\"tspan\");\n        const r = tspans.map((v)=>v.getComputedTextLength());\n        ura.removeChild(fst);\n        ura.remove();\n        return r;\n    }else if(fst != null){\n        ura.removeChild(fst);\n        ura.remove();\n        return [];\n    }else{\n        ura.remove();\n        return [];\n    }\n}\n}\n*/\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/svg_textbox.ts?");

/***/ }),

/***/ "./src/interfaces/virtual_text.ts":
/*!****************************************!*\
  !*** ./src/interfaces/virtual_text.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getVirtualRegion = void 0;\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nfunction createTSpanElement(text) {\n    const tspanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n    tspanElement.textContent = text.textContent;\n    tspanElement.style.fontFamily = text.fontFamily;\n    tspanElement.style.fontSize = text.fontSize;\n    //CommonFunctions.toPX(style.fontSize!);\n    tspanElement.style.fontWeight = text.fontWeight;\n    if (text.dx != null) {\n        tspanElement.setAttribute(\"dx\", text.dx);\n    }\n    if (text.dy != null) {\n        tspanElement.setAttribute(\"dy\", text.dy);\n    }\n    return tspanElement;\n}\nlet baseX = 30;\nlet baseY = 30;\nfunction createTextElement(text) {\n    const svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    text.children.forEach((v) => {\n        svgText.appendChild(createTSpanElement(v));\n    });\n    /*\n    svgText.textContent = text;\n    svgText.style.fontFamily = fontFamily;\n    svgText.style.fontSize = fontSize.toString() + \"px\";\n    svgText.style.fontWeight = fontWeight;\n    */\n    svgText.setAttribute(\"x\", baseX.toString());\n    svgText.setAttribute(\"y\", baseY.toString());\n    return svgText;\n}\nfunction createVirtualTSpan(tspan) {\n    const textContent = tspan.textContent;\n    const style = window.getComputedStyle(tspan);\n    const dx = tspan.getAttribute(\"dx\");\n    const dy = tspan.getAttribute(\"dy\");\n    return { textContent: textContent, fontSize: style.fontSize, fontFamily: style.fontFamily, fontWeight: style.fontWeight, type: \"span\", dx: dx, dy: dy };\n}\nfunction createVirtualText(svgText) {\n    const tpathItems = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName == \"textPath\");\n    let tspans = new Array();\n    if (tpathItems.length == 1) {\n        const tpath = tpathItems[0];\n        tspans = HTMLFunctions.getChildren(tpath).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n    }\n    else {\n        tspans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName.toLowerCase() == \"tspan\");\n    }\n    const r = new Array();\n    tspans.forEach((v) => {\n        r.push(createVirtualTSpan(v));\n    });\n    return { type: \"text\", children: r };\n}\nfunction superComputeRegion(text) {\n    var div = document.createElement('div');\n    var canvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    document.body.appendChild(div);\n    div.appendChild(canvas);\n    canvas.setAttribute(\"width\", \"300px\");\n    canvas.setAttribute(\"height\", \"300px\");\n    canvas.setAttribute(\"viewBox\", \"0 0 300 300\");\n    const obj = text.type == \"text\" ? createTextElement(text) : createTSpanElement(text);\n    //const svgText = createTextElement(obj);\n    canvas.appendChild(obj);\n    const box = obj.getBBox();\n    document.body.removeChild(div);\n    const x = (0, vline_1.round100)(box.x) - (0, vline_1.round100)(baseX);\n    const y = (0, vline_1.round100)(box.y) - (0, vline_1.round100)(baseY);\n    return new vline_1.Rectangle(x, y, (0, vline_1.round100)(box.width), (0, vline_1.round100)(box.height));\n}\nconst CharInfoMap = new Map();\nfunction superComputeTextWidth(text, fontSize, fontFamily, fontWeight) {\n    var div = document.createElement('div');\n    /*\n    div.style.position = 'absolute';\n    div.style.height = 'auto';\n    div.style.width = 'auto';\n    div.style.whiteSpace = 'nowrap';\n    */\n    var canvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    document.body.appendChild(div);\n    div.appendChild(canvas);\n    canvas.setAttribute(\"width\", \"300px\");\n    canvas.setAttribute(\"height\", \"300px\");\n    canvas.setAttribute(\"viewBox\", \"0 0 300 300\");\n    const svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    svgText.textContent = text;\n    svgText.style.fontFamily = fontFamily;\n    svgText.style.fontSize = fontSize.toString() + \"px\";\n    svgText.style.fontWeight = fontWeight;\n    svgText.setAttribute(\"x\", \"30\");\n    svgText.setAttribute(\"y\", \"30\");\n    canvas.appendChild(svgText);\n    /*\n    const b = HTMLFunctions.isShow(svgText);\n\n    if (b) {\n        const rect = svgText.getBBox();\n        return rect.width;\n    } else {\n        return 0;\n    }\n    */\n    const box = svgText.getBBox();\n    document.body.removeChild(div);\n    return box.width;\n    /*\n    div.style.fontFamily = fontFamily;\n    div.style.fontSize = fontSize.toString() + \"px\"; // large enough for good resolution\n\n    div.innerHTML = String.fromCharCode(text);\n    document.body.appendChild(div);\n    var clientWidth = div.clientWidth;\n    CharInfoMap.set(info, clientWidth);\n\n    document.body.removeChild(div);\n    return clientWidth;\n    */\n}\nfunction computeTextWidth(text, fontSize, fontFamily) {\n    if (typeof text == \"string\") {\n        let width = 0;\n        for (let i = 0; i < text.length; i++) {\n            const w = computeTextWidth(text.charCodeAt(i), fontSize, fontFamily);\n            width += w;\n        }\n        return width;\n    }\n    else {\n        const info = { char: text, fontSize: fontSize, fontFamily: fontFamily };\n        if (CharInfoMap.has(info)) {\n            return CharInfoMap.get(info);\n        }\n        else {\n            var div = document.createElement('div');\n            div.style.position = 'absolute';\n            div.style.height = 'auto';\n            div.style.width = 'auto';\n            div.style.whiteSpace = 'nowrap';\n            div.style.fontFamily = fontFamily;\n            div.style.fontSize = fontSize.toString() + \"px\"; // large enough for good resolution\n            div.innerHTML = String.fromCharCode(text);\n            document.body.appendChild(div);\n            var clientWidth = div.clientWidth;\n            CharInfoMap.set(info, clientWidth);\n            document.body.removeChild(div);\n            return clientWidth;\n        }\n    }\n}\n/*\nexport function getVirtualTextLineLength(text: SVGTextElement | SVGTSpanElement | SVGTextPathElement): number {\n\n    if (text instanceof SVGTSpanElement) {\n        const style = getComputedStyle(text);\n        const fontSize = CommonFunctions.toPX(style.fontSize!);\n        const fontFamily = style.fontFamily!;\n        const fontWeight = style.fontWeight!;\n\n        return superComputeTextWidth(text.textContent!, fontSize, fontFamily, fontWeight);\n    } else {\n\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(text).filter((v) => v.nodeName == \"tspan\");\n        let len = 0;\n        tspans.forEach((v) => { len += getVirtualTextLineLength(v) });\n        return len;\n    }\n}\n*/\nfunction getVirtualRegion(text) {\n    if (text instanceof SVGTextElement) {\n        const vtext = createVirtualText(text);\n        const rect = superComputeRegion(vtext);\n        return rect;\n        //return superComputeRegion(vtext);\n    }\n    else {\n        const vtext = createVirtualTSpan(text);\n        const rect = superComputeRegion(vtext);\n        return rect;\n    }\n    /*\n    else{\n        return new Rectangle();\n\n    }\n    */\n    /*\n    if (text instanceof SVGTSpanElement) {\n        const width = getVirtualTextLineLength(text);\n        const style = getComputedStyle(text);\n        const fontSize = CommonFunctions.toPX(style.fontSize!);\n        return new Rectangle(0, 0, width, fontSize);\n\n    } else {\n        const r = new Rectangle();\n        const line = new Rectangle();\n\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(text).filter((v) => v.nodeName == \"tspan\");\n        tspans.forEach((v) =>{\n            const region = getVirtualRegion(v);\n            line.width += region.width;\n            if(line.height > region.height) region.height = line.height;\n            if(v.hasAttribute(\"newline\")){\n                r.height += line.height;\n                if()\n            }\n        })\n        let len = 0;\n        tspans.forEach((v) => { len += getVirtualTextLineLength(v) });\n        return len;\n    }\n    */\n}\nexports.getVirtualRegion = getVirtualRegion;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/interfaces/virtual_text.ts?");

/***/ }),

/***/ "./src/logics/gobject_functions.ts":
/*!*****************************************!*\
  !*** ./src/logics/gobject_functions.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createTextElementFromLogicCell = void 0;\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\nconst logic_text_1 = __webpack_require__(/*! ./logic_text */ \"./src/logics/logic_text.ts\");\nfunction createTextElementFromLogicCell(item, svgText) {\n    if (item.tTexts != null) {\n        SVGTextBox.constructSVGTextByHTMLElements(svgText, item.tTexts, true);\n    }\n    else if (item.text instanceof logic_text_1.LogicText) {\n        if (item.option.textOption.class != undefined) {\n            svgText.setAttribute(\"class\", item.option.textOption.class);\n        }\n        if (item.option.textOption.style != undefined) {\n            svgText.setAttribute(\"style\", item.option.textOption.style);\n        }\n        if (item.option.textOption.id != undefined) {\n            svgText.setAttribute(\"id\", item.option.textOption.id);\n        }\n        item.text.copyToTextElement(svgText);\n    }\n}\nexports.createTextElementFromLogicCell = createTextElementFromLogicCell;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/gobject_functions.ts?");

/***/ }),

/***/ "./src/logics/gobject_reterals.ts":
/*!****************************************!*\
  !*** ./src/logics/gobject_reterals.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toHTML = exports.deepCopy = exports.setSVGReteral = exports.convertAttributesIntoCellOption = exports.convertAttributesIntoAdditionalOption = exports.convertAttributesIntoTableOption = exports.convertAttributesIntoVertexOption = exports.convertAttributesIntoSVGOption = void 0;\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common/index.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\n/*\nexport type _GTableOption = {\n    rowCount?: number,\n    columnCount?: number,\n    rowHeight?: number,\n    columnWidth?: number,\n    //table?: LogicTable\n    \n    columnWidths?: (number | null)[];\n    rowHeights?: (number | null)[];\n    position? : CenterPosition | UpperLeftPosition;\n\n}\n*/\n/*\nfunction getAndRemoveAttribute(item:Element,name: string): string | undefined{\n    const p = ElementExtension.gtGetAttributeStringWithUndefined(item, name);\n    item.removeAttribute(name);\n    return p;\n}\n*/\n/*\nfunction getAndRemoveNumberAttribute(item:Element,name: string): number | undefined{\n    const p = ElementExtension.gtGetAttributeNumberWithUndefined(item, name);\n    item.removeAttribute(name);\n    return p;\n}\n*/\n/*\nfunction getAndRemoveInheritedAttribute(item:Element,name: string): string | undefined{\n    const p = ElementExtension.gtGetInheritedAttributeString(item, name);\n    item.removeAttribute(name);\n    return p;\n}\n*/\nfunction convertAttributesIntoSVGOption(e) {\n    var _a, _b, _c;\n    const output = new Object();\n    output.class = (_a = ElementExtension.gtGetInheritedAttributeString(e, common_1.AttributeNames.className)) !== null && _a !== void 0 ? _a : output.class;\n    output.style = (_b = ElementExtension.gtGetInheritedAttributeString(e, common_1.AttributeNames.style)) !== null && _b !== void 0 ? _b : output.style;\n    output.id = (_c = ElementExtension.gtGetAttributeStringWithUndefined(e, `${common_1.AttributeNames.id}`)) !== null && _c !== void 0 ? _c : output.id;\n    return output;\n}\nexports.convertAttributesIntoSVGOption = convertAttributesIntoSVGOption;\nfunction convertAttributesIntoVertexOption(e) {\n    var _a, _b, _c, _d;\n    const output = convertAttributesIntoSVGOption(e);\n    output.surfaceOption = convertAttributesIntoAdditionalOption(e, \"surface\");\n    output.textOption = convertAttributesIntoAdditionalOption(e, \"text\");\n    output.width = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.width);\n    output.height = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.height);\n    output.cx = (_a = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.cx)) !== null && _a !== void 0 ? _a : output.cx;\n    output.cy = (_b = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.cy)) !== null && _b !== void 0 ? _b : output.cy;\n    output.x = (_c = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.x)) !== null && _c !== void 0 ? _c : output.x;\n    output.y = (_d = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.y)) !== null && _d !== void 0 ? _d : output.y;\n    if (output.cx !== undefined || output.cy !== undefined) {\n        output.positionType = \"center\";\n    }\n    else if (output.x !== undefined || output.y !== undefined) {\n        output.positionType = \"upper-left\";\n    }\n    return output;\n}\nexports.convertAttributesIntoVertexOption = convertAttributesIntoVertexOption;\nfunction convertAttributesIntoTableOption(e) {\n    var _a, _b;\n    const output = convertAttributesIntoVertexOption(e);\n    output.rowHeight = (_a = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.rowHeight)) !== null && _a !== void 0 ? _a : output.rowHeight;\n    output.columnWidth = (_b = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.columnWidth)) !== null && _b !== void 0 ? _b : output.columnWidth;\n    return output;\n}\nexports.convertAttributesIntoTableOption = convertAttributesIntoTableOption;\nfunction convertAttributesIntoAdditionalOption(e, type) {\n    var _a, _b, _c;\n    const output = new Object();\n    output.class = (_a = ElementExtension.gtGetInheritedAttributeString(e, `${type}::${common_1.AttributeNames.className}`)) !== null && _a !== void 0 ? _a : output.class;\n    output.style = (_b = ElementExtension.gtGetInheritedAttributeString(e, `${type}::${common_1.AttributeNames.style}`)) !== null && _b !== void 0 ? _b : output.style;\n    output.id = (_c = ElementExtension.gtGetAttributeStringWithUndefined(e, `${type}::${common_1.AttributeNames.id}`)) !== null && _c !== void 0 ? _c : output.id;\n    return output;\n}\nexports.convertAttributesIntoAdditionalOption = convertAttributesIntoAdditionalOption;\nfunction convertAttributesIntoCellOption(e) {\n    var _a, _b;\n    const output = new Object();\n    output.w = (_a = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.w)) !== null && _a !== void 0 ? _a : output.w;\n    output.h = (_b = ElementExtension.gtGetAttributeNumberWithUndefined(e, common_1.AttributeNames.h)) !== null && _b !== void 0 ? _b : output.h;\n    output.topBorderOption = convertAttributesIntoAdditionalOption(e, \"topborder\");\n    output.leftBorderOption = convertAttributesIntoAdditionalOption(e, \"leftborder\");\n    output.rightBorderOption = convertAttributesIntoAdditionalOption(e, \"rightborder\");\n    output.bottomBorderOption = convertAttributesIntoAdditionalOption(e, \"bottomborder\");\n    output.surfaceOption = convertAttributesIntoAdditionalOption(e, \"surface\");\n    output.textOption = convertAttributesIntoAdditionalOption(e, \"text\");\n    return output;\n}\nexports.convertAttributesIntoCellOption = convertAttributesIntoCellOption;\nfunction setSVGReteral(obj, tag, id, _class, style) {\n    obj.tag = tag;\n    if (id != undefined) {\n        obj.id = id;\n    }\n    if (_class != undefined) {\n        if (typeof _class == \"string\") {\n            obj.class = _class;\n        }\n    }\n    if (style != undefined) {\n        if (typeof style == \"string\") {\n            obj.style = style;\n        }\n    }\n}\nexports.setSVGReteral = setSVGReteral;\nfunction deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.deepCopy = deepCopy;\nfunction toSpecialAttributes(obj, prefixName) {\n    const r = new Array();\n    for (const key in obj) {\n        const value = obj[key];\n        if (typeof value == \"string\" || typeof value == \"number\") {\n            const line = `${prefixName}:${key.toLowerCase()}=\"${value}\"`;\n            r.push(line);\n        }\n        else if (value instanceof Object) {\n            throw new Error(\"Error\");\n        }\n    }\n    return r;\n}\nfunction toHTML(obj, indent) {\n    const r = new Array();\n    const tag = obj[\"tag\"];\n    const replaceDic = new Map();\n    if (tag != undefined) {\n        let fstLine = `<${tag}`;\n        for (const key in obj) {\n            if (key == \"tag\") {\n            }\n            else if (key == \"children\") {\n            }\n            else {\n                const newKey = key.toLowerCase().replace(\"_\", \"-\");\n                const value = obj[key];\n                if (typeof value == \"string\" || typeof value == \"number\") {\n                    fstLine += ` ${newKey}=\"${value}\"`;\n                }\n                else if (typeof value == \"boolean\") {\n                    fstLine += ` ${newKey}=\"${value ? \"true\" : \"false\"}\"`;\n                }\n                else if (value instanceof Object) {\n                    const ind = key.indexOf(\"Option\");\n                    if (ind != -1 && ind == key.length - 6) {\n                        const prefixName = key.substring(0, key.length - 6).toLowerCase();\n                        toSpecialAttributes(value, prefixName).forEach((v) => {\n                            fstLine += ` ${v}`;\n                        });\n                    }\n                    else {\n                    }\n                }\n            }\n        }\n        //r.push(fstLine);\n        const centerLines = new Array();\n        const children = obj[\"children\"];\n        if (Array.isArray(children)) {\n            children.forEach((v) => {\n                const lines = toHTML(v, indent);\n                lines.forEach((w) => {\n                    centerLines.push(indent + w);\n                });\n            });\n        }\n        const lstLine = `</${tag}>`;\n        if (centerLines.length == 0) {\n            fstLine += \"/>\";\n            r.push(`${fstLine}`);\n        }\n        else if (centerLines.length == 1) {\n            fstLine += \">\";\n            r.push(`${fstLine}${centerLines[0].substring(indent.length)}${lstLine}`);\n        }\n        else {\n            fstLine += \">\";\n            r.push(fstLine);\n            centerLines.forEach((v) => {\n                r.push(v);\n            });\n            r.push(lstLine);\n        }\n        //r.push(lstLine);\n    }\n    else {\n        const textContent = obj[\"textContent\"];\n        if (typeof textContent == \"string\") {\n            return [`${textContent}`];\n        }\n        else {\n            return [];\n        }\n    }\n    return r;\n}\nexports.toHTML = toHTML;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/gobject_reterals.ts?");

/***/ }),

/***/ "./src/logics/index.ts":
/*!*****************************!*\
  !*** ./src/logics/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicGroup = exports.Test = exports.buildLogicObjectFromJSON = exports.buildLogicCellLine = exports.buildLogicTable = exports.getIndexArrayTableLine = exports.LogicSVGSVG = exports.LogicBasicShape = exports.LogicTreeNode = exports.LogicTree = exports.LogicGraphNode = exports.LogicGraphEdge = exports.LogicGraph = exports.LogicTable = exports.LogicCell = exports.LogicText = exports.LogicTSpan = void 0;\nconst logic_text_1 = __webpack_require__(/*! ./logic_text */ \"./src/logics/logic_text.ts\");\nObject.defineProperty(exports, \"LogicTSpan\", ({ enumerable: true, get: function () { return logic_text_1.LogicTSpan; } }));\nObject.defineProperty(exports, \"LogicText\", ({ enumerable: true, get: function () { return logic_text_1.LogicText; } }));\nconst logic_cell_1 = __webpack_require__(/*! ./logic_cell */ \"./src/logics/logic_cell.ts\");\nObject.defineProperty(exports, \"LogicCell\", ({ enumerable: true, get: function () { return logic_cell_1.LogicCell; } }));\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./src/logics/logic_table.ts\");\nObject.defineProperty(exports, \"LogicTable\", ({ enumerable: true, get: function () { return logic_table_1.LogicTable; } }));\nconst logic_tree_1 = __webpack_require__(/*! ./logic_tree */ \"./src/logics/logic_tree.ts\");\nObject.defineProperty(exports, \"LogicTree\", ({ enumerable: true, get: function () { return logic_tree_1.LogicTree; } }));\nObject.defineProperty(exports, \"LogicTreeNode\", ({ enumerable: true, get: function () { return logic_tree_1.LogicTreeNode; } }));\nObject.defineProperty(exports, \"LogicBasicShape\", ({ enumerable: true, get: function () { return logic_tree_1.LogicBasicShape; } }));\nObject.defineProperty(exports, \"Test\", ({ enumerable: true, get: function () { return logic_tree_1.Test; } }));\nconst logic_graph_1 = __webpack_require__(/*! ./logic_graph */ \"./src/logics/logic_graph.ts\");\nObject.defineProperty(exports, \"LogicGraph\", ({ enumerable: true, get: function () { return logic_graph_1.LogicGraph; } }));\nObject.defineProperty(exports, \"LogicGraphEdge\", ({ enumerable: true, get: function () { return logic_graph_1.LogicGraphEdge; } }));\nObject.defineProperty(exports, \"LogicGraphNode\", ({ enumerable: true, get: function () { return logic_graph_1.LogicGraphNode; } }));\nconst logic_svgsvg_1 = __webpack_require__(/*! ./logic_svgsvg */ \"./src/logics/logic_svgsvg.ts\");\nObject.defineProperty(exports, \"LogicSVGSVG\", ({ enumerable: true, get: function () { return logic_svgsvg_1.LogicSVGSVG; } }));\nconst logic_group_1 = __webpack_require__(/*! ./logic_group */ \"./src/logics/logic_group.ts\");\nObject.defineProperty(exports, \"LogicGroup\", ({ enumerable: true, get: function () { return logic_group_1.LogicGroup; } }));\nObject.defineProperty(exports, \"buildLogicObjectFromJSON\", ({ enumerable: true, get: function () { return logic_group_1.buildLogicObjectFromJSON; } }));\nconst logic_table_line_1 = __webpack_require__(/*! ./logic_table_line */ \"./src/logics/logic_table_line.ts\");\nObject.defineProperty(exports, \"getIndexArrayTableLine\", ({ enumerable: true, get: function () { return logic_table_line_1.getIndexArrayTableLine; } }));\nObject.defineProperty(exports, \"buildLogicTable\", ({ enumerable: true, get: function () { return logic_table_line_1.buildLogicTable; } }));\nObject.defineProperty(exports, \"buildLogicCellLine\", ({ enumerable: true, get: function () { return logic_table_line_1.buildLogicCellLine; } }));\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/index.ts?");

/***/ }),

/***/ "./src/logics/logic_cell.ts":
/*!**********************************!*\
  !*** ./src/logics/logic_cell.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicCell = void 0;\nconst logic_text_1 = __webpack_require__(/*! ./logic_text */ \"./src/logics/logic_text.ts\");\n/**\n * 表のセルを表す論理クラス\n */\nclass LogicCell {\n    get backgroundOption() {\n        return this.option.surfaceOption;\n    }\n    get topBorderOption() {\n        return this.option.topBorderOption;\n    }\n    get leftBorderOption() {\n        return this.option.leftBorderOption;\n    }\n    get rightBorderOption() {\n        return this.option.rightBorderOption;\n    }\n    get bottomBorderOption() {\n        return this.option.bottomBorderOption;\n    }\n    get connectedColumnCount() {\n        if (this.option.w == undefined) {\n            return 1;\n        }\n        else {\n            return this.option.w;\n        }\n    }\n    get connectedRowCount() {\n        if (this.option.h == undefined) {\n            return 1;\n        }\n        else {\n            return this.option.h;\n        }\n    }\n    //public isLatexMode: boolean = false;\n    constructor() {\n        this.text = new logic_text_1.LogicText();\n        /*\n        public groupOption : GOptions.CellAttributes = { class : defaultCellClass}\n        public backgroundOption: GOptions.backgroundOption = {};\n        public topBorderOption: GOptions.BorderAttributes = {};\n        public leftBorderOption: GOptions.BorderAttributes = {};\n        public rightBorderOption: GOptions.BorderAttributes = {};\n        public bottomBorderOption: GOptions.BorderAttributes = {};\n        public connectedColumnCount: number = 1;\n        public connectedRowCount: number = 1;\n        */\n        this.tTexts = null;\n        this.option = new Object();\n        this.option.topBorderOption = new Object();\n        this.option.leftBorderOption = new Object();\n        this.option.rightBorderOption = new Object();\n        this.option.bottomBorderOption = new Object();\n        this.option.surfaceOption = new Object();\n        this.option.textOption = new Object();\n        //this.option.w = 1;\n        //this.option.h = 1;\n    }\n    buildFromObject(obj) {\n        this.text.buildFromObject(obj[\"text\"]);\n        //this.cellStyle = obj[\"cellStyle\"];\n        /*\n        this.groupOption = obj[\"groupOption\"];\n        this.backgroundOption = obj[\"backgroundOption\"];\n        this.topBorderOption = obj[\"topBorderOption\"];\n        this.leftBorderOption = obj[\"leftBorderOption\"];\n        this.rightBorderOption = obj[\"rightBorderOption\"];\n        this.bottomBorderOption = obj[\"bottomBorderOption\"];\n        this.connectedColumnCount = obj[\"connectedColumnCount\"];\n        this.connectedRowCount = obj[\"connectedRowCount\"];\n        */\n    }\n    copy(cell) {\n        this.text = cell.text;\n        /*\n        this.groupOption = {...cell.groupOption}\n        this.backgroundOption = {...cell.backgroundOption};\n        this.topBorderOption = {...cell.topBorderOption};\n        this.leftBorderOption = {...cell.leftBorderOption};\n        this.rightBorderOption = {...cell.rightBorderOption};\n        this.bottomBorderOption = {...cell.bottomBorderOption};\n        */\n        /*\n        if(cell.topBorderClass !== undefined)this.topBorderClass = cell.topBorderClass;\n        if(cell.leftBorderClass !== undefined)this.leftBorderClass = cell.topBorderClass;\n        if(cell.rightBorderClass !== undefined)this.rightBorderClass = cell.rightBorderClass;\n        if(cell.bottomBorderClass !== undefined){\n            this.bottomBorderClass = cell.bottomBorderClass;\n        }\n        */\n        /*\n         this.connectedRowCount = cell.connectedRowCount;\n         this.connectedColumnCount = cell.connectedColumnCount;\n         */\n        this.item = cell.item;\n    }\n    toReteral() {\n        const p = Object.assign({}, this.option);\n        p.tag = \"cell\";\n        const child = this.text.toReteral();\n        p.children = new Array();\n        p.children.push(child);\n        return p;\n    }\n}\nexports.LogicCell = LogicCell;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_cell.ts?");

/***/ }),

/***/ "./src/logics/logic_graph.ts":
/*!***********************************!*\
  !*** ./src/logics/logic_graph.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicGraph = exports.LogicGraphNode = exports.LogicGraphEdge = void 0;\nclass LogicGraphEdge {\n    constructor() {\n        this.text = null;\n        this.endNodeIndex = -1;\n    }\n}\nexports.LogicGraphEdge = LogicGraphEdge;\nclass LogicGraphNode {\n    constructor() {\n        this.text = null;\n        this.outputEdges = [];\n    }\n    addEdge(e) {\n        this.outputEdges.push(e);\n    }\n}\nexports.LogicGraphNode = LogicGraphNode;\nclass LogicGraph {\n    constructor() {\n        this.nodes = [];\n        this.edges = [];\n        this.option = { relocateStyle: \"standard\", direction: \"down\" };\n        this.className = \"LogicGraph\";\n    }\n    construct(iten) {\n    }\n    addNode() {\n        const node = new LogicGraphNode();\n        this.nodes.push(node);\n        return node;\n    }\n    createEdge() {\n        const edge = new LogicGraphEdge();\n        this.edges.push(edge);\n        return edge;\n    }\n    getIndex(node) {\n        return this.nodes.indexOf(node);\n    }\n}\nexports.LogicGraph = LogicGraph;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_graph.ts?");

/***/ }),

/***/ "./src/logics/logic_group.ts":
/*!***********************************!*\
  !*** ./src/logics/logic_group.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAdditionalLibraryPathList = exports.buildLogicObjectFromJSON = exports.LogicGroup = void 0;\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./src/logics/logic_table.ts\");\nconst logic_tree_1 = __webpack_require__(/*! ./logic_tree */ \"./src/logics/logic_tree.ts\");\nconst logic_graph_1 = __webpack_require__(/*! ./logic_graph */ \"./src/logics/logic_graph.ts\");\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nclass LogicGroup {\n    constructor() {\n        this.items = new Array(0);\n        this.className = \"LogicGroup\";\n        this.itemOrder = \"row\";\n        this.itemInterval = 50;\n    }\n    static build(itmes) {\n        const p = new LogicGroup();\n        itmes.forEach((v) => { p.items.push(v); });\n        return p;\n    }\n    buildFromObject(item) {\n        const temp = item[\"items\"];\n        if (temp !== undefined && temp instanceof Array) {\n            temp.forEach((v, i) => {\n                this.items.push(LogicGroup.buildLogicObjectFromObject(v));\n            });\n        }\n        this.position = item[\"position\"];\n        this.itemOrder = item[\"itemOrder\"];\n        this.itemInterval = item[\"itemInterval\"];\n    }\n    static buildLogicObjectFromObject(obj) {\n        const type = obj[\"className\"];\n        //const type : LogicType = obj[LogicGroup.buildLogicObjectFromObject.toString()];\n        if (type === undefined)\n            throw new exceptions_1.UndefinedError();\n        if (type == \"LogicTree\") {\n            const w = new logic_tree_1.LogicTree();\n            w.buildFromObject(obj);\n            return w;\n        }\n        else if (type == \"LogicTable\") {\n            const w = new logic_table_1.LogicTable();\n            w.buildFromObject(obj);\n            return w;\n        }\n        else if (type == \"LogicGroup\") {\n            const w = new LogicGroup();\n            w.buildFromObject(obj);\n            return w;\n        }\n        else {\n            const w = new logic_graph_1.LogicGraph();\n            //w.buildFromObject(obj);\n            return w;\n        }\n    }\n}\nexports.LogicGroup = LogicGroup;\nfunction buildLogicObjectFromJSON(data) {\n    const obj = JSON.parse(data);\n    return LogicGroup.buildLogicObjectFromObject(obj);\n}\nexports.buildLogicObjectFromJSON = buildLogicObjectFromJSON;\nfunction getAdditionalLibraryPathList(data) {\n    const r = new Set();\n    if (data instanceof LogicGroup) {\n        data.items.forEach((v) => {\n            const sub = getAdditionalLibraryPathList(v);\n            Array.from(sub.values()).forEach((w) => {\n                r.add(w);\n            });\n        });\n    }\n    else if (data instanceof logic_graph_1.LogicGraph) {\n    }\n    else if (data instanceof logic_tree_1.LogicTree) {\n        if (data.option.drawingFunction !== undefined && data.option.drawingFunction.url != null) {\n            r.add(data.option.drawingFunction.url);\n        }\n    }\n    else {\n    }\n    return r;\n}\nexports.getAdditionalLibraryPathList = getAdditionalLibraryPathList;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_group.ts?");

/***/ }),

/***/ "./src/logics/logic_svgsvg.ts":
/*!************************************!*\
  !*** ./src/logics/logic_svgsvg.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicSVGSVG = void 0;\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./src/logics/logic_table.ts\");\nclass LogicSVGSVG {\n    constructor(_option = new Object()) {\n        this.items = new Array(0);\n        this.option = Object.assign({}, _option);\n    }\n    toReteral() {\n        const obj = Object.assign({}, this.option);\n        obj.xmlns = \"http://www.w3.org/2000/svg\";\n        obj.tag = \"svg\";\n        obj.children = new Array();\n        this.items.forEach((v) => {\n            if (v instanceof logic_table_1.LogicTable) {\n                obj.children.push(v.toReteral());\n            }\n        });\n        return obj;\n    }\n    static createDefaultSVGSVG() {\n        const v = new LogicSVGSVG();\n        v.option.style = \"background:#e9e9e9;border:solid 1pt;\";\n        return v;\n    }\n}\nexports.LogicSVGSVG = LogicSVGSVG;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_svgsvg.ts?");

/***/ }),

/***/ "./src/logics/logic_table.ts":
/*!***********************************!*\
  !*** ./src/logics/logic_table.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicTable = void 0;\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst logic_cell_1 = __webpack_require__(/*! ./logic_cell */ \"./src/logics/logic_cell.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst gobject_reterals_1 = __webpack_require__(/*! ./gobject_reterals */ \"./src/logics/gobject_reterals.ts\");\nconst character_1 = __webpack_require__(/*! ../common/character */ \"./src/common/character.ts\");\n//import { Cell } from \"../object/table_helpers/cell\"\n//import * as GOptions from \"../object/x_options\"\n/**\n * 表を表現するクラスです。\n */\nclass LogicTable {\n    get rowCount() {\n        return this.cells.length;\n    }\n    get columnCount() {\n        if (this.cells.length == 0) {\n            return 0;\n        }\n        else {\n            return this.cells[0].length;\n        }\n    }\n    buildFromObject(obj) {\n        /*\n        if(obj[\"position\"] !== undefined){\n            this.position = obj[\"position\"];\n        }\n        this.tableClassName = obj[\"tableClassName\"];\n        */\n        this.option = obj[\"option\"];\n        //this.rowHeights = obj[\"rowHeights\"];\n        //this.columnWidths = obj[\"columnWidths\"];\n        const cells = obj[\"cells\"];\n        const rowCount = cells.length;\n        const columnCount = rowCount == 0 ? 0 : cells[0].length;\n        this.cells = new Array(rowCount);\n        for (let y = 0; y < rowCount; y++) {\n            this.cells[y] = new Array(columnCount);\n            for (let x = 0; x < columnCount; x++) {\n                this.cells[y][x] = new logic_cell_1.LogicCell();\n                this.cells[y][x].buildFromObject(cells[y][x]);\n            }\n        }\n    }\n    constructor(option = { columnCount: 3, rowCount: 3 }) {\n        this.className = \"LogicTable\";\n        //if (option.columnCount == undefined) option.columnCount = 3;\n        //if (option.rowCount == undefined) option.rowCount = 3;\n        this.option = new Object();\n        //this.option.x = 0;\n        //this.option.y = 0;\n        if (option.table_option !== undefined) {\n            this.option = (0, gobject_reterals_1.deepCopy)(option.table_option);\n        }\n        //this.position = option.position;\n        //if(option.tableClassName == undefined) option.tableClassName = null;\n        //this.tableClassName = option.tableClassName == undefined ? null : option.tableClassName;\n        this.cells = new Array(option.rowCount);\n        for (let y = 0; y < option.rowCount; y++) {\n            this.cells[y] = new Array(option.columnCount);\n            for (let x = 0; x < option.columnCount; x++) {\n                this.cells[y][x] = new logic_cell_1.LogicCell();\n            }\n        }\n        /*\n        this.rowHeights = new Array(option.rowCount);\n        for (let y = 0; y < option.rowCount; y++) {\n            this.rowHeights[y] = null;\n        }\n        this.columnWidths = new Array(option.columnCount);\n        for (let x = 0; x < option.columnCount; x++) {\n            this.columnWidths[x] = null;\n        }\n        */\n    }\n    get cellArray() {\n        const r = new Array();\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                r.push(this.cells[y][x]);\n            }\n        }\n        return r;\n    }\n    getColumn(i) {\n        const r = new Array();\n        for (let y = 0; y < this.rowCount; y++) {\n            r.push(this.cells[y][i]);\n        }\n        return r;\n    }\n    getRow(i) {\n        const r = new Array();\n        for (let x = 0; x < this.columnCount; x++) {\n            r.push(this.cells[i][x]);\n        }\n        return r;\n    }\n    /*\n    public checkTable(): boolean {\n\n    }\n    */\n    static parse(str, delimiter) {\n        const lines = str.split(\"\\n\");\n        const r = new Array(lines.length);\n        for (let y = 0; y < lines.length; y++) {\n            const line = lines[y].split(delimiter);\n            r[y] = new Array(line.length);\n            for (let x = 0; x < line.length; x++) {\n                r[y][x] = line[x];\n            }\n            if (y > 0) {\n                if (r[y].length != r[y - 1].length) {\n                    alert(\"Parse Error\");\n                    throw Error(\"Parse Error\");\n                }\n            }\n        }\n        return r;\n    }\n    static create(str, option) {\n        const table = new LogicTable({ columnCount: str[0].length, rowCount: str.length, table_option: option });\n        for (let y = 0; y < str.length; y++) {\n            for (let x = 0; x < str[y].length; x++) {\n                const p = str[y][x].split(\"%%%\");\n                table.cells[y][x].text.textContent = p[0];\n                if (p.length == 3) {\n                    table.cells[y][x].option.w = Number(p[1]);\n                    table.cells[y][x].option.h = Number(p[2]);\n                }\n            }\n        }\n        return table;\n    }\n    /*\n    private static constructHTMLLogicCells(attributeElement: Element, cells: LogicCell[]): void {\n        const backGroundClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement, AttributeNames.backgroundClassName);\n        const backGroundStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement, AttributeNames.backgroundStyle);\n\n        const textClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement, AttributeNames.textClass);\n        const textStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement, AttributeNames.textStyle);\n\n        const topBorderClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.topBorderClassName);\n        const topBorderStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.topBorderStyle);\n\n        const leftBorderClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.leftBorderClassName);\n        const leftBorderStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.leftBorderStyle);\n\n        const rightBorderClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.rightBorderClassName);\n        const rightBorderStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.rightBorderStyle);\n\n        const bottomBorderClassName = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.bottomBorderClassName);\n        const bottomBorderStyle = ElementExtension.gtGetInheritedAttributeString(attributeElement,AttributeNames.bottomBorderStyle);\n\n        cells.forEach((outputCell) => {\n            if (backGroundClassName != null) {\n                outputCell.backgroundOption.class = backGroundClassName;\n            }\n            if (backGroundStyle != null) {\n                outputCell.backgroundOption.style = backGroundStyle;\n            }\n            if (textClassName != null) {\n                outputCell.text.class = textClassName;\n            }\n            if (textStyle != null) {\n                outputCell.text.style = textStyle;\n            }\n            if (topBorderClassName != null) {\n                outputCell.topBorderOption.class = topBorderClassName;\n            }\n            if (topBorderStyle != null) {\n                outputCell.topBorderOption.style = topBorderStyle;\n            }\n\n            if (leftBorderClassName != null) {\n                outputCell.leftBorderOption.class = leftBorderClassName;\n            }\n            if (leftBorderStyle != null) {\n                outputCell.leftBorderOption.style = leftBorderStyle;\n            }\n            if (rightBorderClassName != null) {\n                outputCell.rightBorderOption.class = rightBorderClassName;\n            }\n            if (rightBorderStyle != null) {\n                outputCell.rightBorderOption.style = rightBorderStyle;\n            }\n            if (bottomBorderClassName != null) {\n                outputCell.bottomBorderOption.class = bottomBorderClassName;\n            }\n            if (bottomBorderStyle != null) {\n                outputCell.bottomBorderOption.style = bottomBorderStyle;\n            }\n        })\n\n\n    }\n    */\n    /*\n    public static convertAttributesIntoLogicTableOption(e: Element) : TableOptionReteral{\n            const output : TableOptionReteral = <any> new Object();\n            \n            return output;\n    }\n    */\n    static constructHTMLLogicCell(cellElement, outputCell) {\n        outputCell.option = (0, gobject_reterals_1.convertAttributesIntoCellOption)(cellElement);\n        outputCell.text.textContent = (0, character_1.recoverFromEscapeCharacter)(cellElement.innerHTML);\n        //outputCell.text.class = outputCell.option.\n        const tNodes = HTMLFunctions.getTNodes(cellElement);\n        if (tNodes != null)\n            outputCell.tTexts = tNodes;\n    }\n    static constructHTMLLogicTable(e) {\n        const rows = HTMLFunctions.getChildren(e).filter((v) => v.getAttribute(AttributeNames.customElement) == \"row\").map((v) => v);\n        const widthsStr = ElementExtension.getPropertyStyleValue(e, \"--widths\");\n        if (rows.length == 0)\n            return null;\n        const cells = new Array(rows.length);\n        let columnSize = 0;\n        rows.forEach((v, i) => {\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(AttributeNames.customElement) == \"cell\");\n            cellArray.forEach((v) => v.removeAttribute(AttributeNames.customElement));\n            cells[i] = cellArray;\n            if (columnSize < cellArray.length)\n                columnSize = cellArray.length;\n        });\n        const logicTable = new LogicTable({ columnCount: columnSize, rowCount: rows.length });\n        ;\n        /*\n        if (widthsStr != null) {\n            const widths: (number | null)[] = JSON.parse(widthsStr);\n            widths.forEach((v, i) => logicTable.columnWidths[i] = v);\n        }\n        */\n        for (let y = 0; y < cells.length; y++) {\n            const h = ElementExtension.getPropertyStyleNumberValue(rows[y], \"--height\", null);\n            //logicTable.rowHeights[y] = h;\n            for (let x = 0; x < cells[y].length; x++) {\n                this.constructHTMLLogicCell(cells[y][x], logicTable.cells[y][x]);\n                /*\n                const backGroundClassName = cells[y][x].getAttribute(AttributeNames.backgroundClassName);\n                const backGroundStyle = cells[y][x].getAttribute(AttributeNames.backgroundStyle);\n                const textClassName = cells[y][x].getAttribute(AttributeNames.textClass);\n                const textStyle = cells[y][x].getAttribute(AttributeNames.textStyle);\n\n                if(backGroundClassName != null){\n                    logicTable.cells[y][x].backgroundOption.class = backGroundClassName;\n                }\n                if(backGroundStyle != null){\n                    logicTable.cells[y][x].backgroundOption.style = backGroundStyle;\n                }\n                if(textClassName != null){\n                    logicTable.cells[y][x].text.class = textClassName;\n                }\n                if(textStyle != null){\n                    logicTable.cells[y][x].text.style = textStyle;\n                }\n\n\n                logicTable.cells[y][x].text.textContent = cells[y][x].innerHTML;\n                if (cells[y][x].hasAttribute(\"w\")) {\n                    const w = Number(cells[y][x].getAttribute(\"w\"));\n                    logicTable.cells[y][x].connectedColumnCount = w;\n                }\n                if (cells[y][x].hasAttribute(\"h\")) {\n                    const h = Number(cells[y][x].getAttribute(\"h\"));\n                    logicTable.cells[y][x].connectedRowCount = h;\n                }\n                //const tNodes = openSVGFunctions.getTNodes(cells[y][x]);\n\n                logicTable.cells[y][x].text.textContent = cells[y][x].innerHTML;\n                */\n            }\n        }\n        return logicTable;\n    }\n    toReteral() {\n        const obj = (0, gobject_reterals_1.deepCopy)(this.option);\n        obj.tag = \"g-table\";\n        obj.children = new Array();\n        for (let i = 0; i < this.rowCount; i++) {\n            const row = new Object();\n            row.tag = \"row\";\n            row.children = new Array();\n            this.getRow(i).forEach((v) => {\n                const cell = v.toReteral();\n                row.children.push(cell);\n            });\n            obj.children.push(row);\n        }\n        return obj;\n    }\n    static constructLogicTable(e) {\n        const rows = HTMLFunctions.getChildren(e).filter((v) => v.getAttribute(AttributeNames.customElement) == \"row\").map((v) => v);\n        //const widthsStr = ElementExtension.getPropertyStyleValue(e, \"--widths\");\n        if (rows.length == 0)\n            return null;\n        const cells = new Array(rows.length);\n        let columnSize = 0;\n        rows.forEach((v, i) => {\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(AttributeNames.customElement) == \"cell\");\n            cellArray.forEach((v) => v.removeAttribute(AttributeNames.customElement));\n            cells[i] = cellArray;\n            if (columnSize < cellArray.length)\n                columnSize = cellArray.length;\n        });\n        const logicTable = new LogicTable({ columnCount: columnSize, rowCount: rows.length });\n        logicTable.option = (0, gobject_reterals_1.convertAttributesIntoTableOption)(e);\n        for (let y = 0; y < cells.length; y++) {\n            for (let x = 0; x < cells[y].length; x++) {\n                this.constructHTMLLogicCell(cells[y][x], logicTable.cells[y][x]);\n            }\n        }\n        return logicTable;\n    }\n}\nexports.LogicTable = LogicTable;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_table.ts?");

/***/ }),

/***/ "./src/logics/logic_table_line.ts":
/*!****************************************!*\
  !*** ./src/logics/logic_table_line.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buildLogicTable = exports.buildLogicCellLine = exports.getIndexArrayTableLine = exports.getIndexArray = void 0;\n//import {LogicCell} from \"./logic_cell\"\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./src/logics/logic_table.ts\");\nconst logic_cell_1 = __webpack_require__(/*! ./logic_cell */ \"./src/logics/logic_cell.ts\");\nconst gobject_reterals_1 = __webpack_require__(/*! ./gobject_reterals */ \"./src/logics/gobject_reterals.ts\");\n//export type LogicTableDetailLine = LogicCell[]; \nfunction setCell(cell, value) {\n    if (value instanceof logic_cell_1.LogicCell) {\n        cell.copy(value);\n    }\n    else {\n        cell.text.textContent = value.toString();\n    }\n    //if(cell.groupOption)\n    //cell.groupOption = svgGroupOption;\n}\n/*\nexport type LogicTableLine = { name: string, values: (number | string | LogicCell)[], cellClass?: string | GOptions.ZTextBoxCSS }\nfunction setRow(table: LogicTable, ithRow: number, line: LogicTableLine) {\n    table.cells[ithRow][0].text.textContent = line.name;\n    line.values.forEach((v, i) => {\n        setCell(table.cells[ithRow][i + 1], v, line.cellClass);\n    })\n}\nfunction setColumn(table: LogicTable, ithColumn: number, line: LogicTableLine) {\n    table.cells[0][ithColumn].text.textContent = line.name;\n    line.values.forEach((v, i) => {\n        setCell(table.cells[i + 1][ithColumn], v, line.cellClass);\n    })\n}\nexport function createLogicTable(lines: LogicTableLine[] | LogicTableLine,\n    option?: { isRowLines?: boolean }): LogicTable {\n    if (option == undefined) option = {};\n    if (option.isRowLines == undefined) option.isRowLines = true;\n    //if (option.withIndex == undefined) option.withIndex = false;\n\n    if (lines instanceof Array) {\n\n\n        let maximalLineLength = 0;\n        lines.forEach((v) => {\n            if (maximalLineLength < v.values.length) {\n                maximalLineLength = v.values.length\n            }\n        }\n        )\n        const rowCount = option.isRowLines ? lines.length : maximalLineLength + 1;\n        const columnCount = option.isRowLines ? maximalLineLength + 1 : lines.length;\n        const table: LogicTable = new LogicTable({ rowCount: rowCount, columnCount: columnCount });\n\n        if (option.isRowLines) {\n            lines.forEach((v, i) => {\n                setRow(table, i, v);\n            })\n        } else {\n            lines.forEach((v, i) => {\n                setColumn(table, i, v);\n            })\n\n        }\n        return table;\n    } else {\n        return createLogicTable([lines], option);\n    }\n}\n*/\nfunction getIndexArray(length, zeroBased = true) {\n    return Array.from(Array(length).keys()).map((i) => zeroBased ? i : (i + 1));\n}\nexports.getIndexArray = getIndexArray;\nfunction getIndexArrayTableLine(length, zeroBased = true) {\n    const arr = getIndexArray(length, zeroBased);\n    const name = \"Index\";\n    const r = { name: name, values: arr };\n    return buildLogicCellLine(r.name, r.values);\n}\nexports.getIndexArrayTableLine = getIndexArrayTableLine;\nfunction setRow2(table, ithRow, line) {\n    //table.cells[ithRow][0].text.textContent = line.name;\n    line.forEach((v, i) => {\n        setCell(table.cells[ithRow][i], v);\n    });\n}\nfunction setColumn2(table, ithColumn, line) {\n    line.forEach((v, i) => {\n        setCell(table.cells[i][ithColumn], v);\n    });\n}\n/**\n * 与えられた入力列を表すLogicCellLineを返します。\n * @param name\n * @param values\n * @param svgGroupOption\n * @returns\n */\nfunction buildLogicCellLine(name, values, cellOption = undefined) {\n    const titleCell = new logic_cell_1.LogicCell();\n    titleCell.text.textContent = name;\n    if (cellOption != undefined) {\n        titleCell.option = (0, gobject_reterals_1.deepCopy)(cellOption);\n    }\n    /*\n    if(cellClass !== undefined){\n        titleCell.cellClass = cellClass;\n    }\n    */\n    const cells = values.map((v) => {\n        const cell = new logic_cell_1.LogicCell();\n        cell.text.textContent = v.toString();\n        if (cellOption != undefined) {\n            cell.option = (0, gobject_reterals_1.deepCopy)(cellOption);\n        }\n        return cell;\n    });\n    return [titleCell].concat(cells);\n}\nexports.buildLogicCellLine = buildLogicCellLine;\n/**\n * LogicCellLineの配列を表すLogicTableを構築します。\n * @param lines\n * @param option\n * @returns\n */\nfunction buildLogicTable(lines, option) {\n    if (option == undefined)\n        option = {};\n    if (option.isRowLines == undefined)\n        option.isRowLines = true;\n    //if (option.withIndex == undefined) option.withIndex = false;\n    let maximalLineLength = 0;\n    lines.forEach((v) => {\n        if (maximalLineLength < v.length) {\n            maximalLineLength = v.length;\n        }\n    });\n    const rowCount = option.isRowLines ? lines.length : maximalLineLength;\n    const columnCount = option.isRowLines ? maximalLineLength : lines.length;\n    const table = new logic_table_1.LogicTable({ rowCount: rowCount, columnCount: columnCount });\n    if (option.isRowLines) {\n        lines.forEach((v, i) => {\n            setRow2(table, i, v);\n        });\n    }\n    else {\n        lines.forEach((v, i) => {\n            setColumn2(table, i, v);\n        });\n    }\n    return table;\n}\nexports.buildLogicTable = buildLogicTable;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_table_line.ts?");

/***/ }),

/***/ "./src/logics/logic_text.ts":
/*!**********************************!*\
  !*** ./src/logics/logic_text.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicText = exports.LogicTSpan = void 0;\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst gobject_reterals_1 = __webpack_require__(/*! ./gobject_reterals */ \"./src/logics/gobject_reterals.ts\");\nclass LogicTSpan {\n    constructor() {\n        this.textContent = \"\";\n        this.isLatexMode = false;\n        this.textDecoration = null;\n    }\n    createTSpan() {\n        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n        tspan.textContent = this.textContent;\n        CSS.setCSSClass(tspan, this.class);\n        CSS.setCSSStyle(tspan, this.style);\n        if (this.textDecoration != null) {\n            tspan.setAttribute(\"text-decoration\", this.textDecoration);\n        }\n        return tspan;\n    }\n    parse(obj) {\n        this.textContent = obj[\"textContent\"];\n        this.class = obj[\"class\"];\n        this.style = obj[\"style\"];\n        this.isLatexMode = obj[\"isLatexMode\"];\n        this.textDecoration = obj[\"textDecoration\"];\n    }\n}\nexports.LogicTSpan = LogicTSpan;\n/**\n * 描画されるテキストを表すクラス\n */\nclass LogicText {\n    constructor(_text = null, _class, _style) {\n        this.textContent = \"\";\n        this.isLatexMode = false;\n        this.textDecoration = null;\n        if (_text == null) {\n            this.textContent = \"\";\n        }\n        else {\n            this.textContent = _text;\n        }\n        this.class = _class;\n        this.style = _style;\n    }\n    copyToTextElement(svgText) {\n        CSS.setCSSClass(svgText, this.class);\n        CSS.setCSSStyle(svgText, this.style);\n        if (typeof this.textContent == \"string\") {\n            SVGTextExtension.setTextContent(svgText, this.textContent, this.isLatexMode);\n        }\n        else {\n            svgText.textContent = \"\";\n            this.textContent.map((v) => v.createTSpan()).forEach((v) => {\n                svgText.appendChild(v);\n            });\n        }\n        if (this.textDecoration != null) {\n            svgText.setAttribute(\"text-decoration\", this.textDecoration);\n        }\n    }\n    buildFromObject(obj) {\n        if (Array.isArray(obj[\"textContent\"])) {\n            const arr = obj[\"textContent\"];\n            this.textContent = new Array(arr.length);\n            for (let i = 0; i < arr.length; i++) {\n                this.textContent[i] = new LogicTSpan();\n                this.textContent[i].parse(arr[i]);\n            }\n        }\n        else {\n            this.textContent = obj[\"textContent\"];\n        }\n        this.class = obj[\"class\"];\n        this.style = obj[\"style\"];\n        this.isLatexMode = obj[\"isLatexMode\"];\n        this.textDecoration = obj[\"textDecoration\"];\n    }\n    toReteral() {\n        const obj = new Object();\n        if (typeof this.textContent == \"string\") {\n            obj.textContent = this.textContent;\n        }\n        else {\n            (0, gobject_reterals_1.setSVGReteral)(obj, \"t\", undefined, this.class, this.style);\n        }\n        return obj;\n    }\n}\nexports.LogicText = LogicText;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_text.ts?");

/***/ }),

/***/ "./src/logics/logic_tree.ts":
/*!**********************************!*\
  !*** ./src/logics/logic_tree.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicTree = exports.LogicTreeNode = exports.LogicBasicShape = exports.Test = void 0;\n/*\nexport class BaseLogicTree {\n    public edgeLabel: string | null = null;\n    public nodeText: string | null = null;\n}\n*/\n//import * as Console from \"../../options/console\"\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./src/logics/logic_table.ts\");\n/*\nexport type LogicTreeOption = {\n    x?: number,\n    y?: number,\n    isLatexMode?: boolean\n    relocateStyle?: string\n    direction?: Direction | null;\n}\n*/\nfunction Test(obj) {\n    console.log(obj);\n    console.log(\"test\");\n}\nexports.Test = Test;\nclass LogicBasicShape {\n    get textContent() {\n        if (typeof (this.option.text) == \"string\") {\n            return this.option.text;\n        }\n        else if (this.option.text === undefined) {\n            return \"\";\n        }\n        else {\n            return \"\";\n        }\n    }\n    set textContent(value) {\n        this.option.text = value;\n    }\n    buildFromObject(obj) {\n        this.option = obj[\"option\"];\n        this.shape = obj[\"shape\"];\n        this.item = obj[\"item\"];\n    }\n    constructor(constructorOption = {}) {\n        this.option = {};\n        this.shape = enums_1.ShapeObjectType.Circle;\n        this.className = \"LogicBasicShape\";\n        this.item = null;\n        if (constructorOption.shape !== undefined) {\n            this.shape = constructorOption.shape;\n        }\n        if (constructorOption.option !== undefined) {\n            this.option = constructorOption.option;\n        }\n        if (constructorOption.text !== undefined) {\n            this.textContent = constructorOption.text;\n        }\n    }\n}\nexports.LogicBasicShape = LogicBasicShape;\n/**\n * 木構造を表現するクラスです。\n */\nclass LogicTreeNode {\n    constructor(constructorOption = {}) {\n        this.edgeOption = { class: { pathTextAlignment: enums_1.PathTextAlighnment.regularInterval } };\n        this.children = [];\n        this.shapeObject = new LogicBasicShape();\n        if (constructorOption.vertexShape === enums_1.ShapeObjectType.Table) {\n            this.shapeObject = new logic_table_1.LogicTable();\n        }\n        if (constructorOption.edgeText !== undefined) {\n            this.edgeTextContent = constructorOption.edgeText;\n        }\n        if (constructorOption.vertexText !== undefined) {\n            if (this.shapeObject instanceof logic_table_1.LogicTable) {\n                throw Error(\"You cannot use vertexText if you use LogicTable as the shapeObject property in LogicTreeNode\");\n            }\n            else {\n                this.shapeObject.textContent = constructorOption.vertexText;\n            }\n        }\n    }\n    get edgeTextContent() {\n        if (typeof (this.edgeOption.text) == \"string\") {\n            return this.edgeOption.text;\n        }\n        else if (this.edgeOption.text === undefined) {\n            return \"\";\n        }\n        else {\n            return \"\";\n        }\n    }\n    set edgeTextContent(value) {\n        this.edgeOption.text = value;\n    }\n    buildFromObject(obj) {\n        this.edgeOption = obj[\"edgeOption\"];\n        const className = obj[\"shapeObject\"][\"className\"];\n        if (className == \"LogicTable\") {\n            this.shapeObject = new logic_table_1.LogicTable();\n        }\n        else {\n            this.shapeObject = new LogicBasicShape();\n        }\n        this.shapeObject.buildFromObject(obj[\"shapeObject\"]);\n        const children = obj[\"children\"];\n        this.children = children.map((v) => {\n            if (v == null) {\n                return null;\n            }\n            else {\n                const w = new LogicTreeNode();\n                w.buildFromObject(v);\n                return w;\n            }\n        });\n    }\n    getOrderedNodes(order = enums_1.VertexOrder.Preorder) {\n        const r = [];\n        const edges = this.children;\n        if (order == enums_1.VertexOrder.Preorder) {\n            r.push(this);\n            edges.forEach((v) => {\n                if (v != null) {\n                    v.getOrderedNodes(order).forEach((w) => {\n                        r.push(w);\n                    });\n                }\n            });\n        }\n        else if (order == enums_1.VertexOrder.Postorder) {\n            edges.forEach((v) => {\n                if (v != null) {\n                    v.getOrderedNodes(order).forEach((w) => {\n                        r.push(w);\n                    });\n                }\n            });\n            r.push(this);\n        }\n        return r;\n    }\n}\nexports.LogicTreeNode = LogicTreeNode;\nclass LogicTree {\n    constructor() {\n        this.option = { relocateStyle: \"standard\", direction: \"down\" };\n        this.root = null;\n        this.className = \"LogicTree\";\n    }\n    buildFromObject(obj) {\n        this.option = obj[\"option\"];\n        if (obj[\"root\"] != null) {\n            this.root = new LogicTreeNode();\n            this.root.buildFromObject(obj[\"root\"]);\n        }\n    }\n}\nexports.LogicTree = LogicTree;\n/**\n * 二分木を表現するクラスです。\n */\n/*\nexport class BinaryLogicTree extends LogicTree {\n    public get left(): BinaryLogicTree | null {\n        const left = this.children[0];\n        if (left == null) {\n            return null;\n        } else {\n            return <BinaryLogicTree>left;\n        }\n    }\n    public set left(value: BinaryLogicTree | null) {\n        this.children[0] = value;\n    }\n    public get right(): BinaryLogicTree | null {\n        const right = this.children[1];\n        if (right == null) {\n            return null;\n        } else {\n            return <BinaryLogicTree>right;\n        }\n\n    }\n    public set right(value: BinaryLogicTree | null) {\n        this.children[1] = value;\n    }\n    constructor(public item: any = null, left: BinaryLogicTree | null = null, right: BinaryLogicTree | null = null, vertexOption?: GOptions.ZTextBoxAttributes, edgeOption?: GOptions.GGraphAttributes) {\n        super({ item: item == null ? undefined : item, children: [left, right], vertexOption: vertexOption, edgeOption : edgeOption });\n    }\n}\n*/\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/logics/logic_tree.ts?");

/***/ }),

/***/ "./src/objects/element_builder.ts":
/*!****************************************!*\
  !*** ./src/objects/element_builder.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createSVGText = exports.createPath = void 0;\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\n/**\n     * SVGPathElementを生成します。\n     * @param parent 生成したSVGPathElementを子に追加する要素\n     * @param x 開始位置のX座標\n     * @param y 開始位置のY座標\n     * @param x2 終了位置のX座標\n     * @param y2 終了位置のY座標\n     * @param className SVGPathElementのクラス属性名\n     * @returns 生成されたSVGPathElement\n     */\nfunction createPath(parent, x, y, x2, y2, className, style) {\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    parent.appendChild(path);\n    path.setAttribute(\"d\", (0, vline_1.escapeWithRound100) `M ${x} ${y} L ${x2} ${y2}`);\n    path.setAttribute(AttributeNames.objectIDName, (SVG.getNewID()).toString());\n    GOptions.setClassAndStyle(path, className, style);\n    return path;\n}\nexports.createPath = createPath;\n/**\n* SVGTextElementを生成します。\n* @param className 生成するSVG要素のクラス属性名\n* @returns 生成されたSVGTextElement\n*/\nfunction createSVGText(className, style, dataName) {\n    const _svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    _svgText.setAttribute(AttributeNames.objectIDName, (SVG.getNewID()).toString());\n    if (dataName != null) {\n        _svgText.setAttribute(AttributeNames.dataNameAttribute, dataName);\n    }\n    if (style !== undefined) {\n        _svgText.setAttribute(\"style\", style);\n    }\n    //_svgText.style.textAnchor = \"middle\";\n    if (className === undefined) {\n        _svgText.setAttribute(\"class\", DefaultClassNames.defaultTextClass);\n    }\n    else if (className == null) {\n    }\n    else {\n        _svgText.setAttribute(\"class\", className);\n        //_svgText.className = className;\n    }\n    return _svgText;\n}\nexports.createSVGText = createSVGText;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/element_builder.ts?");

/***/ }),

/***/ "./src/objects/global_gobject_manager.ts":
/*!***********************************************!*\
  !*** ./src/objects/global_gobject_manager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GlobalZObjectManager = exports.LocalZObjectManager = exports.updateSVGSVGTimer = exports.textObserveTimer = void 0;\nconst z_observer_1 = __webpack_require__(/*! ./z_observer */ \"./src/objects/z_observer.ts\");\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\nlet updateSVGSVGTimerCounter = 0;\n/*\nexport function registerGObject(svgsvg: SVGSVGElement, obj: IObject) {\n    if ((<any>svgsvg)._gobjects === undefined) {\n        (<any>svgsvg)._gobjects = new Map<string, Object>();\n\n        setTimeout(updateSVGSVGTimer, timerInterval, svgsvg);\n\n    }\n\n    const map: Map<string, Object> = (<any>svgsvg)._gobjects;\n    if (map instanceof Map) {\n        map.set(obj.objectID, obj);\n\n    }\n}\n*/\nfunction textObserveTimer(manager) {\n    manager.map.forEach((value, key) => {\n        const x = value;\n        const svgText = x.svgText;\n        if (svgText instanceof SVGTextElement) {\n            (0, z_observer_1.updateTextByTimer)(svgText);\n        }\n        const svgPath = x.svgPath;\n        if (svgPath instanceof SVGPathElement) {\n            (0, z_observer_1.updatePathByTimer)(svgPath);\n        }\n    });\n}\nexports.textObserveTimer = textObserveTimer;\nfunction updateSVGSVGTimer(svgsvg) {\n    updateSVGSVGTimerCounter++;\n    const manager = svgsvg._manager;\n    if (manager instanceof LocalZObjectManager) {\n        textObserveTimer(manager);\n        manager.map.forEach((value, key) => {\n            const b = value.stableFlag;\n            if (!b) {\n                const b2 = value.childrenStableFlag;\n                if (b2) {\n                    const b3 = value.updateSurfaceWithoutSVGText();\n                    if (b3) {\n                        debugger_1.Debugger.updateUnstableFlagLog(value, updateSVGSVGTimer, \"false -> true\");\n                        value.svgGroup.setAttribute(z_observer_1.ObjectStableFlagName, \"true\");\n                    }\n                }\n            }\n        });\n    }\n    setTimeout(updateSVGSVGTimer, z_observer_1.timerInterval, svgsvg);\n}\nexports.updateSVGSVGTimer = updateSVGSVGTimer;\nclass LocalZObjectManager {\n    constructor(_svgsvgElement) {\n        this.map = new Map();\n        this.incomingEdgeMapFromVertexID = new Map();\n        this.outgoingEdgeMapFromVertexID = new Map();\n        this.beginVertexMapFromEdgeID = new Map();\n        this.endVertexMapFromEdgeID = new Map();\n        this.svgsvgElement = _svgsvgElement;\n        setTimeout(updateSVGSVGTimer, z_observer_1.timerInterval, this.svgsvgElement);\n    }\n    registerObject(obj) {\n        this.map.set(obj.objectID, obj);\n    }\n    getObject(key) {\n        return this.map.get(key);\n    }\n    dispose() {\n    }\n    removeBeginVertexObjectID(edge, beginVertexID) {\n        const objectID = edge.objectID;\n        const arr = this.outgoingEdgeMapFromVertexID.get(beginVertexID);\n        if (arr != undefined) {\n            for (let i = 0; i < arr.length; i++) {\n                if (arr[i].objectID == objectID) {\n                    arr.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    removeEndVertexObjectID(edge, endVertexID) {\n        const objectID = edge.objectID;\n        const arr = this.incomingEdgeMapFromVertexID.get(endVertexID);\n        if (arr != undefined) {\n            for (let i = 0; i < arr.length; i++) {\n                if (arr[i].objectID == objectID) {\n                    arr.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    addBeginVertexObjectID(edge, beginVertexID) {\n        const objectID = edge.objectID;\n        const arr = this.outgoingEdgeMapFromVertexID.get(beginVertexID);\n        if (arr == null) {\n            this.outgoingEdgeMapFromVertexID.set(beginVertexID, new Array(0));\n            this.addBeginVertexObjectID(edge, beginVertexID);\n        }\n        else {\n            arr.push(edge);\n        }\n    }\n    addEndVertexObjectID(edge, endVertexID) {\n        const objectID = edge.objectID;\n        const arr = this.incomingEdgeMapFromVertexID.get(endVertexID);\n        if (arr == null) {\n            this.incomingEdgeMapFromVertexID.set(endVertexID, new Array(0));\n            this.addEndVertexObjectID(edge, endVertexID);\n        }\n        else {\n            arr.push(edge);\n        }\n    }\n    getBeginVertexID(edge) {\n        const objectID = edge.objectID;\n        const beginVertexID = this.beginVertexMapFromEdgeID.get(objectID);\n        if (beginVertexID == null || beginVertexID == undefined) {\n            return null;\n        }\n        else {\n            return beginVertexID;\n        }\n    }\n    getEndVertexID(edge) {\n        const objectID = edge.objectID;\n        const endVertexID = this.endVertexMapFromEdgeID.get(objectID);\n        if (endVertexID == null || endVertexID == undefined) {\n            return null;\n        }\n        else {\n            return endVertexID;\n        }\n    }\n    registerBeginVertexID(edge, vertexID) {\n        const objectID = edge.objectID;\n        const oldBeginVertexID = this.beginVertexMapFromEdgeID.get(objectID);\n        if (oldBeginVertexID != undefined) {\n            this.removeBeginVertexObjectID(edge, oldBeginVertexID);\n        }\n        if (vertexID != null) {\n            this.addBeginVertexObjectID(edge, vertexID);\n        }\n        this.beginVertexMapFromEdgeID.set(objectID, vertexID);\n    }\n    registerEndVertexID(edge, vertexID) {\n        const objectID = edge.objectID;\n        const oldEndVertexID = this.endVertexMapFromEdgeID.get(objectID);\n        if (oldEndVertexID != undefined) {\n            this.removeEndVertexObjectID(edge, oldEndVertexID);\n        }\n        if (vertexID != null) {\n            this.addEndVertexObjectID(edge, vertexID);\n        }\n        this.endVertexMapFromEdgeID.set(objectID, vertexID);\n    }\n    getIncmoingEdges(obj) {\n        const id = obj.svgGroup.getAttribute(\"id\");\n        if (id == null) {\n            return null;\n        }\n        else {\n            const xb = this.incomingEdgeMapFromVertexID.get(id);\n            if (xb == undefined) {\n                return null;\n            }\n            else {\n                return xb.map((v) => v);\n            }\n        }\n    }\n    getOutgoingEdges(obj) {\n        const id = obj.svgGroup.getAttribute(\"id\");\n        if (id == null) {\n            return null;\n        }\n        else {\n            const xb = this.outgoingEdgeMapFromVertexID.get(id);\n            if (xb == undefined) {\n                return null;\n            }\n            else {\n                return xb.map((v) => v);\n            }\n        }\n    }\n}\nexports.LocalZObjectManager = LocalZObjectManager;\nclass GlobalZObjectManager {\n    //static items : LocalGObjectManager[] = new Array();\n    static getLocalGobjectManager(svgsvg) {\n        const p = svgsvg;\n        if (p._manager != undefined) {\n            return p._manager;\n        }\n        else {\n            return null;\n        }\n    }\n    static tryRegisterSVGSVGElement(svgsvg) {\n        const p = svgsvg;\n        if (p._manager == undefined) {\n            p._manager = new LocalZObjectManager(p);\n            return p._manager;\n        }\n        else {\n            return p._manager;\n        }\n    }\n    static deleteSVGSVGElement(svgsvg) {\n        const p = svgsvg;\n        if (p._manager != undefined) {\n            p._manager.dispose();\n            p._manager = undefined;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n}\nexports.GlobalZObjectManager = GlobalZObjectManager;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/global_gobject_manager.ts?");

/***/ }),

/***/ "./src/objects/graph_helpers/common_functions.ts":
/*!*******************************************************!*\
  !*** ./src/objects/graph_helpers/common_functions.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getGraph = void 0;\nconst z_object_1 = __webpack_require__(/*! ../z_object */ \"./src/objects/z_object.ts\");\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./src/common/attribute_names.ts\");\nfunction getGraph(obj) {\n    const v = obj.svgGroup.parentElement;\n    if (v != null && v instanceof SVGGElement && v.hasAttribute(AttributeNames.objectIDName)) {\n        const id = v.getAttribute(AttributeNames.objectIDName);\n        const obj = z_object_1.ZObject.getObjectFromIDOrObjectID(id);\n        if (obj instanceof z_object_1.ZObject) {\n            return obj;\n        }\n    }\n    return null;\n}\nexports.getGraph = getGraph;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/graph_helpers/common_functions.ts?");

/***/ }),

/***/ "./src/objects/graph_helpers/graph_arrangement.ts":
/*!********************************************************!*\
  !*** ./src/objects/graph_helpers/graph_arrangement.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GraphArrangement = void 0;\nconst SVGTextBox = __webpack_require__(/*! ../../interfaces/svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\nconst z_abstract_text_edge_1 = __webpack_require__(/*! ../z_abstract_text_edge */ \"./src/objects/z_abstract_text_edge.ts\");\nconst virtual_text_1 = __webpack_require__(/*! ../../interfaces/virtual_text */ \"./src/interfaces/virtual_text.ts\");\nconst virtual_tree_constructor_1 = __webpack_require__(/*! ./virtual_tree_constructor */ \"./src/objects/graph_helpers/virtual_tree_constructor.ts\");\nvar GraphArrangement;\n(function (GraphArrangement) {\n    function standardTreeWidthArrangement(graph) {\n        const [xi, yi] = graph.getXYIntervals();\n        const direction = graph.direction == null ? \"down\" : graph.direction;\n        const trees = (0, virtual_tree_constructor_1.createForestInLevelOrder)(graph);\n        let [x, y] = [0, 0];\n        trees.forEach((tree => {\n            standardTreeWidthArrangementSub(tree, xi, yi, direction);\n            tree.setRegionXYLocation(x, y);\n            x += tree.region().width;\n        }));\n    }\n    GraphArrangement.standardTreeWidthArrangement = standardTreeWidthArrangement;\n    function computeChildBInterval(tree, xInterval, yInterval, direction) {\n        const children = tree.virtualTreeChildren;\n        let interval = (direction == \"up\" || direction == \"down\") ? yInterval : xInterval;\n        //let childYInterval = yInterval;\n        children.forEach((v) => {\n            const edge = v.parentEdge;\n            if (edge instanceof z_abstract_text_edge_1.ZAbstractTextEdge) {\n                const path = edge.svgTextPath;\n                const textElement = edge.svgText;\n                if (path.textContent == null || path.textContent.length == 0) {\n                }\n                else if (path.textContent.length == 1) {\n                    const padding = SVGTextBox.getRepresentativeFontSize(path);\n                    const textVRegion = (0, virtual_text_1.getVirtualRegion)(textElement);\n                    const edgeLen = Math.max(textVRegion.width, textVRegion.height) + (padding);\n                    if (edgeLen > interval)\n                        interval = edgeLen;\n                }\n                else {\n                    const padding = SVGTextBox.getRepresentativeFontSize(path);\n                    const textVRegion = (0, virtual_text_1.getVirtualRegion)(textElement);\n                    const edgeLen = Math.max(textVRegion.width, textVRegion.height) + (padding * 4);\n                    //const edgeLen = (SVGTextExtensions.getWidth(path)) + (padding * 4);\n                    if (edgeLen > interval)\n                        interval = edgeLen;\n                }\n            }\n        });\n        return interval;\n    }\n    function preprocessParentWithSingleLeaf(parent, leaf, direction) {\n        if (direction == \"down\" || direction == \"up\") {\n            parent.cx = leaf.cx;\n        }\n        else {\n            parent.cy = leaf.cy;\n        }\n    }\n    function processSingleLeaf(parent, leafSubTree, width, direction) {\n        if (direction == \"down\") {\n            leafSubTree.setRootLocation(parent.cx, width);\n        }\n        else if (direction == \"up\") {\n            leafSubTree.setRootLocation(parent.cx, -width);\n        }\n        else if (direction == \"right\") {\n            leafSubTree.setRootLocation(width, parent.cy);\n        }\n        else {\n            leafSubTree.setRootLocation(-width, parent.cy);\n        }\n    }\n    function processIthChild(children, i, centerA, _a, aInterval, bInterval, childBInterval, direction) {\n        const ithChildrenRect = children[i].region();\n        const ratio = 2;\n        if (direction == \"down\" || direction == \"up\") {\n            const diffX = children[i].root.cx - ithChildrenRect.x;\n            let _x = _a;\n            let _centerX = centerA;\n            if (direction == \"down\") {\n                children[i].setRootLocation(_x + diffX, childBInterval);\n            }\n            else {\n                children[i].setRootLocation(_x + diffX, -childBInterval);\n            }\n            _x += ithChildrenRect.width + aInterval / ratio;\n            if (i < children.length - 1) {\n                _centerX += _x - (aInterval / (2 * ratio));\n            }\n            return [_centerX, _x];\n        }\n        else {\n            const diffY = children[i].root.cy - ithChildrenRect.y;\n            let _y = _a;\n            let _centerY = centerA;\n            if (direction == \"right\") {\n                children[i].setRootLocation(childBInterval, _y + diffY);\n            }\n            else {\n                children[i].setRootLocation(-childBInterval, _y + diffY);\n            }\n            _y += ithChildrenRect.height + bInterval / ratio;\n            if (i < children.length - 1) {\n                _centerY += _y - (bInterval / (2 * ratio));\n            }\n            return [_centerY, _y];\n        }\n    }\n    function processChildren(subtreeRoot, children, centerA, direction) {\n        if (direction == \"down\" || direction == \"up\") {\n            centerA = centerA / (children.length - 1);\n            subtreeRoot.cx = centerA;\n            return centerA;\n        }\n        else {\n            centerA = centerA / (children.length - 1);\n            subtreeRoot.cy = centerA;\n            return centerA;\n        }\n    }\n    function standardTreeWidthArrangementSub(tree, xInterval, yInterval, direction) {\n        tree.subTreeRoot.cx = 0;\n        tree.subTreeRoot.cy = 0;\n        const children = tree.virtualTreeChildren;\n        const childBInterval = computeChildBInterval(tree, xInterval, yInterval, direction);\n        if (children.length == 1) {\n            preprocessParentWithSingleLeaf(tree.subTreeRoot, children[0].root, direction);\n            standardTreeWidthArrangementSub(children[0], xInterval, yInterval, direction);\n            processSingleLeaf(tree.root, children[0], childBInterval, direction);\n        }\n        else if (children.length == 0) {\n        }\n        else {\n            let centerA = 0;\n            let _a = 0;\n            for (let i = 0; i < children.length; i++) {\n                standardTreeWidthArrangementSub(children[i], xInterval, yInterval, direction);\n                [centerA, _a] = processIthChild(children, i, centerA, _a, xInterval, yInterval, childBInterval, direction);\n            }\n            centerA = processChildren(tree.subTreeRoot, children, centerA, direction);\n            //= centerA / (children.length - 1);\n            //tree.subTreeRoot.cx = centerA;\n        }\n    }\n})(GraphArrangement || (exports.GraphArrangement = GraphArrangement = {}));\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/graph_helpers/graph_arrangement.ts?");

/***/ }),

/***/ "./src/objects/graph_helpers/virtual_tree.ts":
/*!***************************************************!*\
  !*** ./src/objects/graph_helpers/virtual_tree.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n//namespace GraphTableSVG {\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VirtualTree = void 0;\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./src/common/vline.ts\");\nclass VirtualTree {\n    constructor(_root, _externalEdgeDic) {\n        this.subTreeRoot = _root;\n        if (_externalEdgeDic !== undefined) {\n            this.externalEdges = _externalEdgeDic;\n        }\n        else {\n            this.externalEdges = new Set();\n        }\n    }\n    get root() {\n        return this.subTreeRoot;\n    }\n    /**\n     * 根の子ノードの配列を返します。\n     */\n    get children() {\n        //const p = this;\n        return this.subTreeRoot.outgoingEdges.filter((v) => !this.externalEdges.has(v) && v.endVertex != null).map((v) => v.endVertex);\n        /*\n        return this.subTreeRoot.children.map(function (x, i, arr) {\n            return x;\n        });\n        */\n    }\n    get virtualTreeChildren() {\n        return this.children.map((v) => v.createVirtualTree(this.externalEdges));\n        //const child = this.children[nth];\n        //return child.createVirtualTree(this.externalEdges);\n    }\n    /**\n     * 根の親との間の辺を返します。\n     */\n    get parentEdge() {\n        const p = this.subTreeRoot.incomingEdges.filter((v) => !this.externalEdges.has(v) && v.beginVertex != null);\n        if (p.length != 0) {\n            return p[0];\n        }\n        else {\n            return null;\n        }\n        //return this.subTreeRoot.parentEdge;\n    }\n    /**\n     * この木の中の全てのVertexを返します。\n     * @param result\n     */\n    getSubtree(result = []) {\n        result.push(this.subTreeRoot);\n        const children = this.virtualTreeChildren;\n        if (children.length == 0) {\n            return result;\n        }\n        else {\n            children.forEach(function (x, i, arr) {\n                x.getSubtree(result);\n            });\n            return result;\n        }\n    }\n    /*\n    public getLeaves(): Vertex[] {\n        const p = this;\n        return this.getSubtree().filter(function (x, i, arr) {\n            return x.outcomingEdges.length == 0;\n        });\n    }\n    */\n    getHeight() {\n        const children = this.virtualTreeChildren;\n        if (children.length == 0) {\n            return 1;\n        }\n        else {\n            let max = 0;\n            children.forEach(function (x, i, arr) {\n                if (max < x.getHeight())\n                    max = x.getHeight();\n            });\n            return max + 1;\n        }\n    }\n    /**\n     * この木を内包する最小の四角形を返します。\n     */\n    region() {\n        const p = this.getSubtree();\n        let minX = this.subTreeRoot.x;\n        let maxX = this.subTreeRoot.x;\n        let minY = this.subTreeRoot.y;\n        let maxY = this.subTreeRoot.y;\n        p.forEach(function (x, i, arr) {\n            const rect = x.region;\n            if (minX > rect.x)\n                minX = rect.x;\n            if (maxX < rect.right)\n                maxX = rect.right;\n            if (minY > rect.y)\n                minY = rect.y;\n            if (maxY < rect.bottom)\n                maxY = rect.bottom;\n        });\n        const result = new vline_1.Rectangle();\n        result.x = minX;\n        result.y = minY;\n        result.width = maxX - minX;\n        result.height = maxY - minY;\n        return result;\n    }\n    /**\n     * 一番左の葉を返します。\n     */\n    get mostLeftLeave() {\n        return this.leaves[0];\n    }\n    addOffset(_x, _y) {\n        this.getSubtree().forEach(function (x, i, arr) {\n            x.cx += _x;\n            x.cy += _y;\n        });\n    }\n    setRectangleLocation(_x, _y) {\n        const x = this.mostLeftLeave.region.x;\n        const y = this.subTreeRoot.region.y;\n        const diffX = _x - x;\n        const diffY = _y - y;\n        this.addOffset(diffX, diffY);\n        //this.graph.updateEdges();\n    }\n    /**\n     * 根を入力位置に移動させます。木も同様に移動します。\n     * @param _x\n     * @param _y\n     */\n    setRootLocation(_x, _y) {\n        const x = this.subTreeRoot.cx;\n        const y = this.subTreeRoot.cy;\n        const diffX = _x - x;\n        const diffY = _y - y;\n        this.addOffset(diffX, diffY);\n        //this.graph.updateEdges();\n    }\n    setRegionXYLocation(_x, _y) {\n        const region = this.region();\n        const newX = _x - region.x;\n        const newY = _y - region.y;\n        this.addOffset(newX, newY);\n        //this.graph.updateEdges();\n    }\n    /**\n     * 葉の配列を返します。\n     */\n    get leaves() {\n        //const p = this;\n        return this.getSubtree().filter((x) => {\n            const r = x.outgoingEdges.filter((v) => !this.externalEdges.has(v) && v.endVertex != null).length;\n            return r == 0;\n        });\n        //return this.getSubtree().filter(function (x, i, arr) {\n        //\n        //    return x.outcomingEdges.length == 0;\n        //});\n    }\n}\nexports.VirtualTree = VirtualTree;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/graph_helpers/virtual_tree.ts?");

/***/ }),

/***/ "./src/objects/graph_helpers/virtual_tree_constructor.ts":
/*!***************************************************************!*\
  !*** ./src/objects/graph_helpers/virtual_tree_constructor.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createForestInLevelOrder = void 0;\nfunction createForestInLevelOrder(graph) {\n    const roots = graph.roots.length == 0 ? [graph.vertices[0]] : graph.roots;\n    const externalEdges = createExternalEdgeDicInLevelOrder(graph);\n    return roots.map((v) => v.createVirtualTree(externalEdges));\n}\nexports.createForestInLevelOrder = createForestInLevelOrder;\nfunction createExternalEdgeDicInLevelOrder(graph) {\n    const externalEdges = new Set();\n    const touchedVertexes = new Set();\n    const inputEdges = new Array(0);\n    if (graph.vertices.length > 0) {\n        const roots = graph.roots.length == 0 ? [graph.vertices[0]] : graph.roots;\n        roots.forEach((v => {\n            touchedVertexes.add(v);\n            v.outgoingEdges.forEach((w) => inputEdges.push(w));\n        }));\n        createExternalEdgeDicInLevelOrderSub(inputEdges, externalEdges, touchedVertexes, 0);\n    }\n    return externalEdges;\n}\nfunction createExternalEdgeDicInLevelOrderSub(inputEdges, externalEdges, touchedVertexes, level) {\n    //const edges = inputEdges.filter((v) => v.endVertex != null);\n    const nextEdges = new Array(0);\n    inputEdges.forEach((v) => {\n        if (v.endVertex != null) {\n            const node = v.endVertex;\n            if (!touchedVertexes.has(node)) {\n                touchedVertexes.add(node);\n                node.outgoingEdges.forEach((w) => nextEdges.push(w));\n            }\n            else {\n                externalEdges.add(v);\n            }\n        }\n    });\n    if (nextEdges.length > 0) {\n        createExternalEdgeDicInLevelOrderSub(nextEdges, externalEdges, touchedVertexes, level + 1);\n    }\n}\nfunction createExternalEdgeDicInPreorder(node, incomingEdge, externalEdges, touchedVertexes) {\n    if (incomingEdge == null) {\n        node.outgoingEdges.forEach((v) => {\n            const child = v.endVertex;\n            if (child != null) {\n                createExternalEdgeDicInPreorder(child, v, externalEdges, touchedVertexes);\n            }\n        });\n    }\n    else {\n        if (!touchedVertexes.has(node)) {\n            touchedVertexes.add(node);\n            node.outgoingEdges.forEach((v) => {\n                const child = v.endVertex;\n                if (child != null) {\n                    createExternalEdgeDicInPreorder(child, v, externalEdges, touchedVertexes);\n                }\n            });\n        }\n        else {\n            if (incomingEdge != null) {\n                externalEdges.add(incomingEdge);\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/graph_helpers/virtual_tree_constructor.ts?");

/***/ }),

/***/ "./src/objects/index.ts":
/*!******************************!*\
  !*** ./src/objects/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * あああああああああああああ\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZForeignObject = exports.GraphArrangement = exports.VirtualTree = exports.GOptions = exports.ZPathTextBox = exports.ZVertex = exports.ZTextBox = exports.ZTable = exports.ZRect = exports.ZRectButton = exports.ZGraph = exports.ZEllipse = exports.ZEdge = exports.ZCircle = exports.ZCallout = exports.ZArrowCallout = exports.ZObject = void 0;\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nObject.defineProperty(exports, \"ZObject\", ({ enumerable: true, get: function () { return z_object_1.ZObject; } }));\nconst z_arrow_callout_1 = __webpack_require__(/*! ./z_arrow_callout */ \"./src/objects/z_arrow_callout.ts\");\nObject.defineProperty(exports, \"ZArrowCallout\", ({ enumerable: true, get: function () { return z_arrow_callout_1.ZArrowCallout; } }));\nconst z_callout_1 = __webpack_require__(/*! ./z_callout */ \"./src/objects/z_callout.ts\");\nObject.defineProperty(exports, \"ZCallout\", ({ enumerable: true, get: function () { return z_callout_1.ZCallout; } }));\nconst z_circle_1 = __webpack_require__(/*! ./z_circle */ \"./src/objects/z_circle.ts\");\nObject.defineProperty(exports, \"ZCircle\", ({ enumerable: true, get: function () { return z_circle_1.ZCircle; } }));\nconst z_edge_1 = __webpack_require__(/*! ./z_edge */ \"./src/objects/z_edge.ts\");\nObject.defineProperty(exports, \"ZEdge\", ({ enumerable: true, get: function () { return z_edge_1.ZEdge; } }));\nconst z_ellipse_1 = __webpack_require__(/*! ./z_ellipse */ \"./src/objects/z_ellipse.ts\");\nObject.defineProperty(exports, \"ZEllipse\", ({ enumerable: true, get: function () { return z_ellipse_1.ZEllipse; } }));\nconst z_graph_1 = __webpack_require__(/*! ./z_graph */ \"./src/objects/z_graph.ts\");\nObject.defineProperty(exports, \"ZGraph\", ({ enumerable: true, get: function () { return z_graph_1.ZGraph; } }));\nconst z_rect_button_1 = __webpack_require__(/*! ./z_rect_button */ \"./src/objects/z_rect_button.ts\");\nObject.defineProperty(exports, \"ZRectButton\", ({ enumerable: true, get: function () { return z_rect_button_1.ZRectButton; } }));\nconst z_rect_1 = __webpack_require__(/*! ./z_rect */ \"./src/objects/z_rect.ts\");\nObject.defineProperty(exports, \"ZRect\", ({ enumerable: true, get: function () { return z_rect_1.ZRect; } }));\nconst z_table_1 = __webpack_require__(/*! ./z_table */ \"./src/objects/z_table.ts\");\nObject.defineProperty(exports, \"ZTable\", ({ enumerable: true, get: function () { return z_table_1.ZTable; } }));\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\nObject.defineProperty(exports, \"ZTextBox\", ({ enumerable: true, get: function () { return z_textbox_1.ZTextBox; } }));\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nObject.defineProperty(exports, \"ZVertex\", ({ enumerable: true, get: function () { return z_vertex_1.ZVertex; } }));\nconst z_foreign_object_1 = __webpack_require__(/*! ./z_foreign_object */ \"./src/objects/z_foreign_object.ts\");\nObject.defineProperty(exports, \"ZForeignObject\", ({ enumerable: true, get: function () { return z_foreign_object_1.ZForeignObject; } }));\nconst virtual_tree_1 = __webpack_require__(/*! ./graph_helpers/virtual_tree */ \"./src/objects/graph_helpers/virtual_tree.ts\");\nObject.defineProperty(exports, \"VirtualTree\", ({ enumerable: true, get: function () { return virtual_tree_1.VirtualTree; } }));\nconst graph_arrangement_1 = __webpack_require__(/*! ./graph_helpers/graph_arrangement */ \"./src/objects/graph_helpers/graph_arrangement.ts\");\nObject.defineProperty(exports, \"GraphArrangement\", ({ enumerable: true, get: function () { return graph_arrangement_1.GraphArrangement; } }));\n//import * as TreeArrangement from \"./graph_helpers/tree_arrangement\"\nconst z_path_textbox_1 = __webpack_require__(/*! ./z_path_textbox */ \"./src/objects/z_path_textbox.ts\");\nObject.defineProperty(exports, \"ZPathTextBox\", ({ enumerable: true, get: function () { return z_path_textbox_1.ZPathTextBox; } }));\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nexports.GOptions = GOptions;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/index.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/border_column.ts":
/*!****************************************************!*\
  !*** ./src/objects/table_helpers/border_column.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BorderColumn = void 0;\n//namespace GraphTableSVG {\nconst cell_1 = __webpack_require__(/*! ./cell */ \"./src/objects/table_helpers/cell.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./src/interfaces/svg.ts\");\nclass BorderColumn {\n    /**\n    列の単位セルのY座標を返します。\n    */\n    get borderX() {\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\n    }\n    set borderX(v) {\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\n    }\n    get svgGroup() {\n        return this._svgGroup;\n    }\n    constructor(_table, _x, rowSize, borderClass) {\n        this._borders = new Array(0);\n        this.table = _table;\n        this._svgGroup = SVG.createGroup(this.table.svgColumnBorderGroup);\n        this._svgGroup.setAttribute(\"name\", \"border_column\");\n        this.borderX = _x;\n        for (let y = 0; y < rowSize; y++) {\n            this.insertBorder(y, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\n        }\n    }\n    get borders() {\n        return this._borders;\n    }\n    insertBorder(rowi, borderClass) {\n        const line = SVG.createLine(0, 0, 0, 0, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\n        this._svgGroup.appendChild(line);\n        this._borders.splice(rowi, 0, line);\n    }\n    removeBorder(i) {\n        this._borders[i].remove();\n        this._borders.splice(i, 1);\n    }\n    remove() {\n        this.svgGroup.remove();\n    }\n}\nexports.BorderColumn = BorderColumn;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/border_column.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/border_row.ts":
/*!*************************************************!*\
  !*** ./src/objects/table_helpers/border_row.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BorderRow = void 0;\n//namespace GraphTableSVG {\nconst cell_1 = __webpack_require__(/*! ./cell */ \"./src/objects/table_helpers/cell.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./src/interfaces/svg.ts\");\n/**\n * 表の行を表現するクラスです。\n */\nclass BorderRow {\n    get svgGroup() {\n        return this._svgGroup;\n    }\n    /**\n    列の単位セルのY座標を返します。\n    */\n    get borderY() {\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\n    }\n    set borderY(v) {\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\n    }\n    constructor(_table, _y, columnSize, borderClass) {\n        this._borders = new Array(0);\n        this.table = _table;\n        this._svgGroup = SVG.createGroup(this.table.svgRowBorderGroup);\n        this._svgGroup.setAttribute(\"name\", \"border_row\");\n        this.borderY = _y;\n        for (let x = 0; x < columnSize; x++) {\n            this.insertBorder(x, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\n        }\n    }\n    get borders() {\n        return this._borders;\n    }\n    insertBorder(coromni, borderClass) {\n        const line = SVG.createLine(0, 0, 0, 0, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\n        this._svgGroup.appendChild(line);\n        this._borders.splice(coromni, 0, line);\n    }\n    removeBorder(i) {\n        this._borders[i].remove();\n        this._borders.splice(i, 1);\n    }\n    remove() {\n        this.svgGroup.remove();\n    }\n}\nexports.BorderRow = BorderRow;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/border_row.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/cell.ts":
/*!*******************************************!*\
  !*** ./src/objects/table_helpers/cell.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n//namespace GraphTableSVG {\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Cell = exports.DirectionType2 = void 0;\nconst CommonFunctions = __webpack_require__(/*! ../../common/common_functions */ \"./src/common/common_functions.ts\");\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./src/common/vline.ts\");\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../../common/style_names */ \"./src/common/style_names.ts\");\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./src/interfaces/svg.ts\");\n//import {CellOption} from \"../../options/attributes_option\"\nconst enums_1 = __webpack_require__(/*! ../../common/enums */ \"./src/common/enums.ts\");\nconst ElementExtension = __webpack_require__(/*! ../../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGGExtension = __webpack_require__(/*! ../../interfaces/svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\nconst SVGElementExtension = __webpack_require__(/*! ../../interfaces/svg_element_extension */ \"./src/interfaces/svg_element_extension.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst virtual_text_1 = __webpack_require__(/*! ../../interfaces/virtual_text */ \"./src/interfaces/virtual_text.ts\");\nconst debugger_1 = __webpack_require__(/*! ../../common/debugger */ \"./src/common/debugger.ts\");\nconst column_1 = __webpack_require__(/*! ./column */ \"./src/objects/table_helpers/column.ts\");\nconst row_1 = __webpack_require__(/*! ./row */ \"./src/objects/table_helpers/row.ts\");\nconst GObserver = __webpack_require__(/*! ../z_observer */ \"./src/objects/z_observer.ts\");\nconst html_functions_1 = __webpack_require__(/*! ../../html/html_functions */ \"./src/html/html_functions.ts\");\nconst global_gobject_manager_1 = __webpack_require__(/*! ../global_gobject_manager */ \"./src/objects/global_gobject_manager.ts\");\n//{\n//    top = 0, left = 1, right = 2, bottom = 3\n//}\nvar DirectionType2;\n(function (DirectionType2) {\n    DirectionType2[DirectionType2[\"topLeft\"] = 0] = \"topLeft\";\n    DirectionType2[DirectionType2[\"bottomLeft\"] = 1] = \"bottomLeft\";\n    DirectionType2[DirectionType2[\"bottomRight\"] = 2] = \"bottomRight\";\n    DirectionType2[DirectionType2[\"topRight\"] = 3] = \"topRight\";\n})(DirectionType2 || (exports.DirectionType2 = DirectionType2 = {}));\nlet uniqueCellID = 0;\n/**\n * セルをSVGで表現するためのクラスです。\n */\nclass Cell {\n    constructor(parent, _px, _py, cellMap, option = {}) {\n        this.__currentClass = null;\n        this.tmpStyle = null;\n        this._observerFunc = (x) => {\n            for (let i = 0; i < x.length; i++) {\n                const p = x[i];\n                if (p.attributeName == \"style\" || p.attributeName == \"class\") {\n                    if (p.attributeName == \"class\") {\n                        const className = this.svgGroup.getAttribute(\"class\");\n                        if (className != this.__currentClass) {\n                            this.recomputeDefaultProperties();\n                            this.__currentClass = className;\n                        }\n                    }\n                    this.locateSVGText();\n                }\n            }\n        };\n        // #endregion\n        this._assurancevisibility = false;\n        this._svgGroup = SVG.createGroup(null);\n        this._table = parent;\n        this.table.rows[_py].svgGroup.appendChild(this.svgGroup);\n        //this.table.svgGroup.insertBefore(this.svgGroup, this.table.svgGroup.firstChild);\n        this.svgGroup.setAttribute(\"class\", option.cellClass !== undefined ? option.cellClass : DefaultClassNames.defaultCellClass);\n        this.svgGroup.setAttribute(AttributeNames.GroupAttribute, \"cell\");\n        this.svgGroup.setAttribute(Cell.cellXName, `${_px}`);\n        this.svgGroup.setAttribute(Cell.cellYName, `${_py}`);\n        this.setMasterDiffX(0);\n        this.setMasterDiffY(0);\n        const backGroundClass = DefaultClassNames.defaultCellBackgroungClass;\n        this._svgSurface = SVG.createCellRectangle(this.svgGroup, backGroundClass);\n        this._svgSurface.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Surface);\n        const textClass = DefaultClassNames.defaultTextClass;\n        this._svgText = SVG.createText(textClass);\n        this._svgText.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Text);\n        this.svgGroup.appendChild(this.svgText);\n        cellMap.set(this.objectID, this);\n        this.stableFlag = false;\n        //const borderClass = option.borderClass === undefined ? null : option.borderClass;\n        //const option1: MutationObserverInit = { childList: true, subtree: true };\n        //this.table.cellTextObserver.observe(this.svgText, option1);\n        //this.unstableCounter = GObserver.unstableCounterDefault;\n        this._observer = new MutationObserver(this._observerFunc);\n        const option2 = { attributes: true };\n        this._observer.observe(this.svgGroup, option2);\n        const svgsvgAncestor = (0, html_functions_1.getSVGSVGAncestor)(this.svgGroup);\n        if (svgsvgAncestor != null) {\n            const xb = global_gobject_manager_1.GlobalZObjectManager.tryRegisterSVGSVGElement(svgsvgAncestor);\n            xb.registerObject(this);\n        }\n    }\n    updateSurfaceWithoutSVGText() {\n        if (this.childrenStableFlag) {\n            this.tryUpdateWithUpdateFlag(true);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    get stableFlag() {\n        return this.svgGroup.getAttribute(GObserver.ObjectStableFlagName) == \"true\";\n    }\n    set stableFlag(b) {\n        this.svgGroup.setAttribute(GObserver.ObjectStableFlagName, b ? \"true\" : \"false\");\n    }\n    get childrenStableFlag() {\n        const b = this.svgText.getAttribute(GObserver.ObjectStableFlagName);\n        return b == \"true\";\n    }\n    get objectID() {\n        return this.svgGroup.getAttribute(AttributeNames.objectIDName);\n    }\n    getBorderPosition(borderType, positionType) {\n        let border = this.svgTopBorder;\n        switch (borderType) {\n            case \"top\":\n                border = this.svgTopBorder;\n                break;\n            case \"left\":\n                border = this.svgLeftBorder;\n                break;\n            case \"right\":\n                border = this.svgRightBorder;\n                break;\n            case \"bottom\":\n                border = this.svgBottomBorder;\n                break;\n        }\n        switch (positionType) {\n            case \"x1\":\n                return (0, vline_1.round100)(border.x1.baseVal.value);\n            case \"x2\":\n                return (0, vline_1.round100)(border.x2.baseVal.value);\n            case \"y1\":\n                return (0, vline_1.round100)(border.y1.baseVal.value);\n            case \"y2\":\n                return (0, vline_1.round100)(border.y2.baseVal.value);\n        }\n        throw new Error(\"Error\");\n    }\n    // #region style\n    recomputeDefaultProperties() {\n        /*\n        if(this.defaultBackgroundClass != null){\n            this._svgBackground.setAttribute(\"class\", this.defaultBackgroundClass);\n        }\n        if(this.defaultTextClass != null){\n            this._svgText.setAttribute(\"class\", this.defaultTextClass);\n        }\n        */\n    }\n    /*\n    public get class() : string | null{\n        return this.svgGroup.getAttribute(\"class\");\n    }\n    public set class(value : string | null){\n        if(value == null){\n            this.svgGroup.removeAttribute(\"class\");\n        }else{\n            this.svgGroup.setAttribute(\"class\", value);\n        }\n    }\n    */\n    /**\n     * このセルが強調してるかどうかを返します。\n     */\n    get isEmphasized() {\n        const cellClass = this.svgSurface.getAttribute(\"class\");\n        return cellClass == AttributeNames.cellEmphasisCellClass;\n    }\n    set isEmphasized(v) {\n        if (v) {\n            if (!this.isEmphasized) {\n                this.tmpStyle = this.svgSurface.getAttribute(\"class\");\n                this.svgSurface.setAttribute(\"class\", AttributeNames.cellEmphasisCellClass);\n            }\n        }\n        else {\n            if (this.isEmphasized) {\n                if (this.tmpStyle == null) {\n                    this.svgSurface.removeAttribute(\"class\");\n                }\n                else {\n                    this.svgSurface.setAttribute(\"class\", this.tmpStyle);\n                    this.tmpStyle = null;\n                }\n            }\n        }\n    }\n    /**\n     * テキストのフォントサイズを返します。\n     */\n    get fontSize() {\n        const p = ElementExtension.getPropertyStyleValueWithDefault(this.svgText, \"font-size\", \"24\");\n        const p2 = parseInt(p);\n        return p2;\n    }\n    get primitivePaddingLeft() {\n        return 3;\n    }\n    get primitivePaddingRight() {\n        return 3;\n    }\n    /**\n    テキストとセル間の左のパディング値を返します。\n    */\n    get paddingLeft() {\n        return SVGElementExtension.getPaddingLeft(this.svgGroup);\n    }\n    /**\n    テキストとセル間の右のパディング値を返します。\n    */\n    get paddingRight() {\n        return SVGElementExtension.getPaddingRight(this.svgGroup);\n    }\n    /**\n    テキストとセル間の上のパディング値を返します。\n    */\n    get paddingTop() {\n        return SVGElementExtension.getPaddingTop(this.svgGroup);\n    }\n    /**\n    テキストとセル間の下のパディング値を返します。\n    */\n    get paddingBottom() {\n        return SVGElementExtension.getPaddingBottom(this.svgGroup);\n    }\n    get horizontalAnchor() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.horizontalAnchor, \"center\");\n        return enums_1.HorizontalAnchor.toHorizontalAnchor(b);\n    }\n    /**\n    テキストの水平方向の配置設定を設定します。\n    */\n    set horizontalAnchor(value) {\n        if (this.horizontalAnchor != value)\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.horizontalAnchor, value);\n    }\n    /**\n    テキストの垂直方向の配置設定を返します。\n    */\n    get verticalAnchor() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.verticalAnchor, \"middle\");\n        return enums_1.VerticalAnchor.toVerticalAnchor(b);\n    }\n    /**\n    テキストの垂直方向の配置設定を設定します。\n    */\n    set verticalAnchor(value) {\n        if (this.verticalAnchor != value)\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.verticalAnchor, value);\n    }\n    /**\n    所属しているTableを返します。\n    */\n    get table() {\n        return this._table;\n    }\n    /**\n    セルの背景を表現しているSVGRectElementを返します。\n    */\n    get svgSurface() {\n        return this._svgSurface;\n    }\n    /**\n    セルのテキストを表現しているSVGTextElementを返します。\n    */\n    get svgText() {\n        return this._svgText;\n    }\n    /**\n    セルを表しているSVGGElementを返します。\n    */\n    get svgGroup() {\n        return this._svgGroup;\n    }\n    // #endregion\n    // #region property\n    get innerExtraPaddingLeft() {\n        const p = this.fontSize;\n        return p / 16;\n    }\n    get innerExtraPaddingRight() {\n        const p = this.fontSize;\n        return p / 16;\n    }\n    //private _masterID: number;\n    /**\n     * このセルのx座標とマスターセルとのX座標の差分を返します。\n     */\n    get masterDiffX() {\n        return Number(this.svgGroup.getAttribute(Cell.masterDiffXName));\n    }\n    /**\n     * このセルのx座標とマスターセルとのX座標の差分を設定します。\n     */\n    setMasterDiffX(id) {\n        this.svgGroup.setAttribute(Cell.masterDiffXName, `${id}`);\n    }\n    /**\n     * このセルのy座標とマスターセルとのy座標の差分を返します。\n     */\n    get masterDiffY() {\n        return Number(this.svgGroup.getAttribute(Cell.masterDiffYName));\n    }\n    /**\n     * このセルのy座標とマスターセルとのy座標の差分を設定します。\n     */\n    setMasterDiffY(id) {\n        this.svgGroup.setAttribute(Cell.masterDiffYName, `${id}`);\n    }\n    /**\n     * マスターセルのx座標を返します。\n     */\n    get masterCellX() {\n        return this.cellX + this.masterDiffX;\n    }\n    /**\n     * マスターセルのx座標を設定します。\n     */\n    setMasterCellX(id) {\n        this.setMasterDiffX(id - this.cellX);\n    }\n    /**\n     * マスターセルのy座標を返します。\n     */\n    get masterCellY() {\n        return this.cellY + this.masterDiffY;\n    }\n    /**\n     * マスターセルのy座標を設定します。\n     */\n    setMasterCellY(id) {\n        this.setMasterDiffY(id - this.cellY);\n    }\n    /**\n     * マスターセルのIDを返します。\n     */\n    get masterObjectID() {\n        return this.table.cells[this.masterCellY][this.masterCellX].objectID;\n    }\n    /*\n    public set masterID(id: number) {\n        this.svgGroup.setAttribute(Cell.masterIDName, `${id}`);\n    }\n    */\n    /**\n     * マスターセルを返します。\n     */\n    get master() {\n        return this.table.getCellFromObjectID(this.masterObjectID);\n    }\n    /**\n    単位セルを基準にした自身のX座標を返します。\n    */\n    get cellX() {\n        return Number(this.svgGroup.getAttribute(Cell.cellXName));\n    }\n    /**\n    単位セルを基準にした自身のX座標を設定します。\n    */\n    set cellX(value) {\n        if (this.cellX != value)\n            this.svgGroup.setAttribute(Cell.cellXName, value.toString());\n    }\n    /**\n    単位セルを基準にした自身のY座標を返します。\n    */\n    get cellY() {\n        return Number(this.svgGroup.getAttribute(Cell.cellYName));\n    }\n    /**\n    単位セルを基準にした自身のY座標を設定します。\n    */\n    set cellY(value) {\n        if (this.cellY != value)\n            this.svgGroup.setAttribute(Cell.cellYName, value.toString());\n    }\n    /*\n    get defaultTextClass(): string | null {\n        const r = this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultTextClass);\n        return r;\n    }\n    get defaultBackgroundClass(): string | null {\n        const v = this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultCellBackgroundClass);\n        return v;\n    }\n    */\n    /**\n    CellがDocumentのDOMに所属しているかどうかを返します。\n    */\n    get isLocated() {\n        return CommonFunctions.IsDescendantOfBody(this.svgGroup);\n    }\n    /**\n     * このセルがマスターセルのときに限りTrueを返します。\n     */\n    get isMaster() {\n        return this.objectID == this.masterObjectID;\n    }\n    /**\n     * このセルが奴隷セルのときに限りTrueを返します。\n     */\n    get isSlave() {\n        return !this.isMaster;\n    }\n    /*\n     get ID(): number {\n         return this.cellX + (this.cellY * this.table.columnCount);\n     }\n     */\n    get isErrorCell() {\n        return this.table.cells[this.cellY][this.cellX] != this;\n    }\n    /**\n     * グループセルの行数を返します。\n     */\n    get GroupRowCount() {\n        if (!this.isMaster)\n            throw Error(\"Slave Error\");\n        return this.leftSideGroupCells.length;\n    }\n    /**\n     * グループセルの列数を返します。\n     */\n    get GroupColumnCount() {\n        if (!this.isMaster)\n            throw Error(\"Slave Error\");\n        return this.upperSideGroupCells.length;\n    }\n    /**\n     * グループセルを構成しているセルを2次元配列で返します。\n     */\n    get cellsInGroup() {\n        if (this.isMaster) {\n            return this.table.getRangeCells(this.cellX, this.cellY, this.GroupColumnCount, this.GroupRowCount);\n        }\n        else {\n            throw Error(\"Slave Error\");\n        }\n    }\n    /**\n     * グループセルを構成しているセルを配列で返します。\n     */\n    get cellArrayInGroup() {\n        if (this.isMaster) {\n            return this.table.getRangeCellArray(this.cellX, this.cellY, this.GroupColumnCount, this.GroupRowCount);\n        }\n        else {\n            throw Error(\"Slave Error\");\n        }\n    }\n    /**\n     * このセルがグループセルであるときに限りTrueを返します。\n     */\n    get isSingleCell() {\n        return this.isMaster && this.leftSideGroupCells.length == 1 && this.upperSideGroupCells.length == 1;\n    }\n    /**\n     * マスターセルかつ行数が１のときに限りTrueを返します。\n     */\n    get isMasterCellOfRowCountOne() {\n        return this.isMaster && this.leftSideGroupCells.length == 1;\n    }\n    /**\n     * マスターセルかつ列数が１のときに限りTrueを返します。\n     */\n    get isMasterCellOfColumnCountOne() {\n        return this.isMaster && this.upperSideGroupCells.length == 1;\n    }\n    /**\n    セルのX座標を返します。\n    */\n    get x() {\n        return (0, vline_1.round100)(SVGGExtension.getX(this.svgGroup));\n    }\n    /**\n    セルのX座標を設定します。\n    */\n    set x(value) {\n        SVGGExtension.setX(this.svgGroup, (0, vline_1.round100)(value));\n    }\n    /**\n    セルのY座標を返します。\n    */\n    get y() {\n        return (0, vline_1.round100)(SVGGExtension.getY(this.svgGroup));\n    }\n    /**\n    セルのY座標を設定します。\n    */\n    set y(value) {\n        SVGGExtension.setY(this.svgGroup, (0, vline_1.round100)(value));\n    }\n    /**\n    セルの幅を返します。\n    */\n    get width() {\n        return (0, vline_1.round100)(this.svgSurface.width.baseVal.value);\n    }\n    /**\n    セルの幅を設定します。\n    */\n    set width(value) {\n        const newValue = (0, vline_1.round100)(value);\n        this.svgSurface.width.baseVal.value = newValue;\n    }\n    /**\n    セルの高さを返します。\n    */\n    get height() {\n        return (0, vline_1.round100)(this.svgSurface.height.baseVal.value);\n    }\n    /**\n    セルの高さを設定します。\n    */\n    set height(value) {\n        const newValue = (0, vline_1.round100)(value);\n        this.svgSurface.height.baseVal.value = newValue;\n    }\n    /**\n    セルの領域を表すRectangleを返します。領域の基準は属しているテーブルのSVGGElementです。\n    */\n    get region() {\n        const p = new vline_1.Rectangle(this.x, this.y, this.width, this.height);\n        return p;\n    }\n    /**\n     * グループセルの横幅を返します。\n     */\n    get computeGroupWidth() {\n        if (this.isSingleCell) {\n            return this.width;\n        }\n        else {\n            const p = this.master.upperSideGroupCells;\n            const x2 = p[p.length - 1].cellX;\n            let w = 0;\n            for (let i = this.cellX; i <= x2; i++) {\n                w += this.table.columns[i].width;\n            }\n            return w;\n        }\n    }\n    /**\n     * グループセルの縦幅を返します。\n     */\n    get computeGroupHeight() {\n        if (this.isSingleCell) {\n            return this.height;\n        }\n        else {\n            const p = this.master.leftSideGroupCells;\n            const y2 = p[p.length - 1].cellY;\n            let w = 0;\n            for (let i = this.cellY; i <= y2; i++) {\n                w += this.table.rows[i].height;\n            }\n            return w;\n        }\n    }\n    /**\n     * ２つの線分がオーバーラップしている部分の線分を返します。\n     * @param v\n     * @param w\n     */\n    static computeOverlapRange(v, w) {\n        if (w[0] < v[0]) {\n            return Cell.computeOverlapRange(w, v);\n        }\n        else {\n            if (v[1] < w[0]) {\n                return null;\n            }\n            else {\n                if (w[1] < v[1]) {\n                    return [w[0], w[1]];\n                }\n                else {\n                    return [w[0], v[1]];\n                }\n            }\n        }\n    }\n    /**\n     * ２つの線分がオーバーラップしているときに限り、その結合した線分を返します。\n     * @param v\n     * @param w\n     */\n    static computeDisjunction(v, w) {\n        if (w[0] < v[0]) {\n            return Cell.computeDisjunction(w, v);\n        }\n        else {\n            if (v[1] < w[0]) {\n                return null;\n            }\n            else {\n                return [v[0], Math.max(v[1], w[1])];\n            }\n        }\n    }\n    /**\n     * このグループセルの左上のX座標と右上のX座標を返します。\n     */\n    get groupColumnRange() {\n        return [this.master.cellX, this.master.mostRightCellX];\n    }\n    /**\n     * このグループセルの左上のY座標と左下のY座標を返します。\n     */\n    get groupRowRange() {\n        return [this.master.cellY, this.master.mostBottomCellY];\n    }\n    computeBorderLength2(dir) {\n        //const andFunc = ((v, w) => v);\n        const d1 = dir == \"top\" || dir == \"bottom\" ? this.master.x : this.master.y;\n        const d2 = dir == \"top\" || dir == \"bottom\" ? this.master.x + this.computeGroupWidth : this.master.y + this.computeGroupHeight;\n        const nextCell = this.getNextMasterCell(dir);\n        if (nextCell != null) {\n            const e1 = dir == \"top\" || dir == \"bottom\" ? nextCell.x : nextCell.y;\n            const e2 = dir == \"top\" || dir == \"bottom\" ? nextCell.x + nextCell.computeGroupWidth : nextCell.y + nextCell.computeGroupHeight;\n            //const e2 = nextCell.x;\n            const range = Cell.computeOverlapRange([d1, d2], [e1, e2]);\n            if (range == null) {\n                return 0;\n            }\n            else {\n                return (0, vline_1.round100)(range[1]) - (0, vline_1.round100)(range[0]);\n            }\n        }\n        else {\n            if (dir == \"top\" || dir == \"bottom\") {\n                const newW = Math.max(column_1.CellColumn.defaultWidth, (0, vline_1.round100)(d2) - (0, vline_1.round100)(d1));\n                return newW;\n            }\n            else {\n                const newH = Math.max(row_1.CellRow.defaultHeight, (0, vline_1.round100)(d2) - (0, vline_1.round100)(d1));\n                return newH;\n            }\n        }\n    }\n    // #endregion\n    // #region border\n    //private _borders: SVGLineElement[] = new Array(4);\n    //private _topBorder: SVGLineElement;\n    /**\n    セルの上にある枠を返します\n    */\n    get svgTopBorder() {\n        return this._table.borderRows[this.cellY].borders[this.cellX];\n        //return this._borders[DirectionType.top];\n    }\n    /*\n    set svgTopBorder(line: SVGLineElement) {\n\n        this._borders[DirectionType.top] = line;\n    }\n    */\n    /**\n    セルの左にある枠を返します\n    */\n    get svgLeftBorder() {\n        return this._table.borderColumns[this.cellX].borders[this.cellY];\n        //return this._borders[DirectionType.left];\n    }\n    /*\n    set svgLeftBorder(line: SVGLineElement) {\n        this._borders[DirectionType.left] = line;\n    }\n    */\n    /**\n    セルの右にある枠を返します\n    */\n    get svgRightBorder() {\n        return this._table.borderColumns[this.cellX + 1].borders[this.cellY];\n        //return this._borders[DirectionType.right];\n    }\n    /*\n    set svgRightBorder(line: SVGLineElement) {\n        this._borders[DirectionType.right] = line;\n\n    }\n    */\n    /**\n    セルの下にある枠を返します\n    */\n    get svgBottomBorder() {\n        return this._table.borderRows[this.cellY + 1].borders[this.cellX];\n        //return this._borders[DirectionType.bottom];\n    }\n    /*\n    set svgBottomBorder(line: SVGLineElement) {\n        this._borders[DirectionType.bottom] = line;\n\n    }\n    */\n    // #endregion\n    // #region other\n    /**\n    未定義\n    */\n    get logicalWidth() {\n        if (this.isMaster) {\n            let w = 0;\n            let now = this;\n            while (now != null && this.objectID == now.masterObjectID) {\n                now = this.rightCell;\n                w++;\n            }\n            return w;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n    未定義\n    */\n    get logicalHeight() {\n        if (this.isMaster) {\n            let h = 0;\n            let now = this;\n            while (now != null && this.objectID == now.masterObjectID) {\n                now = this.bottomCell;\n                h++;\n            }\n            return h;\n        }\n        else {\n            return 0;\n        }\n    }\n    /*\n    get calculatedWidthUsingText(): number {\n        if (this.isLocated) {\n            const textRect = SVGTextExtension.getSize(this.svgText, this._assurancevisibility);\n            const w = textRect.width + this.innerExtraPaddingLeft + this.innerExtraPaddingRight\n            + this.paddingLeft + this.paddingRight;\n            return w;\n        } else {\n            return 0;\n        }\n    }\n\n    get calculatedHeightUsingText(): number {\n        if (this.isLocated) {\n            const textRect = SVGTextExtension.getSize(this.svgText, this._assurancevisibility);\n\n            return textRect.height + this.paddingTop + this.paddingBottom;\n        } else {\n            return 0;\n        }\n    }\n    */\n    computeSidePosition(dir) {\n        switch (dir) {\n            case DirectionType2.topLeft: return [this.x, this.y];\n            case DirectionType2.topRight: return [this.x + this.width, this.y];\n            case DirectionType2.bottomLeft: return [this.x, this.y + this.height];\n            case DirectionType2.bottomRight: return [this.x + this.width, this.y + this.height];\n        }\n        throw Error(\"error\");\n    }\n    // #endregion\n    // #region NextCell\n    /**\n     * 与えられた方向にあるセルを返します。\n     * @param direction\n     */\n    getNextCell(direction) {\n        switch (direction) {\n            case \"top\": return this.cellY != 0 ? this.table.cells[this.cellY - 1][this.cellX] : null;\n            case \"left\": return this.cellX != 0 ? this.table.cells[this.cellY][this.cellX - 1] : null;\n            case \"right\": return this.cellX + 1 != this.table.columnCount ? this.table.cells[this.cellY][this.cellX + 1] : null;\n            case \"bottom\": return this.cellY + 1 != this.table.rowCount ? this.table.cells[this.cellY + 1][this.cellX] : null;\n        }\n        throw Error(\"error\");\n    }\n    /**\n     * 与えられた方向にある、このセルが属しているグループセルとは異なる最初のグループセルのマスターセルを返します。\n     * @param direction\n     */\n    getNextMasterCell(direction) {\n        const nextCell = this.getNextCell(direction);\n        return nextCell == null ? null :\n            nextCell.masterObjectID != this.masterObjectID ? nextCell.master : nextCell.getNextMasterCell(direction);\n    }\n    /**\n    上にあるセルを返します。\n    */\n    get topCell() {\n        return this.getNextCell(\"top\");\n    }\n    /**\n    左にあるセルを返します。\n    */\n    get leftCell() {\n        return this.getNextCell(\"left\");\n    }\n    /**\n    右にあるセルを返します。\n    */\n    get rightCell() {\n        return this.getNextCell(\"right\");\n    }\n    /**\n    下にあるセルを返します。\n    */\n    get bottomCell() {\n        return this.getNextCell(\"bottom\");\n    }\n    /**\n     * 右下のセルを返します。\n     */\n    get bottomRightCell() {\n        return this.bottomCell == null ? null : this.bottomCell.rightCell == null ? null : this.bottomCell.rightCell;\n    }\n    /**\n     * 右上のセルを返します。\n     */\n    get topRightCell() {\n        return this.topCell == null ? null : this.topCell.rightCell == null ? null : this.topCell.rightCell;\n    }\n    /**\n     * 左下のセルを返します。\n     */\n    get bottomLeftCell() {\n        return this.bottomCell == null ? null : this.bottomCell.leftCell == null ? null : this.bottomCell.leftCell;\n    }\n    /**\n     * 左上のセルを返します。\n     */\n    get topLeftCell() {\n        return this.topCell == null ? null : this.topCell.leftCell == null ? null : this.topCell.leftCell;\n    }\n    /**\n     * このグループセルの上にあるグループセルのマスターセルを返します。\n     */\n    get topMasterCell() {\n        return this.getNextMasterCell(\"top\");\n    }\n    /**\n     * このグループセルの左にあるグループセルのマスターセルを返します。\n     */\n    get leftMasterCell() {\n        return this.getNextMasterCell(\"left\");\n    }\n    /**\n     * このグループセルの右にあるグループセルのマスターセルを返します。\n     */\n    get rightMasterCell() {\n        return this.getNextMasterCell(\"right\");\n    }\n    /**\n     * このグループセルの下にあるグループセルのマスターセルを返します。\n     */\n    get bottomMasterCell() {\n        return this.getNextMasterCell(\"bottom\");\n    }\n    /**\n     * グループセル内の右端にあるせるセルのX座標を返します。\n     */\n    get mostRightCellX() {\n        return this.cellX + this.GroupColumnCount - 1;\n    }\n    /**\n     * グループセル内の下端にあるせるセルのY座標を返します。\n     */\n    get mostBottomCellY() {\n        return this.cellY + this.GroupRowCount - 1;\n    }\n    /**\n     * 指定した方向にあるグループセルの配列を返します。\n     * @param direction\n     */\n    getNextGroupCells(direction) {\n        if (this.isMaster) {\n            //if(this.isErrorCell) throw new Error(\"error!\");\n            const w = [this];\n            let now = this.getNextCell(direction);\n            while (now != null && this.objectID == now.masterObjectID) {\n                w.push(now);\n                now = now.getNextCell(direction);\n                if (this.table.columnCount < w.length && (direction == \"left\" || direction == \"right\")) {\n                    throw new Error(\"Invalid getNextGroupCells-Loop!\");\n                }\n            }\n            return w;\n        }\n        else {\n            return [];\n        }\n    }\n    /**\n    未定義\n    */\n    get leftSideGroupCells() {\n        return this.getNextGroupCells(\"bottom\");\n    }\n    /**\n    未定義\n    */\n    get upperSideGroupCells() {\n        return this.getNextGroupCells(\"right\");\n    }\n    // #endregion\n    /**\n     * セルの背景を表すSVGRectElementを作成します。\n     * @param className\n     */\n    /*\n    private static createCellRectangle(parent : SVGElement, className: string | null = null): SVGRectElement {\n        const rect = <SVGRectElement>document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        parent.appendChild(rect);\n        rect.width.baseVal.value = 30;\n        rect.height.baseVal.value = 30;\n        if (className == null) {\n            rect.style.fill = \"#ffffff\";\n        } else {\n            SVG.createRectangle(className);\n        }\n        return rect;\n    }\n    */\n    toPlainText() {\n        if (this.isMaster) {\n            const textContext = this.svgText.textContent != null ? this.svgText.textContent : \"\";\n            if (this.isSingleCell) {\n                return textContext;\n            }\n            else {\n                return `${textContext}%%%${this.GroupColumnCount}%%%${this.GroupRowCount}`;\n            }\n        }\n        else {\n            return \"\";\n        }\n    }\n    // #region update\n    updateNodeRelations() {\n        this.updateSVGGroupParent();\n        this.updateBorderParent();\n        //this.updateBorderAttributes();\n    }\n    tryUpdateWithUpdateFlag(withUpdate) {\n        let b = false;\n        if (this.table.isNoneMode)\n            return false;\n        const className = this.svgGroup.getAttribute(\"class\");\n        if (className != this.__currentClass) {\n            if (withUpdate) {\n                this.recomputeDefaultProperties();\n                this.__currentClass = className;\n            }\n            else {\n                return true;\n            }\n        }\n        b = this.tryResizeWithUpdateFlag(withUpdate) || b;\n        if (!withUpdate && b) {\n            debugger_1.Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag, this.tryResizeWithUpdateFlag.name);\n            return b;\n        }\n        b = this.tryLocateSVGTextWithUpdateFlag(withUpdate) || b;\n        if (!withUpdate && b) {\n            debugger_1.Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag, this.tryLocateSVGTextWithUpdateFlag.name);\n            return b;\n        }\n        /*\n        b = this.tryLocateSVGTextWithUpdateFlag(withUpdate) || b;\n        if (!withUpdate && b) {\n            Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag, this.tryLocateSVGTextWithUpdateFlag.name)\n            return b;\n        }\n        */\n        return b;\n    }\n    getUpdateFlag() {\n        return this.tryUpdateWithUpdateFlag(false);\n    }\n    /**\n     * このセルを更新します。\n     */\n    update() {\n        this.tryUpdateWithUpdateFlag(true);\n    }\n    /**\n     * svgGroupの親関係を更新します。\n     */\n    updateSVGGroupParent() {\n        if (this.isMaster) {\n            if (this.table.rows[this.cellY].svgGroup != this.table.svgGroup) {\n                this.table.rows[this.cellY].svgGroup.appendChild(this.svgGroup);\n            }\n        }\n        else {\n            this.table.svgHiddenGroup.appendChild(this.svgGroup);\n            this.svgText.textContent = \"\";\n        }\n    }\n    get topBorderRow() {\n        return this.table.borderRows[this.cellY];\n    }\n    get bottomBorderRow() {\n        return this.table.borderRows[this.cellY + 1];\n    }\n    get leftBorderColumn() {\n        return this.table.borderColumns[this.cellX];\n    }\n    get rightBorderColumn() {\n        return this.table.borderColumns[this.cellX + 1];\n    }\n    /**\n     * 枠の親関係を更新します。\n     */\n    updateBorderParent() {\n        if (this.isMaster || (this.topCell != null && this.topCell.isMaster)) {\n            if (this.topBorderRow.svgGroup != this.svgTopBorder.parentNode)\n                this.topBorderRow.svgGroup.appendChild(this.svgTopBorder);\n        }\n        else {\n            if (this.table.svgHiddenGroup != this.svgTopBorder.parentNode)\n                this.table.svgHiddenGroup.appendChild(this.svgTopBorder);\n        }\n        if (this.isMaster || (this.leftCell != null && this.leftCell.isMaster)) {\n            if (this.leftBorderColumn.svgGroup != this.svgLeftBorder.parentNode)\n                this.leftBorderColumn.svgGroup.appendChild(this.svgLeftBorder);\n        }\n        else {\n            if (this.table.svgHiddenGroup != this.svgLeftBorder.parentNode)\n                this.table.svgHiddenGroup.appendChild(this.svgLeftBorder);\n        }\n        if (this.isMaster || (this.rightCell != null && this.rightCell.isMaster)) {\n            if (this.rightBorderColumn.svgGroup != this.svgRightBorder.parentNode)\n                this.rightBorderColumn.svgGroup.appendChild(this.svgRightBorder);\n        }\n        else {\n            if (this.table.svgHiddenGroup != this.svgRightBorder.parentNode)\n                this.table.svgHiddenGroup.appendChild(this.svgRightBorder);\n        }\n        if (this.isMaster || (this.bottomCell != null && this.bottomCell.isMaster)) {\n            if (this.bottomBorderRow.svgGroup != this.svgBottomBorder.parentNode)\n                this.bottomBorderRow.svgGroup.appendChild(this.svgBottomBorder);\n        }\n        else {\n            if (this.table.svgHiddenGroup != this.svgBottomBorder.parentNode)\n                this.table.svgHiddenGroup.appendChild(this.svgBottomBorder);\n        }\n    }\n    tryResizeWithUpdateFlag(withUpdate) {\n        let b = false;\n        if (!this.isMaster) {\n            return false;\n        }\n        const [w, h] = this.calculatedSizeUsingGroup();\n        if (!(0, vline_1.nearlyEqual)(this.width, w)) {\n            b = true;\n            if (withUpdate) {\n                debugger_1.Debugger.updateLog(this, this.tryResizeWithUpdateFlag, `Width: ${this.width} -> ${w}`);\n                this.width = w;\n            }\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryResizeWithUpdateFlag, `Width: ${this.width} -> ${w}`);\n                return b;\n            }\n        }\n        if (!(0, vline_1.nearlyEqual)(this.height, h)) {\n            b = true;\n            if (withUpdate) {\n                debugger_1.Debugger.updateLog(this, this.tryResizeWithUpdateFlag, `Height: ${this.height} -> ${h}`);\n                this.height = h;\n            }\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryResizeWithUpdateFlag, `Height: ${this.height} -> ${h}`);\n                return b;\n            }\n        }\n        const rect = this.getVirtualRegion();\n        if (this.width < rect.width) {\n            b = true;\n            if (withUpdate) {\n                debugger_1.Debugger.updateLog(this, this.tryResizeWithUpdateFlag, `W: ${this.width} << ${rect.width}`);\n                this.width = rect.width;\n            }\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryResizeWithUpdateFlag, `W: ${this.width} << ${rect.width}`);\n                return b;\n            }\n        }\n        if (this.height < rect.height) {\n            b = true;\n            if (withUpdate) {\n                debugger_1.Debugger.updateLog(this, this.tryResizeWithUpdateFlag, `H: ${this.height} << ${rect.height}`);\n                this.height = rect.height;\n            }\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryResizeWithUpdateFlag, `H: ${this.height} << ${rect.height}`);\n                return b;\n            }\n        }\n        return b;\n    }\n    /**\n     *セルのサイズを再計算します。\n     */\n    resize() {\n        this.tryResizeWithUpdateFlag(true);\n    }\n    /**\n     * 指定した方向の枠を取り除きます。\n     * @param dir\n     */\n    removeBorder(dir) {\n        /*\n        const border = this._borders[dir];\n        if (this.table.svgHiddenGroup.contains(border)) {\n            this.table.svgHiddenGroup.removeChild(border);\n        } else if (this.table.svgGroup.contains(border)) {\n            this.table.svgGroup.removeChild(border);\n        } else {\n            throw Error(\"error\");\n        }\n        */\n    }\n    /**\n     * このセルを取り除きます。\n     * @param isColumn\n     */\n    removeFromTable(isColumn) {\n        this.svgGroup.remove();\n        /*\n        if (this.table.svgGroup.contains(this.svgGroup)) {\n            this.table.svgGroup.removeChild(this.svgGroup);\n        } else if (this.table.svgHiddenGroup.contains(this.svgGroup)) {\n            this.table.svgHiddenGroup.removeChild(this.svgGroup);\n        } else {\n            throw Error(\"error\");\n        }\n        */\n        /*\n         if (isColumn) {\n             this.removeBorder(DirectionType.top);\n             if (this.table.svgGroup.contains(this.svgTopBorder)) {\n                 throw Error(\"err\");\n             }\n             if (this.bottomCell == null) this.removeBorder(DirectionType.bottom);\n             if (this.leftCell == null) this.removeBorder(DirectionType.left);\n             if (this.rightCell == null) this.removeBorder(DirectionType.right);\n         } else {\n\n             this.removeBorder(DirectionType.left);\n             if (this.rightCell == null) this.removeBorder(DirectionType.right);\n             if (this.topCell == null) this.removeBorder(DirectionType.top);\n             if (this.bottomCell == null) this.removeBorder(DirectionType.bottom);\n         }\n         */\n    }\n    /**\n     * このセルが持つ枠の情報を更新します。\n     */\n    updateBorderAttributes() {\n        /*\n        if (this.leftCell != null && this.leftCell.svgRightBorder != this.svgLeftBorder) {\n            this.removeBorder(DirectionType.left);\n            this.svgLeftBorder = this.leftCell.svgRightBorder;\n        }\n\n        if (this.topCell != null && this.topCell.svgBottomBorder != this.svgTopBorder) {\n            this.removeBorder(DirectionType.top);\n            this.svgTopBorder = this.topCell.svgBottomBorder;\n        }\n\n        if (this.rightCell != null && this.rightCell.svgLeftBorder != this.svgRightBorder) {\n            this.rightCell.removeBorder(DirectionType.left);\n            this.rightCell.svgLeftBorder = this.svgRightBorder;\n        }\n\n        if (this.bottomCell != null && this.bottomCell.svgTopBorder != this.svgBottomBorder) {\n            this.bottomCell.removeBorder(DirectionType.top);\n            this.bottomCell.svgTopBorder = this.svgBottomBorder;\n        }\n        */\n        const topCellX = this.svgTopBorder.getAttribute(Cell.borderXName);\n        const topCellY = this.svgTopBorder.getAttribute(Cell.borderYName);\n        const topCellAttr = this.svgTopBorder.getAttribute(Cell.borderTypeName);\n        if (topCellX != `${this.cellX}`)\n            this.svgTopBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\n        if (topCellY != `${this.cellY}`)\n            this.svgTopBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\n        if (topCellAttr != `horizontal`)\n            this.svgTopBorder.setAttribute(Cell.borderTypeName, \"horizontal\");\n        //this.topBorder.setAttribute(\"data-border\", \"top\");\n        const leftCellX = this.svgLeftBorder.getAttribute(Cell.borderXName);\n        const leftCellY = this.svgLeftBorder.getAttribute(Cell.borderYName);\n        const leftCellAttr = this.svgLeftBorder.getAttribute(Cell.borderTypeName);\n        if (leftCellX != `${this.cellX}`)\n            this.svgLeftBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\n        if (leftCellY != `${this.cellY}`)\n            this.svgLeftBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\n        if (leftCellAttr != `vertical`)\n            this.svgLeftBorder.setAttribute(Cell.borderTypeName, \"vertical\");\n        const rightCellX = this.svgRightBorder.getAttribute(Cell.borderXName);\n        const rightCellY = this.svgRightBorder.getAttribute(Cell.borderYName);\n        const rightCellAttr = this.svgRightBorder.getAttribute(Cell.borderTypeName);\n        if (rightCellX != `${this.cellX + 1}`)\n            this.svgRightBorder.setAttribute(Cell.borderXName, `${this.cellX + 1}`);\n        if (rightCellY != `${this.cellY}`)\n            this.svgRightBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\n        if (rightCellAttr != `vertical`)\n            this.svgRightBorder.setAttribute(Cell.borderTypeName, \"vertical\");\n        const bottomCellX = this.svgBottomBorder.getAttribute(Cell.borderXName);\n        const bottomCellY = this.svgBottomBorder.getAttribute(Cell.borderYName);\n        const bottomCellAttr = this.svgBottomBorder.getAttribute(Cell.borderTypeName);\n        if (bottomCellX != `${this.cellX}`)\n            this.svgBottomBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\n        if (bottomCellY != `${this.cellY + 1}`)\n            this.svgBottomBorder.setAttribute(Cell.borderYName, `${this.cellY + 1}`);\n        if (bottomCellAttr != `horizontal`)\n            this.svgBottomBorder.setAttribute(Cell.borderTypeName, \"horizontal\");\n    }\n    // #endregion\n    // #region relocate\n    /*\n    private relocateTopBorder() {\n        this.tryRelocateTopBorderWithUpdateFlag(true);\n    }\n    private relocateLeftBorder() {\n        this.tryRelocateLeftBorderWithUpdateFlag(true);\n    }\n    private relocateRightBorder() {\n        this.tryRelocateRightBorderWithUpdateFlag(true);\n    }\n    private relocateBottomBorder() {\n        this.tryRelocateBottomBorderWithUpdateFlag(true);\n    }\n    */\n    /*\n    public tryAAA(withUpdate: boolean): boolean {\n        //let b = false;\n        if (!CommonFunctions.IsDescendantOfBody(this.svgGroup)) {\n            return false;\n        }\n\n        const b5 = this.tryLocateSVGTextWithUpdateFlag(withUpdate);\n        if (withUpdate && b5) {\n            Debugger.updateLog(this, this.tryAAA, `${this.tryLocateSVGTextWithUpdateFlag.name}`)\n        }\n        if (!withUpdate && b5) {\n            Debugger.updateFlagLog(this, this.tryAAA, `${this.tryLocateSVGTextWithUpdateFlag.name}`)\n            return true;\n        }\n\n        return b5;\n    }\n    */\n    relocation() {\n        this.tryLocateSVGTextWithUpdateFlag(true);\n    }\n    // #endregion\n    // #region merge\n    /**\n     * 右のグループセルと結合します。\n     */\n    mergeRight() {\n        const range = this.getMergedRangeRight();\n        if (range != null) {\n            this.merge(range[0], range[1]);\n        }\n        else {\n            throw Error(\"Error\");\n        }\n    }\n    /**\n     * 下のグループセルと結合します。\n     */\n    mergeBottom() {\n        const range = this.getMergedRangeBottom();\n        if (range != null) {\n            this.merge(range[0], range[1]);\n        }\n        else {\n            throw Error(\"Error\");\n        }\n    }\n    /**\n     * このセルをマスターセルとした横セル数wかつ縦セル数hのグループセルを作成できるとき、Trueを返します。\n     * @param w\n     * @param h\n     */\n    canMerge(w, h) {\n        const range = this.table.getRangeCells(this.cellX, this.cellY, w, h);\n        for (let x = 0; x < w; x++) {\n            const topCell = range[0][x].topCell;\n            if (topCell != null) {\n                if (range[0][x].masterObjectID == topCell.masterObjectID)\n                    return false;\n            }\n            const bottomCell = range[h - 1][x].bottomCell;\n            if (bottomCell != null) {\n                if (range[h - 1][x].masterObjectID == bottomCell.masterObjectID)\n                    return false;\n            }\n        }\n        for (let y = 0; y < h; y++) {\n            const leftCell = range[y][0].leftCell;\n            if (leftCell != null) {\n                if (range[y][0].masterObjectID == leftCell.masterObjectID)\n                    return false;\n            }\n            const rightCell = range[y][w - 1].rightCell;\n            if (rightCell != null) {\n                if (range[y][w - 1].masterObjectID == rightCell.masterObjectID)\n                    return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * このセルをマスターセルとした横セル数wかつ縦セル数hのグループセルを作成します。\n     * @param w\n     * @param h\n     */\n    merge(w, h) {\n        if (!this.isMaster)\n            throw Error(\"Error\");\n        const range = this.table.getRangeCellArray(this.cellX, this.cellY, w, h);\n        range.forEach((v) => { v.setMasterCellX(this.masterCellX); v.setMasterCellY(this.masterCellY); });\n        range.forEach((v) => { v.updateNodeRelations(); v.update(); });\n    }\n    /**\n     * このセルから見て右にあるグループセルとこのセルが属しているグループセルが結合できるとき、そのグループセルの左上のY座標と左下のY座標を返します。\n     * さもなければnullを返します。\n     */\n    getMergedRangeRight() {\n        if (!this.isMaster)\n            return null;\n        if (this.rightMasterCell != null) {\n            const b1 = this.cellY == this.rightMasterCell.cellY;\n            const b2 = this.GroupRowCount == this.rightMasterCell.GroupRowCount;\n            if (b1 && b2) {\n                return [this.GroupColumnCount + this.rightMasterCell.GroupColumnCount, this.GroupRowCount];\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * このセルから見て下にあるグループセルとこのセルが属しているグループセルが結合できるとき、そのグループセルの左上のX座標と右上のX座標を返します。\n     * さもなければnullを返します。\n     */\n    getMergedRangeBottom() {\n        if (!this.isMaster)\n            return null;\n        if (this.bottomMasterCell != null) {\n            const b1 = this.cellX == this.bottomMasterCell.cellX;\n            const b2 = this.GroupColumnCount == this.bottomMasterCell.GroupColumnCount;\n            if (b1 && b2) {\n                return [this.GroupColumnCount, this.GroupRowCount + this.bottomMasterCell.GroupRowCount];\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * 右のセルと結合できるときTrueを返します。\n     */\n    get canMergeRight() {\n        return this.getMergedRangeRight() != null;\n    }\n    /**\n     * 下のセルと結合できるときTrueを返します。\n     */\n    get canMergeBottom() {\n        return this.getMergedRangeBottom() != null;\n    }\n    // #endregion\n    // #region decompose\n    decomposeRow(upperRowCount) {\n        if (this.isMaster) {\n            const upperSide = this.table.getRangeCellArray(this.cellX, this.cellY, this.GroupColumnCount, upperRowCount);\n            const lowerSide = this.table.getRangeCellArray(this.cellX, this.cellY + upperRowCount, this.GroupColumnCount, this.GroupRowCount - upperRowCount);\n            const lowerMaster = lowerSide[0];\n            lowerSide.forEach((v) => {\n                v.setMasterCellX(lowerMaster.cellX);\n                v.setMasterCellY(lowerMaster.cellY);\n            });\n            upperSide.forEach((v) => v.update());\n            lowerSide.forEach((v) => v.update());\n        }\n        else {\n            throw Error(\"Slave Error\");\n        }\n    }\n    decomposeColomn(leftColumnCount) {\n        if (this.isMaster) {\n            const leftSide = this.table.getRangeCellArray(this.cellX, this.cellY, leftColumnCount, this.GroupRowCount);\n            const rightSide = this.table.getRangeCellArray(this.cellX + leftColumnCount, this.cellY, this.GroupColumnCount - leftColumnCount, this.GroupRowCount);\n            const rightMaster = rightSide[0];\n            rightSide.forEach((v) => {\n                v.setMasterCellX(rightMaster.cellX);\n                v.setMasterCellY(rightMaster.cellY);\n            });\n            leftSide.forEach((v) => v.update());\n            rightSide.forEach((v) => v.update());\n        }\n        else {\n            throw Error(\"Slave Error\");\n        }\n    }\n    /**\n    セルの仮想上の領域を返します。\n    */\n    getVirtualRegion() {\n        //const textRect = SVGTextExtension.getRegion(this.svgText);\n        const textRect = (0, virtual_text_1.getVirtualRegion)(this.svgText);\n        const rect = new vline_1.Rectangle();\n        rect.x = 0;\n        rect.width = textRect.width + this.paddingRight + this.paddingLeft + this.primitivePaddingLeft + this.primitivePaddingRight;\n        rect.y = 0;\n        rect.height = textRect.height + this.paddingBottom + this.paddingTop;\n        return rect;\n    }\n    getVirtualInnerRegion() {\n        //const rect = this.getVirtualRegion();\n        const innerRec = new vline_1.Rectangle();\n        innerRec.x = 0 + this.paddingLeft + this.primitivePaddingLeft;\n        innerRec.y = 0 + this.paddingTop;\n        innerRec.width = this.width - this.paddingLeft - this.paddingRight - this.primitivePaddingLeft - this.primitivePaddingRight;\n        innerRec.height = this.height - this.paddingBottom - this.paddingTop;\n        //innerRec.width = rect.width - this.paddingLeft - this.paddingRight;\n        //innerRec.height = rect.height - this.paddingBottom - this.paddingTop;\n        return innerRec;\n    }\n    calculatedSizeUsingGroup() {\n        if (this.isLocated) {\n            let w = 0;\n            let h = 0;\n            this.leftSideGroupCells.forEach((v) => h += (0, vline_1.round100)(this.table.rows[v.cellY].height));\n            this.upperSideGroupCells.forEach((v) => w += (0, vline_1.round100)(this.table.columns[v.cellX].width));\n            const newW = Math.max(column_1.CellColumn.defaultWidth, w);\n            const newH = Math.max(row_1.CellRow.defaultHeight, h);\n            return [newW, newH];\n        }\n        else {\n            return [column_1.CellColumn.defaultWidth, row_1.CellRow.defaultHeight];\n        }\n    }\n    /**\n     * テキストを再描画します。\n     */\n    tryLocateSVGTextWithUpdateFlag(withUpdate) {\n        const innerRect = this.getVirtualInnerRegion();\n        return SVGTextExtension.updateLocationOrGetUpdateFlag(this.svgText, innerRect, this.verticalAnchor, this.horizontalAnchor, enums_1.AutoSizeShapeToFitText.None, withUpdate);\n    }\n    /**\n     * テキストを再描画します。\n     */\n    locateSVGText() {\n        this.tryLocateSVGTextWithUpdateFlag(true);\n    }\n}\nexports.Cell = Cell;\n// #endregion\n// #region field\n//private static readonly defaultBackgroundClassName: string = \"--default-background-class\";\n//\nCell.cellXName = \"data-cellX\";\nCell.cellYName = \"data-cellY\";\nCell.borderXName = \"data-borderX\";\nCell.borderYName = \"data-borderY\";\nCell.borderTypeName = \"data-borderType\";\nCell.masterIDName = \"data-masterID\";\nCell.masterDiffXName = \"data-masterDiffX\";\nCell.masterDiffYName = \"data-masterDiffY\";\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/cell.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/column.ts":
/*!*********************************************!*\
  !*** ./src/objects/table_helpers/column.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CellColumn = void 0;\n//namespace GraphTableSVG {\nconst cell_1 = __webpack_require__(/*! ./cell */ \"./src/objects/table_helpers/cell.ts\");\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./src/common/vline.ts\");\nconst element_extension_1 = __webpack_require__(/*! ../../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst debugger_1 = __webpack_require__(/*! ../../common/debugger */ \"./src/common/debugger.ts\");\n/**\n * 表の列を表現するクラスです。\n */\nclass CellColumn {\n    /**\n    列の単位セルのX座標を返します。\n    */\n    get cellX() {\n        return Number(this._svgMetaData.getAttribute(cell_1.Cell.cellXName));\n    }\n    set cellX(v) {\n        this._svgMetaData.setAttribute(cell_1.Cell.cellXName, `${v}`);\n        this.cells.forEach((w) => w.cellX = v);\n    }\n    get minimumWidth() {\n        const attr = this._svgMetaData.getAttribute(CellColumn.minimumWidthAttributeName);\n        if (attr != null) {\n            return Number.parseInt(attr);\n        }\n        else {\n            return CellColumn.defaultWidth;\n        }\n    }\n    set minimumWidth(value) {\n        this._svgMetaData.setAttribute(CellColumn.minimumWidthAttributeName, value.toString());\n    }\n    //public defaultWidth : number | null = null;\n    /**\n    列の幅を返します。\n    */\n    get width() {\n        return Number(this._svgMetaData.getAttribute(CellColumn.rowWidthName));\n    }\n    /**\n    列の幅を設定します。\n    */\n    set width(value) {\n        (0, element_extension_1.setAttributeNumber)(this._svgMetaData, CellColumn.rowWidthName, value);\n        //this._svgGroup.setAttribute(CellColumn.rowWidthName, `${value}`);\n        //this.setWidthToCells();\n        /*\n        let b = false;\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (cell.isColumnSingleCell && cell.width != value) {\n                cell.width = value;\n                b = true;\n            }\n        }\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (!cell.isColumnSingleCell) {\n                cell.update();\n                //cell.resize();\n                b = true;\n            }\n        }\n        if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\n        */\n    }\n    /*\n    public setWidthToCellsWithUpdateFlag(withUpdate: boolean): boolean {\n        let b = false;\n        const width = Math.max(this.width, CellColumn.defaultWidth);\n\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (cell.isMasterCellOfColumnCountOne && !nearlyEqual(cell.width, width)) {\n                b = true;\n                if (withUpdate) {\n                    cell.width = width;\n                }\n\n                if (!withUpdate && b) {\n                    Debugger.updateFlagLog(this, this.setWidthToCellsWithUpdateFlag, `${cell.width} != ${width} y = ${y}`)\n\n                    return true;\n                }\n            }\n        }\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (!cell.isMasterCellOfColumnCountOne) {\n\n                b = cell.tryUpdateWithUpdateFlag(withUpdate)  || b;\n                if (!withUpdate && b) {\n                    Debugger.updateFlagLog(this, this.setWidthToCellsWithUpdateFlag, `${cell.tryUpdateWithUpdateFlag.name} y = ${y}`)\n                    return b;\n                }\n            }\n        }\n        return b;\n\n    }\n    */\n    /*\n    private setWidthToCells() {\n        this.setWidthToCellsWithUpdateFlag(true);\n        // TODO : implement the event of the below code.\n        //if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\n\n    }\n    */\n    /**\n     * この列のセルの配列を返します。\n     */\n    get cells() {\n        const items = [];\n        for (let i = 0; i < this.table.rowCount; i++) {\n            //if(this.table.rows[i].cells.length <= this.cellX) throw new Error(\"error\");\n            items.push(this.table.rows[i].cells[this.cellX]);\n        }\n        return items;\n    }\n    get length() {\n        return this.cells.length;\n    }\n    constructor(_table, _x, _width = CellColumn.defaultWidth) {\n        this.table = _table;\n        this._svgMetaData = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');\n        this._svgMetaData.setAttribute(\"name\", \"cell_column\");\n        this.table.svgColumnInfo.appendChild(this._svgMetaData);\n        //this._svgMetaData = SVG.createGroup(this.table.svgColumnInfo);\n        //this.table.svgGroup.appendChild(this._svgGroup);\n        this.cellX = _x;\n        this._svgMetaData.setAttribute(CellColumn.rowWidthName, `${_width}`);\n        //this.width = this.getMaxWidth();\n    }\n    /**\n     * この列の仮想上のサイズを返します。\n     */\n    getVirtualSize() {\n        let height = 0;\n        let width = 0;\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            const rect = cell.getVirtualRegion();\n            if (cell.isMasterCellOfColumnCountOne) {\n                if (width < rect.width)\n                    width = rect.width;\n            }\n            height += cell.master.getVirtualRegion().height;\n        }\n        return new vline_1.Size((0, vline_1.round100)(width), (0, vline_1.round100)(height));\n    }\n    /*\n    private getMaxWidth(): number {\n        let width = 0;\n\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (cell.isMasterCellOfColumnCountOne) {\n                const rect = cell.getVirtualRegion();\n                if (width < rect.width) width = rect.width;\n                //if (width < cell.width) width = cell.width;\n            }\n        }\n\n        return width;\n    }\n    */\n    /**\n     * この列を更新します。\n     */\n    /*\n     public update() {\n        this.setWidthToCells();\n        //this.width = this.getMaxWidth();\n    }\n    */\n    /*\n     public tryResizeWithUpdateFlag(withUpdate: boolean) {\n         let b = false;\n         const cells = this.cells;\n         for (let i = 0; i < cells.length; i++) {\n             b = cells[i].tryUpdateWithUpdateFlag(withUpdate)  || b;\n             if (!withUpdate && b) {\n                 return b;\n             }\n         }\n         b = this.setHeightToCellsWithUpdateFlag(withUpdate)  || b;\n \n         return b;\n     }\n     */\n    /**\n     * 列内のセルのサイズを再計算します。\n     */\n    /*\n    public resize() {\n\n        this.tryResizeWithUpdateFlag(true);\n    }\n    */\n    tryUpdateWidthWithUpdateFlag(allowShrink, withUpdate) {\n        let b = false;\n        const __width = allowShrink ? this.getVirtualSize().width : Math.max(this.width, this.getVirtualSize().width);\n        const newWidth = Math.max(this.minimumWidth, (0, vline_1.round100)(__width));\n        if (!(0, vline_1.nearlyEqual)(this.width, newWidth)) {\n            b = true;\n            if (withUpdate) {\n                this.width = newWidth;\n            }\n            else {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdateWidthWithUpdateFlag, `Width: ${this.width} -> ${newWidth}`);\n            }\n        }\n        return b;\n    }\n    /**\n     * セルの元々のサイズに合わせて列のサイズを調整します。\n     * @param allowShrink 現在の列の幅より短くなることを許す\n     */\n    fitWidthToOriginalCell(allowShrink) {\n        this.tryUpdateWidthWithUpdateFlag(allowShrink, true);\n    }\n    setXWithUpdate(posX, withUpdate) {\n        const posx100 = (0, vline_1.round100)(posX);\n        let b = false;\n        for (let y = 0; y < this.table.rowCount; y++) {\n            const cell = this.table.cells[y][this.cellX];\n            if (cell.x != posx100) {\n                b = true;\n                if (withUpdate) {\n                    cell.x = posx100;\n                }\n                if (!withUpdate && b) {\n                    debugger_1.Debugger.updateFlagLog(this, this.setXWithUpdate, `${this.selfx}, ${posx100}`);\n                    return b;\n                }\n            }\n        }\n        return b;\n    }\n    /**\n     * 列のX座標を設定します。\n     * @param posX\n     */\n    setX(posX) {\n        this.setXWithUpdate(posX, true);\n    }\n    /**\n     * この列の左の枠を配列で返します。\n     */\n    get leftBorders() {\n        const r = [];\n        this.cells.forEach((v) => {\n            if (r.length == 0) {\n                r.push(v.svgLeftBorder);\n            }\n            else {\n                const last = r[r.length - 1];\n                if (last != v.svgLeftBorder)\n                    r.push(v.svgLeftBorder);\n            }\n        });\n        return r;\n    }\n    /**\n     * この列の右の枠を配列で返します。\n     */\n    get rightBorders() {\n        const r = [];\n        this.cells.forEach((v) => {\n            if (r.length == 0) {\n                r.push(v.svgRightBorder);\n            }\n            else {\n                const last = r[r.length - 1];\n                if (last != v.svgRightBorder)\n                    r.push(v.svgRightBorder);\n            }\n        });\n        return r;\n    }\n    /**\n     * この列の上の枠を返します。\n     */\n    get topBorder() {\n        return this.cells[0].svgTopBorder;\n    }\n    /**\n     * この列の下の枠を返します。\n     */\n    get bottomBorder() {\n        const cells = this.cells;\n        return cells[cells.length - 1].svgBottomBorder;\n    }\n    get selfx() {\n        for (let i = 0; i < this.table.columnCount; i++) {\n            if (this.table.columns[i] == this) {\n                return i;\n            }\n        }\n        throw new Error(\"error\");\n    }\n    /**\n     * この列を取り除きます。\n     * @param isUnit\n     */\n    _dispose() {\n        /*\n        while (this.length > 0){\n            const x = this.length - 1;\n            this.cells[x].removeFromTable(false);\n            this.cells.splice(x, 1);\n        }\n        */\n        const x = this.selfx;\n        this.table.rows.forEach((v, i) => v._removeCell(x));\n        this._svgMetaData.remove();\n        /*\n        if (isUnit) {\n            if (this.table.columns.length > 1) {\n                this.table.columns[this.cellX].cells.forEach((v) => {\n                    v.removeFromTable(true);\n                    this.table.cells[v.cellY].splice(this.cellX, 1);\n                });\n\n\n                this.table.columns.splice(this.cellX, 1);\n                this.table.columns.forEach((v, i) => v.cellX = i);\n                this.table.svgGroup.removeChild(this._svgGroup);\n                this.table.update();\n            } else if (this.table.columns.length == 1) {\n                while (this.table.rows.length > 0) {\n                    this.table.rows[this.table.rows.length - 1].remove(true);\n                }\n                if (this.table.columns.length == 1) this.table.columns.splice(0, 1);\n            } else {\n                throw Error(\"error\");\n            }\n        } else {\n            const [b, e] = this.groupColumnRange;\n            for (let x = e; x >= b; x--) {\n                this.table.columns[x].remove(true);\n            }\n        }\n        */\n    }\n    /**\n     * この列のセルの位置を再計算します。\n     */\n    relocation() {\n        this.cells.forEach((v) => v.relocation());\n    }\n    /**\n     * この列に属しているグループセルによって関係している列の範囲を返します。\n     */\n    get groupColumnRange() {\n        let range = this.cells[0].groupColumnRange;\n        this.cells.forEach((v) => {\n            if (range != null) {\n                range = cell_1.Cell.computeDisjunction(range, v.groupColumnRange);\n            }\n        });\n        if (range == null) {\n            throw Error(\"error\");\n        }\n        else {\n            return range;\n        }\n    }\n}\nexports.CellColumn = CellColumn;\n//private readonly _cellX: number;\nCellColumn.rowWidthName = \"data-width\";\nCellColumn.minimumWidthAttributeName = \"data-minimum-width\";\nCellColumn.defaultWidth = 20;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/column.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/row.ts":
/*!******************************************!*\
  !*** ./src/objects/table_helpers/row.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CellRow = void 0;\n//namespace GraphTableSVG {    \nconst cell_1 = __webpack_require__(/*! ./cell */ \"./src/objects/table_helpers/cell.ts\");\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./src/common/vline.ts\");\nconst element_extension_1 = __webpack_require__(/*! ../../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst debugger_1 = __webpack_require__(/*! ../../common/debugger */ \"./src/common/debugger.ts\");\nconst GObserver = __webpack_require__(/*! ../z_observer */ \"./src/objects/z_observer.ts\");\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst html_functions_1 = __webpack_require__(/*! ../../html/html_functions */ \"./src/html/html_functions.ts\");\nconst global_gobject_manager_1 = __webpack_require__(/*! ../global_gobject_manager */ \"./src/objects/global_gobject_manager.ts\");\n/**\n * 表の行を表現するクラスです。\n */\nclass CellRow {\n    constructor(_table, _y, _height = CellRow.defaultHeight) {\n        /*\n        public removeCell(i: number) {\n            this.cells[i].removeFromTable(false);\n            //this.cells.forEach((v) => v.removeFromTable(false));\n            this.cells.splice(i, 1);\n        }\n    \n        */\n        this._cells = [];\n        this.table = _table;\n        this._svgGroup = SVG.createGroup(this.table.svgGroup);\n        this.svgGroup.setAttribute(\"name\", \"cell_row\");\n        this.stableFlag = false;\n        this.table.svgGroup.insertBefore(this.svgGroup, this.table.svgRowBorderGroup);\n        this.cellY = _y;\n        this._svgGroup.setAttribute(CellRow.heightAttributeName, `${_height}`);\n        //this.unstableCounter = GObserver.unstableCounterDefault;\n        const svgsvgAncestor = (0, html_functions_1.getSVGSVGAncestor)(this.svgGroup);\n        if (svgsvgAncestor != null) {\n            const xb = global_gobject_manager_1.GlobalZObjectManager.tryRegisterSVGSVGElement(svgsvgAncestor);\n            xb.registerObject(this);\n        }\n        /*\n        for(let i=0;i<cellCount;i++){\n            this._cells.push(this.createCell(i, _y));\n        }\n        */\n        //this.height = this.getMaxHeight();\n    }\n    get minimumHeight() {\n        const attr = this.svgGroup.getAttribute(CellRow.minimumHeightAttributeName);\n        if (attr != null) {\n            return Number.parseInt(attr);\n        }\n        else {\n            return CellRow.defaultHeight;\n        }\n    }\n    set minimumHeight(value) {\n        this.svgGroup.setAttribute(CellRow.minimumHeightAttributeName, value.toString());\n    }\n    /*\n    public get unstableCounter(): number | null {\n        const p = this.svgGroup.getAttribute(GObserver.unstableCounterName);\n        if (p == null) {\n            return null;\n        } else {\n            const num = Number(p);\n            return num;\n        }\n    }\n    private set unstableCounter(value: number | null) {\n        if (value == null) {\n            this.svgGroup.removeAttribute(GObserver.unstableCounterName)\n        } else {\n            this.svgGroup.setAttribute(GObserver.unstableCounterName, value.toString());\n \n        }\n    }\n    public resetUnstableCounter(): void {\n        this.unstableCounter = GObserver.unstableCounterDefault;\n    }\n    */\n    get childrenStableFlag() {\n        let b = true;\n        for (let i = 0; i < this._cells.length; i++) {\n            if (!this._cells[i].stableFlag) {\n                b = false;\n                break;\n            }\n        }\n        return b;\n    }\n    updateSurfaceWithoutSVGText() {\n        if (this.childrenStableFlag) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    createCell(cellX, cellY, cellMap) {\n        const cellClass = undefined; //this.table.defaultCellClass == null ? undefined : this.table.defaultCellClass;\n        const borderClass = undefined;\n        //this.table.defaultBorderClass == null ? undefined : this.table.defaultBorderClass;\n        const option = { cellClass: cellClass, borderClass: borderClass };\n        return new cell_1.Cell(this.table, cellX, cellY, cellMap, option);\n    }\n    _insertCell(i, cellMap) {\n        const cell = this.createCell(i, this.cellY, cellMap);\n        this.cells.splice(i, 0, cell);\n    }\n    _appendCell(cellMap, num = 1) {\n        for (let i = 0; i < num; i++) {\n            const cell = this.createCell(this.cells.length, this.cellY, cellMap);\n            this.cells.push(cell);\n        }\n    }\n    get cells() {\n        return this._cells;\n    }\n    get length() {\n        return this.cells.length;\n    }\n    get svgGroup() {\n        return this._svgGroup;\n    }\n    get stableFlag() {\n        return this.svgGroup.getAttribute(GObserver.ObjectStableFlagName) == \"true\";\n    }\n    set stableFlag(b) {\n        this.svgGroup.setAttribute(GObserver.ObjectStableFlagName, b ? \"true\" : \"false\");\n    }\n    /**\n    列の単位セルのY座標を返します。\n    */\n    get cellY() {\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\n    }\n    set cellY(v) {\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\n        this.cells.forEach((w) => w.cellY = v);\n    }\n    /**\n    行の高さを返します。\n    */\n    get height() {\n        return Number(this._svgGroup.getAttribute(CellRow.heightAttributeName));\n    }\n    /**\n    行の高さを設定します。\n    */\n    set height(value) {\n        (0, element_extension_1.setAttributeNumber)(this._svgGroup, CellRow.heightAttributeName, (0, vline_1.round100)(value));\n        //this._svgGroup.setAttribute(CellRow.columnHeightName, `${value}`);\n        //this.setHeightToCells();\n        /*\n        let b = false;\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            if (cell.isRowSingleCell && cell.height != value) {\n                cell.height = value;\n                b = true;\n            }\n        }\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            if (!cell.isRowSingleCell) {\n                cell.update();\n                //cell.resize();\n                b = true;\n            }\n        }\n        if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\n        */\n    }\n    getVirtualSize() {\n        let height = 0;\n        let width = 0;\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            const rect = cell.getVirtualRegion();\n            if (cell.isMasterCellOfRowCountOne) {\n                if (height < rect.height)\n                    height = rect.height;\n            }\n            width += cell.master.getVirtualRegion().width;\n        }\n        return new vline_1.Size((0, vline_1.round100)(width), (0, vline_1.round100)(height));\n    }\n    /**\n     * この行のセル配列を返します。\n     */\n    /*\n     public get cells(): Cell[] {\n        return this.table.cells[this.cellY];\n    }\n    */\n    /**\n     * この行のセルの上にある枠の配列を返します。\n     */\n    get topBorders() {\n        const r = [];\n        this.cells.forEach((v) => {\n            if (r.length == 0) {\n                r.push(v.svgTopBorder);\n            }\n            else {\n                const last = r[r.length - 1];\n                if (last != v.svgTopBorder)\n                    r.push(v.svgTopBorder);\n            }\n        });\n        return r;\n    }\n    /**\n     * この行のセルの下にある枠の配列を返します。\n     */\n    get bottomBorders() {\n        const r = [];\n        this.cells.forEach((v) => {\n            if (r.length == 0) {\n                r.push(v.svgBottomBorder);\n            }\n            else {\n                const last = r[r.length - 1];\n                if (last != v.svgBottomBorder)\n                    r.push(v.svgBottomBorder);\n            }\n        });\n        return r;\n    }\n    /**\n     * この行のセルの左にある枠を返します。\n     */\n    get leftBorder() {\n        return this.cells[0].svgLeftBorder;\n    }\n    /**\n     * この行のセルの右にある枠を返します。\n     */\n    get rightBorder() {\n        const cells = this.cells;\n        return cells[cells.length - 1].svgRightBorder;\n    }\n    /*\n    public setHeightToCellsWithUpdateFlag(withUpdate : boolean) : boolean {\n        let b = false;\n        const height = Math.max(this.height, CellRow.defaultHeight);\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            if (cell.isMasterCellOfRowCountOne && !nearlyEqual(cell.height, height)) {\n                b = true;\n                if(withUpdate){\n                    cell.height = height;\n                }\n                if(!withUpdate && b){\n                    Debugger.updateFlagLog(this, this.setHeightToCellsWithUpdateFlag, `${cell.height} != ${height}`)\n\n                    return b;\n                }\n            }\n        }\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            if (!cell.isMasterCellOfRowCountOne) {\n                b = cell.tryUpdateWithUpdateFlag(withUpdate)  || b;\n\n                if(!withUpdate && b){\n                    Debugger.updateFlagLog(this, this.setHeightToCellsWithUpdateFlag, `${cell.tryUpdateWithUpdateFlag.name} x = ${x}`)\n                    return b;\n                }\n            }\n        }\n        return b;\n\n    }\n    */\n    //public setHeightToCells() {\n    //this.setHeightToCellsWithUpdateFlag(true);\n    // TODO : implement the event of the below code.\n    //if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\n    //}\n    /**\n     * この行を更新します。\n     */\n    /*\n     public update() {\n        this.setHeightToCells();\n        //this.height = this.getMaxHeight();\n    }\n    */\n    /*\n    public tryResizeWithUpdateFlag(withUpdate : boolean) : boolean {\n        let b = false;\n        const cells = this.cells;\n        for(let i = 0;i<cells.length;i++){\n            b = cells[i].tryUpdateWithUpdateFlag(withUpdate)  || b;\n            if(!withUpdate && b){\n                return b;\n            }\n        }\n        b = this.setHeightToCellsWithUpdateFlag(withUpdate)  || b;\n        return b;\n    }\n    */\n    /**\n     * 行内のセルのサイズを再計算します。\n     */\n    //public resize() {\n    //this.setHeightToCellsWithUpdateFlag(true);\n    //this.tryResizeWithUpdateFlag(true);\n    //this.height = this.getMaxHeight();\n    //}\n    tryUpdateHeightWithUpdateFlag(allowShrink, withUpdate) {\n        let b = false;\n        const __height = allowShrink ? this.getVirtualSize().height : Math.max(this.height, this.getVirtualSize().height);\n        const newHeight = Math.max(this.minimumHeight, (0, vline_1.round100)(__height));\n        if (!(0, vline_1.nearlyEqual)(this.height, newHeight)) {\n            b = true;\n            if (withUpdate) {\n                this.height = newHeight;\n            }\n            else {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdateHeightWithUpdateFlag, `Height: ${this.height} -> ${newHeight}`);\n            }\n        }\n        return b;\n    }\n    /**\n     * セルの元々のサイズに合わせて行のサイズを調整します。\n     * @param allowShrink 現在の行の幅より短くなることを許す\n     */\n    fitHeightToOriginalCell(allowShrink) {\n        this.tryUpdateHeightWithUpdateFlag(allowShrink, true);\n    }\n    setYWithUpdate(posY, withUpdate) {\n        const posY100 = (0, vline_1.round100)(posY);\n        let b = false;\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            if (cell.y != posY100) {\n                b = true;\n                if (withUpdate) {\n                    cell.y = posY100;\n                }\n                if (!withUpdate && b) {\n                    return b;\n                }\n            }\n        }\n        return b;\n    }\n    /**\n     * 行内のセルのY座標を設定します。\n     *\n     */\n    setY(posY) {\n        this.setYWithUpdate(posY, true);\n    }\n    /**\n     * この行の最大の縦幅を持つセルの縦幅を返します。\n     */\n    /*\n    private getMaxHeight(): number {\n        let height = 0;\n        for (let x = 0; x < this.table.columnCount; x++) {\n            const cell = this.table.cells[this.cellY][x];\n            const rect = cell.getVirtualRegion();\n            if (cell.isMasterCellOfRowCountOne) {\n                if (height < rect.height) height = rect.height;\n                if (height < cell.height) height = cell.height;\n            }\n        }\n        return height;\n    }\n    */\n    get selfy() {\n        for (let i = 0; i < this.table.rowCount; i++) {\n            if (this.table.rows[i] == this) {\n                return i;\n            }\n        }\n        throw new Error(\"error\");\n    }\n    _dispose() {\n        while (this.length > 0) {\n            const x = this.length - 1;\n            this._removeCell(x);\n        }\n        this.svgGroup.remove();\n        //this.rows.splice(this.rows[i].selfy, 1);\n    }\n    _removeCell(i) {\n        this.cells[i].removeFromTable(false);\n        this.cells.splice(i, 1);\n    }\n    /**\n     * この行を取り除きます。\n     * @param isUnit\n     */\n    /*\n    public remove(isUnit: boolean = false) {\n        while (this.cells.length > 0) this.removeCell(this.cells.length - 1);\n        this.svgGroup.remove();\n        this.table.rows.splice(this.selfy, 1);\n    }\n    */\n    /*\n    public updateBorders() {\n        this.cells.forEach((v) => v.updateBorder());\n    }\n    */\n    /**\n     * この行の各セルを再配置します。\n     */\n    //public relocation() {\n    //    this.cells.forEach((v) => v.relocation());\n    //}\n    /**\n     * この行に属しているグループセルによって関係している行の範囲を返します。\n     */\n    get groupRowRange() {\n        let range = this.cells[0].groupRowRange;\n        this.cells.forEach((v) => {\n            if (range != null) {\n                range = cell_1.Cell.computeDisjunction(range, v.groupRowRange);\n            }\n        });\n        if (range == null) {\n            throw Error(\"error\");\n        }\n        else {\n            return range;\n        }\n    }\n    /*\n    public getBase1UpdateFlag(){\n        const b = this.cells.every((v) => v.unstableCounter == null);\n        return !b;\n    }\n    public base1Update(){\n        this.cells.forEach((v) => {\n            const b = v.tryUpdateWithUpdateFlag(true);\n            if(b){\n                v.resetUnstableCounter();\n            }else{\n                GObserver.decrementUnstableCounter(v);\n            }\n        })\n    }\n    */\n    get objectID() {\n        return this.svgGroup.getAttribute(AttributeNames.objectIDName);\n    }\n}\nexports.CellRow = CellRow;\nCellRow.heightAttributeName = \"data-height\";\nCellRow.minimumHeightAttributeName = \"data-minimum-height\";\nCellRow.defaultHeight = 20;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/row.ts?");

/***/ }),

/***/ "./src/objects/table_helpers/update_table.ts":
/*!***************************************************!*\
  !*** ./src/objects/table_helpers/update_table.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n//namespace GraphTableSVG {\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UpdateTable = void 0;\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./src/common/vline.ts\");\nconst debugger_1 = __webpack_require__(/*! ../../common/debugger */ \"./src/common/debugger.ts\");\nclass UpdateTable {\n    static tryUpdateBorderCoodinateWithUpdateFlag(cell, borderType, newValue, type, withUpdate) {\n        let b = false;\n        const oldValue = cell.getBorderPosition(borderType, type);\n        const newValue100 = (0, vline_1.round100)(newValue);\n        if (!(0, vline_1.nearlyEqual)(oldValue, newValue100)) {\n            b = true;\n            if (withUpdate) {\n                debugger_1.Debugger.updateLog(cell, UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag, `Border = ${borderType}, Position = ${type}: ${oldValue}->${newValue100}`);\n                UpdateTable.setBorderPosition(cell, borderType, type, newValue100);\n            }\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag, `Border = ${borderType}, Position = ${type}: ${oldValue}->${newValue100}`);\n            }\n        }\n        return b;\n    }\n    static setBorderPosition(cell, borderType, positionType, newValue) {\n        let border = cell.svgTopBorder;\n        switch (borderType) {\n            case \"top\":\n                border = cell.svgTopBorder;\n                break;\n            case \"left\":\n                border = cell.svgLeftBorder;\n                break;\n            case \"right\":\n                border = cell.svgRightBorder;\n                break;\n            case \"bottom\":\n                border = cell.svgBottomBorder;\n                break;\n        }\n        switch (positionType) {\n            case \"x1\":\n                border.setAttribute(\"x1\", (0, vline_1.round100)(newValue).toString());\n            case \"x2\":\n                border.setAttribute(\"x2\", (0, vline_1.round100)(newValue).toString());\n            case \"y1\":\n                border.setAttribute(\"y1\", (0, vline_1.round100)(newValue).toString());\n            case \"y2\":\n                border.setAttribute(\"y2\", (0, vline_1.round100)(newValue).toString());\n        }\n    }\n    static tryRelocateBottomBorderWithUpdateFlag(cell, withUpdate) {\n        if (!cell.isMaster) {\n            return false;\n        }\n        if (cell.table.svgGroup.contains(cell.svgBottomBorder)) {\n            if (cell.isMaster) {\n                const x1 = cell.x;\n                const b1 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"bottom\", x1, \"x1\", withUpdate);\n                if (!withUpdate && b1) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateBottomBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x1`);\n                    return true;\n                }\n                const x2 = cell.x + cell.computeBorderLength2(\"bottom\");\n                const b2 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"bottom\", x2, \"x2\", withUpdate);\n                if (!withUpdate && b2) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateBottomBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x2`);\n                    return true;\n                }\n                const y1 = cell.y + cell.height;\n                const b3 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"bottom\", y1, \"y1\", withUpdate);\n                if (!withUpdate && b3) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateBottomBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y1`);\n                    return true;\n                }\n                const y2 = cell.getBorderPosition(\"bottom\", \"y1\");\n                const b4 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"bottom\", y2, \"y2\", withUpdate);\n                if (!withUpdate && b4) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateBottomBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y2`);\n                    return true;\n                }\n                return b1 || b2 || b3 || b4;\n            }\n            else if (cell.bottomCell != null && cell.bottomCell.isMaster) {\n                const b = UpdateTable.tryRelocateTopBorderWithUpdateFlag(cell.bottomCell, withUpdate);\n                return b;\n            }\n            else {\n                throw Error(\"error\");\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    static tryRelocateTopBorderWithUpdateFlag(cell, withUpdate) {\n        //let b = false;\n        if (!cell.isMaster)\n            return false;\n        if (cell.table.svgGroup.contains(cell.svgTopBorder)) {\n            if (cell.isMaster) {\n                const x1 = cell.x;\n                const b1 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"top\", x1, \"x1\", withUpdate);\n                if (!withUpdate && b1) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateTopBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x1`);\n                    return true;\n                }\n                //const x2 = cell.x;\n                const x2 = cell.x + cell.computeBorderLength2(\"top\");\n                const b2 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"top\", x2, \"x2\", withUpdate);\n                if (!withUpdate && b2) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateTopBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x2`);\n                    return true;\n                }\n                const y1 = cell.y;\n                const b3 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"top\", y1, \"y1\", withUpdate);\n                if (!withUpdate && b3) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateTopBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y1`);\n                    return true;\n                }\n                const y2 = cell.getBorderPosition(\"top\", \"y1\");\n                const b4 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"top\", y2, \"y2\", withUpdate);\n                if (!withUpdate && b4) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateTopBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y2`);\n                    return true;\n                }\n                return b1 || b2 || b3 || b4;\n            }\n            else if (cell.topCell != null && cell.topCell.isMaster) {\n                const b = UpdateTable.tryRelocateBottomBorderWithUpdateFlag(cell.topCell, withUpdate);\n                return b;\n            }\n            else {\n                throw Error(\"error\");\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    static tryRelocateLeftBorderWithUpdateFlag(cell, withUpdate) {\n        if (!cell.isMaster) {\n            return false;\n        }\n        if (cell.table.svgGroup.contains(cell.svgLeftBorder)) {\n            if (cell.isMaster) {\n                const x1 = cell.x;\n                const b1 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"left\", x1, \"x1\", withUpdate);\n                if (!withUpdate && b1) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateLeftBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x1`);\n                    return true;\n                }\n                const x2 = cell.getBorderPosition(\"left\", \"x1\");\n                ;\n                const b2 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"left\", x2, \"x2\", withUpdate);\n                if (!withUpdate && b2) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateLeftBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x2`);\n                    return true;\n                }\n                const y1 = cell.y;\n                const b3 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"left\", y1, \"y1\", withUpdate);\n                if (!withUpdate && b3) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateLeftBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y1`);\n                    return true;\n                }\n                const y2 = cell.y + cell.computeBorderLength2(\"left\");\n                const b4 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"left\", y2, \"y2\", withUpdate);\n                if (!withUpdate && b4) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateLeftBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y2`);\n                    return true;\n                }\n                return b1 || b2 || b3 || b4;\n            }\n            else if (cell.leftCell != null && cell.leftCell.isMaster) {\n                const b = UpdateTable.tryRelocateRightBorderWithUpdateFlag(cell.leftCell, withUpdate);\n                return b;\n            }\n            else {\n                throw Error(\"error\");\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    static tryRelocateRightBorderWithUpdateFlag(cell, withUpdate) {\n        if (!cell.isMaster) {\n            return false;\n        }\n        if (cell.table.svgGroup.contains(cell.svgRightBorder)) {\n            if (cell.isMaster) {\n                const x1 = cell.x + cell.width;\n                const b1 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"right\", x1, \"x1\", withUpdate);\n                if (!withUpdate && b1) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateRightBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x1`);\n                    return true;\n                }\n                const x2 = cell.x + cell.width;\n                const b2 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"right\", x2, \"x2\", withUpdate);\n                if (!withUpdate && b2) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateRightBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} x2`);\n                    return true;\n                }\n                const y1 = cell.y;\n                const b3 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"right\", y1, \"y1\", withUpdate);\n                if (!withUpdate && b3) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateRightBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y1`);\n                    return true;\n                }\n                const y2 = cell.y + cell.computeBorderLength2(\"right\");\n                const b4 = UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag(cell, \"right\", y2, \"y2\", withUpdate);\n                if (!withUpdate && b4) {\n                    debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryRelocateRightBorderWithUpdateFlag, `${UpdateTable.tryUpdateBorderCoodinateWithUpdateFlag.name} y2`);\n                    return true;\n                }\n                return b1 || b2 || b3 || b4;\n            }\n            else if (cell.rightCell != null && cell.rightCell.isMaster) {\n                const b = UpdateTable.tryRelocateLeftBorderWithUpdateFlag(cell.rightCell, withUpdate);\n                return b;\n            }\n            else {\n                throw Error(\"error\");\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n    *セルの位置を再計算します。\n    */\n    static tryUpdateBordersWithUpdateFlag(cell, withUpdate) {\n        //let b = false;\n        const b1 = UpdateTable.tryRelocateTopBorderWithUpdateFlag(cell, withUpdate);\n        if (!withUpdate && b1) {\n            debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryUpdateBordersWithUpdateFlag, `${UpdateTable.tryRelocateTopBorderWithUpdateFlag.name}`);\n            return true;\n        }\n        const b2 = UpdateTable.tryRelocateLeftBorderWithUpdateFlag(cell, withUpdate);\n        if (!withUpdate && b2) {\n            debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryUpdateBordersWithUpdateFlag, `${UpdateTable.tryRelocateLeftBorderWithUpdateFlag.name}`);\n            return true;\n        }\n        const b3 = UpdateTable.tryRelocateRightBorderWithUpdateFlag(cell, withUpdate);\n        if (!withUpdate && b3) {\n            debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryUpdateBordersWithUpdateFlag, `${UpdateTable.tryRelocateRightBorderWithUpdateFlag.name}`);\n            return true;\n        }\n        const b4 = UpdateTable.tryRelocateBottomBorderWithUpdateFlag(cell, withUpdate);\n        if (!withUpdate && b4) {\n            debugger_1.Debugger.updateFlagLog(cell, UpdateTable.tryUpdateBordersWithUpdateFlag, `${UpdateTable.tryRelocateBottomBorderWithUpdateFlag.name}`);\n            return true;\n        }\n        return b1 || b2 || b3 || b4;\n    }\n    static tryUpdateBorders(cellArray, withUpdate) {\n        let b = false;\n        const date1 = new Date();\n        cellArray.forEach((v) => {\n            if (v.isMaster) {\n                b = UpdateTable.tryUpdateBordersWithUpdateFlag(v, withUpdate) || b;\n            }\n        });\n        const date2 = new Date();\n        debugger_1.Debugger.showTime(date1, date2, `Table: X`, \"updateBorders\");\n        return b;\n    }\n    static updateCellSizeAfterUpdatingRowsAndColumns(rows, columns, withUpdate) {\n        let b = false;\n        for (let y = 0; y < rows.length; y++) {\n            const height = Math.max(rows[y].height, rows[y].minimumHeight);\n            for (let x = 0; x < rows[y].length; x++) {\n                const width = Math.max(columns[x].width, columns[x].minimumWidth);\n                const cell = rows[y].cells[x];\n                if (cell.isMasterCellOfRowCountOne && !(0, vline_1.nearlyEqual)(cell.height, height)) {\n                    b = true;\n                    if (withUpdate) {\n                        debugger_1.Debugger.updateLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.height} != ${height}`);\n                        cell.height = height;\n                    }\n                    if (!withUpdate && b) {\n                        debugger_1.Debugger.updateFlagLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.height} != ${height}`);\n                        return b;\n                    }\n                }\n                if (cell.isMasterCellOfColumnCountOne && !(0, vline_1.nearlyEqual)(cell.width, width)) {\n                    b = true;\n                    if (withUpdate) {\n                        debugger_1.Debugger.updateLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.width} != ${width} y = ${y}`);\n                        cell.width = width;\n                    }\n                    if (!withUpdate && b) {\n                        debugger_1.Debugger.updateFlagLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.width} != ${width} y = ${y}`);\n                        return true;\n                    }\n                }\n                if (!cell.isMasterCellOfRowCountOne) {\n                    b = cell.tryUpdateWithUpdateFlag(withUpdate) || b;\n                    if (!withUpdate && b) {\n                        debugger_1.Debugger.updateFlagLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.tryUpdateWithUpdateFlag.name} x = ${x}`);\n                        return b;\n                    }\n                }\n                if (!cell.isMasterCellOfColumnCountOne) {\n                    b = cell.tryUpdateWithUpdateFlag(withUpdate) || b;\n                    if (!withUpdate && b) {\n                        debugger_1.Debugger.updateFlagLog(cell, UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns, `${cell.tryUpdateWithUpdateFlag.name} y = ${y}`);\n                        return b;\n                    }\n                }\n            }\n        }\n        return b;\n    }\n    static relocateCellsAfterUpdatingCellSize(rows, columns, withUpdate) {\n        let b = false;\n        let height = 0;\n        for (let i = 0; i < rows.length; i++) {\n            b = rows[i].setYWithUpdate(height, withUpdate) || b;\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(rows[i], UpdateTable.relocateCellsAfterUpdatingCellSize, rows[i].setYWithUpdate.name);\n                return b;\n            }\n            height += rows[i].height;\n        }\n        let width = 0;\n        for (let i = 0; i < columns.length; i++) {\n            b = columns[i].setXWithUpdate(width, withUpdate) || b;\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(columns[i], UpdateTable.relocateCellsAfterUpdatingCellSize, columns[i].setXWithUpdate.name);\n                return b;\n            }\n            width += columns[i].width;\n        }\n        return b;\n    }\n    static tryUpdateRowHeightAndColumnWidthWithUpdateFlag(rows, columns, allowShrink, withUpdate) {\n        let b = false;\n        for (let i = 0; i < rows.length; i++) {\n            b = rows[i].tryUpdateHeightWithUpdateFlag(allowShrink, withUpdate) || b;\n            if (!withUpdate && b) {\n                return b;\n            }\n        }\n        for (let i = 0; i < columns.length; i++) {\n            b = columns[i].tryUpdateWidthWithUpdateFlag(allowShrink, withUpdate) || b;\n            if (!withUpdate && b) {\n                return b;\n            }\n        }\n        return b;\n    }\n}\nexports.UpdateTable = UpdateTable;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/table_helpers/update_table.ts?");

/***/ }),

/***/ "./src/objects/z_abstract_edge.ts":
/*!****************************************!*\
  !*** ./src/objects/z_abstract_edge.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZAbstractEdge = void 0;\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst common_functions_1 = __webpack_require__(/*! ./graph_helpers/common_functions */ \"./src/objects/graph_helpers/common_functions.ts\");\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./src/html/enum_extension.ts\");\nconst element_builder_1 = __webpack_require__(/*! ./element_builder */ \"./src/objects/element_builder.ts\");\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\nconst html_1 = __webpack_require__(/*! ../html */ \"./src/html/index.ts\");\nconst z_observer_1 = __webpack_require__(/*! ./z_observer */ \"./src/objects/z_observer.ts\");\n//import { Direction } from \"readline\";\nclass ZAbstractEdge extends z_object_1.ZObject {\n    constructor(svgbox) {\n        super(svgbox);\n        this.connectPositionChangedFunc = () => {\n            //this.update();\n        };\n        this.updateAttributes.push(AttributeNames.beginNodeName);\n        this.updateAttributes.push(AttributeNames.endNodeName);\n        const pathClass = this.svgSurface.getAttribute(\"class\");\n        if (pathClass == DefaultClassNames.defaultSurfaceClass) {\n            this.svgSurface.setAttribute(\"class\", DefaultClassNames.defaultPathSurfaceClass);\n        }\n        this.svgPath.id = `path-${this.objectID}`;\n    }\n    createSurface(svgbox, option = {}) {\n        if (option.surfaceClass === undefined)\n            option.surfaceClass = DefaultClassNames.defaultEdgePathClass;\n        const path = (0, element_builder_1.createPath)(this.svgGroup, 0, 0, 0, 0, option.surfaceClass, option.surfaceStyle);\n        path.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Surface);\n        this._svgSurface = path;\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        const edgeColor = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke\");\n        const edgeColor2 = edgeColor == null ? undefined : edgeColor;\n        const strokeWidth = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke-width\");\n        const strokeWidth2 = strokeWidth == null ? undefined : strokeWidth;\n        const style = getComputedStyle(this.svgGroup);\n        const markerStart = style.getPropertyValue(StyleNames.EdgeStyleNames.markerStart);\n        const markerEnd = style.getPropertyValue(StyleNames.EdgeStyleNames.markerEnd);\n        if (markerStart.length != 0)\n            this.markerStart = ZAbstractEdge.createStartMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\n        if (markerEnd.length != 0)\n            this.markerEnd = ZAbstractEdge.createEndMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\n        const x1 = ElementExtension._getAttributeNumber(source, AttributeNames.x1, true);\n        const x2 = ElementExtension._getAttributeNumber(source, AttributeNames.x2, true);\n        const y1 = ElementExtension._getAttributeNumber(source, AttributeNames.y1, true);\n        const y2 = ElementExtension._getAttributeNumber(source, AttributeNames.y2, true);\n        if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {\n            this.pathPoints = [[x1, y1], [x2, y2]];\n        }\n        const beginVertex = ElementExtension._getAttribute(source, AttributeNames.beginVertex, true);\n        const endVertex = ElementExtension._getAttribute(source, AttributeNames.endVertex, true);\n        if (beginVertex != null) {\n            this.beginVertexID = beginVertex;\n        }\n        if (endVertex != null) {\n            this.endVertexID = endVertex;\n        }\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZAbstractEdgeAttributes) {\n\n        super.setBasicOption(option);\n\n        const edgeColor = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke\");\n        const edgeColor2 = edgeColor == null ? undefined : edgeColor;\n        const strokeWidth = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke-width\");\n        const strokeWidth2 = strokeWidth == null ? undefined : strokeWidth;\n\n        const style = getComputedStyle(this.svgGroup);\n        const markerStart = style.getPropertyValue(StyleNames.markerStart);\n        const markerEnd = style.getPropertyValue(StyleNames.markerEnd);\n\n        if (markerStart.length != 0) this.markerStart = ZAbstractEdge.createStartMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\n        if (markerEnd.length != 0) this.markerEnd = ZAbstractEdge.createEndMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\n\n        if (option.x1 !== undefined && option.y1 !== undefined && option.x2 !== undefined && option.y2 !== undefined) {\n            this.pathPoints = [[option.x1!, option.y1!], [option.x2!, option.y2!]];\n        }\n\n\n        if (typeof option.beginVertex == \"object\") {\n            if (option.beginVertex instanceof ZVertex) this.beginVertex = option.beginVertex;\n        } else if (typeof option.beginVertex == \"string\") {\n            this.beginVertexID = option.beginVertex;\n        }\n\n        if (typeof option.endVertex == \"object\") {\n            if (option.endVertex instanceof ZVertex) this.endVertex = option.endVertex;\n        } else if (typeof option.endVertex == \"string\") {\n            this.endVertexID = option.endVertex;\n        }\n\n    }\n    */\n    get edgeType() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.EdgeStyleNames.edgeType, \"none\");\n        if (b == \"straight\") {\n            return \"straight\";\n        }\n        else if (b == \"elbow\") {\n            return \"elbow\";\n        }\n        else if (b == \"curve\") {\n            return \"curve\";\n        }\n        else {\n            return \"none\";\n        }\n        /*\n        if (b == undefined) {\n            return false;\n        } else {\n            return b;\n        }\n        */\n    }\n    set edgeType(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.edgeType, value);\n        //this.svgGroup.setPropertyStyleValue(AttributeNames.Style.autoSizeShapeToFitText, value ? \"true\" : \"false\");\n    }\n    get svgPath() {\n        return this.svgSurface;\n    }\n    get degree() {\n        const rad = Math.atan2(this.y2 - this.y1, this.x2 - this.x1);\n        const degree = (180 * rad) / Math.PI;\n        return degree;\n    }\n    get childrenStableFlag() {\n        const b = this.svgPath.getAttribute(z_observer_1.ObjectStableFlagName);\n        return b == \"true\";\n    }\n    /**\n     * この辺を廃棄します。廃棄した辺はグラフから取り除かれます。\n     */\n    dispose() {\n        this.beginVertex = null;\n        this.endVertex = null;\n    }\n    get coordinateType() {\n        return \"group00\";\n    }\n    get defaultClassName() {\n        return DefaultClassNames.defaultEdgeClass;\n    }\n    get hasSize() {\n        return false;\n    }\n    get graph() {\n        return (0, common_functions_1.getGraph)(this);\n    }\n    get beginVertexID() {\n        return this.svgGroup.getAttribute(AttributeNames.beginNodeName);\n    }\n    set beginVertexID(v) {\n        if (v == null) {\n            this.svgGroup.removeAttribute(AttributeNames.beginNodeName);\n        }\n        else {\n            this.svgGroup.setAttribute(AttributeNames.beginNodeName, v);\n        }\n        const svgsvg = html_1.HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvg != null) {\n            const manager = svgsvg._manager;\n            if (manager != undefined) {\n                manager.registerBeginVertexID(this, v);\n            }\n        }\n    }\n    /**\n     * svgPathのstyle:strokeを返します。\n     */\n    get lineColor() {\n        if (this.svgPath != null) {\n            return ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"black\");\n        }\n        else {\n            return null;\n        }\n    }\n    get endVertexID() {\n        return this.svgGroup.getAttribute(AttributeNames.endNodeName);\n    }\n    set endVertexID(v) {\n        if (v == null) {\n            this.svgGroup.removeAttribute(AttributeNames.endNodeName);\n        }\n        else {\n            this.svgGroup.setAttribute(AttributeNames.endNodeName, v);\n        }\n        const svgsvg = html_1.HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvg != null) {\n            const manager = svgsvg._manager;\n            if (manager != undefined) {\n                manager.registerEndVertexID(this, v);\n            }\n        }\n    }\n    /*\n    protected updateSurface() {\n        this.updateDashArray();\n        if (this.markerStart != null) {\n            var node = <SVGPolygonElement>this.markerStart.firstChild;\n            if (this.lineColor != null) {\n                node.setAttribute(\"fill\", this.lineColor);\n            }\n        }\n        if (this.markerEnd != null) {\n            var node = <SVGPolygonElement>this.markerEnd.firstChild;\n            if (this.lineColor != null) {\n                node.setAttribute(\"fill\", this.lineColor);\n            }\n        }\n\n\n    }\n\n    private updateDashArray() {\n\n        this.hasConnectedObserverFunction = false;\n        const dashStyle = this.msoDashStyle;\n        if (dashStyle != null) {\n            updateAppropriateDashArray(this.svgPath);\n        }\n        this.hasConnectedObserverFunction = true;\n    }\n    */\n    /**\n     * この辺のテキストがパスに沿って均等に描画される状態ならばTrueを返します。\n     */\n    get pathTextAlignment() {\n        const value = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.EdgeStyleNames.pathTextAlignment, \"center\");\n        return enums_1.PathTextAlighnment.toPathTextAlighnment(value);\n    }\n    set pathTextAlignment(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.pathTextAlignment, value);\n    }\n    get pathPoints() {\n        const dAttr = this.svgPath.getAttribute(\"d\");\n        if (dAttr == null)\n            throw Error(\"error\");\n        const r = [];\n        if (dAttr.length > 0) {\n            const d = dAttr.split(\" \");\n            let i = 0;\n            while (i < d.length) {\n                if (d[i] == \"M\") {\n                    r.push([(0, vline_1.round100)(Number(d[i + 1])), (0, vline_1.round100)(Number(d[i + 2]))]);\n                    i += 3;\n                }\n                else if (d[i] == \"L\") {\n                    r.push([(0, vline_1.round100)(Number(d[i + 1])), (0, vline_1.round100)(Number(d[i + 2]))]);\n                    i += 3;\n                }\n                else if (d[i] == \"Q\") {\n                    r.push([(0, vline_1.round100)(Number(d[i + 1])), (0, vline_1.round100)(Number(d[i + 2]))]);\n                    r.push([(0, vline_1.round100)(Number(d[i + 3])), (0, vline_1.round100)(Number(d[i + 4]))]);\n                    i += 5;\n                }\n                else {\n                    throw Error(\"path points parse error/\" + dAttr + \"/\" + dAttr.length);\n                }\n            }\n            return r;\n        }\n        else {\n            return r;\n        }\n    }\n    set pathPoints(points) {\n        points.forEach((v) => {\n            if (v[0] === undefined) {\n                throw new exceptions_1.UndefinedError();\n            }\n        });\n        let path = \"\";\n        if (this.edgeType == \"elbow\") {\n            path += `M ${points[0][0]} ${points[0][1]} `;\n            for (let i = 1; i < points.length - 1; i++) {\n                path += `L ${points[i][0]} ${points[i][1]} `;\n            }\n            path += `L ${points[points.length - 1][0]} ${points[points.length - 1][1]}`;\n        }\n        else {\n            if (points.length == 2) {\n                const [x1, y1] = points[0];\n                const [x2, y2] = points[1];\n                path = (0, vline_1.escapeWithRound100) `M ${x1} ${y1} L ${x2} ${y2}`;\n            }\n            else if (points.length == 3) {\n                const [x1, y1] = points[0];\n                const [x2, y2] = points[2];\n                const [cx1, cy1] = points[1];\n                path = (0, vline_1.escapeWithRound100) `M ${x1} ${y1} Q ${cx1} ${cy1} ${x2} ${y2}`;\n            }\n            else if (points.length == 1) {\n                throw Error(\"path points ivnalid error\");\n            }\n            else {\n                path = (0, vline_1.escapeWithRound100) `M ${0} ${0} L ${0} ${0}`;\n            }\n        }\n        const prevPath = this.svgPath.getAttribute(\"d\");\n        if (prevPath == null || path != prevPath) {\n            this.svgPath.setAttribute(\"d\", path);\n        }\n    }\n    /**\n    開始接点を返します。\n    */\n    get beginVertex() {\n        if (this.beginVertexID == null) {\n            return null;\n        }\n        else {\n            return z_object_1.ZObject.getObjectFromIDOrObjectID(this.beginVertexID);\n        }\n    }\n    /**\n    開始接点を設定します。\n    */\n    set beginVertex(value) {\n        if (value == null) {\n            this.beginVertexID = null;\n        }\n        else {\n            this.beginVertexID = value.objectID;\n        }\n        //this.update();\n    }\n    /**\n    終了接点を返します。\n    */\n    get endVertex() {\n        if (this.endVertexID == null) {\n            return null;\n        }\n        else {\n            return z_object_1.ZObject.getObjectFromIDOrObjectID(this.endVertexID);\n        }\n    }\n    /**\n    終了接点を設定します。\n    */\n    set endVertex(value) {\n        if (value == null) {\n            this.endVertexID = null;\n        }\n        else {\n            this.endVertexID = value.objectID;\n        }\n        //this.update();\n    }\n    /**\n        開始位置のX座標を返します。\n        */\n    get x1() {\n        return this.pathPoints[0][0];\n    }\n    set x1(value) {\n        const p = this.pathPoints;\n        p[0][0] = value;\n        this.pathPoints = p;\n    }\n    /**\n    開始位置のY座標を返します。\n    */\n    get y1() {\n        return this.pathPoints[0][1];\n    }\n    set y1(value) {\n        const p = this.pathPoints;\n        p[0][1] = value;\n        this.pathPoints = p;\n    }\n    /**\n    終了位置のX座標を返します。\n    */\n    get x2() {\n        const d = this.pathPoints;\n        return d[d.length - 1][0];\n    }\n    set x2(value) {\n        const p = this.pathPoints;\n        p[p.length - 1][0] = value;\n        this.pathPoints = p;\n    }\n    /**\n    終了位置のY座標を返します。\n    */\n    get y2() {\n        const d = this.pathPoints;\n        return d[d.length - 1][1];\n    }\n    set y2(value) {\n        const p = this.pathPoints;\n        p[p.length - 1][1] = value;\n        this.pathPoints = p;\n    }\n    /**\n    開始接点の接続位置を返します。\n    */\n    get beginConnectorType() {\n        const p = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.beginConnectorType);\n        const type = enums_1.ConnectorType.ToConnectorPosition(p);\n        if (type == enums_1.ConnectorType.Auto) {\n            if (this.graph != null) {\n                const dir = this.graph.direction;\n                if (dir != null) {\n                    if (dir == \"up\") {\n                        return enums_1.ConnectorType.Top;\n                    }\n                    else if (dir == \"left\") {\n                        return enums_1.ConnectorType.Left;\n                    }\n                    else if (dir == \"right\") {\n                        return enums_1.ConnectorType.Right;\n                    }\n                    else {\n                        return enums_1.ConnectorType.Bottom;\n                    }\n                }\n                else {\n                    return type;\n                }\n            }\n            else {\n                return type;\n            }\n        }\n        else {\n            return type;\n        }\n    }\n    /**\n    開始接点の接続位置を設定します。\n    */\n    set beginConnectorType(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.beginConnectorType, value);\n        //this.svgGroup.setAttribute(Edge.beginConnectorTypeName, ToStrFromConnectorPosition(value));\n    }\n    /**\n    終了接点の接続位置を返します。\n    */\n    get endConnectorType() {\n        const p = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.endConnectorType);\n        const type = enums_1.ConnectorType.ToConnectorPosition(p);\n        if (type == enums_1.ConnectorType.Auto) {\n            if (this.graph != null) {\n                const dir = this.graph.direction;\n                if (dir != null) {\n                    if (dir == \"up\") {\n                        return enums_1.ConnectorType.Bottom;\n                    }\n                    else if (dir == \"left\") {\n                        return enums_1.ConnectorType.Right;\n                    }\n                    else if (dir == \"right\") {\n                        return enums_1.ConnectorType.Left;\n                    }\n                    else {\n                        return enums_1.ConnectorType.Top;\n                    }\n                }\n                else {\n                    return type;\n                }\n            }\n            else {\n                return type;\n            }\n        }\n        else {\n            return type;\n        }\n    }\n    /**\n    終了接点の接続位置を設定します。\n    */\n    set endConnectorType(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.endConnectorType, value);\n    }\n    /**\n     * 矢印オブジェクトを作成します。\n     */\n    static createMark(option = {}) {\n        var [marker, path] = SVG.createMarker(option);\n        if (option.isEnd != undefined && option.isEnd) {\n            path.setAttribute(\"transform\", \"rotate(180,5,5)\");\n            marker.setAttribute(\"refX\", \"0\");\n        }\n        marker.id = `marker-${ZAbstractEdge.markerCounter++}`;\n        return marker;\n    }\n    static createStartMarker(option = {}) {\n        const option2 = { className: option.className, strokeWidth: option.strokeWidth, color: option.color, isEnd: true };\n        return this.createMark(option2);\n    }\n    static createEndMarker(option = {}) {\n        return this.createMark(option);\n    }\n    /**\n         * 開始位置の矢印オブジェクトを返します。\n         */\n    get markerStart() {\n        if (this.svgPath != null) {\n            var p = this.svgPath.getAttribute(\"marker-start\");\n            if (p != null) {\n                const str = p.substring(5, p.length - 1);\n                const ele = document.getElementById(str);\n                return ele;\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * 開始位置の矢印オブジェクトを設定します。\n     * @param value 代入するSVGMarkerElementもしくはNull\n     */\n    set markerStart(value) {\n        if (this.svgPath != null) {\n            if (value == null) {\n                this.svgPath.removeAttribute(\"marker-start\");\n            }\n            else {\n                this.svgGroup.appendChild(value);\n                this.svgPath.setAttribute(\"marker-start\", `url(#${value.id})`);\n            }\n        }\n    }\n    /**\n     * 終了位置の矢印オブジェクトを返します。\n     */\n    get markerEnd() {\n        if (this.svgPath != null) {\n            var p = this.svgPath.getAttribute(\"marker-end\");\n            if (p != null) {\n                const str = p.substring(5, p.length - 1);\n                const ele = document.getElementById(str);\n                return ele;\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    set markerEnd(value) {\n        if (this.svgPath != null) {\n            if (value == null) {\n                this.svgPath.removeAttribute(\"marker-end\");\n            }\n            else {\n                this.svgGroup.appendChild(value);\n                this.svgPath.setAttribute(\"marker-end\", `url(#${value.id})`);\n            }\n        }\n    }\n    get msoDashStyle() {\n        if (this.svgSurface != null) {\n            const dashStyle = ElementExtension.getPropertyStyleValue(this.svgSurface, StyleNames.msoDashStyleName);\n            if (dashStyle != null) {\n                return enums_1.msoDashStyle.toMSODashStyle(dashStyle);\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    set msoDashStyle(value) {\n        if (this.svgSurface != null) {\n            if (enums_1.msoDashStyle == null) {\n                this.svgSurface.style.removeProperty(StyleNames.msoDashStyleName);\n            }\n            else {\n                ElementExtension.setPropertyStyleValue(this.svgSurface, StyleNames.msoDashStyleName, value);\n            }\n        }\n    }\n    removeVertexEvent(vertex) {\n        vertex.svgGroup.removeEventListener(AttributeNames.connectPositionChangedEventName, this.connectPositionChangedFunc);\n    }\n    addVertexEvent(vertex) {\n        vertex.svgGroup.addEventListener(AttributeNames.connectPositionChangedEventName, this.connectPositionChangedFunc);\n    }\n    tryUpdateConnectorWithUpdateFlag(withUpdate) {\n        let b = false;\n        const svgsvg = html_1.HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvg != null) {\n            const manager = svgsvg._manager;\n            if (manager != null) {\n                const oldBeginVertexID = manager.getBeginVertexID(this);\n                const oldEndVertexID = manager.getEndVertexID(this);\n                if (this.beginVertexID != oldBeginVertexID) {\n                    b = true;\n                    if (!withUpdate) {\n                        debugger_1.Debugger.updateFlagLog(this, this.tryUpdateConnectorWithUpdateFlag, `this.beginVertex != oldBeginVertex`);\n                        return b;\n                    }\n                    if (withUpdate) {\n                        if (oldBeginVertexID != null) {\n                            const oldBeginVertex = z_object_1.ZObject.getObjectFromIDOrObjectID(oldBeginVertexID);\n                            if (oldBeginVertex != null && oldBeginVertex instanceof z_vertex_1.ZVertex) {\n                                this.removeVertexEvent(oldBeginVertex);\n                            }\n                        }\n                        if (this.beginVertex != null) {\n                            this.addVertexEvent(this.beginVertex);\n                        }\n                    }\n                }\n                if (this.endVertexID != oldEndVertexID) {\n                    b = true;\n                    if (!withUpdate) {\n                        debugger_1.Debugger.updateFlagLog(this, this.tryUpdateConnectorWithUpdateFlag, `this.endVertex != oldEndVertex`);\n                        return b;\n                    }\n                    if (withUpdate) {\n                        if (oldEndVertexID != null) {\n                            const oldEndVertex = z_object_1.ZObject.getObjectFromIDOrObjectID(oldEndVertexID);\n                            if (oldEndVertex != null && oldEndVertex instanceof z_vertex_1.ZVertex) {\n                                this.removeVertexEvent(oldEndVertex);\n                            }\n                        }\n                        if (this.endVertex != null) {\n                            this.addVertexEvent(this.endVertex);\n                        }\n                    }\n                }\n            }\n        }\n        return b;\n    }\n    tryUpdateDashArrayWithUpdateFlag(withUpdate) {\n        let b = false;\n        this.hasConnectedObserverFunction = false;\n        const dashStyle = this.msoDashStyle;\n        if (dashStyle != null) {\n            b = (0, enum_extension_1.tryUpdateAppropriateDashArrayWithUpdateFlag)(this.svgPath, withUpdate);\n        }\n        this.hasConnectedObserverFunction = true;\n        return b;\n    }\n    updateSurfaceWithUpdateFlag(withUpdate) {\n        let b = this.tryUpdateDashArrayWithUpdateFlag(withUpdate);\n        if (!withUpdate && b) {\n            debugger_1.Debugger.updateFlagLog(this, this.updateSurfaceWithUpdateFlag, `${this.tryUpdateDashArrayWithUpdateFlag.name}`);\n        }\n        if (this.markerStart != null) {\n            var node = this.markerStart.firstChild;\n            if (this.lineColor != null) {\n                const fill = node.getAttribute(\"fill\");\n                if (fill != this.lineColor) {\n                    b = true;\n                    if (withUpdate) {\n                        node.setAttribute(\"fill\", this.lineColor);\n                    }\n                    else {\n                        debugger_1.Debugger.updateFlagLog(this, this.updateSurfaceWithUpdateFlag, \"fill != this.lineColor (markerStart)\");\n                        return b;\n                    }\n                }\n            }\n        }\n        if (this.markerEnd != null) {\n            var node = this.markerEnd.firstChild;\n            if (this.lineColor != null) {\n                const fill = node.getAttribute(\"fill\");\n                if (fill != this.lineColor) {\n                    b = true;\n                    if (withUpdate) {\n                        node.setAttribute(\"fill\", this.lineColor);\n                    }\n                    else {\n                        debugger_1.Debugger.updateFlagLog(this, this.updateSurfaceWithUpdateFlag, \"fill != this.lineColor (markerEnd)\");\n                        return b;\n                    }\n                }\n            }\n        }\n        return b;\n    }\n    updateLocationWithUpdateFlag(withUpdate) {\n        let b = false;\n        const [x1, y1] = this.beginConnectoPosition;\n        const [x2, y2] = this.endConnectorPosition;\n        const equalFunc = (prevObj, newObj) => {\n            if (prevObj.length != newObj.length) {\n                return false;\n            }\n            else {\n                for (let i = 0; i < prevObj.length; i++) {\n                    if (!(0, vline_1.nearlyEqual)(prevObj[i][0], newObj[i][0])) {\n                        return false;\n                    }\n                    else if (!(0, vline_1.nearlyEqual)(prevObj[i][1], newObj[i][1])) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        const arrayRound100 = (obj) => {\n            for (let i = 0; i < obj.length; i++) {\n                obj[i] = [(0, vline_1.round100)(obj[i][0]), (0, vline_1.round100)(obj[i][1])];\n            }\n        };\n        if (this.edgeType == \"elbow\") {\n            const points = new Array();\n            const elbowPositions = this.elbowCalculator(x1, y1, this.beginConnectorType, x2, y2, this.endConnectorType);\n            points.push([x1, y1]);\n            elbowPositions.forEach((v) => points.push(v));\n            points.push([x2, y2]);\n            arrayRound100(points);\n            if (!equalFunc(this.pathPoints, points)) {\n                b = true;\n                if (withUpdate) {\n                    this.pathPoints = points;\n                }\n            }\n        }\n        else if (this.edgeType == \"curve\") {\n        }\n        else {\n            const points = new Array();\n            this.pathPoints.forEach((v) => points.push(v));\n            points[0] = [x1, y1];\n            points[points.length - 1] = [x2, y2];\n            arrayRound100(points);\n            if (!equalFunc(this.pathPoints, points)) {\n                b = true;\n                if (withUpdate) {\n                    this.pathPoints = points;\n                }\n            }\n        }\n        //if (points[0][0] == undefined) throw new UndefinedError();\n        //this.pathPoints = points;\n        return b;\n    }\n    getUpdateFlag() {\n        const b1 = super.getUpdateFlag();\n        if (b1) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${super.getUpdateFlag.name}`);\n        }\n        const b2 = this.tryUpdateConnectorWithUpdateFlag(false);\n        if (b2) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.tryUpdateConnectorWithUpdateFlag.name}`);\n        }\n        const b3 = this.updateSurfaceWithUpdateFlag(false);\n        if (b3) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.updateSurfaceWithUpdateFlag.name}`);\n        }\n        const b4 = this.updateLocationWithUpdateFlag(false);\n        if (b4) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.updateLocationWithUpdateFlag.name}`);\n        }\n        return b1 || b2 || b3 || b4;\n    }\n    update() {\n        super.update();\n        const b2 = this.tryUpdateConnectorWithUpdateFlag(true);\n        const b3 = this.updateSurfaceWithUpdateFlag(true);\n        const b4 = this.updateLocationWithUpdateFlag(true);\n    }\n    /*\n    protected updateConnectorInfo() {\n        const oldBeginVertex = ZAbstractEdge.getConnectedVertexFromDic(this, true);\n        const oldEndVertex = ZAbstractEdge.getConnectedVertexFromDic(this, false);\n        if (this.beginVertex != oldBeginVertex) {\n            if (oldBeginVertex != null) {\n\n                this.removeVertexEvent(oldBeginVertex);\n                if (oldBeginVertex.outcomingEdges.indexOf(this) != -1) {\n                    oldBeginVertex.removeOutcomingEdge(this);\n                }\n            }\n\n            if (this.beginVertex != null) {\n                this.addVertexEvent(this.beginVertex);\n                if (this.beginVertex.outcomingEdges.indexOf(this) == -1) {\n                    this.beginVertex.insertOutcomingEdge(this);\n                }\n            }\n            ZAbstractEdge.setConnectedVertexFromDic(this, true);\n        }\n        if (this.endVertex != oldEndVertex) {\n            if (oldEndVertex != null) {\n                this.removeVertexEvent(oldEndVertex);\n                if (oldEndVertex.incomingEdges.indexOf(this) != -1) {\n                    oldEndVertex.removeIncomingEdge(this);\n                }\n            }\n\n            if (this.endVertex != null) {\n                this.addVertexEvent(this.endVertex);\n                if (this.endVertex.incomingEdges.indexOf(this) == -1) {\n                    this.endVertex.insertIncomingEdge(this);\n                }\n            }\n            ZAbstractEdge.setConnectedVertexFromDic(this, false);\n        }\n        //if(this.beginVertexID != )\n    }\n    */\n    get beginConnectoPosition() {\n        const [cx1, cy1] = this.beginVertex != null ? [this.beginVertex.cx, this.beginVertex.cy] : [this.x1, this.y1];\n        const [cx2, cy2] = this.endVertex != null ? [this.endVertex.cx, this.endVertex.cy] : [this.x2, this.y2];\n        const [x1, y1] = this.beginVertex != null ? this.beginVertex.getContactPosition(this.beginConnectorType, cx2, cy2) : [cx1, cy1];\n        return [x1, y1];\n    }\n    get endConnectorPosition() {\n        const [cx1, cy1] = this.beginVertex != null ? [this.beginVertex.cx, this.beginVertex.cy] : [this.x1, this.y1];\n        const [cx2, cy2] = this.endVertex != null ? [this.endVertex.cx, this.endVertex.cy] : [this.x2, this.y2];\n        const [x2, y2] = this.endVertex != null ? this.endVertex.getContactPosition(this.endConnectorType, cx1, cy1) : [cx2, cy2];\n        return [x2, y2];\n    }\n    elbowCalculator(x1, y1, type1, x2, y2, type2, recursion = 0) {\n        if (recursion > 6) {\n            return [];\n        }\n        const xgap = Math.abs(x2 - x1) / 2;\n        const ygap = Math.abs(y2 - y1) / 2;\n        const gap = 30;\n        let area = \"leftup\";\n        if (x1 < x2) {\n            if (y1 < y2) {\n                area = \"rightdown\";\n            }\n            else {\n                area = \"rightup\";\n            }\n        }\n        else {\n            if (y1 < y2) {\n                area = \"leftdown\";\n            }\n            else {\n                area = \"leftup\";\n            }\n        }\n        const right = area == \"rightdown\" || area == \"rightup\";\n        const left = area == \"leftdown\" || area == \"leftup\";\n        const up = area == \"rightup\" || area == \"leftup\";\n        const down = area == \"rightdown\" || area == \"leftdown\";\n        if (type1 == enums_1.ConnectorType.Bottom) {\n            const x3 = x1;\n            const type3 = right ? enums_1.ConnectorType.Right : enums_1.ConnectorType.Left;\n            let y3 = 0;\n            if (type2 == enums_1.ConnectorType.Top) {\n                if (x1 == x2 && down) {\n                    return [];\n                }\n                else {\n                    y3 = y1 + ygap;\n                }\n            }\n            else if (type2 == enums_1.ConnectorType.Left) {\n                y3 = (area == \"rightdown\") ? y2 : y1 + gap;\n            }\n            else if (type2 == enums_1.ConnectorType.Right) {\n                y3 = (area == \"leftdown\") ? y2 : y1 + ygap;\n            }\n            else {\n                y3 = down ? y2 + gap : y1 + gap;\n            }\n            const arr = this.elbowCalculator(x3, y3, type3, x2, y2, type2, recursion + 1);\n            arr.unshift([x3, y3]);\n            return arr;\n        }\n        else if (type1 == enums_1.ConnectorType.Right) {\n            const y3 = y1;\n            const type3 = up ? enums_1.ConnectorType.Top : enums_1.ConnectorType.Bottom;\n            let x3 = 0;\n            if (type2 == enums_1.ConnectorType.Top) {\n                x3 = area == \"rightdown\" ? x2 : x1 + gap;\n            }\n            else if (type2 == enums_1.ConnectorType.Bottom) {\n                x3 = area == \"rightup\" ? x2 : x1 + xgap;\n            }\n            else if (type2 == enums_1.ConnectorType.Left) {\n                if (y1 == y2 && right) {\n                    return [];\n                }\n                else {\n                    x3 = x1 + xgap;\n                }\n            }\n            else {\n                x3 = right ? x2 + gap : x1 + gap;\n            }\n            const arr = this.elbowCalculator(x3, y3, type3, x2, y2, type2, recursion + 1);\n            arr.unshift([x3, y3]);\n            return arr;\n        }\n        else if (type1 == enums_1.ConnectorType.Left) {\n            const y3 = y1;\n            const type3 = up ? enums_1.ConnectorType.Top : enums_1.ConnectorType.Bottom;\n            let x3 = 0;\n            if (type2 == enums_1.ConnectorType.Top) {\n                x3 = area == \"leftdown\" ? x2 : x1 - gap;\n            }\n            else if (type2 == enums_1.ConnectorType.Bottom) {\n                x3 = area == \"leftup\" ? x2 : x1 - gap;\n            }\n            else if (type2 == enums_1.ConnectorType.Right) {\n                if (y1 == y2 && left) {\n                    return [];\n                }\n                else {\n                    x3 = x1 - gap;\n                }\n            }\n            else {\n                x3 = right ? x1 - gap : x2 - gap;\n            }\n            const arr = this.elbowCalculator(x3, y3, type3, x2, y2, type2, recursion + 1);\n            arr.unshift([x3, y3]);\n            return arr;\n        }\n        else {\n            const x3 = x1;\n            const type3 = right ? enums_1.ConnectorType.Right : enums_1.ConnectorType.Left;\n            let y3 = 0;\n            if (type2 == enums_1.ConnectorType.Bottom) {\n                if (x1 == x2 && up) {\n                    return [];\n                }\n                else {\n                    y3 = y1 - gap;\n                }\n            }\n            else if (type2 == enums_1.ConnectorType.Left) {\n                y3 = (area == \"rightup\") ? y2 : y1 - gap;\n            }\n            else if (type2 == enums_1.ConnectorType.Right) {\n                y3 = (area == \"leftup\") ? y2 : y1 - gap;\n            }\n            else {\n                //y3 = up ? y2 + gap : y1 - gap;\n                y3 = y1 - gap;\n            }\n            const arr = this.elbowCalculator(x3, y3, type3, x2, y2, type2, recursion + 1);\n            arr.unshift([x3, y3]);\n            return arr;\n        }\n    }\n}\nexports.ZAbstractEdge = ZAbstractEdge;\nZAbstractEdge.markerCounter = 0;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_abstract_edge.ts?");

/***/ }),

/***/ "./src/objects/z_abstract_text_edge.ts":
/*!*********************************************!*\
  !*** ./src/objects/z_abstract_text_edge.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZAbstractTextEdge = void 0;\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst virtual_text_1 = __webpack_require__(/*! ../interfaces/virtual_text */ \"./src/interfaces/virtual_text.ts\");\nconst z_abstract_edge_1 = __webpack_require__(/*! ./z_abstract_edge */ \"./src/objects/z_abstract_edge.ts\");\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst element_builder_1 = __webpack_require__(/*! ./element_builder */ \"./src/objects/element_builder.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\nconst z_observer_1 = __webpack_require__(/*! ./z_observer */ \"./src/objects/z_observer.ts\");\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\nclass ZAbstractTextEdge extends z_abstract_edge_1.ZAbstractEdge {\n    createSurface(svgbox, option = {}) {\n        super.createSurface(svgbox, option);\n        this.svgGroup.insertBefore(this.svgPath, this.svgText);\n    }\n    constructor(svgbox) {\n        super(svgbox);\n        this._isSpecialTextBox = false;\n        this.textObserverFunc = (x) => {\n            if (!this.isShown)\n                return;\n            if (!this.isLocated)\n                return;\n            let b = false;\n            for (let i = 0; i < x.length; i++) {\n                const p = x[i];\n                if (ZAbstractTextEdge.updateTextAttributes.some((v) => v == p.attributeName)) {\n                    b = true;\n                }\n                if (p.attributeName == null) {\n                    b = true;\n                }\n            }\n            if (b) {\n                //this.resetUnstableCounter();\n                //this.update();\n            }\n        };\n        this._svgText = (0, element_builder_1.createSVGText)(DefaultClassNames.defaultTextClass, undefined, \"text\");\n        this.svgGroup.appendChild(this.svgText);\n        this._textObserver = new MutationObserver(this.textObserverFunc);\n        const option2 = { childList: true, attributes: true, subtree: true };\n        this._textObserver.observe(this.svgText, option2);\n        this._isSpecialTextBox = true;\n        this.svgText.textContent = \"\";\n        this._svgTextPath = SVG.createTextPath2(undefined);\n        this.svgText.appendChild(this._svgTextPath);\n        this._svgTextPath.href.baseVal = `#${this.svgPath.id}`;\n        //if (this.type == ShapeObjectType.Edge) this.firstFunctionAfterInitialized();\n        //this.setAppropriateText();\n    }\n    get svgText() {\n        return this._svgText;\n    }\n    get svgTextPath() {\n        return this._svgTextPath;\n    }\n    get childrenStableFlag() {\n        const b1 = this.svgPath.getAttribute(z_observer_1.ObjectStableFlagName);\n        const b2 = this.svgText.getAttribute(z_observer_1.ObjectStableFlagName);\n        return b1 == \"true\" && b2 == \"true\";\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        z_textbox_1.ZTextBox.importTextFromSource(this.svgTextPath, null, source);\n        if (this.svgText != null) {\n            z_object_1.ZObject.setSubAttributes(this.svgText, source);\n        }\n    }\n    get readableTextFlag() {\n        const p = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.readableText);\n        if (p == \"true\") {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    set readableTextFlag(value) {\n        if (value) {\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.beginConnectorType, \"true\");\n        }\n        else {\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.EdgeStyleNames.beginConnectorType, \"false\");\n        }\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZAbstractTextEdgeAttributes) {\n\n        super.setBasicOption(option);\n        const textClass = CSS.createCSSClass(option.textClass);\n        const styleClass = CSS.createCSSClass(option.textStyle);\n        GOptions.setClassAndStyle(this.svgText, textClass, styleClass);\n        if (option.textClass === undefined) option.textClass = DefaultClassNames.defaultTextClass;\n\n        if (typeof option.text == \"string\") {\n            Extensions.setTextContent(this.svgTextPath, option.text);\n        } else if (Array.isArray(option.text)) {\n            SVGTextBox.constructSVGTextByHTMLElements(this.svgTextPath, option.text, false);\n\n        } else {\n\n        }\n    }\n    */\n    /*\n     static constructAttributes(e: Element, removeAttributes: boolean = false, output: GOptions.ZAbstractTextEdgeAttributes = {}): GOptions.ZAbstractTextEdgeAttributes {\n         ZAbstractEdge.constructAttributes(e, removeAttributes, output);\n         //output.isAutoSizeShapeToFitText = e.gtGetStyleBooleanWithUndefined(AttributeNames.Style.autoSizeShapeToFitText);\n         //const textChild = HTMLFunctions.getChildByNodeName(e, AttributeNames.textStyle);\n         output.textClass = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.textClass);\n         output.textStyle = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.textStyle);\n \n \n         if (e.children.length > 0) {\n             const tNodes = HTMLFunctions.getTNodes(e);\n             if (tNodes != null) {\n                 tNodes.forEach((v) => v.remove())\n                 output.text = tNodes;\n             }\n         } else if (e.innerHTML.length > 0) {\n             output.text = e.innerHTML;\n         }\n \n \n         if (removeAttributes) {\n             //e.removeAttribute(AttributeNames.text);\n             e.removeAttribute(AttributeNames.textClass);\n             e.removeAttribute(AttributeNames.textStyle);\n \n             (<any>e).style.removeProperty(StyleNames.autoSizeShapeToFitText);\n         }\n         return output;\n     }\n     */\n    get startOffset() {\n        return ElementExtension.gtGetAttributeNumber(this.svgTextPath, \"startOffset\", null);\n    }\n    set startOffset(value) {\n        if (value == null) {\n            this.svgTextPath.removeAttribute(\"startOffset\");\n        }\n        else {\n            ElementExtension.setAttributeNumber(this.svgTextPath, \"startOffset\", value);\n        }\n    }\n    get isShown() {\n        const b1 = super.isShown;\n        const b2 = true;\n        const b3 = HTMLFunctions.isShow(this.svgText);\n        return b1 && b2 && b3;\n    }\n    removeTextLengthAttributeOrGetUpdateFlag(withUpdate) {\n        let b = false;\n        if (this.svgText.hasAttribute(\"textLength\")) {\n            b = true;\n            if (withUpdate) {\n                this.svgText.removeAttribute(\"textLength\");\n            }\n        }\n        if (this.svgTextPath.hasAttribute(\"textLength\")) {\n            b = true;\n            if (withUpdate) {\n                this.svgTextPath.removeAttribute(\"textLength\");\n            }\n        }\n        if (this.svgText.hasAttribute(\"letter-spacing\")) {\n            b = true;\n            if (withUpdate) {\n                this.svgText.removeAttribute(\"letter-spacing\");\n            }\n        }\n        return b;\n    }\n    setRegularIntervalOrGetUpdateFlag(newTextPathLen, newTextWidth, withUpdate) {\n        let b = false;\n        const svgTextTextLength = ElementExtension.gtGetAttributeNumber(this.svgText, \"textLength\", null);\n        const svgTextPathTextLength = ElementExtension.gtGetAttributeNumber(this.svgTextPath, \"textLength\", null);\n        const svgTextLetterSpacing = ElementExtension.gtGetAttributeNumber(this.svgText, \"letter-spacing\", null);\n        if (newTextPathLen != svgTextTextLength) {\n            b = true;\n            if (withUpdate) {\n                ElementExtension.setAttributeNumber(this.svgText, \"textLength\", newTextPathLen);\n            }\n        }\n        if (newTextPathLen != svgTextPathTextLength) {\n            b = true;\n            if (withUpdate) {\n                ElementExtension.setAttributeNumber(this.svgTextPath, \"textLength\", newTextPathLen);\n            }\n        }\n        if (svgTextLetterSpacing != null) {\n            b = true;\n            if (withUpdate) {\n                this.svgText.removeAttribute(\"letter-spacing\");\n            }\n        }\n        return b;\n    }\n    /*\n    private removeTextLengthAttribute(): void {\n        if (this.svgText.hasAttribute(\"textLength\")) this.svgText.removeAttribute(\"textLength\");\n        if (this.svgTextPath.hasAttribute(\"textLength\")) this.svgTextPath.removeAttribute(\"textLength\");\n        if (this.svgText.hasAttribute(\"letter-spacing\")) this.svgText.removeAttribute(\"letter-spacing\");\n    }\n    private setRegularInterval(textPathLen: number, textWidth : number): void {\n        this.removeTextLengthAttribute();\n        ElementExtension.setAttributeNumber(this.svgText, \"textLength\", textPathLen);\n        ElementExtension.setAttributeNumber(this.svgTextPath, \"textLength\", textPathLen);\n    }\n    */\n    get isAppropriatelyReverseMode() {\n        const p = this.svgGroup.getAttribute(AttributeNames.isAppropriatelyReverseTextMode);\n        if (p == null) {\n            return false;\n        }\n        else {\n            return p == \"true\";\n        }\n        //return this.svgGroup.getAttribute(AttributeNames.appropriateEdgeText);\n    }\n    set isAppropriatelyReverseMode(v) {\n        this.svgGroup.setAttribute(AttributeNames.isAppropriatelyReverseTextMode, v.toString());\n    }\n    get side() {\n        return this.svgTextPath.getAttribute(\"side\");\n    }\n    set side(v) {\n        if (v == null) {\n            this.svgTextPath.removeAttribute(\"side\");\n        }\n        else {\n            this.svgTextPath.setAttribute(\"side\", v);\n        }\n    }\n    revTextForApp() {\n        if (this.side == \"left\" || this.side == null) {\n            this.side = \"right\";\n        }\n        else {\n            this.side = \"left\";\n        }\n        const tspans = new Array(0);\n        this.svgTextPath.children.item;\n        for (let i = this.svgTextPath.children.length; i >= 0; i--) {\n            const tspan = this.svgTextPath.children.item(i);\n            if (tspan instanceof SVGTSpanElement) {\n                tspans.push(tspan);\n            }\n        }\n        tspans.forEach((v) => v.remove());\n        tspans.forEach((v) => {\n            const text = v.textContent;\n            if (text != null) {\n                const revText = ZAbstractTextEdge.getRevString(text);\n                v.textContent = revText;\n            }\n            this.svgTextPath.appendChild(v);\n        });\n    }\n    static getRevString(text) {\n        let s = \"\";\n        for (let i = text.length - 1; i >= 0; i--) {\n            s += text[i];\n        }\n        return s;\n    }\n    get svgElements() {\n        const r = [];\n        r.push(this.svgGroup);\n        r.push(this.svgText);\n        return r;\n    }\n    hasDescendant(obj) {\n        const ids = this.svgElements.map((v) => v.getAttribute(AttributeNames.objectIDName)).filter((v) => v != null);\n        const id = obj.getAttribute(AttributeNames.objectIDName);\n        return ids.some((v) => v == id);\n    }\n    isDrawnText() {\n        const text = this.svgTextPath.textContent;\n        if (text == null || text.length == 0) {\n            return true;\n        }\n        else {\n            const len = this.svgTextPath.getComputedTextLength();\n            return len != 0;\n        }\n    }\n    /**\n     * 再描画します。\n     */\n    update() {\n        super.update();\n        /*\n        this.updateConnectorInfoOrGetUpdateFlag(true);\n        this.updateSurfaceOrGetUpdateFlag(true);\n        this.updateLocationOrGetUpdateFlag(true);\n        */\n        this.tryUpdateTextPathWithUpdateFlag(true);\n    }\n    getUpdateFlag() {\n        const b1 = super.getUpdateFlag();\n        if (b1) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${super.getUpdateFlag.name}`);\n        }\n        const b2 = this.tryUpdateTextPathWithUpdateFlag(false);\n        if (b2) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.tryUpdateTextPathWithUpdateFlag.name}`);\n        }\n        return b1 || b2;\n    }\n    tryUpdateTextPathWithUpdateFlag(withUpdate) {\n        const b1 = this.tryUpdateDYWithUpdateFlag(withUpdate);\n        if (!withUpdate && b1) {\n            debugger_1.Debugger.updateFlagLog(this, this.tryUpdateTextPathWithUpdateFlag, `${this.tryUpdateDYWithUpdateFlag.name}`);\n        }\n        /*\n        if (this.isAppropriatelyReverseMode) {\n            const degree = this.degree;\n            if (degree < -90 || degree > 90) {\n                //Rev\n                if (this.side == \"left\" || this.side == null) {\n                    this.revTextForApp();\n                }\n            } else {\n                if (this.side == \"right\") {\n                    this.revTextForApp();\n                }\n            }\n        }\n        */\n        /*\n        if (!HTMLFunctions.isShow(this.svgTextPath)) {\n            throw new Error();\n        }\n        */\n        const b2 = this.tryUpdatePathOffsetWithUpdateFlag(withUpdate);\n        if (!withUpdate && b2) {\n            debugger_1.Debugger.updateFlagLog(this, this.tryUpdateTextPathWithUpdateFlag, `${this.tryUpdatePathOffsetWithUpdateFlag.name}`);\n        }\n        const b3 = this.tryUpdateRotateAttributeWithUpdateFlag(withUpdate);\n        if (!withUpdate && b3) {\n            debugger_1.Debugger.updateFlagLog(this, this.tryUpdateTextPathWithUpdateFlag, `${this.tryUpdatePathOffsetWithUpdateFlag.name}`);\n        }\n        return b1 || b2 || b3;\n    }\n    tryUpdateRotateAttributeWithUpdateFlag(withUpdate) {\n        let b = false;\n        if (this.readableTextFlag) {\n            const rotateAttr = this.svgText.getAttribute(\"rotate\");\n            const oldRotate = rotateAttr == null ? 0 : parseInt(rotateAttr);\n            const degree = this.degree;\n            if (degree < -90 || degree > 90) {\n                if (oldRotate != 180) {\n                    b = true;\n                    if (withUpdate) {\n                        this.svgText.setAttribute(\"rotate\", \"180\");\n                    }\n                    else {\n                        debugger_1.Debugger.updateFlagLog(this, this.tryUpdateDYWithUpdateFlag, `oldRotate != newRotate`);\n                        return b;\n                    }\n                }\n            }\n            else {\n                if (oldRotate != 0) {\n                    b = true;\n                    if (withUpdate) {\n                        this.svgText.setAttribute(\"rotate\", \"0\");\n                    }\n                    else {\n                        debugger_1.Debugger.updateFlagLog(this, this.tryUpdateDYWithUpdateFlag, `oldRotate != newRotate`);\n                        return b;\n                    }\n                }\n            }\n        }\n        else {\n            if (this.svgText.hasAttribute(\"rotate\")) {\n                b = true;\n                if (withUpdate) {\n                    this.svgText.removeAttribute(\"rotate\");\n                }\n                else {\n                    debugger_1.Debugger.updateFlagLog(this, this.tryUpdateDYWithUpdateFlag, `oldRotate != newRotate`);\n                    return b;\n                }\n            }\n        }\n        return b;\n    }\n    tryUpdateDYWithUpdateFlag(withUpdate) {\n        let b = false;\n        const strokeWidth = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke-width\");\n        const oldDY = this.svgText.getAttribute(\"dy\");\n        let newDY = \"0\";\n        if (strokeWidth != null) {\n            const diffy = CommonFunctions.toPX(strokeWidth) + 3;\n            newDY = `-${diffy}`;\n        }\n        if (oldDY != newDY) {\n            b = true;\n            if (withUpdate) {\n                this.svgText.setAttribute(\"dy\", newDY);\n            }\n            else {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdateDYWithUpdateFlag, `oldDY != newDY`);\n                return b;\n            }\n        }\n        return b;\n    }\n    tryUpdatePathOffsetWithUpdateFlag(withUpdate) {\n        let b = false;\n        const region = (0, virtual_text_1.getVirtualRegion)(this.svgText);\n        const strWidth = (0, vline_1.round100)(region.width);\n        const pathLen = (0, vline_1.round100)(this.svgPath.getTotalLength());\n        if (this.pathTextAlignment == enums_1.PathTextAlighnment.regularInterval) {\n            const strCharCount = this.svgTextPath.textContent == null ? 0 : this.svgTextPath.textContent.length;\n            if (strWidth > 0) {\n                const paddingWidth = (0, vline_1.round100)(pathLen - strWidth);\n                if (strCharCount != 0) {\n                    const paddingUnit = (0, vline_1.round100)(paddingWidth / (strCharCount + 1));\n                    let textPathLen = (0, vline_1.round100)(pathLen - (paddingUnit * 2));\n                    if (textPathLen <= 0)\n                        textPathLen = 5;\n                    const _startOffset = this.startOffset;\n                    const xb = _startOffset == null || !(0, vline_1.nearlyEqual)(_startOffset, paddingUnit);\n                    if (xb) {\n                        b = true;\n                        if (withUpdate) {\n                            this.startOffset = paddingUnit;\n                        }\n                        else {\n                            debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, this.startOffset != paddingUnit`);\n                            return b;\n                        }\n                    }\n                    b = this.setRegularIntervalOrGetUpdateFlag(textPathLen, strWidth, withUpdate) || b;\n                    if (!withUpdate && b) {\n                        debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, ${this.setRegularIntervalOrGetUpdateFlag.name}`);\n                        return b;\n                    }\n                }\n            }\n        }\n        else if (this.pathTextAlignment == enums_1.PathTextAlighnment.end) {\n            b = this.removeTextLengthAttributeOrGetUpdateFlag(withUpdate);\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, ${this.removeTextLengthAttributeOrGetUpdateFlag.name}`);\n                return b;\n            }\n            const newStartOffset = (0, vline_1.round100)(this.side == \"right\" ? 0 : (pathLen - strWidth));\n            const _startOffset = this.startOffset;\n            const xb = _startOffset == null || !(0, vline_1.nearlyEqual)(_startOffset, newStartOffset);\n            if (xb) {\n                b = true;\n                if (withUpdate) {\n                    this.startOffset = newStartOffset;\n                }\n                else {\n                    debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, _startOffset == null || !nearlyEqual(_startOffset, newStartOffset)`);\n                    return b;\n                }\n            }\n        }\n        else if (this.pathTextAlignment == enums_1.PathTextAlighnment.center) {\n            b = this.removeTextLengthAttributeOrGetUpdateFlag(withUpdate);\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, ${this.removeTextLengthAttributeOrGetUpdateFlag.name}`);\n                return b;\n            }\n            const newStartOffset = (0, vline_1.round100)((pathLen / 2) - (strWidth / 2));\n            const _startOffset = this.startOffset;\n            const xb = _startOffset == null || !(0, vline_1.nearlyEqual)(_startOffset, newStartOffset);\n            if (xb) {\n                b = true;\n                if (withUpdate) {\n                    this.startOffset = newStartOffset;\n                }\n                else {\n                    debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, _startOffset == null || !nearlyEqual(_startOffset, newStartOffset)`);\n                    return b;\n                }\n            }\n            //こっちだとEdgeではおかしくなる\n            //this.svgTextPath.startOffset.baseVal.value = (pathLen - box.width)/2;                    \n        }\n        else {\n            b = this.removeTextLengthAttributeOrGetUpdateFlag(withUpdate);\n            if (!withUpdate && b) {\n                debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, ${this.removeTextLengthAttributeOrGetUpdateFlag.name}`);\n                return b;\n            }\n            const newStartOffset = (0, vline_1.round100)(this.side == \"right\" ? (pathLen - strWidth) : 0);\n            const _startOffset = this.startOffset;\n            const xb = _startOffset == null || !(0, vline_1.nearlyEqual)(_startOffset, newStartOffset);\n            if (xb) {\n                b = true;\n                if (withUpdate) {\n                    this.startOffset = newStartOffset;\n                }\n                else {\n                    debugger_1.Debugger.updateFlagLog(this, this.tryUpdatePathOffsetWithUpdateFlag, `pathTextAlignment = ${this.pathTextAlignment}, _startOffset == null || !nearlyEqual(_startOffset, newStartOffset)`);\n                    return b;\n                }\n            }\n        }\n        return b;\n    }\n    updateSurfaceWithoutSVGText() {\n        this.update();\n        return true;\n    }\n}\nexports.ZAbstractTextEdge = ZAbstractTextEdge;\nZAbstractTextEdge.updateTextAttributes = [\"style\"];\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_abstract_text_edge.ts?");

/***/ }),

/***/ "./src/objects/z_arrow_callout.ts":
/*!****************************************!*\
  !*** ./src/objects/z_arrow_callout.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZArrowCallout = void 0;\n/// <reference path=\"z_path_textbox.ts\"/>\n//namespace GraphTableSVG {\nconst z_path_textbox_1 = __webpack_require__(/*! ./z_path_textbox */ \"./src/objects/z_path_textbox.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\n//import {ZTextBoxAttributes, ZObjectAttributes, ZCalloutAttributes, ZShapeArrowCalloutAttributes} from \"../options/attributes_option\"\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nclass ZArrowCallout extends z_path_textbox_1.ZPathTextBox {\n    constructor(svgbox) {\n        super(svgbox);\n        //this.height = 100;\n        //this.width = 100;\n        this.arrowNeckWidth = 10;\n        this.arrowNeckHeight = 10;\n        this.arrowHeadWidth = 20;\n        this.arrowHeadHeight = 20;\n        this.svgGroup.setAttribute(\"data-direction\", \"down\");\n        this.updateAttributes.push(\"data-direction\");\n        if (this.type == enums_1.ShapeObjectType.ArrowCallout)\n            this.firstFunctionAfterInitialized();\n    }\n    /*\n    static constructAttributes(e: Element, removeAttributes: boolean = false, output: ZShapeArrowCalloutAttributes = {}): ZShapeArrowCalloutAttributes {\n        ZTextBox.constructAttributes(e, removeAttributes, output);\n        output.arrowNeckWidth = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.arrowNeckWidth);\n        output.arrowNeckHeight = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.arrowNeckHeight);\n        output.arrowHeadWidth = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.arrowHeadWidth);\n        output.arrowHeadHeight = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.arrowNeckHeight);\n        const p = <string>ElementExtension.gtGetAttributeStringWithUndefined(e, AttributeNames.direction);\n        if (p !== undefined) {\n            output.direction = Direction.toDirection(p);\n        }\n\n        if (removeAttributes) {\n            e.removeAttribute(AttributeNames.arrowNeckWidth);\n            e.removeAttribute(AttributeNames.arrowNeckHeight);\n            e.removeAttribute(AttributeNames.arrowHeadWidth);\n            e.removeAttribute(AttributeNames.arrowHeadHeight);\n            e.removeAttribute(AttributeNames.direction);\n        }\n\n        return output;\n    }\n    */\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        const _arrowNeckWidth = ElementExtension._getAttributeNumber(source, AttributeNames.arrowNeckWidth, true);\n        const _arrowNeckHeight = ElementExtension._getAttributeNumber(source, AttributeNames.arrowNeckHeight, true);\n        const _arrowHeadWidth = ElementExtension._getAttributeNumber(source, AttributeNames.arrowHeadWidth, true);\n        const _arrowHeadHeight = ElementExtension._getAttributeNumber(source, AttributeNames.arrowNeckHeight, true);\n        const _direction = ElementExtension._getAttribute(source, AttributeNames.direction, true);\n        this.arrowNeckWidth = _arrowNeckWidth !== null ? _arrowNeckWidth : this.arrowNeckWidth;\n        this.arrowNeckHeight = _arrowNeckHeight !== null ? _arrowNeckHeight : this.arrowNeckHeight;\n        this.arrowHeadWidth = _arrowHeadWidth !== null ? _arrowHeadWidth : this.arrowHeadWidth;\n        this.arrowHeadHeight = _arrowHeadHeight !== null ? _arrowHeadHeight : this.arrowHeadHeight;\n        this.direction = _direction !== null ? enums_1.Direction.toDirection(_direction) : this.direction;\n    }\n    /*\n    protected setBasicOption(option: ZShapeArrowCalloutAttributes) {\n        super.setBasicOption(option);\n    }\n    public setOption(option: ZShapeArrowCalloutAttributes) {\n        super.setOption(option)\n    }\n    */\n    /*\n    static openCustomElement(e: SVGElement): ShapeArrowCallout {\n        const parent = e.parentElement;\n        if (parent instanceof SVGSVGElement) {\n            const option = ShapeArrowCallout.constructAttributes(e, true);\n            const attrs = e.gtGetAttributes();\n            const r = new ShapeArrowCallout(parent, option);\n            e.remove();\n            attrs.forEach((v) => r.svgGroup.setAttribute(v.name, v.value));\n            return r;\n        } else {\n            throw Error(\"error!\");\n        }\n    }\n    */\n    get type() {\n        return enums_1.ShapeObjectType.ArrowCallout;\n    }\n    get arrowNeckWidth() {\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-neck-width\", 0);\n    }\n    set arrowNeckWidth(value) {\n        if (this.arrowNeckWidth != value)\n            this.svgGroup.setAttribute(\"data-arrow-neck-width\", value.toString());\n    }\n    get arrowNeckHeight() {\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-neck-height\", 0);\n    }\n    set arrowNeckHeight(value) {\n        if (this.arrowNeckHeight != value)\n            this.svgGroup.setAttribute(\"data-arrow-neck-height\", value.toString());\n    }\n    get arrowHeadWidth() {\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-head-width\", 0);\n    }\n    set arrowHeadWidth(value) {\n        if (this.arrowHeadWidth != value)\n            this.svgGroup.setAttribute(\"data-arrow-head-width\", value.toString());\n    }\n    get arrowHeadHeight() {\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-head-height\", 0);\n    }\n    set arrowHeadHeight(value) {\n        if (this.arrowHeadHeight != value)\n            this.svgGroup.setAttribute(\"data-arrow-head-height\", value.toString());\n    }\n    get direction() {\n        const r = this.svgGroup.getAttribute(\"data-direction\");\n        return enums_1.Direction.toDirection(r);\n    }\n    set direction(value) {\n        if (this.direction != value) {\n            this.svgGroup.setAttribute(\"data-direction\", value.toString());\n        }\n    }\n    get topExtraLength() {\n        if (this.direction == \"up\") {\n            return this.arrowHeadHeight + this.arrowNeckHeight + this.marginPaddingTop;\n        }\n        else {\n            return this.marginPaddingTop;\n        }\n    }\n    get leftExtraLength() {\n        if (this.direction == \"left\") {\n            return this.arrowHeadHeight + this.arrowNeckHeight + this.marginPaddingLeft;\n        }\n        else {\n            return this.marginPaddingLeft;\n        }\n    }\n    get rightExtraLength() {\n        if (this.direction == \"right\") {\n            return this.arrowHeadHeight + this.arrowNeckHeight + this.marginPaddingRight;\n        }\n        else {\n            return this.marginPaddingRight;\n        }\n    }\n    get bottomExtraLength() {\n        if (this.direction == \"down\") {\n            return this.arrowHeadHeight + this.arrowNeckHeight + this.marginPaddingBottom;\n        }\n        else {\n            return this.marginPaddingBottom;\n        }\n    }\n    /*\n    get innerRectangle(): Rectangle {\n        const rect = new Rectangle();\n        if (this.isAutoSizeShapeToFitText == AutoSizeShapeToFitText.Auto) {\n            \n            const textRect = SVGTextExtensions.getSize(this.svgText);\n            //const b = this.svgText.getBBox();\n            rect.width = textRect.width;\n            rect.height = textRect.height;\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\n        } else {\n            rect.width = this.boxWidth - this.marginPaddingLeft;\n            rect.height = this.boxHeight - this.marginPaddingTop;\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\n        }\n        if (this.direction == \"up\") rect.y += this.arrowNeckHeight + this.arrowHeadHeight;\n        if (this.direction == \"left\") rect.x += this.arrowNeckHeight + this.arrowHeadHeight;\n        return rect;\n    }\n    */\n    /**\n     * 矢印部分を除いた図形の高さを表します。\n     */\n    get boxHeight() {\n        if (this.direction == \"up\" || this.direction == \"down\") {\n            return this.height - this.arrowNeckHeight - this.arrowHeadWidth;\n        }\n        else {\n            return this.height;\n        }\n    }\n    get boxWidth() {\n        if (this.direction == \"up\" || this.direction == \"down\") {\n            return this.width;\n        }\n        else {\n            return this.width - this.arrowNeckHeight - this.arrowHeadWidth;\n        }\n    }\n    /*\n    protected updateToFitText() {\n\n        const textRect = SVGTextExtensions.getSize(this.svgText);\n        //const box = this.svgText.getBBox();\n        if (this.direction == \"up\" || this.direction == \"down\") {\n            this.width = textRect.width + this.marginPaddingLeft + this.marginPaddingRight;\n            this.height = textRect.height + this.marginPaddingTop + this.marginPaddingBottom + this.arrowNeckHeight + this.arrowHeadHeight;\n        } else {\n            this.width = textRect.width + this.marginPaddingLeft + this.marginPaddingRight + this.arrowNeckHeight + this.arrowHeadHeight;\n            this.height = textRect.height + this.marginPaddingTop + this.marginPaddingBottom;\n        }\n    }\n    */\n    /*\n     public getVirtualRegion(): Rectangle {\n         const textRect = SVGTextExtension.getVirtualRegion(this.svgText);\n         let _w = 0;\n         let _h = 0;\n         if (this.direction == \"up\" || this.direction == \"down\") {\n             _w = textRect.width + this.marginPaddingLeft + this.marginPaddingRight;\n             _h = textRect.height + this.marginPaddingTop + this.marginPaddingBottom + this.arrowNeckHeight + this.arrowHeadHeight;\n         } else {\n             _w = textRect.width + this.marginPaddingLeft + this.marginPaddingRight + this.arrowNeckHeight + this.arrowHeadHeight;\n             _h = textRect.height + this.marginPaddingTop + this.marginPaddingBottom;\n         }\n\n         if (this.isAutoSizeShapeToFitText == AutoSizeShapeToFitText.Auto) {\n \n\n             const textWidth = _w < this._minimumWidth ? this._minimumWidth : _w;\n             const textHeight = _h < this._minimumHeight ? this._minimumHeight : _h;\n             const width = _w;\n             const height = _h;\n \n             return new Rectangle(this.cx - (width / 2), this.cy - (height / 2), width, height);\n \n         } else if (this.isAutoSizeShapeToFitText == AutoSizeShapeToFitText.SemiAuto) {\n             const newWidth = this.width < _w ? _w : this.width;\n             const newHeigth = this.height < _h ? _h : this.height;\n             return new Rectangle(this.cx - (newWidth / 2), this.cy - (newHeigth / 2), newWidth, newHeigth);\n         } else {\n \n             return new Rectangle(this.cx - (this.width / 2), this.cy - (this.height / 2), this.width, this.height);\n \n             //return new Rectangle(this.x, this.y, this.width, this.height);\n         }\n     }\n     */\n    update() {\n        super.update();\n        const region = this.getVirtualRegion();\n        const x1 = region.x;\n        const y1 = region.y;\n        const x2 = region.right;\n        const y2 = region.bottom;\n        if (this.direction == \"up\") {\n            const bx1 = x1;\n            const by1 = y1 + this.arrowHeadHeight + this.arrowNeckHeight;\n            const bx2 = x2;\n            const by2 = y2;\n            let nx1 = -(this.arrowNeckWidth / 2);\n            let nx2 = (this.arrowNeckWidth / 2);\n            let ny = by1 - this.arrowNeckHeight;\n            let cx = 0;\n            let hx1 = -(this.arrowHeadWidth / 2);\n            let hx2 = (this.arrowHeadWidth / 2);\n            let hy = y1;\n            const mes = (0, vline_1.escapeWithRound100) `H ${nx1} V ${ny} H ${hx1} L ${cx} ${hy} L ${hx2} ${ny} H ${nx2} V ${by1}`;\n            const top = (0, vline_1.escapeWithRound100) `M ${bx1} ${by1} ${mes} H ${bx2}`;\n            const right = (0, vline_1.escapeWithRound100) `V ${by2}`;\n            const bottom = (0, vline_1.escapeWithRound100) `H ${bx1}`;\n            const left = (0, vline_1.escapeWithRound100) `V ${by1}`;\n            this.svgPath.setAttribute(\"d\", (0, vline_1.escapeWithRound100) `${top} ${right} ${bottom} ${left} z`);\n        }\n        else if (this.direction == \"left\") {\n            const bx1 = x1 + this.arrowHeadHeight + this.arrowNeckHeight;\n            const by1 = y1;\n            const bx2 = x2;\n            const by2 = y2;\n            let ny1 = 0 + (this.arrowNeckWidth / 2);\n            let ny2 = 0 - (this.arrowNeckWidth / 2);\n            let nx = bx1 - this.arrowNeckHeight;\n            let cy = 0;\n            let hy1 = 0 + (this.arrowHeadWidth / 2);\n            let hy2 = 0 - (this.arrowHeadWidth / 2);\n            let hx = x1;\n            const top = (0, vline_1.escapeWithRound100) `M ${bx1} ${by1} H ${bx2}`;\n            const right = (0, vline_1.escapeWithRound100) `V ${by2}`;\n            const bottom = (0, vline_1.escapeWithRound100) `H ${bx1}`;\n            const left = (0, vline_1.escapeWithRound100) `V ${ny1} H ${nx} V ${hy1} L ${hx} ${cy} L ${nx} ${hy2} V ${ny2} H ${bx1} V ${by1}`;\n            this.svgPath.setAttribute(\"d\", (0, vline_1.escapeWithRound100) `${top} ${right} ${bottom} ${left} z`);\n        }\n        else if (this.direction == \"right\") {\n            const bx1 = x1;\n            const by1 = y1;\n            const bx2 = x2 - this.arrowNeckHeight - this.arrowHeadHeight;\n            const by2 = y2;\n            let ny1 = 0 - (this.arrowNeckWidth / 2);\n            let ny2 = 0 + (this.arrowNeckWidth / 2);\n            let nx = bx2 + this.arrowNeckHeight;\n            let cy = 0;\n            let hy1 = 0 - (this.arrowHeadWidth / 2);\n            let hy2 = 0 + (this.arrowHeadWidth / 2);\n            let hx = x2;\n            const top = (0, vline_1.escapeWithRound100) `M ${bx1} ${by1} H ${bx2}`;\n            const right = (0, vline_1.escapeWithRound100) `V ${ny1} H ${nx} V ${hy1} L ${hx} ${cy} L ${nx} ${hy2} V ${ny2} H ${bx2} V ${by2}`;\n            const bottom = (0, vline_1.escapeWithRound100) `H ${bx1}`;\n            const left = (0, vline_1.escapeWithRound100) `V ${by1}`;\n            this.svgPath.setAttribute(\"d\", (0, vline_1.escapeWithRound100) `${top} ${right} ${bottom} ${left} z`);\n        }\n        else {\n            const bx1 = x1;\n            const by1 = y1;\n            const bx2 = x2;\n            const by2 = y2 - this.arrowHeadHeight - this.arrowNeckHeight;\n            //const by = boxHeight + dy;\n            let nx1 = -(this.arrowNeckWidth / 2);\n            let nx2 = (this.arrowNeckWidth / 2);\n            let ny = by2 + this.arrowNeckHeight;\n            let cx = 0;\n            let hx1 = -(this.arrowHeadWidth / 2);\n            let hx2 = (this.arrowHeadWidth / 2);\n            let hy = y2;\n            const top = (0, vline_1.escapeWithRound100) `M ${bx1} ${by1} H ${bx2}`;\n            const right = (0, vline_1.escapeWithRound100) `V ${by2}`;\n            const bottom = (0, vline_1.escapeWithRound100) `H ${nx2} V ${ny} H ${hx2} L ${cx} ${hy} L ${hx1} ${ny} H ${nx1} V ${by2} H ${bx1}`;\n            const left = (0, vline_1.escapeWithRound100) `V ${by1}`;\n            this.svgPath.setAttribute(\"d\", (0, vline_1.escapeWithRound100) `${top} ${right} ${bottom} ${left} z`);\n        }\n    }\n    get shape() {\n        switch (this.direction) {\n            case \"up\": return enums_1.VBAShapeType.UpArrowCallout;\n            case \"left\": return enums_1.VBAShapeType.LeftArrowCallout;\n            case \"right\": return enums_1.VBAShapeType.RightArrowCallout;\n            case \"down\": return enums_1.VBAShapeType.DownArrowCallout;\n        }\n        return enums_1.VBAShapeType.DownArrowCallout;\n    }\n    /**\n     * VBAコードでのこの図形を表すShape図形のVBAAdjustmentsプロパティを表します。\n     * 第一要素は矢印の首の幅（）\n     * 第二要素は矢印の頭の幅\n     * @returns VBAAdjustments値の配列。\n     */\n    get VBAAdjustments() {\n        if (this.direction == \"up\") {\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\n            const headHeightRatio = this.arrowHeadHeight / this.height;\n            const boxHeightRatio = this.boxHeight / this.height;\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxHeightRatio];\n        }\n        else if (this.direction == \"right\") {\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\n            const headHeightRatio = this.arrowHeadHeight / this.height;\n            const boxWidthRatio = this.boxWidth / this.width;\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxWidthRatio];\n        }\n        else if (this.direction == \"left\") {\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\n            const headHeightRatio = this.arrowHeadHeight / this.height;\n            const boxWidthRatio = this.boxWidth / this.width;\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxWidthRatio];\n        }\n        else {\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\n            const headHeightRatio = this.arrowHeadHeight / this.height;\n            const boxHeightRatio = this.boxHeight / this.height;\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxHeightRatio];\n        }\n    }\n    /**\n             * 接続部分の座標を返します。\n             * @param type\n             * @param x\n             * @param y\n             */\n    getContactPosition(type, x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        switch (type) {\n            case enums_1.ConnectorType.Top:\n                return [this.x, this.y - hr];\n            case enums_1.ConnectorType.TopRight:\n            case enums_1.ConnectorType.Right:\n            case enums_1.ConnectorType.BottomRight:\n                return [this.x + wr, this.y];\n            case enums_1.ConnectorType.Bottom:\n                return [this.x, this.y + hr];\n            case enums_1.ConnectorType.BottomLeft:\n            case enums_1.ConnectorType.Left:\n            case enums_1.ConnectorType.TopLeft:\n                return [this.x - wr, this.y];\n            default:\n                const autoType = this.getContactAutoPosition(x, y);\n                return this.getContactPosition(autoType, x, y);\n        }\n    }\n    getContactAutoPosition(x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        const line1 = new vline_1.VLine(this.x, this.y, this.x + wr, this.y + hr);\n        const line2 = new vline_1.VLine(this.x, this.y, this.x + wr, this.y - hr);\n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n        if (b1) {\n            if (b2) {\n                return enums_1.ConnectorType.Top;\n            }\n            else {\n                return enums_1.ConnectorType.Right;\n            }\n        }\n        else {\n            if (b2) {\n                return enums_1.ConnectorType.Left;\n            }\n            else {\n                return enums_1.ConnectorType.Bottom;\n            }\n        }\n    }\n}\nexports.ZArrowCallout = ZArrowCallout;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_arrow_callout.ts?");

/***/ }),

/***/ "./src/objects/z_callout.ts":
/*!**********************************!*\
  !*** ./src/objects/z_callout.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZCallout = void 0;\nconst z_path_textbox_1 = __webpack_require__(/*! ./z_path_textbox */ \"./src/objects/z_path_textbox.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common/index.ts\");\nclass ZCallout extends z_path_textbox_1.ZPathTextBox {\n    constructor(svgbox) {\n        super(svgbox);\n        //const defaultSX = this.cx - 100 : this.fixedX - 50;\n        //const defaultSY = this.fixedY == null ? this.cy - 100 : this.fixedY - 50;\n        // const defaultSX = this.fixedX == null ? this.cx - 100 : this.fixedX - 50;\n        //const defaultSY = this.fixedY == null ? this.cy - 100 : this.fixedY - 50;\n        /*\n        */\n        if (this.type == enums_1.ShapeObjectType.Callout)\n            this.firstFunctionAfterInitialized();\n    }\n    /*\n    protected setBasicOption(option: ZCalloutAttributes) {\n        super.setBasicOption(option);\n        this.speakerX = option.speakerX == undefined ? 0 : option.speakerX;\n        this.speakerY = option.speakerY == undefined ? 0 : option.speakerY;\n\n    }\n    public setOption(option: ZCalloutAttributes) {\n        super.setOption(option)\n    }\n    */\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        const _speakerX = ElementExtension._getAttributeNumber(source, common_1.AttributeNames.speakerX, true);\n        const _speakerY = ElementExtension._getAttributeNumber(source, common_1.AttributeNames.speakerY, true);\n        this.speakerX = _speakerX == null ? 0 : _speakerX;\n        this.speakerY = _speakerY == null ? 0 : _speakerY;\n    }\n    /*\n    static constructAttributes(e: Element, removeAttributes: boolean = false, output: ZCalloutAttributes = {}): ZCalloutAttributes {\n        ZTextBox.constructAttributes(e, removeAttributes, output);\n\n\n        if (e.hasAttribute(AttributeNames.speakerX)) output.speakerX = ElementExtension.gtGetAttributeNumber(e, AttributeNames.speakerX, 0)!;\n        if (e.hasAttribute(AttributeNames.speakerY)) output.speakerY = ElementExtension.gtGetAttributeNumber(e, AttributeNames.speakerY, 0)!;\n\n        if (removeAttributes) {\n            e.removeAttribute(AttributeNames.speakerX);\n            e.removeAttribute(AttributeNames.speakerY);\n        }\n\n        return output;\n    }\n    */\n    /*\n    static openCustomElement(e: SVGElement): ZCallout {\n        const parent = e.parentElement;\n        if (parent instanceof SVGSVGElement) {\n            const option = ZCallout.constructAttributes(e,true);\n            const attrs = e.gtGetAttributes();\n\n            const r = new ZCallout(parent, option);\n            attrs.forEach((v)=>r.svgGroup.setAttribute(v.name, v.value));\n            e.remove();\n            return r;\n        } else {\n            throw Error(\"error!\");\n        }\n    }\n    */\n    get type() {\n        return enums_1.ShapeObjectType.Callout;\n    }\n    updateSurfaceSize() {\n        const region = this.getVirtualRegion();\n        if (this.width != region.width) {\n            this.width = region.width;\n        }\n        if (this.height != region.height) {\n            this.height = region.height;\n        }\n        return false;\n    }\n    update() {\n        super.update();\n        const x1 = -(this.width / 2);\n        const y1 = -(this.height / 2);\n        const x2 = (this.width / 2);\n        const y2 = (this.height / 2);\n        const speakerDiffX = this.speakerX - this.cx;\n        const speakerDiffY = this.speakerY - this.cy;\n        let px1 = 0, px2 = 0, py1 = 0, py2 = 0;\n        let mes = \"\";\n        switch (this.speakerPosition) {\n            case \"upleft\":\n                px1 = (x1 / 3) * 2;\n                px2 = (x1 / 3) * 1;\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y1}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} ${mes} H ${x2} V ${y2} H ${x1} V ${y1} z`);\n                break;\n            case \"upright\":\n                px1 = (x2 / 3) * 1;\n                px2 = (x2 / 3) * 2;\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y1}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} ${mes} H ${x2} V ${y2} H ${x1} V ${y1} z`);\n                break;\n            case \"rightup\":\n                py1 = (y1 / 3) * 2;\n                py2 = (y1 / 3) * 1;\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x2} ${py2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} ${mes} V ${y2} H ${x1} V ${y1} z`);\n                break;\n            case \"rightdown\":\n                py1 = (y2 / 3) * 1;\n                py2 = (y2 / 3) * 2;\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x2} ${py2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} ${mes} V ${y2} H ${x1} V ${y1} z`);\n                break;\n            case \"leftup\":\n                py1 = (y1 / 3) * 1;\n                py2 = (y1 / 3) * 2;\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x1} ${py2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} ${mes} V ${y1} z`);\n                break;\n            case \"leftdown\":\n                py1 = (y2 / 3) * 2;\n                py2 = (y2 / 3) * 1;\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x1} ${py2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} ${mes} V ${y1} z`);\n                break;\n            case \"downleft\":\n                px1 = (x1 / 3) * 1;\n                px2 = (x1 / 3) * 2;\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} ${mes} H ${x1} V ${y1} z`);\n                break;\n            case \"downright\":\n                px1 = (x2 / 3) * 2;\n                px2 = (x2 / 3) * 1;\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y2}`;\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} ${mes} H ${x1} V ${y1} z`);\n                break;\n            default:\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} V ${y1} z`);\n                break;\n        }\n        //this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x1 + this.width} V ${y1 + this.height} H ${x1} V ${y1} z`);\n    }\n    get speakerX() {\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-speaker-x\", 0);\n    }\n    set speakerX(value) {\n        if (this.speakerX != value)\n            this.svgGroup.setAttribute(\"data-speaker-x\", value.toString());\n    }\n    get speakerY() {\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-speaker-y\", 0);\n    }\n    set speakerY(value) {\n        if (this.speakerY != value)\n            this.svgGroup.setAttribute(\"data-speaker-y\", value.toString());\n    }\n    get speakerPosition() {\n        const speakerDiffX = this.speakerX - this.cx;\n        const speakerDiffY = this.speakerY - this.cy;\n        const x1 = -(this.width / 2);\n        const y1 = -(this.height / 2);\n        const x2 = (this.width / 2);\n        const y2 = (this.height / 2);\n        if (x1 <= speakerDiffX && speakerDiffX <= x2 && y1 <= speakerDiffY && speakerDiffY <= y2) {\n            return \"inner\";\n        }\n        if (this.speakerX > this.cx) {\n            if (this.speakerY > this.cy) {\n                const line = new vline_1.VLine(0, 0, this.width, this.height);\n                if (line.contains(speakerDiffX, speakerDiffY)) {\n                    return \"rightdown\";\n                }\n                else {\n                    return \"downright\";\n                }\n            }\n            else {\n                const line = new vline_1.VLine(0, 0, this.width, -this.height);\n                if (line.contains(speakerDiffX, speakerDiffY)) {\n                    return \"upright\";\n                }\n                else {\n                    return \"rightup\";\n                }\n            }\n        }\n        else {\n            if (this.speakerY > this.cy) {\n                const line = new vline_1.VLine(0, 0, this.width, -this.height);\n                if (line.contains(speakerDiffX, speakerDiffY)) {\n                    return \"leftdown\";\n                }\n                else {\n                    return \"downleft\";\n                }\n            }\n            else {\n                const line = new vline_1.VLine(0, 0, this.width, this.height);\n                if (line.contains(speakerDiffX, speakerDiffY)) {\n                    return \"upleft\";\n                }\n                else {\n                    return \"leftup\";\n                }\n            }\n        }\n    }\n    get shape() {\n        return enums_1.VBAShapeType.Callout;\n    }\n    get VBAAdjustments() {\n        const y1 = this.speakerY - this.cy;\n        const py = y1 / this.height;\n        const x1 = this.speakerX - this.cx;\n        const px = x1 / this.width;\n        return [px, py];\n    }\n}\nexports.ZCallout = ZCallout;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_callout.ts?");

/***/ }),

/***/ "./src/objects/z_circle.ts":
/*!*********************************!*\
  !*** ./src/objects/z_circle.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZCircle = void 0;\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst z_ellipse_1 = __webpack_require__(/*! ./z_ellipse */ \"./src/objects/z_ellipse.ts\");\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nclass ZCircle extends z_ellipse_1.ZAbstractEllipseCircle {\n    get svgCircle() {\n        return this._svgSurface;\n    }\n    constructor(svgbox) {\n        super(svgbox);\n        if (this.type == enums_1.ShapeObjectType.Circle)\n            this.firstFunctionAfterInitialized();\n    }\n    createSurface(svgbox) {\n        //if(option.surfaceClass === undefined) option.surfaceClass = DefaultClassNames.defaultSurfaceClass;\n        this._svgSurface = ZCircle.createCircle(this.svgGroup, DefaultClassNames.defaultSurfaceClass, undefined);\n        this.svgGroup.insertBefore(this.svgCircle, this.svgText);\n    }\n    static createCircle(parent, className, style) {\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n        circle.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Surface);\n        parent.appendChild(circle);\n        GOptions.setClassAndStyle(circle, className, style);\n        /*\n        if(style !== undefined){\n            if(typeof(style) == \"string\"){\n                circle.setAttribute(\"style\", style);\n            }else{\n                circle.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\n            }\n\n        }\n        */\n        //if(style !== undefined) circle.setAttribute(\"style\", style);\n        circle.r.baseVal.value = AttributeNames.defaultCircleRadius;\n        //circle.setAttribute(\"class\", className);\n        /*\n        if(typeof(className) == \"string\"){\n            circle.setAttribute(\"class\", className);\n        }else{\n            circle.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\n        }\n        */\n        const radius = ElementExtension.getPropertyStyleNumberValue(circle, StyleNames.defaultRadius, null);\n        if (radius != null) {\n            circle.r.baseVal.value = radius;\n        }\n        circle.cx.baseVal.value = 0;\n        circle.cy.baseVal.value = 0;\n        return circle;\n    }\n    get rx() {\n        return this.svgCircle.r.baseVal.value;\n    }\n    get ry() {\n        return this.svgCircle.r.baseVal.value;\n    }\n    set width(value) {\n        const _rx = value / 2;\n        if (this.width != value)\n            this.svgCircle.setAttribute(\"r\", _rx.toString());\n    }\n    set height(value) {\n        const _ry = value / 2;\n        if (this.height != value)\n            this.svgCircle.setAttribute(\"r\", _ry.toString());\n    }\n    get width() {\n        return this.svgCircle.r.baseVal.value * 2;\n    }\n    get height() {\n        return this.svgCircle.r.baseVal.value * 2;\n    }\n    get type() {\n        return enums_1.ShapeObjectType.Circle;\n    }\n    get shape() {\n        return enums_1.VBAShapeType.Oval;\n    }\n}\nexports.ZCircle = ZCircle;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_circle.ts?");

/***/ }),

/***/ "./src/objects/z_edge.ts":
/*!*******************************!*\
  !*** ./src/objects/z_edge.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n//namespace GraphTableSVG {\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZEdge = void 0;\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./src/common/vba_functions.ts\");\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./src/html/enum_extension.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst z_abstract_text_edge_1 = __webpack_require__(/*! ./z_abstract_text_edge */ \"./src/objects/z_abstract_text_edge.ts\");\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common/index.ts\");\nconst html_1 = __webpack_require__(/*! ../html */ \"./src/html/index.ts\");\n/**\n * 辺をSVGで表現するためのクラスです。\n */\nclass ZEdge extends z_abstract_text_edge_1.ZAbstractTextEdge {\n    //public tag: any;\n    constructor(svgbox) {\n        super(svgbox);\n        //private isFixTextSize: boolean = false;\n        this.surfaceAttributes = [];\n        this._minimumWidth = 10;\n        this._minimumHeight = 10;\n        this.VBAConnectorNumber = 1;\n        if (this.type == enums_1.ShapeObjectType.Edge)\n            this.firstFunctionAfterInitialized();\n        //this.setAppropriateText();\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        const x3 = ElementExtension._getAttributeNumber(source, common_1.AttributeNames.x3, true);\n        const y3 = ElementExtension._getAttributeNumber(source, common_1.AttributeNames.y3, true);\n        if (x3 != null && y3 != null) {\n            this.controlPoint = [[x3, y3]];\n        }\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZEdgeAttributes) {\n        super.setBasicOption(option);\n\n        if (option.x3 !== undefined && option.y3 !== undefined) {\n            this.controlPoint = [[option.x3, option.y3]];\n        }\n    }\n    */\n    /*\n    static constructAttributes(e: Element, removeAttributes: boolean = false, output: GOptions.ZEdgeAttributes = {}): GOptions.ZEdgeAttributes {\n        ZAbstractTextEdge.constructAttributes(e, removeAttributes, output);\n\n        if (e.hasAttribute(AttributeNames.x3)) {\n            output.x3 = ElementExtension.gtGetAttributeNumberWithoutNull(e, AttributeNames.x3, 0);\n        }\n        if (e.hasAttribute(AttributeNames.y3)) {\n            output.y3 = ElementExtension.gtGetAttributeNumberWithoutNull(e, AttributeNames.y3, 0);\n        }\n\n\n        if (removeAttributes) {\n            e.removeAttribute(AttributeNames.x3);\n            e.removeAttribute(AttributeNames.y3);\n        }\n        return output;\n    }\n    */\n    get type() {\n        return enums_1.ShapeObjectType.Edge;\n    }\n    /**\n     * 辺の制御点を返します。\n     */\n    get controlPoint() {\n        const r = this.pathPoints;\n        r.shift();\n        r.pop();\n        return r;\n    }\n    set controlPoint(value) {\n        const fst = [this.x1, this.y1];\n        const lst = [this.x2, this.y2];\n        value.unshift(fst);\n        value.push(lst);\n        this.pathPoints = value;\n    }\n    setIndexDictionaryForVBA(vertexDic, edgeDic) {\n        if (this.controlPoint.length == 0) {\n            edgeDic[this.objectID] = Object.keys(edgeDic).length;\n        }\n        else if (this.controlPoint.length > 0) {\n            //edgeDic[this.objectID] = Object.keys(edgeDic).length;\n            for (let i = 0; i < this.VBAConnectorNumber; i++) {\n                vertexDic[`${this.objectID}_${i}`] = Object.keys(vertexDic).length;\n            }\n            for (let i = 0; i <= this.VBAConnectorNumber; i++) {\n                edgeDic[`${this.objectID}_${i}`] = Object.keys(edgeDic).length;\n            }\n        }\n    }\n    get shape() {\n        return \"msoConnectorStraight\";\n    }\n    createVBACode(id) {\n        const lineArr = [];\n        const r = [];\n        r.push(`Sub create${id}(createdSlide As slide)`);\n        r.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n        r.push(` Dim obj As Shape`);\n        if (this.controlPoint.length == 0 || this.edgeType == \"elbow\") {\n            if (this.edgeType == \"elbow\") {\n                r.push(` Set obj = shapes_.AddConnector(msoConnectorElbow, ${this.x1}, ${this.y1}, ${this.x2}, ${this.y2})`);\n            }\n            else {\n                r.push(` Set obj = shapes_.AddConnector(msoConnectorStraight, ${this.x1}, ${this.y1}, ${this.x2}, ${this.y2})`);\n            }\n            if (this.markerStart != null) {\n                r.push(` obj.Line.BeginArrowheadLength = msoArrowheadLong`);\n                r.push(` obj.Line.BeginArrowheadStyle = msoArrowheadTriangle`);\n                r.push(` obj.Line.BeginArrowheadWidth = msoArrowheadWide`);\n            }\n            if (this.markerEnd != null) {\n                r.push(` obj.Line.EndArrowheadLength = msoArrowheadLong`);\n                r.push(` obj.Line.EndArrowheadStyle = msoArrowheadTriangle`);\n                r.push(` obj.Line.EndArrowheadWidth = msoArrowheadWide`);\n            }\n            if (this.beginVertex != null) {\n                const endX = this.endVertex == null ? this.x2 : this.endVertex.cx;\n                const endY = this.endVertex == null ? this.y2 : this.endVertex.cy;\n                let begType = 0;\n                if (this.beginConnectorType == \"auto\") {\n                    begType = enums_1.ConnectorType.ToVBAConnectorPosition2(this.beginVertex.shape, this.beginVertex.getContactAutoPosition(endX, endY));\n                }\n                else {\n                    begType = enums_1.ConnectorType.ToVBAConnectorPosition2(this.beginVertex.shape, this.beginConnectorType);\n                }\n                r.push(` Call obj.ConnectorFormat.BeginConnect(shapes_(\"${this.beginVertex.objectID}\"), ${begType})`);\n            }\n            if (this.endVertex != null) {\n                const beginX = this.beginVertex == null ? this.x1 : this.beginVertex.cx;\n                const beginY = this.beginVertex == null ? this.y1 : this.beginVertex.cy;\n                let endType = 0;\n                if (this.endConnectorType == \"auto\") {\n                    endType = enums_1.ConnectorType.ToVBAConnectorPosition2(this.endVertex.shape, this.endVertex.getContactAutoPosition(beginX, beginY));\n                }\n                else {\n                    endType = enums_1.ConnectorType.ToVBAConnectorPosition2(this.endVertex.shape, this.endConnectorType);\n                }\n                r.push(` Call obj.ConnectorFormat.EndConnect(shapes_(\"${this.endVertex.objectID}\"), ${endType})`);\n            }\n            const lineType = (0, enum_extension_1.getLineType)(this.svgPath);\n            const colorName = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"gray\");\n            const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(colorName);\n            const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke-width\", \"4\"));\n            const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n            r.push(` Call EditLine(obj.Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\n        }\n        else if (this.controlPoint.length > 0) {\n            //subline.push(` Set obj = shapes_.AddConnector(msoConnectorStraight, 0, 0, 0, 0)`);\n            //lineArr.push(i);\n            r.push(` Dim nodes(${this.VBAConnectorNumber}) As Shape`);\n            for (let j = 0; j < this.VBAConnectorNumber; j++) {\n                const t = (j + 1) / (this.VBAConnectorNumber + 1);\n                const centerPoint = CommonFunctions.bezierLocation([this.x1, this.y1], this.controlPoint[0], [this.x2, this.y2], t);\n                r.push(`shapes_.AddShape(msoShapeOval, ${centerPoint[0]}, ${centerPoint[1]}, 0, 0).name = \"${this.objectID}_node_${j}\"`);\n            }\n            for (let j = 0; j <= this.VBAConnectorNumber; j++) {\n                //const centerPoint = Common.bezierLocation([this.x1, this.y1], this.controlPoint[0], [this.x2, this.y2], 0.5);\n                const edgeID = `${this.objectID}_edge_${j}`;\n                r.push(` shapes_.AddConnector(msoConnectorStraight, ${this.x1}, ${this.y1}, ${this.x2}, ${this.y2}).name = \"${this.objectID}_edge_${j}\"`);\n                const lineType = (0, enum_extension_1.getLineType)(this.svgPath);\n                const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"gray\"));\n                const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke-width\", \"4\"));\n                const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n                r.push(` Call EditLine(shapes_(\"${edgeID}\").Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\n                if (this.beginVertex != null) {\n                    const beg = j == 0 ? this.beginVertex.objectID : `${this.objectID}_node_${j - 1}`;\n                    const endX = this.endVertex == null ? this.x2 : this.endVertex.x;\n                    const endY = this.endVertex == null ? this.y2 : this.endVertex.y;\n                    const begType = j == 0 ? enums_1.ConnectorType.ToVBAConnectorPosition2(this.beginVertex.shape, this.beginVertex.getConnectorType(this.beginConnectorType, endX, endY)) : 1;\n                    r.push(` Call shapes_(\"${edgeID}\").ConnectorFormat.BeginConnect(shapes_(\"${beg}\"), ${begType})`);\n                }\n                if (this.endVertex != null) {\n                    const end = j == this.VBAConnectorNumber ? this.endVertex.objectID : `${this.objectID}_node_${j}`;\n                    const beginX = this.beginVertex == null ? this.x1 : this.beginVertex.x;\n                    const beginY = this.beginVertex == null ? this.y1 : this.beginVertex.y;\n                    const endType = j == this.VBAConnectorNumber ? enums_1.ConnectorType.ToVBAConnectorPosition2(this.endVertex.shape, this.endVertex.getConnectorType(this.endConnectorType, beginX, beginY)) : 1;\n                    r.push(` Call shapes_(\"${edgeID}\").ConnectorFormat.EndConnect(shapes_(\"${end}\"), ${endType})`);\n                }\n                //r.push(` Call EditConnector(shapes_(\"${edgeID}\").ConnectorFormat, shapes_(\"${beg}\"), shapes_(\"${end}\"), ${begType}, ${endType})`)\n            }\n        }\n        lineArr.forEach((v) => {\n            const lineType = (0, enum_extension_1.getLineType)(this.svgPath);\n            const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"gray\"));\n            const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke-width\", \"4\"));\n            const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n            r.push(` Call EditLine(edges(${v}).Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\n        });\n        //subline.forEach((v) => sub.push([v]));\n        const textCodes = this.createVBACodeOfText(id);\n        textCodes.forEach((v, i) => r.push(`Call create${id}_label_${i}(shapes_)`));\n        r.push(`End Sub`);\n        textCodes.forEach((v) => v.forEach((w) => r.push(w)));\n        return r;\n    }\n    static getVisibleCharElements(e) {\n        const r = new Array(0);\n        for (let i = 0; i < e.childNodes.length; i++) {\n            const child = e.childNodes.item(i);\n            if (child instanceof SVGTextPathElement) {\n                const r2 = this.getVisibleCharElements(child);\n                r2.forEach(([a, b]) => {\n                    r.push([a, b]);\n                });\n            }\n            else if (child instanceof SVGTSpanElement) {\n                const r2 = this.getVisibleCharElements(child);\n                r2.forEach(([a, b]) => {\n                    r.push([a, b]);\n                });\n            }\n            else {\n                if (child.textContent != null && child.textContent.length > 0) {\n                    const newText = html_1.HTMLFunctions.removeInvisibleCharacters(child.textContent);\n                    for (let j = 0; j < newText.length; j++) {\n                        const character = newText[j];\n                        r.push([e, character]);\n                    }\n                }\n            }\n        }\n        return r;\n    }\n    /**\n     * VBAコードを作成します。\n     * @param shapes\n     * @param result\n     */\n    createVBACodeOfText(id) {\n        const r = [];\n        const globalX = this.graph != null ? this.graph.x : 0;\n        const globalY = this.graph != null ? this.graph.y : 0;\n        //let pid = 0;\n        const charInfoArray = ZEdge.getVisibleCharElements(this.svgText);\n        charInfoArray.forEach(([parent, character], i) => {\n            if (parent instanceof SVGTSpanElement) {\n                //const character = this.svgText.textContent![i];\n                const fontSize = parseInt(ElementExtension.getInheritedPropertyStyleValueWithDefault(parent, \"font-size\", \"12\"));\n                const fontFamily = vba_functions_1.VBATranslateFunctions.ToVBAFont(ElementExtension.getInheritedPropertyStyleValueWithDefault(parent, \"font-family\", \"MS PGothic\"));\n                const fontBold = vba_functions_1.VBATranslateFunctions.ToFontBold(ElementExtension.getInheritedPropertyStyleValueWithDefault(parent, \"font-weight\", \"none\"));\n                const css = getComputedStyle(parent);\n                const childColor = common_1.Color.createRGBFromColorName(css.fill);\n                const s = new Array(0);\n                const p1 = this.svgText.getStartPositionOfChar(i);\n                const p2 = this.svgText.getEndPositionOfChar(i);\n                const width = Math.abs(p2.x - p1.x);\n                //const height = Math.abs(p2.y - p1.y);\n                const rad = this.svgText.getRotationOfChar(i);\n                const diffx = (fontSize * 1 / 2) * Math.sin((rad / 180) * Math.PI);\n                const diffy = (fontSize * 3 / 8) + ((fontSize * 3 / 8) * Math.cos((rad / 180) * Math.PI));\n                const left = p1.x + globalX + diffx;\n                //const top = this.graph.svgGroup.getY() + p1.y - (fontSize / 2);\n                const top = p1.y + globalY - (fontSize * 1 / 4) - diffy;\n                //const top = p1.y + globalY  - diffy;\n                //const top = this.graph.svgGroup.getY() + p1.y - diffy;\n                s.push(`Sub create${id}_label_${i}(shapes_ As Shapes)`);\n                s.push(`With shapes_.AddTextBox(msoTextOrientationHorizontal, ${left}, ${top},${width},${fontSize})`);\n                s.push(`.TextFrame.TextRange.Text = \"${(0, vba_functions_1.sanityze)(character)}\"`);\n                s.push(`.TextFrame.marginLeft = 0`);\n                s.push(`.TextFrame.marginRight = 0`);\n                s.push(`.TextFrame.marginTop = 0`);\n                s.push(`.TextFrame.marginBottom = 0`);\n                s.push(`.TextFrame.TextRange.Font.color.RGB = RGB(CInt(${childColor.r}), CInt(${childColor.g}), CInt(${childColor.b}))`);\n                s.push(`.TextFrame.TextRange.Font.Size = ${fontSize}`);\n                s.push(`.TextFrame.TextRange.Font.name = \"${fontFamily}\"`);\n                s.push(`.TextFrame.TextRange.Font.Bold = ${fontBold}`);\n                s.push(`.IncrementRotation(${this.svgText.getRotationOfChar(i)})`);\n                //s.push(`.IncrementRotation(${this.svgText.transform.baseVal.getItem(0).angle})`);\n                s.push(`End With`);\n                s.push(`End Sub`);\n                r.push(s);\n            }\n        });\n        /*\n        for (let i = 0; i < this.svgText.getNumberOfChars(); i++) {\n        }\n        */\n        /*\n        if (this.svgTextPath.textContent != null) {\n        }\n        */\n        return r;\n    }\n}\nexports.ZEdge = ZEdge;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_edge.ts?");

/***/ }),

/***/ "./src/objects/z_ellipse.ts":
/*!**********************************!*\
  !*** ./src/objects/z_ellipse.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZEllipse = exports.ZAbstractEllipseCircle = void 0;\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nclass ZAbstractEllipseCircle extends z_textbox_1.ZTextBox {\n    get rx() {\n        return 5;\n    }\n    get ry() {\n        return 5;\n    }\n    /**\n    頂点の幅を返します。\n    */\n    get width() {\n        return this.rx * 2;\n    }\n    /**\n    頂点の高さを返します。\n    */\n    get height() {\n        return this.ry * 2;\n    }\n    constructor(svgbox) {\n        super(svgbox);\n    }\n    /**\n    テキストの領域を返します。\n    */\n    /*\n     get innerRectangle(): Rectangle {\n         const rect = new Rectangle();\n         const textRect = SVGTextExtension.getVirtualRegion(this.svgText);\n \n         //const rect = new Rectangle();\n         rect.width = this.width;\n         rect.height = this.height;\n         rect.x = -this.rx;\n         rect.y = -this.ry;\n         return rect;\n     }\n     */\n    /*\n    public getPosition(type: ConnectorType) : [number, number]{\n        const centerX = (Math.sqrt(2) / 2) * this.rx;\n        const centerY = (Math.sqrt(2) / 2) * this.ry;\n\n        switch (type) {\n            case ConnectorType.Top:\n                return [this.cx, this.cy - this.ry];\n            case ConnectorType.TopRight:\n                return [this.cx + centerX, this.cy - centerY];\n            case ConnectorType.Right:\n                return [this.cx + this.rx, this.cy];\n            case ConnectorType.BottomRight:\n                return [this.cx + centerX, this.cy + centerY];\n            case ConnectorType.Bottom:\n                return [this.cx, this.cy + this.ry];\n            case ConnectorType.BottomLeft:\n                return [this.cx - centerX, this.cy + centerY];\n            case ConnectorType.Left:\n                return [this.cx - this.rx, this.cy];\n            case ConnectorType.TopLeft:\n                return [this.cx - centerX, this.cy - centerY];\n            default:\n                return [this.cx, this.cy - this.ry];\n        }\n\n    }\n    */\n    getContactPosition(type, x, y) {\n        const centerX = (Math.sqrt(2) / 2) * this.rx;\n        const centerY = (Math.sqrt(2) / 2) * this.ry;\n        switch (type) {\n            case enums_1.ConnectorType.Top:\n                return [this.cx, this.cy - this.ry];\n            case enums_1.ConnectorType.TopRight:\n                return [this.cx + centerX, this.cy - centerY];\n            case enums_1.ConnectorType.Right:\n                return [this.cx + this.rx, this.cy];\n            case enums_1.ConnectorType.BottomRight:\n                return [this.cx + centerX, this.cy + centerY];\n            case enums_1.ConnectorType.Bottom:\n                return [this.cx, this.cy + this.ry];\n            case enums_1.ConnectorType.BottomLeft:\n                return [this.cx - centerX, this.cy + centerY];\n            case enums_1.ConnectorType.Left:\n                return [this.cx - this.rx, this.cy];\n            case enums_1.ConnectorType.TopLeft:\n                return [this.cx - centerX, this.cy - centerY];\n            default:\n                const autoType = this.getContactAutoPosition(x, y);\n                return this.getContactPosition(autoType, x, y);\n        }\n    }\n    getContactAutoPosition(x, y) {\n        const centerX = (Math.sqrt(2) / 2) * this.rx;\n        const centerY = (Math.sqrt(2) / 2) * this.ry;\n        const lineTop = new vline_1.VLine(x, y, this.cx, this.cy - centerY);\n        const lineTopRight = new vline_1.VLine(x, y, this.cx + centerX, this.cy - centerY);\n        const lineRight = new vline_1.VLine(x, y, this.cx + centerX, this.cy);\n        const lineBottomRight = new vline_1.VLine(x, y, this.cx + centerX, this.cy + centerY);\n        const lineBottom = new vline_1.VLine(x, y, this.cx, this.cy + centerY);\n        const lineBottomLeft = new vline_1.VLine(x, y, this.cx - centerX, this.cy + centerY);\n        const lineLeft = new vline_1.VLine(x, y, this.cx - centerX, this.cy);\n        const lineTopLeft = new vline_1.VLine(x, y, this.cx - centerX, this.cy - centerY);\n        const arr = [[lineTop.distance(), enums_1.ConnectorType.Top], [lineTopRight.distance(), enums_1.ConnectorType.TopRight], [lineRight.distance(), enums_1.ConnectorType.Right],\n            [lineBottomRight.distance(), enums_1.ConnectorType.BottomRight], [lineBottom.distance(), enums_1.ConnectorType.Bottom], [lineBottomLeft.distance(), enums_1.ConnectorType.BottomLeft],\n            [lineLeft.distance(), enums_1.ConnectorType.Left], [lineTopLeft.distance(), enums_1.ConnectorType.TopLeft]];\n        const [minDis, minDir] = arr.reduce(([a, b], [c, d]) => {\n            if (a < c) {\n                return [a, b];\n            }\n            else {\n                return [c, d];\n            }\n        });\n        return minDir;\n        /*\n        const line2 = new VLine(this.x, this.y, this.x + r, this.y - r);\n \n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n \n        if (b1) {\n            if (b2) {\n                return ConnectorType.Top;\n            } else {\n                return ConnectorType.Right;\n            }\n        } else {\n            if (b2) {\n                return ConnectorType.Left;\n            } else {\n                return ConnectorType.Bottom;\n            }\n        }\n        */\n    }\n    get surfaceRegion() {\n        const x = -this.rx;\n        const y = -this.ry;\n        const w = this.width;\n        const h = this.height;\n        return new vline_1.Rectangle(x, y, w, h);\n    }\n}\nexports.ZAbstractEllipseCircle = ZAbstractEllipseCircle;\nclass ZEllipse extends ZAbstractEllipseCircle {\n    get svgEllipse() {\n        return this._svgSurface;\n    }\n    constructor(svgbox) {\n        super(svgbox);\n        if (this.type == enums_1.ShapeObjectType.Ellipse)\n            this.firstFunctionAfterInitialized();\n    }\n    createSurface(svgbox) {\n        //if(option.surfaceClass === undefined) option.surfaceClass = DefaultClassNames.defaultSurfaceClass;\n        this._svgSurface = ZEllipse.createEllipse(this.svgGroup, DefaultClassNames.defaultSurfaceClass, undefined);\n        this.svgGroup.insertBefore(this.svgEllipse, this.svgText);\n    }\n    static createEllipse(parent, className, style) {\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');\n        circle.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Surface);\n        parent.appendChild(circle);\n        GOptions.setClassAndStyle(circle, className, style);\n        circle.rx.baseVal.value = AttributeNames.defaultCircleRadius;\n        circle.ry.baseVal.value = AttributeNames.defaultCircleRadius;\n        const radius = ElementExtension.getPropertyStyleNumberValue(circle, StyleNames.defaultRadius, null);\n        if (radius != null) {\n            circle.rx.baseVal.value = radius;\n            circle.ry.baseVal.value = radius;\n        }\n        circle.cx.baseVal.value = 0;\n        circle.cy.baseVal.value = 0;\n        return circle;\n    }\n    /*\n    public static constructAttributes(e: Element, removeAttributes: boolean = false, output: GOptions.ZTextBoxAttributes = {}): GOptions.ZTextBoxAttributes {\n        ZTextBox.constructAttributes(e, removeAttributes, output);\n\n\n        return output;\n    }\n    */\n    get width() {\n        return (0, vline_1.round100)(this.svgEllipse.rx.baseVal.value * 2);\n    }\n    get height() {\n        return (0, vline_1.round100)(this.svgEllipse.ry.baseVal.value * 2);\n    }\n    set width(value) {\n        const _rx = value / 2;\n        if (this.width != value)\n            ElementExtension.setAttributeNumber(this.svgEllipse, \"rx\", _rx);\n    }\n    set height(value) {\n        const _ry = value / 2;\n        if (this.height != value)\n            ElementExtension.setAttributeNumber(this.svgEllipse, \"ry\", _ry);\n        //this.svgEllipse.setAttribute(\"ry\", _ry.toString());\n    }\n    get rx() {\n        return (0, vline_1.round100)(this.svgEllipse.rx.baseVal.value);\n    }\n    get ry() {\n        return (0, vline_1.round100)(this.svgEllipse.ry.baseVal.value);\n    }\n    get type() {\n        return enums_1.ShapeObjectType.Ellipse;\n    }\n    /*\n    public getLocation(type: ConnectorPosition, x: number, y: number): [number, number] {\n\n        const centerX = (Math.sqrt(2) / 2) * this.svgEllipse.rx.baseVal.value;\n        const centerY = (Math.sqrt(2) / 2) * this.svgEllipse.ry.baseVal.value;\n\n        switch (type) {\n            case ConnectorType.Top:\n                return [this.cx, this.cy - this.ry];\n            case ConnectorType.TopRight:\n                return [this.cx + centerX, this.cy - centerY];\n            case ConnectorType.Right:\n                return [this.cx + this.rx, this.cy];\n            case ConnectorType.BottomRight:\n                return [this.cx + centerX, this.cy + centerY];\n            case ConnectorType.Bottom:\n                return [this.cx, this.cy + this.ry];\n            case ConnectorType.BottomLeft:\n                return [this.cx - centerX, this.cy + centerY];\n            case ConnectorType.Left:\n                return [this.cx - this.rx, this.cy];\n            case ConnectorType.TopLeft:\n                return [this.cx - centerX, this.cy - centerY];\n            default:\n                const autoType = this.getAutoPosition(x, y);\n                return this.getLocation(autoType, x, y);\n        }\n    }\n    protected getAutoPosition(x: number, y: number): ConnectorPosition {\n        const radius = this.rx;\n        const r = (Math.sqrt(2) / 2) * radius;\n        const line1 = new VLine(this.x, this.y, this.x + r, this.y + r);\n        const line2 = new VLine(this.x, this.y, this.x + r, this.y - r);\n\n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n\n        if (b1) {\n            if (b2) {\n                return ConnectorType.Top;\n            } else {\n                return ConnectorType.Right;\n            }\n        } else {\n            if (b2) {\n                return ConnectorType.Left;\n            } else {\n                return ConnectorType.Bottom;\n            }\n        }\n    }\n    */\n    get shape() {\n        return enums_1.VBAShapeType.Oval;\n    }\n}\nexports.ZEllipse = ZEllipse;\n/*\nexport type EllipseAttributes = TextBoxShapeAttributes & {\n    speakerX? : number,\n    speakerY? : number,\n}\n*/\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_ellipse.ts?");

/***/ }),

/***/ "./src/objects/z_foreign_button.ts":
/*!*****************************************!*\
  !*** ./src/objects/z_foreign_button.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZForeignButton = void 0;\nconst z_foreign_object_1 = __webpack_require__(/*! ./z_foreign_object */ \"./src/objects/z_foreign_object.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst html_1 = __webpack_require__(/*! ../html */ \"./src/html/index.ts\");\nclass ZForeignButton extends z_foreign_object_1.ZForeignObject {\n    //private static updateTextAttributes = [\"style\"]\n    constructor(svgbox) {\n        super(svgbox);\n        //console.log(option);\n        this._button = document.createElement(\"button\");\n        /*\n        if(option != null){\n            if(option.text != undefined){\n                if(typeof option.text == \"string\"){\n                    this._button.textContent = option.text;\n                }else{\n                    let s = \"\";\n                    option.text.forEach((v) => s += v.textContent);\n                    this._button.textContent = s;\n                }\n            }\n        }\n        */\n        this.foreignObject.appendChild(this._button);\n        if (this.type == enums_1.ShapeObjectType.Object)\n            this.firstFunctionAfterInitialized();\n    }\n    get type() {\n        return enums_1.ShapeObjectType.ForeignButton;\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        if (source.children.length > 0) {\n            let s = \"\";\n            const tNodes = html_1.HTMLFunctions.getTNodes(source);\n            if (tNodes != null) {\n                tNodes.forEach((v) => v.remove());\n                tNodes.forEach((v) => {\n                    s += v.textContent;\n                });\n                this._button.textContent = s;\n            }\n        }\n        else if (source.innerHTML.length > 0) {\n            this._button.textContent = source.textContent;\n            source.innerHTML = \"\";\n        }\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZTextBoxAttributes) {\n        super.setBasicOption(option)\n        const textClass = CSS.createCSSClass(option.textClass);\n        const styleClass = CSS.createCSSClass(option.textStyle);\n        //GOptions.setClassAndStyle(this._button, textClass, styleClass);\n        \n\n        if (typeof option.text == \"string\") {\n            this._button.textContent = option.text\n        } else if (Array.isArray(option.text)) {\n            let s = \"\";\n            option.text.forEach((v) => s += v.textContent);\n            this._button.textContent = s;\n        } else {\n\n        }\n    }\n    */\n    get width() {\n        return this._button.getBoundingClientRect().width;\n    }\n    set width(value) {\n        this._button.style.setProperty(\"width\", `${value}px`);\n    }\n    /**\n    頂点の高さを返します。\n    */\n    get height() {\n        return this._button.getBoundingClientRect().height;\n    }\n    set height(value) {\n        this._button.style.setProperty(\"height\", `${value}px`);\n    }\n}\nexports.ZForeignButton = ZForeignButton;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_foreign_button.ts?");

/***/ }),

/***/ "./src/objects/z_foreign_object.ts":
/*!*****************************************!*\
  !*** ./src/objects/z_foreign_object.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZForeignObject = void 0;\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nclass ZForeignObject extends z_vertex_1.ZVertex {\n    //private static updateTextAttributes = [\"style\"]\n    get foreignObject() {\n        return this._foreignObject;\n    }\n    constructor(svgbox) {\n        super(svgbox);\n        this._foreignObject = ZForeignObject.createForeignObject(this.svgGroup, undefined, undefined);\n        if (this.type == enums_1.ShapeObjectType.Object)\n            this.firstFunctionAfterInitialized();\n    }\n    static createForeignObject(parent, className, style) {\n        const obj = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n        parent.appendChild(obj);\n        obj.width.baseVal.value = 30;\n        obj.height.baseVal.value = 30;\n        if (style !== undefined) {\n            if (typeof (style) == \"string\") {\n                obj.setAttribute(\"style\", style);\n            }\n            else {\n                obj.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\n            }\n        }\n        //if(style !== undefined) rect.setAttribute(\"style\", style);\n        return obj;\n    }\n    get type() {\n        return enums_1.ShapeObjectType.ForeignObject;\n    }\n}\nexports.ZForeignObject = ZForeignObject;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_foreign_object.ts?");

/***/ }),

/***/ "./src/objects/z_graph.ts":
/*!********************************!*\
  !*** ./src/objects/z_graph.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZGraph = void 0;\n//namespace GraphTableSVG {\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nconst z_edge_1 = __webpack_require__(/*! ./z_edge */ \"./src/objects/z_edge.ts\");\nconst z_rect_1 = __webpack_require__(/*! ./z_rect */ \"./src/objects/z_rect.ts\");\nconst z_callout_1 = __webpack_require__(/*! ./z_callout */ \"./src/objects/z_callout.ts\");\nconst z_arrow_callout_1 = __webpack_require__(/*! ./z_arrow_callout */ \"./src/objects/z_arrow_callout.ts\");\nconst z_ellipse_1 = __webpack_require__(/*! ./z_ellipse */ \"./src/objects/z_ellipse.ts\");\nconst z_circle_1 = __webpack_require__(/*! ./z_circle */ \"./src/objects/z_circle.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst graph_arrangement_1 = __webpack_require__(/*! ./graph_helpers/graph_arrangement */ \"./src/objects/graph_helpers/graph_arrangement.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\nconst z_table_1 = __webpack_require__(/*! ./z_table */ \"./src/objects/z_table.ts\");\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\n/**\nグラフを表します。\n*/\nclass ZGraph extends z_object_1.ZObject {\n    constructor(box) {\n        super(box);\n        this.objectCreatedFunction = (e) => {\n            const obj = z_object_1.ZObject.getObjectFromIDOrObjectID(e.target);\n            if (obj instanceof z_vertex_1.ZVertex) {\n                this.dispatchVertexCreatedEvent(obj);\n            }\n            else if (obj instanceof z_edge_1.ZEdge) {\n            }\n            else {\n            }\n        };\n        if (this.type == enums_1.ShapeObjectType.Graph)\n            this.firstFunctionAfterInitialized();\n        //this.setOptionInGObject(option)\n        //this.svgGroup.addEventListener(AttributeNames.objectCreatedEventName, this.objectCreatedFunction);\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZGraphAttributes){\n        super.setBasicOption(option);\n        if (option.isLatexMode == undefined) option.isLatexMode = false;\n        if (option.direction !== undefined) {\n            this.direction = option.direction;\n        }\n\n        if (option.relocateStyle !== undefined) {\n            this.relocateStyle = option.relocateStyle;\n        } else {\n            //this.relocateStyle = \"standard\"\n        }\n    }\n    */\n    /*\n    public setOption(option: GOptions.ZGraphAttributes){\n        super.setOption(option);\n    }\n    */\n    get graphAllocateFunction() {\n        const svg = this.svgGroup;\n        const f = svg.__graph_allocate_function;\n        return f;\n    }\n    set graphAllocateFunction(value) {\n        this.svgGroup.__graph_allocate_function = value;\n    }\n    get isCenterBased() {\n        return false;\n    }\n    get vertices() {\n        const r = [];\n        HTMLFunctions.getChildren(this.svgGroup).filter((v) => v.hasAttribute(AttributeNames.objectIDName)).forEach((v) => {\n            const item = z_object_1.ZObject.getObjectFromIDOrObjectID(v.getAttribute(AttributeNames.objectIDName));\n            if (item instanceof z_vertex_1.ZVertex) {\n                r.push(item);\n            }\n        });\n        return r;\n    }\n    get edges() {\n        const r = [];\n        HTMLFunctions.getChildren(this.svgGroup).filter((v) => v.hasAttribute(AttributeNames.objectIDName)).forEach((v) => {\n            const item = z_object_1.ZObject.getObjectFromIDOrObjectID(v.getAttribute(AttributeNames.objectIDName));\n            if (item instanceof z_edge_1.ZEdge) {\n                r.push(item);\n            }\n        });\n        return r;\n    }\n    get roots() {\n        return this.vertices.filter((v) => v.incomingEdges.length == 0);\n    }\n    //protected _roots: ZVertex[] = [];\n    get vertexXInterval() {\n        const v = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.vertexXInterval);\n        if (v == null) {\n            return null;\n        }\n        else {\n            return parseInt(v);\n        }\n    }\n    set vertexXInterval(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.vertexXInterval, value == null ? null : value.toString());\n    }\n    get vertexYInterval() {\n        const v = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.vertexYInterval);\n        if (v == null) {\n            return null;\n        }\n        else {\n            return parseInt(v);\n        }\n    }\n    get direction() {\n        const v = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.graphDirection);\n        if (v == null) {\n            return null;\n        }\n        else {\n            if (v == \"up\") {\n                return \"up\";\n            }\n            else if (v == \"left\") {\n                return \"left\";\n            }\n            else if (v == \"right\") {\n                return \"right\";\n            }\n            else {\n                return \"down\";\n            }\n        }\n    }\n    set direction(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.graphDirection, value == null ? null : value.toString());\n    }\n    set vertexYInterval(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.GraphStyleNames.vertexYInterval, value == null ? null : value.toString());\n    }\n    /*\n    get defaultVertexClass(): string | null {\n        return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultVertexClass);\n    }\n    set defaultVertexClass(value: string | null) {\n        this.svgGroup.setPropertyStyleValue(AttributeNames.Style.defaultVertexClass, value);\n    }\n    */\n    /*\n     get defaultEdgeClass(): string | null {\n         return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultEdgeClass);\n     }\n     */\n    /*\n     set defaultEdgeClass(value: string | null) {\n         this.svgGroup.setPropertyStyleValue(AttributeNames.Style.defaultEdgeClass, value);\n     }\n     */\n    /**\n    根を返します。\n    */\n    get rootVertex() {\n        if (this.roots.length == 0) {\n            return null;\n        }\n        else {\n            return this.roots[0];\n        }\n    }\n    /**\n     * 頂点もしくは辺をグラフに追加します。\n     * @param item\n     */\n    add(item) {\n        if (item instanceof z_edge_1.ZEdge) {\n            this.svgGroup.appendChild(item.svgGroup);\n        }\n        else {\n            this.svgGroup.insertBefore(item.svgGroup, this.svgGroup.firstChild);\n        }\n    }\n    /**\n     * 頂点もしくは辺を削除します。\n     * @param item\n     */\n    remove(item) {\n        this.svgGroup.removeChild(item.svgGroup);\n        item.dispose();\n    }\n    clear() {\n        while (this.edges.length > 0) {\n            this.remove(this.edges[0]);\n        }\n        while (this.vertices.length > 0) {\n            this.remove(this.vertices[0]);\n        }\n    }\n    /*\n    public connect(beginVertex: ZVertex, edge: ZEdge, endVertex: ZVertex, option: GOptions.ConnecterOption = {}) {\n\n        const oIndex = option.outcomingInsertIndex == undefined ? beginVertex.outgoingEdges.length : option.outcomingInsertIndex;\n        const iIndex = option.incomingInsertIndex == undefined ? endVertex.incomingEdges.length : option.incomingInsertIndex;\n        //this._connect(node1, edge, node2);\n\n        beginVertex.insertOutcomingEdge(edge, oIndex);\n        endVertex.insertIncomingEdge(edge, iIndex);\n\n        const i = this.roots.indexOf(beginVertex);\n        const j = this.roots.indexOf(endVertex);\n        if (j != -1) {\n            if (i == -1) {\n                this.roots[j] = beginVertex;\n            } else {\n                this.roots.splice(j, 1);\n            }\n        }\n        if (option.beginConnectorType != undefined) edge.beginConnectorType = option.beginConnectorType;\n        if (option.endConnectorType != undefined) edge.endConnectorType = option.endConnectorType;\n    }\n    */\n    getOrderedVertices(order, node = null) {\n        const r = [];\n        if (node == null) {\n            this.roots.forEach((v) => {\n                this.getOrderedVertices(order, v).forEach((w) => {\n                    r.push(w);\n                });\n            });\n        }\n        else {\n            const edges = node.outgoingEdges;\n            if (order == enums_1.VertexOrder.Preorder) {\n                r.push(node);\n                edges.forEach((v) => {\n                    this.getOrderedVertices(order, v.endVertex).forEach((w) => {\n                        r.push(w);\n                    });\n                });\n            }\n            else if (order == enums_1.VertexOrder.Postorder) {\n                edges.forEach((v) => {\n                    this.getOrderedVertices(order, v.endVertex).forEach((w) => {\n                        r.push(w);\n                    });\n                });\n                r.push(node);\n            }\n        }\n        return r;\n    }\n    /**\n     * 親ノードに子ノードを追加します。\n     * @param parent\n     * @param child\n     * @param option\n     */\n    /*\n    public appendChild(parent: ZVertex, child: ZVertex | null, option: { insertIndex?: number } = {}) {\n        const _child = child == null ? ZGraph.createVertex2(this) : child;\n        const edge: ZEdge = <any>GGraph.createEdge(this);\n        this.connect(parent, edge, _child, { beginConnectorType: \"bottom\", endConnectorType: \"top\" });\n        //this.createdNodeCallback(child);\n        this.relocate();\n\n    }\n    */\n    get relocateStyle() {\n        return ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.relocateName);\n    }\n    set relocateStyle(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.relocateName, value);\n    }\n    relocate() {\n        //if(this.isDrawnText()){\n        this.hasConnectedObserverFunction = false;\n        const value = this.relocateStyle;\n        if (this.graphAllocateFunction !== undefined) {\n            this.graphAllocateFunction(this);\n        }\n        else if (value != null) {\n            if (value == \"standard\") {\n                graph_arrangement_1.GraphArrangement.standardTreeWidthArrangement(this);\n            }\n            else {\n                //const p = Function(\"v\", `return ${value}(v)`);\n                const f = Function(\"graph\", `${value}(graph)`);\n                f(this);\n            }\n        }\n        //this.relocate();\n        //this.moveInCanvas();\n        this.hasConnectedObserverFunction = true;\n        // }\n    }\n    get width() {\n        return this.Noderegion().width;\n    }\n    get height() {\n        return this.Noderegion().height;\n    }\n    set width(value) {\n    }\n    set height(value) {\n    }\n    Noderegion() {\n        const _x = SVGGExtension.getX(this.svgGroup);\n        const _y = SVGGExtension.getY(this.svgGroup);\n        let left = _x;\n        let right = _y;\n        let top = _x;\n        let bottom = _y;\n        this.vertices.forEach((v) => {\n            const x = v.x + _x;\n            const y = v.y + _y;\n            if (x < left)\n                left = x;\n            if (right < (x + v.width))\n                right = x + v.width;\n            if (y < top)\n                top = y;\n            if (bottom < (y + v.height))\n                bottom = y + v.height;\n        });\n        return new vline_1.Rectangle(left, top, right - left, bottom - top);\n    }\n    moveInCanvas() {\n        const rect = this.Noderegion();\n        if (rect.x < 0) {\n            this.x = this.x - (rect.x);\n        }\n        if (rect.y < 0) {\n            this.y = this.y - (rect.y);\n        }\n    }\n    /**\n     * グラフ内のVertexからVertex間の水平間隔と垂直間隔を自動で算出します。\n     * @param graph\n     */\n    computeAutoXYIntervals() {\n        let yMaximalInterval = 10;\n        let xMaximalInterval = 10;\n        this.vertices.forEach((v) => {\n            if (v.width > xMaximalInterval)\n                xMaximalInterval = v.width;\n            if (v.height > yMaximalInterval)\n                yMaximalInterval = v.height;\n        });\n        return [xMaximalInterval + 30, yMaximalInterval + 30];\n    }\n    /**\n     * グラフに設定されているVertex間の水平間隔と垂直間隔を算出します。\n     * @param graph\n     */\n    getXYIntervals() {\n        const [xMaximalInterval, yMaximalInterval] = this.computeAutoXYIntervals();\n        const xi = this.vertexXInterval != null ? this.vertexXInterval : xMaximalInterval;\n        const yi = this.vertexYInterval != null ? this.vertexYInterval : yMaximalInterval;\n        return [xi, yi];\n    }\n    /*\n    public build(logicGraph: LogicGraph | LogicTree ) {\n        const option = logicGraph.option;\n        if(option ===undefined){\n            throw new Exceptions.UndefinedError();\n        }\n        //this.setOption(option);\n        //if (option.isLatexMode == undefined) option.isLatexMode = false;\n        this.clear();\n        const svgsvg = SVG.getSVGSVG(this.svgGroup);\n        //if (option.direction !== undefined) {\n        //    this.direction = option.direction;\n       // }\n\n        \n\n        if (logicGraph instanceof LogicGraph) {\n            const dic: Map<number, ZVertex> = new Map();\n\n            logicGraph.nodes.forEach((v, i) => {\n                const node = ZGraph.createVertex(svgsvg, ShapeObjectType.Circle)\n                const svgText = node.tryGetSVGText();\n                if(svgText != null){\n                    svgText.textContent = v.text;\n                }\n                this.add(node);\n                dic.set(i, node);\n            })\n            logicGraph.nodes.forEach((v, i) => {\n                v.outputEdges.forEach((e, j) => {\n                    const edge = ZGraph.createEdge(svgsvg)\n                    if (e.text != undefined) {\n                        const b = option.isLatexMode == undefined ? false : option.isLatexMode;\n                        Extensions.setTextContent(edge.svgTextPath, e.text, b);\n\n                    }\n                    this.add(edge);\n                    const beginNode = dic.get(i);\n                    const endNode = dic.get(e.endNodeIndex);\n                    if (beginNode == undefined || endNode == undefined) throw Error(\"error\");\n                    this.connect(beginNode, edge, endNode);\n                })\n            })\n        } else {\n    \n            const dic: Map<LogicTreeNode, ZVertex> = new Map();\n            if(logicGraph.root != null){\n                logicGraph.root.getOrderedNodes(VertexOrder.Preorder).forEach((v, i) => {\n                    const node = v.shapeObject instanceof LogicTable ? ZGraph.createVertexTable(svgsvg, v.shapeObject) : ZGraph.createVertex(svgsvg, v.shapeObject.shape, v.shapeObject.option)\n                    if(this.roots.length == 0) this.roots.push(node);\n                    this.add(node);\n                    dic.set(v, node);\n                })\n                logicGraph.root.getOrderedNodes(VertexOrder.Preorder).forEach((v, i) => {\n                    v.children.forEach((e, j) => {\n                        if (e != null) {\n                            const edge = ZGraph.createEdge(svgsvg, e.edgeOption)\n                            if (edge.svgTextPath.textContent != null) {\n                                edge.isAppropriatelyReverseMode = true;\n                            }\n                            this.add(edge);\n                            const beginNode = dic.get(v);\n                            const endNode = dic.get(e);\n\n                            if (beginNode == undefined || endNode == undefined) throw Error(\"error\");\n                            this.connect(beginNode, edge, endNode);\n                        }\n    \n                    })\n                })\n    \n            }else{\n                throw Error(\"error\")\n            }\n        }\n\n        this.relocate();\n\n    }\n    */\n    /*\n     public constructFromLogicTree(roots: LogicTree[] | LogicTree, option: { x?: number, y?: number, isLatexMode?: boolean } = {}) {\n         if (option.isLatexMode == undefined) option.isLatexMode = false;\n         if (roots instanceof Array) {\n             this.clear();\n             roots.forEach((v) => {\n                 if (v != null) {\n                     this.createChildFromLogicTree(null, v, option);\n                 }\n             });\n             this.relocate();\n \n         } else {\n             this.constructFromLogicTree([roots], option);\n         }\n         if (option.x != undefined) this.svgGroup.setX(option.x);\n         if (option.y != undefined) this.svgGroup.setY(option.y);\n \n         //this.roots = roots;\n     }\n     */\n    removeGraph(svg) {\n        if (svg.contains(this.svgGroup)) {\n            svg.removeChild(this.svgGroup);\n        }\n    }\n    /*\n    public isDrawnText() :boolean{\n        if(this.edges.length == 0){\n            return true;\n        }else{\n            \n            const b = this.edges.every((v) => v.isDrawnText());\n            return b;\n        }\n    }\n    */\n    /**\n     * グラフの領域を表すRectangleを返します。位置の基準はグラフが追加されているNodeです。\n     */\n    getRegion() {\n        const rects = this.vertices.map((v) => v.region);\n        const rect = vline_1.Rectangle.merge(rects);\n        rect.addOffset(SVGGExtension.getX(this.svgGroup), SVGGExtension.getY(this.svgGroup));\n        return rect;\n    }\n    /**\n     * 入力のVertexを親として、入力のLogicTreeを子とした部分木を作成します。\n     * @param parent 親にするVertex\n     * @param logicVertex 子にするLogicTree\n     * @param option 作成オプション\n     * @returns logicVertexを表すVertex\n     */\n    /*\n    private createChildFromLogicTree<T>(parent: ZVertex | null = null, logicVertex: LogicTreeGraph, option: { isLatexMode?: boolean } = {}): ZVertex {\n        if (option.isLatexMode == undefined) option.isLatexMode = false;\n        const node: ZVertex = <any>GGraph.createVertex2(this, logicVertex.vertexOption);\n\n        if (parent != null) {\n            const edge: ZEdge = ZGraph.createEdge(this, logicVertex.edgeOption);\n            this.connect(parent, edge, node, { beginConnectorType: \"bottom\", endConnectorType: \"top\" });\n        } else {\n            this.roots.push(node);\n        }\n        logicVertex.children.forEach((v) => {\n            if (v != null) this.createChildFromLogicTree(node, v, option);\n        });\n        return node;\n    }\n    */\n    createVBACode(id) {\n        const r = [];\n        this.vertices.forEach((v) => v.createVBACode(id++).forEach((w) => r.push(w)));\n        this.edges.forEach((v) => v.createVBACode(id++).forEach((w) => r.push(w)));\n        return r;\n    }\n    get VBAObjectNum() {\n        return this.vertices.length + this.edges.length;\n    }\n    getStyleValue(className, valueName) {\n        if (this.svgGroup.hasAttribute(\"class\")) {\n            const oldClass = this.svgGroup.getAttribute(\"class\");\n            this.svgGroup.setAttribute(\"class\", className);\n            const r = ElementExtension.getPropertyStyleValue(this.svgGroup, valueName);\n            this.svgGroup.setAttribute(\"class\", oldClass);\n            return r;\n        }\n        else {\n            this.svgGroup.setAttribute(\"class\", className);\n            const r = ElementExtension.getPropertyStyleValue(this.svgGroup, valueName);\n            this.svgGroup.removeAttribute(\"class\");\n            return r;\n        }\n    }\n    dispatchVertexCreatedEvent(vertex) {\n        var event = document.createEvent(\"HTMLEvents\");\n        event.initEvent(AttributeNames.vertexCreatedEventName, true, true);\n        vertex.svgGroup.dispatchEvent(event);\n    }\n    setRootIndex(vertex, rootIndex) {\n        if (vertex.graph == this) {\n            if (rootIndex < this.roots.length) {\n                this.svgGroup.insertBefore(vertex.svgGroup, this.roots[rootIndex].svgGroup);\n            }\n            else {\n                if (this.roots.length == 0) {\n                    if (this.svgGroup.firstChild == null) {\n                        this.svgGroup.appendChild(vertex.svgGroup);\n                    }\n                    else {\n                        this.svgGroup.insertBefore(vertex.svgGroup, this.svgGroup.firstChild);\n                    }\n                }\n                else {\n                    if (this.roots[this.roots.length - 1].svgGroup.nextSibling == null) {\n                        this.svgGroup.appendChild(vertex.svgGroup);\n                    }\n                    else {\n                        this.svgGroup.insertBefore(vertex.svgGroup, this.roots[this.roots.length - 1].svgGroup.nextSibling);\n                    }\n                }\n            }\n        }\n        else {\n            throw Error(\"error!\");\n        }\n    }\n    observerFunction(x) {\n        super.observerFunction(x);\n        for (let i = 0; i < x.length; i++) {\n            const p = x[i];\n            if (p.attributeName == \"style\") {\n                this.relocate();\n            }\n        }\n    }\n    get type() {\n        return enums_1.ShapeObjectType.Graph;\n    }\n    update() {\n        super.update();\n        this.vertices.forEach((v) => {\n            v.update();\n        });\n        this.edges.forEach((v) => {\n            v.update();\n        });\n        this.relocate();\n    }\n    getUpdateFlag() {\n        const b0 = super.getUpdateFlag();\n        const arr1 = this.vertices.map((v) => v.getUpdateFlag());\n        const arr2 = this.edges.map((v) => v.getUpdateFlag());\n        const b1 = arr1.reduce((x, y) => x || y, false);\n        const b2 = arr2.reduce((x, y) => x || y, false);\n        const b = b0 || b1 || b2;\n        if (b) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `getUpdateFlag Type = ${this.type} ID = ${this.objectID}: (b0 = ${b0}, b1 = ${b1}, b2 = ${b2})`);\n        }\n        return b0 || b1 || b2;\n    }\n    static createVertex2(parent, option = {}) {\n        let _parent = parent.svgGroup;\n        if (option.class == undefined)\n            option.class = DefaultClassNames.defaultVertexClass;\n        const type = typeof (option.class) == \"string\" ? parent.getStyleValue(option.class, StyleNames.defaultSurfaceType) : null;\n        if (type != null) {\n            switch (type) {\n                case enums_1.ShapeObjectType.Callout: return new z_callout_1.ZCallout(_parent);\n                case enums_1.ShapeObjectType.ArrowCallout: return new z_arrow_callout_1.ZArrowCallout(_parent);\n                case enums_1.ShapeObjectType.Ellipse: return new z_ellipse_1.ZEllipse(_parent);\n                case enums_1.ShapeObjectType.Circle: return new z_circle_1.ZCircle(_parent);\n                case enums_1.ShapeObjectType.Rect: return new z_rect_1.ZRect(_parent);\n            }\n        }\n        return new z_ellipse_1.ZEllipse(_parent);\n    }\n    /*\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-rect-button\", option?: GOptions.ZTextBoxAttributes): ZRectButton\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-rect\", option?: GOptions.ZTextBoxAttributes): ZRect\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-path-textbox\", option?: GOptions.ZTextBoxAttributes): ZPathTextBox\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-ellipse\", option?: GOptions.ZTextBoxAttributes): ZEllipse\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-callout\", option?: GOptions.ZTextBoxAttributes): ZCallout\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-circle\", option?: GOptions.ZTextBoxAttributes): ZCircle\n    public static createVertex(parent: SVGElement | string | ZObject, type: \"z-arrow-callout\", option?: GOptions.ZTextBoxAttributes): ZArrowCallout\n    */\n    static getParent(parent) {\n        let _parent;\n        if (parent instanceof z_object_1.ZObject) {\n            _parent = parent.svgGroup;\n        }\n        else if (parent instanceof SVGElement) {\n            _parent = parent;\n        }\n        else {\n            _parent = document.getElementById(parent);\n        }\n        return _parent;\n    }\n    /*\n    public static createVertex(parent: SVGElement | string | ZObject, type: VertexObjectType, option: any = {}): ZVertex {\n        const _parent: SVGElement = ZGraph.getParent(parent);\n\n        switch (type) {\n            case ShapeObjectType.Callout:\n                const call = new ZCallout(_parent);\n                call.setOption(option);\n                return call;\n            case ShapeObjectType.ArrowCallout:\n                const arr = new ZArrowCallout(_parent);\n                arr.setOption(option);\n            case ShapeObjectType.Ellipse:\n                const ell = new ZEllipse(_parent);\n                ell.setOption(option);\n                return ell;\n            case ShapeObjectType.Rect:\n                const rect = new ZRect(_parent);\n                rect.setOption(option);\n                return rect;\n            case ShapeObjectType.Table:\n                const table = new ZTable(_parent);\n                table.setOption(option);\n                return table;\n            case ShapeObjectType.RectButton:\n                const rectb = new ZRectButton(_parent);\n                rectb.setOption(option);\n                return rectb;\n            case ShapeObjectType.Circle:\n                const circle = new ZCircle(_parent);\n                circle.setOption(option);\n                return circle;\n        }\n        throw new ArgumentOutOfRangeError();\n    }\n    */\n    static createVertexTable(parent, obj) {\n        const _parent = ZGraph.getParent(parent);\n        const table = new z_table_1.ZTable(_parent);\n        table.buildFromLogicTable(obj);\n        return table;\n    }\n    /*\n    public static createEdge(parent: SVGElement | string | ZObject, option: any = {}): ZEdge {\n        const _parent: SVGElement = ZGraph.getParent(parent);\n        const edge = new ZEdge(_parent);\n        edge.setOption(option);\n        return edge;\n    }\n    */\n    updateSurfaceWithoutSVGText() {\n        //super.updateSurfaceWithoutSVGText();\n        /*\n        this.vertices.forEach((v) =>{\n            v.update();\n        })\n        */\n        /*\n         this.edges.forEach((v) =>{\n             v.update();\n         })\n         */\n        this.relocate();\n        return true;\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        while (source.children.length > 0) {\n            const fst = source.children.item(0);\n            if (fst != null) {\n                this.svgGroup.append(fst);\n            }\n        }\n    }\n}\nexports.ZGraph = ZGraph;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_graph.ts?");

/***/ }),

/***/ "./src/objects/z_object.ts":
/*!*********************************!*\
  !*** ./src/objects/z_object.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZObject = void 0;\n//namespace GraphTableSVG {\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\nconst GUIObserver = __webpack_require__(/*! ../html/gui_observer */ \"./src/html/gui_observer.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst draggable_object_1 = __webpack_require__(/*! ../html/draggable_object */ \"./src/html/draggable_object.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst enums_2 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\nconst GObserver = __webpack_require__(/*! ./z_observer */ \"./src/objects/z_observer.ts\");\nconst global_gobject_manager_1 = __webpack_require__(/*! ./global_gobject_manager */ \"./src/objects/global_gobject_manager.ts\");\nclass ZObject {\n    constructor(svgbox) {\n        this._svgSurface = null;\n        /*\n        public get id() : string | null{\n            return this.svgGroup.getAttribute(\"id\");\n        }\n        */\n        /*\n        public setUnstableFlag() : void {\n            this.isStable = false;\n        }\n        */\n        /*\n        public get unstableCounter(): number | null {\n            const p = this.svgGroup.getAttribute(GObserver.unstableCounterName);\n            if (p == null) {\n                return null;\n            } else {\n                const num = Number(p);\n                return num;\n            }\n        }\n        protected set unstableCounter(value: number | null) {\n            if (value == null) {\n                this.svgGroup.removeAttribute(GObserver.unstableCounterName)\n            } else {\n                this.svgGroup.setAttribute(GObserver.unstableCounterName, value.toString());\n    \n            }\n        }\n        public resetUnstableCounter(): void {\n            this.unstableCounter = GObserver.unstableCounterDefault;\n        }\n        */\n        /*\n        public get shape() : ShapeObjectType {\n            return ShapeObjectType.Object;\n        }\n        */\n        this._isInitialized = false;\n        this._hasConnectedObserverFunction = false;\n        this.groupObserverOption = { attributes: true, childList: true, subtree: true };\n        this.pUpdateFunc = () => {\n            if (!this.isShown)\n                return;\n        };\n        this.observerFunc = (x) => {\n            this.observerFunction(x);\n        };\n        /*\n        public get isStable(): boolean {\n            const p = this.svgGroup.getAttribute(\"data-object-stable\");\n            return p == \"true\";\n        }\n        protected set isStable(value: boolean) {\n            this.svgGroup.setAttribute(\"data-object-stable\", value == true ? \"true\" : \"false\");\n        }\n        */\n        this._isUpdating = false;\n        this.updateAttributes = [\"style\", \"transform\", \"data-speaker-x\", \"data-speaker-y\",\n            \"data-width\", \"data-height\", \"data-arrow-neck-width\", \"data-arrow-neck-height\",\n            \"data-arrow-head-width\", \"data-arrow-head-height\"];\n        CSS.setGraphTableCSS();\n        let parentElement = svgbox instanceof SVGElement ? svgbox : document.getElementById(svgbox);\n        if (parentElement instanceof SVGSVGElement && !GUIObserver.isObserved(parentElement)) {\n            GUIObserver.observeSVGSVG(parentElement);\n        }\n        this._svgGroup = SVG.createGroup(parentElement);\n        this.stableFlag = false;\n        /*\n        GOptions.setClassAndStyle(this._svgGroup, option.class, option.style);\n        if(option.attributes !== undefined){\n            Object.keys(option.attributes).forEach((v) =>{\n                const value : string = option.attributes![v];\n                this._svgGroup.setAttribute(v, value);\n            })\n        }\n        */\n        ZObject.setObjectFromObjectID(this);\n        this.svgGroup.operator = this;\n        this.svgGroup.setAttribute(AttributeNames.GroupAttribute, this.type);\n        this.createSurface(parentElement);\n        this._observer = new MutationObserver(this.observerFunc);\n        this._observerOption = { attributes: true, childList: true, subtree: true };\n        this.hasConnectedObserverFunction = true;\n        this.dispatchObjectCreatedEvent();\n        this.addResizeEvent();\n        const __svg = this.svgGroup;\n        __svg.operator = this;\n        this.allowHover = true;\n        //this.unstableCounter = GObserver.unstableCounterDefault;\n        const svgsvgAncestor = HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvgAncestor instanceof SVGSVGElement) {\n            const xb = global_gobject_manager_1.GlobalZObjectManager.tryRegisterSVGSVGElement(svgsvgAncestor);\n            xb.registerObject(this);\n        }\n        //this.setOptionInGObject(option);\n        /*\n        if (_option.x !== undefined) this.fixedX = _option.x;\n        if (_option.y !== undefined) this.fixedY = _option.y;\n        */\n        if (this.type == enums_2.ShapeObjectType.Object)\n            this.firstFunctionAfterInitialized();\n    }\n    copyAttribute(from, to, attributeName, remove) {\n        const attr = from.getAttribute(attributeName);\n        if (attr != null) {\n            to.setAttribute(attributeName, attr);\n        }\n        if (remove) {\n            from.removeAttribute(attributeName);\n        }\n    }\n    initializeSetBasicOption(source) {\n        this.copyAttribute(source, this._svgGroup, \"class\", true);\n        this.copyAttribute(source, this._svgGroup, \"style\", true);\n        this.copyAttribute(source, this._svgGroup, \"id\", true);\n        const width = ElementExtension._getAttributeNumber(source, AttributeNames.width, true);\n        if (width != null) {\n            this.width = width;\n        }\n        const height = ElementExtension._getAttributeNumber(source, AttributeNames.height, true);\n        if (height != null) {\n            this.height = height;\n        }\n        if (this.svgSurface != null) {\n            ZObject.setSubAttributes(this.svgSurface, source);\n        }\n    }\n    static setSubAttributes(e, source) {\n        const objName = e.getAttribute(AttributeNames.dataNameAttribute);\n        if (objName != null) {\n            this.setSubAttributesWithObjName(e, objName, source);\n        }\n    }\n    static setSubAttributesWithObjName(e, objName, source) {\n        if (objName != null) {\n            const map = HTMLFunctions.getSubAttributeFromAncestors(source, objName);\n            map.forEach((value, key) => {\n                e.setAttribute(key, value);\n            });\n        }\n    }\n    //protected setText\n    initializeOptionalPosition(source) {\n        const cx = ElementExtension._getAttributeNumber(source, AttributeNames.cx, true);\n        const cy = ElementExtension._getAttributeNumber(source, AttributeNames.cy, true);\n        const x = ElementExtension._getAttributeNumber(source, AttributeNames.x, true);\n        const y = ElementExtension._getAttributeNumber(source, AttributeNames.y, true);\n        if (x != null || y != null) {\n            this.positionType = vline_1.PositionType.UpperLeft;\n            const __x = x == null ? 0 : x;\n            const __y = y == null ? 0 : y;\n            this.setVirtualXY(__x, __y);\n        }\n        else {\n            this.positionType = vline_1.PositionType.Center;\n            this.cx = cx == null ? 0 : cx;\n            this.cy = cy == null ? 0 : cy;\n        }\n    }\n    initialize(source) {\n        this.initializeSetBasicOption(source);\n        this.initializeOptionalPosition(source);\n        while (source.attributes.length > 0) {\n            const attr = source.attributes.item(0);\n            if (attr != null) {\n                this.svgGroup.setAttribute(attr.name, attr.value);\n                source.removeAttribute(attr.name);\n            }\n        }\n        source.remove();\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZObjectAttributes): void {\n\n        GOptions.setClassAndStyle(this._svgGroup, option.class, option.style);\n\n        if (option.attributes !== undefined) {\n            Object.keys(option.attributes).forEach((v) => {\n                const value: string = option.attributes![v];\n                this._svgGroup.setAttribute(v, value);\n            })\n        }\n        if (typeof option.id !== \"undefined\") this.svgGroup.id = option.id;\n    }\n    */\n    /*\n    public setOption(option: GOptions.ZObjectAttributes) {\n        this.setBasicOption(option);\n        //this.setOptionalSize(option);\n        this.setOptionalPosition(option)\n    }\n    */\n    /*\n    protected setOptionalSize(option: GOptions.ZObjectAttributes) {\n        if (this.svgSurface !== null) {\n            GOptions.setClassAndStyle(this.svgSurface, option.surfaceClass, option.surfaceStyle)\n        }\n\n        this.width = (option.width !== undefined ? option.width : 25);\n        this.height = (option.height !== undefined ? option.height : 25);\n    }\n    */\n    /*\n    protected setOptionalPosition(option: GOptions.ZObjectAttributes) {\n\n        if (option.position !== undefined) {\n            if (option.position.type == \"center\") {\n                this.positionType = PositionType.Center;\n                this.cx = option.position.x;\n                this.cy = option.position.y;\n            } else {\n\n                this.positionType = PositionType.UpperLeft;\n                this.setVirtualXY(option.position.x, option.position.y);\n                //this.x = option.position.x;\n                //this.y = option.position.y;\n\n            }\n        } else {\n            this.positionType = PositionType.Center;\n            this.__cx = 0;\n            this.__cy = 0;\n\n        }\n    }\n    */\n    /*\n    public assignOption(option: ZVertexOptionReteral) {\n        GOptions.setClassAndStyle(this._svgGroup, option.class, option.style);\n\n        if(option.id !== undefined){\n            this.svgGroup.setAttribute(\"id\", option.id);\n        }\n        if (this.svgSurface !== null) {\n            GOptions.setClassAndStyle(this.svgSurface, option.surfaceOption.class, option.surfaceOption.style)\n        }\n        this.width = option.width !== undefined ? option.width : 25;\n        this.height = option.height !== undefined ? option.height : 25;\n\n\n        if (option.positionType !== undefined) {\n            if (option.positionType == \"center\") {\n                this.positionType = PositionType.Center;\n                this.cx = option.cx ?? 0;\n                this.cy = option.cy ?? 0;\n            } else {\n                const x = option.x ?? 0;\n                const y = option.y ?? 0;\n                this.positionType = PositionType.UpperLeft;\n                this.setVirtualXY(x, y);\n                //this.x = option.position.x;\n                //this.y = option.position.y;\n            }\n        } else {\n            this.positionType = PositionType.Center;\n            this.__cx = 0;\n            this.__cy = 0;\n\n        }\n    }\n    */\n    get stableFlag() {\n        return this.svgGroup.getAttribute(GObserver.ObjectStableFlagName) == \"true\";\n    }\n    get syncXTargetObject() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncXTarget);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return ZObject.getObjectFromIDOrObjectID(p);\n        }\n    }\n    get syncYTargetObject() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncYTarget);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return ZObject.getObjectFromIDOrObjectID(p);\n        }\n    }\n    get syncXSourcePosition() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncXSourcePosition);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return enums_1.HorizontalAnchor.toHorizontalAnchor(p);\n        }\n    }\n    get syncXTargetPosition() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncXTargetPosition);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return enums_1.HorizontalAnchor.toHorizontalAnchor(p);\n        }\n    }\n    get syncYSourcePosition() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncYSourcePosition);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return enums_1.VerticalAnchor.toVerticalAnchor(p);\n        }\n    }\n    get syncYTargetPosition() {\n        const p = this.svgGroup.getAttribute(AttributeNames.syncYTargetPosition);\n        if (p == null) {\n            return null;\n        }\n        else {\n            return enums_1.VerticalAnchor.toVerticalAnchor(p);\n        }\n    }\n    set stableFlag(b) {\n        this.svgGroup.setAttribute(GObserver.ObjectStableFlagName, b ? \"true\" : \"false\");\n    }\n    get childrenStableFlag() {\n        return true;\n    }\n    updateSurfaceWithoutSVGText() {\n        this.update();\n        return true;\n    }\n    updateObjectLocation() {\n        this.joint();\n    }\n    joint() {\n        const objRegion = this.getRegion();\n        if (this.syncXTargetObject != null) {\n            const jointRegion = this.syncXTargetObject.getRegion();\n            let diffX = 0;\n            if (this.syncXSourcePosition == \"left\" || this.syncXSourcePosition == null) {\n                if (this.syncXTargetPosition == \"left\" || this.syncXTargetPosition == null) {\n                    diffX = jointRegion.x - objRegion.x;\n                }\n                else if (this.syncXTargetPosition == \"center\") {\n                    diffX = jointRegion.x + (jointRegion.width / 2) - objRegion.x;\n                }\n                else {\n                    diffX = jointRegion.right - objRegion.x;\n                }\n            }\n            else if (this.syncXSourcePosition == \"center\") {\n                if (this.syncXTargetPosition == \"left\" || this.syncXTargetPosition == null) {\n                    diffX = jointRegion.x - objRegion.x - (objRegion.width / 2);\n                }\n                else if (this.syncXTargetPosition == \"center\") {\n                    diffX = jointRegion.x + (jointRegion.width / 2) - objRegion.x - (objRegion.width / 2);\n                }\n                else {\n                    diffX = jointRegion.right - objRegion.x - (objRegion.width / 2);\n                }\n            }\n            else {\n                if (this.syncXTargetPosition == \"left\" || this.syncXTargetPosition == null) {\n                    diffX = jointRegion.x - objRegion.right;\n                }\n                else if (this.syncXTargetPosition == \"center\") {\n                    diffX = jointRegion.x + (jointRegion.width / 2) - objRegion.right;\n                }\n                else {\n                    diffX = jointRegion.right - objRegion.right;\n                }\n            }\n            this.x = this.x + diffX;\n        }\n        if (this.syncYTargetObject != null) {\n            const jointRegion = this.syncYTargetObject.getRegion();\n            let diffy = 0;\n            if (this.syncYSourcePosition == \"top\" || this.syncYSourcePosition == null) {\n                if (this.syncYTargetPosition == \"top\" || this.syncYTargetPosition == null) {\n                    diffy = jointRegion.y - objRegion.y;\n                }\n                else if (this.syncYTargetPosition == \"middle\") {\n                    diffy = jointRegion.y + (jointRegion.height / 2) - objRegion.y;\n                }\n                else {\n                    diffy = jointRegion.bottom - objRegion.y;\n                }\n            }\n            else if (this.syncYSourcePosition == \"middle\") {\n                if (this.syncYTargetPosition == \"top\" || this.syncYTargetPosition == null) {\n                    diffy = jointRegion.y - objRegion.y - (objRegion.height / 2);\n                }\n                else if (this.syncYTargetPosition == \"middle\") {\n                    diffy = jointRegion.y + (jointRegion.height / 2) - objRegion.y - (objRegion.height / 2);\n                }\n                else {\n                    diffy = jointRegion.bottom - objRegion.y - (objRegion.height / 2);\n                }\n            }\n            else {\n                if (this.syncYTargetPosition == \"top\" || this.syncYTargetPosition == null) {\n                    diffy = jointRegion.y - objRegion.bottom;\n                }\n                else if (this.syncYTargetPosition == \"middle\") {\n                    diffy = jointRegion.y + (jointRegion.height / 2) - objRegion.bottom;\n                }\n                else {\n                    diffy = jointRegion.bottom - objRegion.bottom;\n                }\n            }\n            this.y = this.y + diffy;\n        }\n    }\n    disconnectObserverFunction() {\n        this._observer.disconnect();\n    }\n    connectObserverFunction() {\n        this._observer.observe(this.svgGroup, this._observerOption);\n    }\n    get hasConnectedObserverFunction() {\n        return this._hasConnectedObserverFunction;\n    }\n    set hasConnectedObserverFunction(b) {\n        if (this._hasConnectedObserverFunction != b) {\n            if (b) {\n                this.connectObserverFunction();\n            }\n            else {\n                this.disconnectObserverFunction();\n            }\n            this._hasConnectedObserverFunction = b;\n        }\n    }\n    get coordinateType() {\n        return \"object-center\";\n    }\n    get defaultClassName() {\n        return undefined;\n    }\n    get isInitialized() {\n        return this._isInitialized;\n    }\n    firstFunctionAfterInitialized() {\n        if (this._isInitialized) {\n            throw new Error(\"This function is already called\");\n        }\n        this._isInitialized = true;\n        //this.update();\n        //this.resetUnstableCounter();\n        if (this.__cx !== undefined)\n            this.cx = this.__cx;\n        if (this.__cy !== undefined)\n            this.cy = this.__cy;\n        if (this.__x !== undefined)\n            this.x = this.__x;\n        if (this.__y !== undefined)\n            this.y = this.__y;\n    }\n    removeResizeEvent() {\n        this.svgGroup.removeEventListener(AttributeNames.resizeName, this.pUpdateFunc);\n    }\n    addResizeEvent() {\n        this.svgGroup.addEventListener(AttributeNames.resizeName, this.pUpdateFunc);\n    }\n    /*\n    private addOnLoadEvent() {\n        this.svgGroup.onload = this.onLoadFunction;\n        //this.svgGroup.addEventListener(\"load\", this.onLoadFunction);\n    }\n\n    private removeOnLoadEvent() {\n        \n        this.svgGroup.removeEventListener(\"load\", this.onLoadFunction);\n    }\n    protected onLoadFunction = () => {\n    }\n    */\n    firstResizeUpdate() {\n    }\n    /*\n    protected _isLoaded = false;\n    public get isLoaded(){\n        return this._isLoaded;\n    }\n    */\n    /*\n    static constructAttributes(e: Element,\n        removeAttributes: boolean = false, output: GOptions.ZObjectAttributes = {}, defaultPositionType : \"center\" | \"upper-left\" ): GOptions.ZObjectAttributes {\n        output.class = ElementExtension.gtGetAttributeStringWithUndefined(e, AttributeNames.className);\n        if (output.class === undefined) ElementExtension.gtGetAttributeStringWithUndefined(e, AttributeNames.className);\n        output.surfaceClass = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.surfaceClassName);\n        output.surfaceStyle = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.surfaceStyle);\n\n        output.style = ElementExtension.gtGetAttributeStringWithUndefined(e, AttributeNames.style);\n        if (e.hasAttribute(AttributeNames.style)) output.style = ElementExtension.gtGetAttributeStringWithUndefined(e, AttributeNames.style);\n\n        const cx = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.cx);\n        const cy = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.cy);\n        const x = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.x);\n        const y = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.y);\n        if (cx !== undefined || cy !== undefined) {\n            output.position = { type: \"center\", x: cx !== undefined ? cx : 0, y: cy !== undefined ? cy : 0 }\n        } else if (x !== undefined || y !== undefined) {\n            output.position = { type: \"upper-left\", x: x !== undefined ? x : 0, y: y !== undefined ? y : 0 }\n        } else {\n            output.position = { type: defaultPositionType, x: 0, y: 0 }\n        }\n        //const cx =\n        output.width = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.width);\n        output.height = ElementExtension.gtGetAttributeNumberWithUndefined(e, AttributeNames.height);\n\n        if (removeAttributes) {\n            e.removeAttribute(AttributeNames.cx);\n            e.removeAttribute(AttributeNames.cy);\n            e.removeAttribute(AttributeNames.x);\n            e.removeAttribute(AttributeNames.y);\n            e.removeAttribute(AttributeNames.className);\n            e.removeAttribute(AttributeNames.surfaceClassName);\n            //e.removeAttribute(AttributeNames.groupClassName);\n            e.removeAttribute(AttributeNames.surfaceStyle);\n            //e.removeAttribute(AttributeNames.groupStyle);\n            e.removeAttribute(AttributeNames.style);\n\n            e.removeAttribute(AttributeNames.width);\n            e.removeAttribute(AttributeNames.height);\n        }\n        return output;\n    }\n    */\n    get tag() {\n        return this._tag;\n    }\n    set tag(v) {\n        this._tag = v;\n    }\n    get isShown() {\n        return HTMLFunctions.isShow(this.svgGroup);\n    }\n    /**\n    セルを表しているSVGGElementを返します。\n    */\n    get svgGroup() {\n        return this._svgGroup;\n    }\n    get isLocated() {\n        return CommonFunctions.IsDescendantOfBody(this.svgGroup);\n    }\n    get svgSurface() {\n        return this._svgSurface;\n    }\n    /**\nこのVertexのX座標を返します。\n*/\n    get cx() {\n        if (this.isCenterBased) {\n            return SVGGExtension.getX(this.svgGroup);\n        }\n        else {\n            return SVGGExtension.getX(this.svgGroup) + (this.width / 2);\n        }\n    }\n    set cx(value) {\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            //throw Error(\"This object does not support set cx!\" + this.type);\n        }\n        else {\n            if (this.isCenterBased) {\n                if (SVGGExtension.getX(this.svgGroup) != value) {\n                    SVGGExtension.setX(this.svgGroup, value);\n                }\n            }\n            else {\n                SVGGExtension.setX(this.svgGroup, value - (this.width / 2));\n            }\n        }\n    }\n    /**\n    このVertexのY座標を返します。\n    */\n    get cy() {\n        if (this.isCenterBased) {\n            return SVGGExtension.getY(this.svgGroup);\n        }\n        else {\n            return SVGGExtension.getY(this.svgGroup) + (this.height / 2);\n        }\n    }\n    set cy(value) {\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            //throw Error(\"This object does not support set cy!\");\n        }\n        else {\n            if (this.isCenterBased) {\n                if (SVGGExtension.getY(this.svgGroup) != value) {\n                    SVGGExtension.setY(this.svgGroup, value);\n                }\n            }\n            else {\n                SVGGExtension.setY(this.svgGroup, value - (this.height / 2));\n            }\n        }\n    }\n    get upperHeight() {\n        return (this.height / 2);\n    }\n    get leftWidth() {\n        return (this.width / 2);\n    }\n    get surfaceRegion() {\n        return new vline_1.Rectangle();\n    }\n    get x() {\n        if (this.isCenterBased) {\n            return SVGGExtension.getX(this.svgGroup) + this.surfaceRegion.x;\n        }\n        else {\n            return SVGGExtension.getX(this.svgGroup);\n        }\n    }\n    get y() {\n        if (this.isCenterBased) {\n            return SVGGExtension.getY(this.svgGroup) + this.surfaceRegion.y;\n        }\n        else {\n            return SVGGExtension.getY(this.svgGroup);\n        }\n    }\n    set x(v) {\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            throw Error(\"This object does not support set x!\");\n        }\n        else {\n            if (this.isCenterBased) {\n                SVGGExtension.setX(this.svgGroup, v - this.surfaceRegion.x);\n            }\n            else {\n                SVGGExtension.setX(this.svgGroup, v);\n            }\n        }\n    }\n    set y(v) {\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            throw Error(\"This object does not support set y!\");\n        }\n        else {\n            if (this.isCenterBased) {\n                SVGGExtension.setY(this.svgGroup, v - this.surfaceRegion.y);\n            }\n            else {\n                SVGGExtension.setY(this.svgGroup, v);\n            }\n        }\n    }\n    setVirtualXY(x, y) {\n        const rect = this.getVirtualRegion();\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            throw Error(\"This object does not support set x!\");\n        }\n        else {\n            if (this.isCenterBased) {\n                SVGGExtension.setX(this.svgGroup, x - rect.x);\n            }\n            else {\n                SVGGExtension.setX(this.svgGroup, x);\n            }\n        }\n        if (this.coordinateType == enums_1.CoodinateType.Group00) {\n            throw Error(\"This object does not support set y!\");\n        }\n        else {\n            if (this.isCenterBased) {\n                SVGGExtension.setY(this.svgGroup, y - rect.y);\n            }\n            else {\n                SVGGExtension.setY(this.svgGroup, y);\n            }\n        }\n    }\n    /*\n    public set virtualX(v: number) {\n        if(this.coordinateType == CoodinateType.Group00){\n            throw Error(\"This object does not support set x!\");\n        }else{\n            if (this.isCenterBased) {\n                SVGGExtension.setX(this.svgGroup,v - this.getVirtualRegion().x );\n            } else {\n                SVGGExtension.setX(this.svgGroup, v);\n            }\n        }\n\n    }\n    */\n    /*\n    public set virtualY(v: number) {\n        if(this.coordinateType == CoodinateType.Group00){\n            throw Error(\"This object does not support set y!\");\n        }else{\n            if (this.isCenterBased) {\n                SVGGExtension.setY(this.svgGroup, v + (this.getVirtualHeight() / 2));\n            } else {\n                SVGGExtension.setY(this.svgGroup, v);\n            }\n        }\n\n    }\n    */\n    /**\n    頂点の幅を返します。\n    */\n    get width() {\n        if (this.hasSize) {\n            return (0, vline_1.round100)(ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-width\", 0));\n        }\n        else {\n            return 0;\n        }\n    }\n    set width(value) {\n        const newValue = (0, vline_1.round100)(value);\n        if (this.hasSize) {\n            if (!(0, vline_1.nearlyEqual)(this.width, newValue)) {\n                ElementExtension.setAttributeNumber(this.svgGroup, \"data-width\", newValue);\n            }\n            //this.svgGroup.setAttribute(\"data-width\", value.toString());\n        }\n    }\n    /*\n    protected setWidthWithoutUpdate(value: number) {\n        this.width = value;\n\n    }\n    protected setHeightWithoutUpdate(value: number) {\n        this.height = value;\n    }\n    */\n    /**\n    頂点の高さを返します。\n    */\n    get height() {\n        if (this.hasSize) {\n            return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-height\", 0);\n        }\n        else {\n            return 0;\n        }\n    }\n    set height(value) {\n        const newValue = (0, vline_1.round100)(value);\n        if (this.hasSize) {\n            if (!(0, vline_1.nearlyEqual)(this.height, newValue)) {\n                ElementExtension.setAttributeNumber(this.svgGroup, \"data-height\", newValue);\n            }\n            //this.svgGroup.setAttribute(\"data-height\", value.toString());\n        }\n    }\n    /*\n    public get fixedX(): number | null {\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-fixedX\", null);\n    }\n    public set fixedX(v: number | null) {\n        if (v == null) {\n            this.svgGroup.removeAttribute(\"data-fixedX\");\n        } else {\n            this.svgGroup.setAttribute(\"data-fixedX\", v.toString());\n        }\n    }\n    \n    public get fixedY(): number | null {\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-fixedY\", null);\n    }\n    public set fixedY(v: number | null) {\n        if (v == null) {\n            this.svgGroup.removeAttribute(\"data-fixedY\");\n        } else {\n            this.svgGroup.setAttribute(\"data-fixedY\", v.toString());\n        }\n    }\n    */\n    get isCenterBased() {\n        return true;\n    }\n    get positionType() {\n        const str = this.svgGroup.getAttribute(\"data-position-type\");\n        if (str !== undefined) {\n            if (str == vline_1.PositionType.Center) {\n                return vline_1.PositionType.Center;\n            }\n            else {\n                return vline_1.PositionType.UpperLeft;\n            }\n        }\n        else {\n            return vline_1.PositionType.Center;\n        }\n    }\n    set positionType(value) {\n        this.svgGroup.setAttribute(\"data-position-type\", value);\n    }\n    get isProhibitionOutOfRange() {\n        const p = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.prohibitionOutOfRange, \"true\");\n        return p == \"true\";\n    }\n    set isProhibitionOutOfRange(v) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.prohibitionOutOfRange, v.toString());\n    }\n    moveInCanvas() {\n        this.x = (this.width / 2) + 10;\n        this.y = (this.height / 2) + 10;\n    }\n    get type() {\n        return enums_2.ShapeObjectType.Object;\n    }\n    createSurface(svgbox) {\n    }\n    setClassNameOfSVGGroup() {\n    }\n    observerFunction(x) {\n        //throw Error(\"error1\");\n        if (!this.isShown)\n            return;\n        let b = false;\n        if (!this.isLocated)\n            return;\n        for (let i = 0; i < x.length; i++) {\n            const p = x[i];\n            if (this.updateAttributes.some((v) => v == p.attributeName)) {\n                b = true;\n            }\n            if (p.target == this.svgGroup) {\n                if (p.attributeName == \"x\" || p.attributeName == \"y\") {\n                    this.dispatchConnectPositionChangedEvent();\n                }\n            }\n            if (p.attributeName == \"transform\") {\n                this.dispatchConnectPositionChangedEvent();\n            }\n        }\n        if (b) {\n            //this.resetUnstableCounter();\n            //this.update();\n        }\n    }\n    /**\n     * この頂点を廃棄します。廃棄された頂点はグラフから取り除かれます。\n     */\n    dispose() {\n    }\n    /**\n    この頂点が廃棄されていたらTrueを返します。\n    */\n    get isDisposed() {\n        return false;\n        //return this.graph == null;\n    }\n    /**\n    このVertexのObjectIDを返します。\n    */\n    get objectID() {\n        const r = this.svgGroup.getAttribute(AttributeNames.objectIDName);\n        if (r == null) {\n            throw new Error();\n        }\n        else {\n            return r;\n        }\n    }\n    createVBACode(id) {\n        const lines = [];\n        lines.push(`Sub create${id}(createdSlide As slide)`);\n        lines.push(`End Sub`);\n        return lines;\n    }\n    get VBAObjectNum() {\n        return 1;\n    }\n    dispatchObjectCreatedEvent() {\n        var event = document.createEvent(\"HTMLEvents\");\n        event.initEvent(AttributeNames.objectCreatedEventName, true, true);\n        this.svgGroup.dispatchEvent(event);\n    }\n    get isDynamic() {\n        const p = this.svgGroup.getAttribute(\"data-is-dynamic\");\n        return p == \"true\";\n    }\n    set isDynamic(value) {\n        this.svgGroup.setAttribute(\"data-is-dynamic\", value == true ? \"true\" : \"false\");\n    }\n    getUpdateFlag() {\n        return false;\n    }\n    update() {\n        if (!this._isInitialized) {\n            //throw new Error(\"This instance have not been initialized!\");\n            //return true;\n        }\n        else {\n            this._isUpdating = true;\n            this._isUpdating = false;\n            //return true;\n        }\n    }\n    dispatchConnectPositionChangedEvent() {\n        if (this.svgSurface != null) {\n            var event = document.createEvent(\"HTMLEvents\");\n            event.initEvent(AttributeNames.connectPositionChangedEventName, false, true);\n            this.svgGroup.dispatchEvent(event);\n        }\n    }\n    get hasSize() {\n        return false;\n    }\n    static getObjectFromIDOrObjectID(id) {\n        if (id instanceof SVGElement) {\n            if (id.hasAttribute(AttributeNames.objectIDName)) {\n                const _id = id.getAttribute(AttributeNames.objectIDName);\n                return ZObject.getObjectFromIDOrObjectID(_id);\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            if (id in this.objectDic) {\n                return this.objectDic[id];\n            }\n            else {\n                const element = document.getElementById(id);\n                if (element !== null && element.operator !== undefined && element.operator instanceof ZObject) {\n                    return element.operator;\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    }\n    static setObjectFromObjectID(obj) {\n        const id = obj.objectID;\n        this.objectDic[id] = obj;\n    }\n    static getObjectFromID(id) {\n        for (let key in this.objectDic) {\n            if (this.objectDic[key].svgGroup.id == id) {\n                return this.objectDic[key];\n            }\n        }\n        return null;\n    }\n    /**\n     * グラフの領域を表すRectangleを返します。位置の基準はグラフが追加されているNodeです。\n     */\n    getRegion() {\n        let rect = new vline_1.Rectangle();\n        rect.x = this.x;\n        rect.y = this.y;\n        rect.width = this.width;\n        rect.height = this.height;\n        return rect;\n    }\n    getVirtualWidth() {\n        return 0;\n    }\n    getVirtualHeight() {\n        return 0;\n    }\n    getVirtualRegion() {\n        let rect = new vline_1.Rectangle();\n        rect.x = this.x;\n        rect.y = this.y;\n        rect.width = this.width;\n        rect.height = this.height;\n        return rect;\n    }\n    movable() {\n        draggable_object_1.DraggableObjectFunctions.appendDragFunctionsToDocument();\n        draggable_object_1.DraggableObjectFunctions.draggable(this.svgSurface, this.svgGroup);\n    }\n    get allowHover() {\n        return this.svgGroup.getAttribute(AttributeNames.allowHoverName) == \"true\";\n    }\n    set allowHover(value) {\n        if (value) {\n            this.svgGroup.setAttribute(AttributeNames.allowHoverName, \"true\");\n        }\n        else {\n            this.svgGroup.setAttribute(AttributeNames.allowHoverName, \"false\");\n        }\n    }\n}\nexports.ZObject = ZObject;\nZObject.objectDic = {};\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_object.ts?");

/***/ }),

/***/ "./src/objects/z_observer.ts":
/*!***********************************!*\
  !*** ./src/objects/z_observer.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.updateTextByTimer = exports.updatePathByTimer = exports.ObjectStableFlagName = exports.svgPathLenName = exports.svgTextBBoxHeightName = exports.svgTextBBoxWidthName = exports.timerInterval = void 0;\nconst attribute_names_1 = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nexports.timerInterval = 100;\n//export const unstableCounterDefault = 10;\n//export const unstableCounterName = \"data-unstable-counter\";\nconst timerDic = new Map();\nexports.svgTextBBoxWidthName = \"data-bbox-width\";\nexports.svgTextBBoxHeightName = \"data-bbox-height\";\nexports.svgPathLenName = \"data-path-length\";\nexports.ObjectStableFlagName = \"data-stable-flag\";\nfunction bubbleFalse(obj) {\n    const objectID = obj.getAttribute(attribute_names_1.objectIDName);\n    if (objectID != null) {\n        const attr = obj.getAttribute(exports.ObjectStableFlagName);\n        if (attr != \"false\") {\n            obj.setAttribute(exports.ObjectStableFlagName, \"false\");\n        }\n    }\n    const parent = obj.parentElement;\n    if (parent instanceof SVGElement) {\n        if (!(parent instanceof SVGSVGElement)) {\n            bubbleFalse(parent);\n        }\n    }\n}\nfunction updatePathByTimer(svgPath) {\n    const pathLen = (0, vline_1.round100)(svgPath.getTotalLength());\n    let b = false;\n    let prevPathLen = 0;\n    if (svgPath.hasAttribute(exports.svgPathLenName)) {\n        prevPathLen = Number.parseFloat(svgPath.getAttribute(exports.svgPathLenName));\n        if (!(0, vline_1.nearlyEqual)(prevPathLen, pathLen)) {\n            svgPath.setAttribute(exports.svgPathLenName, pathLen.toString());\n            b = true;\n        }\n    }\n    else {\n        svgPath.setAttribute(exports.svgPathLenName, pathLen.toString());\n        b = true;\n    }\n    const stableFlag = svgPath.getAttribute(exports.ObjectStableFlagName);\n    if (b) {\n        bubbleFalse(svgPath);\n    }\n    else {\n        if (stableFlag == \"false\") {\n            svgPath.setAttribute(exports.ObjectStableFlagName, \"true\");\n        }\n    }\n    return b;\n}\nexports.updatePathByTimer = updatePathByTimer;\nfunction updateTextByTimer(svgText) {\n    const bbox = svgText.getBBox();\n    const width = (0, vline_1.round100)(bbox.width);\n    const height = (0, vline_1.round100)(bbox.height);\n    let b = false;\n    let prevWidth = 0;\n    let prevHeight = 0;\n    if (svgText.hasAttribute(exports.svgTextBBoxWidthName)) {\n        prevWidth = Number.parseFloat(svgText.getAttribute(exports.svgTextBBoxWidthName));\n        if (!(0, vline_1.nearlyEqual)(prevWidth, width)) {\n            svgText.setAttribute(exports.svgTextBBoxWidthName, width.toString());\n            b = true;\n        }\n    }\n    else {\n        svgText.setAttribute(exports.svgTextBBoxWidthName, width.toString());\n        b = true;\n    }\n    if (svgText.hasAttribute(exports.svgTextBBoxHeightName)) {\n        prevHeight = Number.parseFloat(svgText.getAttribute(exports.svgTextBBoxHeightName));\n        if (!(0, vline_1.nearlyEqual)(prevHeight, height)) {\n            svgText.setAttribute(exports.svgTextBBoxHeightName, height.toString());\n            b = true;\n        }\n    }\n    else {\n        svgText.setAttribute(exports.svgTextBBoxHeightName, height.toString());\n        b = true;\n    }\n    const stableFlag = svgText.getAttribute(exports.ObjectStableFlagName);\n    if (b) {\n        bubbleFalse(svgText);\n    }\n    else {\n        if (stableFlag == \"false\") {\n            svgText.setAttribute(exports.ObjectStableFlagName, \"true\");\n        }\n    }\n}\nexports.updateTextByTimer = updateTextByTimer;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_observer.ts?");

/***/ }),

/***/ "./src/objects/z_options.ts":
/*!**********************************!*\
  !*** ./src/objects/z_options.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setClassAndStyle = void 0;\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nfunction setClassAndStyle(svg, className, style) {\n    if (typeof (className) == \"string\") {\n        svg.setAttribute(\"class\", className);\n    }\n    else if (className === undefined) {\n    }\n    else if (className === null) {\n        svg.removeAttribute(\"class\");\n    }\n    else {\n        svg.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\n    }\n    if (typeof (style) == \"string\") {\n        svg.setAttribute(\"style\", style);\n    }\n    else if (style === undefined) {\n    }\n    else if (style === null) {\n        svg.removeAttribute(\"style\");\n    }\n    else {\n        const cssString = CSS.createCSSString(style);\n        svg.setAttribute(\"style\", cssString === undefined ? \"\" : cssString);\n    }\n}\nexports.setClassAndStyle = setClassAndStyle;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_options.ts?");

/***/ }),

/***/ "./src/objects/z_path_textbox.ts":
/*!***************************************!*\
  !*** ./src/objects/z_path_textbox.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/// <reference path=\"z_vertex.ts\"/>\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZPathTextBox = void 0;\n//namespace GraphTableSVG {\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nclass ZPathTextBox extends z_textbox_1.ZTextBox {\n    //private _svgPath: SVGPathElement;\n    get svgPath() {\n        return this.svgSurface;\n    }\n    constructor(svgbox) {\n        super(svgbox);\n        if (this.type == enums_1.ShapeObjectType.PathTextBox)\n            this.firstFunctionAfterInitialized();\n    }\n    createSurface(svgbox) {\n        this._svgSurface = ZPathTextBox.createSurfacePath(this.svgGroup, 0, 0, 0, 0, DefaultClassNames.defaultTextboxPathClass, undefined);\n        this.svgGroup.insertBefore(this.svgPath, this.svgText);\n    }\n    static createSurfacePath(parent, x, y, x2, y2, className, style) {\n        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n        parent.appendChild(path);\n        path.setAttribute(\"d\", `M ${x} ${y} L ${x2} ${y2}`);\n        GOptions.setClassAndStyle(path, className, style);\n        return path;\n    }\n    get type() {\n        return enums_1.ShapeObjectType.PathTextBox;\n    }\n    /**\n    * 接続部分の座標を返します。\n    * @param type\n    * @param x\n    * @param y\n    */\n    getContactPosition(type, x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        switch (type) {\n            case enums_1.ConnectorType.Top:\n                return [this.cx, this.cy - hr];\n            case enums_1.ConnectorType.TopRight:\n            case enums_1.ConnectorType.Right:\n            case enums_1.ConnectorType.BottomRight:\n                return [this.cx + wr, this.cy];\n            case enums_1.ConnectorType.Bottom:\n                return [this.cx, this.cy + hr];\n            case enums_1.ConnectorType.BottomLeft:\n            case enums_1.ConnectorType.Left:\n            case enums_1.ConnectorType.TopLeft:\n                return [this.cx - wr, this.cy];\n            default:\n                const autoType = this.getContactAutoPosition(x, y);\n                return this.getContactPosition(autoType, x, y);\n        }\n    }\n    getContactAutoPosition(x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        const line1 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy + hr);\n        const line2 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy - hr);\n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n        if (b1) {\n            if (b2) {\n                return enums_1.ConnectorType.Top;\n            }\n            else {\n                return enums_1.ConnectorType.Right;\n            }\n        }\n        else {\n            if (b2) {\n                return enums_1.ConnectorType.Left;\n            }\n            else {\n                return enums_1.ConnectorType.Bottom;\n            }\n        }\n    }\n}\nexports.ZPathTextBox = ZPathTextBox;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_path_textbox.ts?");

/***/ }),

/***/ "./src/objects/z_rect.ts":
/*!*******************************!*\
  !*** ./src/objects/z_rect.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZRect = void 0;\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\n/**\n * ZRectです。\n * <template data-path=\"sutoring.Factorizations\" data-module=\"LZ78\"></template>\n*/\nclass ZRect extends z_textbox_1.ZTextBox {\n    get svgRectangle() {\n        return this._svgSurface;\n    }\n    constructor(svgbox, option = null) {\n        super(svgbox);\n        this.updateAttributes.push(\"width\");\n        this.updateAttributes.push(\"height\");\n        //throw Error(\"error2\");\n        //this.update();\n        if (this.type == enums_1.ShapeObjectType.Rect)\n            this.firstFunctionAfterInitialized();\n    }\n    createSurface(svgbox) {\n        this._svgSurface = ZRect.createRectangle(this.svgGroup, DefaultClassNames.defaultSurfaceClass, undefined);\n        this.svgGroup.insertBefore(this.svgRectangle, this.svgText);\n    }\n    /**\n     * SVGRectElementを生成します。\n     * @param parent 生成したSVG要素を子に追加する要素\n     * @param className 生成するSVG要素のクラス属性名\n     * @returns 生成されたSVGRectElement\n     */\n    static createRectangle(parent, className, style) {\n        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        rect.setAttribute(AttributeNames.dataNameAttribute, enums_1.DataName.Surface);\n        parent.appendChild(rect);\n        rect.width.baseVal.value = 30;\n        rect.height.baseVal.value = 30;\n        if (style !== undefined) {\n            if (typeof (style) == \"string\") {\n                rect.setAttribute(\"style\", style);\n            }\n            else {\n                rect.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\n            }\n        }\n        //if(style !== undefined) rect.setAttribute(\"style\", style);\n        if (className == null) {\n            if (rect.style.stroke == null || rect.style.stroke == \"\")\n                rect.style.stroke = \"black\";\n            if (rect.style.fill == null || rect.style.fill == \"\")\n                rect.style.fill = \"white\";\n            if (rect.style.strokeWidth == null || rect.style.strokeWidth == \"\")\n                rect.style.strokeWidth = \"1pt\";\n        }\n        else {\n            if (typeof (className) == \"string\") {\n                rect.setAttribute(\"class\", className);\n            }\n            else {\n                rect.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\n            }\n            //const dashStyle = rect.getPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName);\n            //if (dashStyle != null) msoDashStyle.setStyle(rect, dashStyle);\n            const width = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultWidth, null);\n            if (width != null) {\n                rect.width.baseVal.value = width;\n            }\n            const height = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultHeight, null);\n            if (height != null) {\n                rect.height.baseVal.value = height;\n            }\n        }\n        return rect;\n    }\n    /*\n    static constructAttributes(e: Element, removeAttributes: boolean = false, output: GOptions.ZTextBoxAttributes = {}): GOptions.ZTextBoxAttributes {\n        ZTextBox.constructAttributes(e, removeAttributes, output);\n\n        return output;\n    }\n    */\n    get type() {\n        return enums_1.ShapeObjectType.Rect;\n    }\n    /*\n     get innerRectangle(): Rectangle {\n         const rect = new Rectangle();\n         rect.width = this.width;\n         rect.height = this.height;\n         rect.x = (-this.width / 2);\n         rect.y = (-this.height / 2);\n\n         return rect;\n     }\n     */\n    /**\n    頂点の幅を返します。\n    */\n    get width() {\n        return (0, vline_1.round100)(this.svgRectangle.width.baseVal.value);\n    }\n    set width(value) {\n        //const value100 = round100(value);\n        //if (this.width != value100) this.svgRectangle.setAttribute(\"width\", value100.toString());\n        this.setWidthWithoutUpdate(value);\n        //this.update();\n    }\n    setWidthWithoutUpdate(value) {\n        const value100 = (0, vline_1.round100)(value);\n        if (this.width != value100) {\n            this.svgRectangle.setAttribute(\"width\", value100.toString());\n        }\n    }\n    /**\n    頂点の高さを返します。\n    */\n    get height() {\n        return (0, vline_1.round100)(this.svgRectangle.height.baseVal.value);\n    }\n    set height(value) {\n        this.setHeightWithoutUpdate(value);\n        //this.update();\n    }\n    setHeightWithoutUpdate(value) {\n        const value100 = (0, vline_1.round100)(value);\n        if (this.height != value100)\n            this.svgRectangle.setAttribute(\"height\", value100.toString());\n    }\n    get surfaceRegion() {\n        const x = this.svgRectangle.x.baseVal.value;\n        const y = this.svgRectangle.y.baseVal.value;\n        const w = this.width;\n        const h = this.height;\n        return new vline_1.Rectangle(x, y, w, h);\n    }\n    updateSurfaceLocation() {\n        const virtualRegion = this.getVirtualRegion();\n        this.svgRectangle.x.baseVal.value = -virtualRegion.width / 2;\n        this.svgRectangle.y.baseVal.value = -virtualRegion.height / 2;\n        return false;\n    }\n    /*\n    protected updateSurface() {\n        this.hasConnectedObserverFunction = false;\n        const dashStyle = this.msoDashStyle;\n        if (dashStyle != null) {\n            setComputedDashArray(this.svgRectangle);\n        }\n        this.hasConnectedObserverFunction = true;\n        //this._observer.observe(this.svgGroup, this._observerOption);\n    }\n    */\n    /**\n            * 接続部分の座標を返します。\n            * @param type\n            * @param x\n            * @param y\n            */\n    getContactPosition(type, x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        switch (type) {\n            case enums_1.ConnectorType.Top:\n                return [this.cx, this.cy - hr];\n            case enums_1.ConnectorType.TopRight:\n            case enums_1.ConnectorType.Right:\n            case enums_1.ConnectorType.BottomRight:\n                return [this.cx + wr, this.cy];\n            case enums_1.ConnectorType.Bottom:\n                return [this.cx, this.cy + hr];\n            case enums_1.ConnectorType.BottomLeft:\n            case enums_1.ConnectorType.Left:\n            case enums_1.ConnectorType.TopLeft:\n                return [this.cx - wr, this.cy];\n            default:\n                const autoType = this.getContactAutoPosition(x, y);\n                return this.getContactPosition(autoType, x, y);\n        }\n    }\n    getContactAutoPosition(x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        const line1 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy + hr);\n        const line2 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy - hr);\n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n        if (b1) {\n            if (b2) {\n                return enums_1.ConnectorType.Top;\n            }\n            else {\n                return enums_1.ConnectorType.Right;\n            }\n        }\n        else {\n            if (b2) {\n                return enums_1.ConnectorType.Left;\n            }\n            else {\n                return enums_1.ConnectorType.Bottom;\n            }\n        }\n    }\n    get shape() {\n        return enums_1.VBAShapeType.Rectangle;\n    }\n}\nexports.ZRect = ZRect;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_rect.ts?");

/***/ }),

/***/ "./src/objects/z_rect_button.ts":
/*!**************************************!*\
  !*** ./src/objects/z_rect_button.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZRectButton = void 0;\n//namespace GraphTableSVG {\nconst z_rect_1 = __webpack_require__(/*! ./z_rect */ \"./src/objects/z_rect.ts\");\n//import {ZTextBoxAttributes, ZObjectAttributes} from \"../options/attributes_option\"\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common/index.ts\");\n/**\n * ZRectButtonです。\n */\nclass ZRectButton extends z_rect_1.ZRect {\n    constructor(svgbox) {\n        super(svgbox);\n        this.svgGroup.setAttribute(\"class\", common_1.DefaultClassNames.defaultRectButtonClass);\n        this.svgGroup.setAttribute(\"cursor\", \"pointer\");\n        //this.update();\n        if (this.type == enums_1.ShapeObjectType.RectButton)\n            this.firstFunctionAfterInitialized();\n    }\n    get defaultClassName() {\n        return undefined;\n        //return GraphTableSVG.AttributeNames.StyleValue.defaultRectButtonClass;\n    }\n    get type() {\n        return enums_1.ShapeObjectType.RectButton;\n    }\n}\nexports.ZRectButton = ZRectButton;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_rect_button.ts?");

/***/ }),

/***/ "./src/objects/z_table.ts":
/*!********************************!*\
  !*** ./src/objects/z_table.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZTable = void 0;\nconst Color = __webpack_require__(/*! ../common/color */ \"./src/common/color.ts\");\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./src/common/common_functions.ts\");\n//import {GTableOption} from \"../options/attributes_option\"\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst gobject_functions_1 = __webpack_require__(/*! ../logics/gobject_functions */ \"./src/logics/gobject_functions.ts\");\nconst row_1 = __webpack_require__(/*! ./table_helpers/row */ \"./src/objects/table_helpers/row.ts\");\nconst column_1 = __webpack_require__(/*! ./table_helpers/column */ \"./src/objects/table_helpers/column.ts\");\nconst border_row_1 = __webpack_require__(/*! ./table_helpers/border_row */ \"./src/objects/table_helpers/border_row.ts\");\nconst border_column_1 = __webpack_require__(/*! ./table_helpers/border_column */ \"./src/objects/table_helpers/border_column.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./src/common/vba_functions.ts\");\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst GOptions = __webpack_require__(/*! ./z_options */ \"./src/objects/z_options.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./src/interfaces/svg_g_extension.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nconst update_table_1 = __webpack_require__(/*! ./table_helpers/update_table */ \"./src/objects/table_helpers/update_table.ts\");\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common/index.ts\");\nconst z_textbox_1 = __webpack_require__(/*! ./z_textbox */ \"./src/objects/z_textbox.ts\");\n/**\nテーブルを表します。\n*/\nclass ZTable extends z_vertex_1.ZVertex {\n    /**\n     * コンストラクタです。\n     */\n    constructor(svgbox) {\n        super(svgbox);\n        this._cellMap = new Map();\n        /*\n        protected setBasicOption(option: ZTableOption): void {\n            super.setBasicOption(option);\n            const columnCount = option.columnCount !== undefined ? option.columnCount : 5;\n            const rowCount = option.rowCount !== undefined ? option.rowCount : 5;\n            this.setSize(columnCount, rowCount);\n    \n        }\n        */\n        /*\n        protected setOptionalSize(option: ZTableOption) {\n            super.setOptionalSize(option);\n            if (option.rowHeight !== undefined) {\n                this.rows.forEach((v) => v.height = <number>option.rowHeight);\n            }\n            if (option.columnWidth !== undefined) {\n                this.columns.forEach((v) => v.width = <number>option.columnWidth);\n            }\n        }\n        */\n        /*\n         public setOption(option: ZTableOption) {\n             super.setOption(option);\n         }\n         */\n        /*\n         public assignOption(option : TableOptionReteral){\n             super.assignOption(option);\n     \n         }\n         */\n        this._isNoneMode = false;\n        /**\n        各行を表す配列を返します。読み取り専用です。\n        */\n        this._rows = new Array(0);\n        /**\n        各列を表す配列を返します。読み取り専用です。\n        */\n        this._columns = new Array(0);\n        this._borderRows = new Array(0);\n        this._borderColumns = new Array(0);\n        //private _cells: Cell[][] = [];\n        this.isConstructing = false;\n        this._isDrawing = false;\n        this._isAutoResized = false;\n        this._cellTextObserverFunc = (x) => {\n            let b = false;\n            let b2 = false;\n            for (let i = 0; i < x.length; i++) {\n                const p = x[i];\n                if (p.type == \"childList\") {\n                    b = true;\n                    b2 = true;\n                }\n                for (let j = 0; j < p.addedNodes.length; j++) {\n                    const item = p.addedNodes.item(j);\n                    if (item != null && item.nodeName.toLowerCase() == \"#text\") {\n                        b = true;\n                        b2 = true;\n                    }\n                }\n            }\n            if (b2 && !this.isConstructing) {\n                //if(this.cellArray.some((v)=>v.isErrorCell)) throw new Error(\"err!\");\n                //this.fitSizeToOriginalCells(false);\n                //this.fitSizeToOriginalCells(true);\n            }\n            if (b) {\n                //this.resetUnstableCounter();\n                //this.update();\n            }\n        };\n        // #endregion\n        this._isTextObserved = false;\n        this.isSetSize = false;\n        CSS.setGraphTableCSS();\n        this._svgHiddenGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        this._svgRowBorderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        this._svgRowBorderGroup.setAttribute(\"name\", \"rowBorderGroup\");\n        this._svgColumnBorderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        this._svgColumnBorderGroup.setAttribute(\"name\", \"columnBorderGroup\");\n        this._svgColumnInfo = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');\n        this._svgColumnInfo.setAttribute(\"name\", \"columnInfo\");\n        this._svgHiddenGroup.style.visibility = \"hidden\";\n        this._svgHiddenGroup.setAttribute(\"name\", \"hidden\");\n        this.svgGroup.appendChild(this.svgRowBorderGroup);\n        this.svgGroup.appendChild(this.svgColumnBorderGroup);\n        this.svgGroup.appendChild(this.svgHiddenGroup);\n        this.svgGroup.appendChild(this.svgColumnInfo);\n        this._cellTextObserver = new MutationObserver(this._cellTextObserverFunc);\n        this.updateAttributes = [];\n        this.isConstructing = true;\n        this.firstSetSize();\n        this.setSize(1, 1);\n        /*\n        if (option.table === undefined) {\n\n            //this.update();\n\n        } else {\n\n            this.svgGroup.style.display = \"none\"\n            this._isNoneMode = true;\n\n            this.buildFromLogicTable(option.table);\n\n            this._isNoneMode = false;\n\n            this.svgGroup.style.removeProperty(\"display\");\n            this.isTextObserved = true;\n\n        }\n        */\n        //if (option.cx !== undefined) this.cx = option.cx;\n        //if (option.cy !== undefined) this.cy = option.cy;\n        //this.setOptionInGTable(option)\n        this.isConstructing = false;\n        //this.update();\n        if (this.type == enums_1.ShapeObjectType.Table)\n            this.firstFunctionAfterInitialized();\n    }\n    getCellFromObjectID(id) {\n        const cell = this._cellMap.get(id);\n        if (cell == undefined) {\n            return null;\n        }\n        else {\n            return cell;\n        }\n    }\n    get isNoneMode() {\n        return this._isNoneMode;\n    }\n    get isCenterBased() {\n        return false;\n    }\n    updateSurfaceWithoutSVGText() {\n        const withUpdate = true;\n        this.hasConnectedObserverFunction = false;\n        const xb = HTMLFunctions.isShow(this.svgGroup);\n        if (!xb) {\n            return false;\n        }\n        this._isDrawing = true;\n        const b1 = update_table_1.UpdateTable.tryUpdateRowHeightAndColumnWidthWithUpdateFlag(this.rows, this.columns, true, withUpdate);\n        const b2 = update_table_1.UpdateTable.updateCellSizeAfterUpdatingRowsAndColumns(this.rows, this.columns, withUpdate);\n        const b3 = update_table_1.UpdateTable.relocateCellsAfterUpdatingCellSize(this.rows, this.columns, withUpdate);\n        const b4 = update_table_1.UpdateTable.tryUpdateBorders(this.createCellArray(), withUpdate);\n        this._isDrawing = false;\n        this.hasConnectedObserverFunction = true;\n        return b1 || b2 || b3 || b4;\n        //this.prevShow = false;\n        //b = this.tryResizeWithUpdateFlag(withUpdate) || b;\n    }\n    get svgRowBorderGroup() {\n        return this._svgRowBorderGroup;\n    }\n    get svgColumnBorderGroup() {\n        return this._svgColumnBorderGroup;\n    }\n    get svgColumnInfo() {\n        return this._svgColumnInfo;\n    }\n    get borderRows() {\n        return this._borderRows;\n    }\n    get borderColumns() {\n        return this._borderColumns;\n    }\n    get shape() {\n        return enums_1.VBAShapeType.Table;\n    }\n    get width() {\n        if (this.columns === undefined) {\n            return 0;\n        }\n        else {\n            let width = 0;\n            this.columns.forEach((v) => width += v.width);\n            return width;\n        }\n    }\n    set width(value) {\n    }\n    get height() {\n        if (this.rows === undefined) {\n            return 0;\n        }\n        else {\n            let height = 0;\n            this.rows.forEach((v) => height += v.height);\n            return height;\n        }\n    }\n    set height(value) {\n    }\n    /**\n     * mergeによって見えなくなったBorderなどを格納している特別なSVGGElementです。\n     */\n    get svgHiddenGroup() {\n        return this._svgHiddenGroup;\n    }\n    get type() {\n        return enums_1.ShapeObjectType.Table;\n    }\n    /**\n    各行を表す配列を返します。読み取り専用です。\n    */\n    get rows() {\n        return this._rows;\n    }\n    /**\n    各列を表す配列を返します。読み取り専用です。\n    */\n    get columns() {\n        return this._columns;\n    }\n    /**\n    各セルを格納している二次元ジャグ配列を返します。\n    */\n    get cells() {\n        return this.rows.map((v) => v.cells);\n    }\n    get isDrawing() {\n        return this._isDrawing;\n    }\n    get isAutoResized() {\n        return this._isAutoResized;\n    }\n    set isAutoResized(value) {\n        this._isAutoResized = value;\n        if (value) {\n            //this.resetUnstableCounter();\n            //this.update();\n        }\n    }\n    get cellTextObserver() {\n        return this._cellTextObserver;\n    }\n    /**\n    * テーブルの行方向の単位セルの数を返します。\n    * @returns 表の列数\n    */\n    get columnCount() {\n        if (this.cells.length == 0) {\n            return 0;\n        }\n        else {\n            if (this.rows.length > 2 && (this.rows[0].length != this.rows[1].length))\n                throw new Error(\"Invalid length error\");\n            return this.rows[0].length;\n        }\n    }\n    /**\n    * テーブルの列方向の単位セルの数を返します。\n    * @returns 表の行数\n    */\n    get rowCount() {\n        return this.cells.length;\n    }\n    // #endregion\n    // #region property\n    /*\n     get defaultCellClass(): string | null {\n         return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultCellClass);\n     }\n     */\n    /*\n     get defaultBorderClass(): string | null {\n         return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultBorderClass);\n     }\n     */\n    /**\n    各セルを表す配列を返します。テーブルの左上のセルから右に向かってインデックスが割り当てられ、\n    テーブル右下のセルが配列の最後の値となります。読み取り専用です。\n    */\n    createCellArray() {\n        const arr = new Array(0);\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                arr.push(this.cells[y][x]);\n            }\n        }\n        return arr;\n    }\n    /**\n    各ボーダーを表す配列を返します。\n    ボーダーの順番は未定義です。\n    読み取り専用です。\n    */\n    get borders() {\n        const arr = new Array(0);\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                if (arr.indexOf(this.cells[y][x].svgTopBorder) == -1) {\n                    arr.push(this.cells[y][x].svgTopBorder);\n                }\n                if (arr.indexOf(this.cells[y][x].svgLeftBorder) == -1) {\n                    arr.push(this.cells[y][x].svgLeftBorder);\n                }\n                if (arr.indexOf(this.cells[y][x].svgRightBorder) == -1) {\n                    arr.push(this.cells[y][x].svgRightBorder);\n                }\n                if (arr.indexOf(this.cells[y][x].svgBottomBorder) == -1) {\n                    arr.push(this.cells[y][x].svgBottomBorder);\n                }\n            }\n        }\n        return arr;\n    }\n    // #endregion\n    /*\n    public fitSizeToOriginalCellsWithUpdateFlag(allowShrink: boolean, withUpdate : boolean) : boolean {\n        let b = false;\n        for(let i = 0;i<this.rows.length;i++){\n            b = this.rows[i].tryUpdateHeightWithUpdateFlag(allowShrink, withUpdate) || b;\n            if(!withUpdate && b){\n                return b;\n            }\n        }\n        for(let i = 0;i<this.columns.length;i++){\n            b = this.columns[i].tryUpdateWidthWithUpdateFlag(allowShrink, withUpdate) || b;\n            if(!withUpdate && b){\n                return b;\n            }\n        }\n        return b;\n    }\n    */\n    // #region method\n    /**\n     * セルの元々のサイズに合わせて表のサイズを調整します。\n     * @param allowShrink 各行と各列が現在の幅より短くなることを許す\n     */\n    // public fitSizeToOriginalCells(allowShrink: boolean) {\n    //    this.fitSizeToOriginalCellsWithUpdateFlag(allowShrink, true);\n    //}\n    /**\n     * 指定したセル座標のセルを返します。そのようなセルが存在しない場合nullを返します。\n     * @param x セルの列番号\n     * @param y セルの行番号\n     */\n    getTryCell(x, y) {\n        if (x < 0 || x >= this.columnCount || y < 0 || y >= this.rowCount) {\n            return null;\n        }\n        else {\n            return this.cells[y][x];\n        }\n    }\n    /**\n     * 指定したセル座標範囲の二次元セル配列を返します。\n     * @param x 範囲の左上を示す列番号\n     * @param y 範囲の左上を示す行番号\n     * @param width 範囲に含まれる列数\n     * @param height 範囲に含まれる行数\n     */\n    getRangeCells(x, y, width, height) {\n        let cells = new Array(height);\n        for (let i = 0; i < cells.length; i++) {\n            cells[i] = new Array(0);\n            for (let j = 0; j < width; j++) {\n                cells[i].push(this.cells[y + i][x + j]);\n            }\n        }\n        return cells;\n    }\n    /**\n     * 指定したセル座標範囲のセルを配列でかえします。\n     * @param x 範囲の左上を示す列番号\n     * @param y 範囲の左上を示す行番号\n     * @param width 範囲に含まれる列数\n     * @param height 範囲に含まれる行数\n     */\n    getRangeCellArray(x, y, width, height) {\n        let cells = new Array();\n        this.getRangeCells(x, y, width, height).forEach((v) => { v.forEach((w) => { cells.push(w); }); });\n        return cells;\n    }\n    /**\n    所属しているSVGタグ上でのテーブルの領域を表すRectangleクラスを返します。\n    */\n    getRegion() {\n        let rect = new vline_1.Rectangle();\n        rect.x = SVGGExtension.getX(this.svgGroup);\n        rect.y = SVGGExtension.getY(this.svgGroup);\n        rect.width = this.width;\n        rect.height = this.height;\n        return rect;\n        /*\n        const regions = this.cellArray.map((v) => v.region);\n        const rect = Rectangle.merge(regions);\n        rect.addOffset(this.svgGroup.getX(), this.svgGroup.getY());\n        return rect;\n        */\n    }\n    /**\n    * 強調セルを全て返します。\n    */\n    getEmphasizedCells() {\n        return this.createCellArray().filter((v) => v.isEmphasized);\n    }\n    /**\n    * 表を文字列に変換した結果を返します。\n    */\n    toPlainText() {\n        const plainTable = this.cells.map((v) => v.map((w) => w.toPlainText()));\n        const widtharr = new Array(this.columnCount);\n        for (let x = 0; x < this.columnCount; x++) {\n            widtharr[x] = 0;\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const width = plainTable[y][x].length;\n                if (widtharr[x] < width)\n                    widtharr[x] = width;\n            }\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                plainTable[y][x] = CommonFunctions.paddingLeft(plainTable[y][x], widtharr[x], \" \");\n            }\n        }\n        return plainTable.map((v) => v.join(\",\")).join(\"\\n\");\n    }\n    get isTextObserved() {\n        return this._isTextObserved;\n    }\n    set isTextObserved(b) {\n        if (this._isTextObserved != b) {\n            if (this._isTextObserved) {\n                this.cellTextObserver.disconnect();\n            }\n            else {\n                const option1 = { childList: true, subtree: true };\n                this.createCellArray().forEach((v) => {\n                    this.cellTextObserver.observe(v.svgText, option1);\n                });\n            }\n        }\n    }\n    // #region construct2\n    updateCellByLogicCell(logicTable, x, y) {\n        const cell = this.cells[y][x];\n        //const isShow = HTMLFunctions.(this.svgGroup);\n        if (logicTable != null) {\n            const cellInfo = logicTable.cells[y][x];\n            if (cellInfo != null) {\n                //CSS.setCSSClass(cell.svgGroup, cellInfo.cellClass);\n                GOptions.setClassAndStyle(cell.svgGroup, cellInfo.option.class, cellInfo.option.style);\n                GOptions.setClassAndStyle(cell.svgSurface, cellInfo.backgroundOption.class, cellInfo.backgroundOption.style);\n                (0, gobject_functions_1.createTextElementFromLogicCell)(cellInfo, cell.svgText);\n                GOptions.setClassAndStyle(cell.svgTopBorder, cellInfo.topBorderOption.class, cellInfo.topBorderOption.style);\n                GOptions.setClassAndStyle(cell.svgLeftBorder, cellInfo.leftBorderOption.class, cellInfo.leftBorderOption.style);\n                GOptions.setClassAndStyle(cell.svgRightBorder, cellInfo.rightBorderOption.class, cellInfo.rightBorderOption.style);\n                GOptions.setClassAndStyle(cell.svgBottomBorder, cellInfo.bottomBorderOption.class, cellInfo.bottomBorderOption.style);\n            }\n        }\n    }\n    updateCell(sourceCell, x, y) {\n        const cell = this.cells[y][x];\n        /*\n        GOptions.setClassAndStyle(cell.svgGroup, cellInfo.option.class, cellInfo.option.style);\n        GOptions.setClassAndStyle(cell.svgBackground, cellInfo.backgroundOption.class, cellInfo.backgroundOption.style);\n        */\n        z_object_1.ZObject.setSubAttributes(cell.svgSurface, sourceCell);\n        z_object_1.ZObject.setSubAttributes(cell.svgText, sourceCell);\n        z_textbox_1.ZTextBox.importTextFromSource(cell.svgText, null, sourceCell);\n        z_object_1.ZObject.setSubAttributesWithObjName(cell.svgTopBorder, \"topborder\", sourceCell);\n        z_object_1.ZObject.setSubAttributesWithObjName(cell.svgLeftBorder, \"leftborder\", sourceCell);\n        z_object_1.ZObject.setSubAttributesWithObjName(cell.svgRightBorder, \"rightborder\", sourceCell);\n        z_object_1.ZObject.setSubAttributesWithObjName(cell.svgBottomBorder, \"bottomborder\", sourceCell);\n        /*\n        GOptions.setClassAndStyle(cell.svgTopBorder, cellInfo.topBorderOption.class, cellInfo.topBorderOption.style);\n        GOptions.setClassAndStyle(cell.svgLeftBorder, cellInfo.leftBorderOption.class, cellInfo.leftBorderOption.style);\n        GOptions.setClassAndStyle(cell.svgRightBorder, cellInfo.rightBorderOption.class, cellInfo.rightBorderOption.style);\n        GOptions.setClassAndStyle(cell.svgBottomBorder, cellInfo.bottomBorderOption.class, cellInfo.bottomBorderOption.style);\n        */\n        while (sourceCell.attributes.length > 0) {\n            const attr = sourceCell.attributes.item(0);\n            if (attr != null) {\n                cell.svgGroup.setAttribute(attr.name, attr.value);\n                sourceCell.removeAttribute(attr.name);\n            }\n        }\n    }\n    getRowCountAndColumnCount(source) {\n        const rows = HTMLFunctions.getChildren(source).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"row\").map((v) => v);\n        const cells = new Array(rows.length);\n        let columnSize = 0;\n        rows.forEach((v, i) => {\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"cell\");\n            cells[i] = cellArray;\n            if (columnSize < cellArray.length)\n                columnSize = cellArray.length;\n        });\n        return [rows.length, columnSize];\n    }\n    getRowHeightAndColumnWidth(source, rowCount, columnCount) {\n        const rArray = new Array(rowCount);\n        for (let i = 0; i < rowCount; i++) {\n            rArray[i] = 0;\n        }\n        const cArray = new Array(columnCount);\n        for (let i = 0; i < columnCount; i++) {\n            cArray[i] = 0;\n        }\n        const rows = HTMLFunctions.getChildren(source).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"row\").map((v) => v);\n        rows.forEach((v, y) => {\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"cell\");\n            cellArray.forEach((w, x) => {\n                const attr_w = HTMLFunctions.getAttributeFromAncestors(w, \"column::width\");\n                if (attr_w != null) {\n                    const attr_nw = Number.parseInt(attr_w);\n                    cArray[x] = Math.max(cArray[x], attr_nw);\n                }\n                const attr_h = HTMLFunctions.getAttributeFromAncestors(w, \"row::height\");\n                if (attr_h != null) {\n                    const attr_nh = Number.parseInt(attr_h);\n                    rArray[y] = Math.max(rArray[y], attr_nh);\n                }\n            });\n        });\n        return [rArray, cArray];\n    }\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        const [rowCount, columnCount] = this.getRowCountAndColumnCount(source);\n        this.setSize(columnCount, rowCount);\n        const [rArray, cArray] = this.getRowHeightAndColumnWidth(source, rowCount, columnCount);\n        rArray.forEach((minimumHeight, y) => {\n            if (minimumHeight != 0) {\n                this.rows[y].minimumHeight = minimumHeight;\n            }\n        });\n        cArray.forEach((minimumWidth, x) => {\n            if (minimumWidth != 0) {\n                this.columns[x].minimumWidth = minimumWidth;\n            }\n        });\n        const rows = HTMLFunctions.getChildren(source).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"row\").map((v) => v);\n        rows.forEach((v, y) => {\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(common_1.AttributeNames.customElement) == \"cell\");\n            cellArray.forEach((w, x) => {\n                if (w instanceof SVGElement) {\n                    this.updateCell(w, x, y);\n                }\n            });\n        });\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const cell = this.cells[y][x];\n                const merge_w = ElementExtension._getAttributeNumber(cell.svgGroup, common_1.AttributeNames.w, true);\n                const merge_h = ElementExtension._getAttributeNumber(cell.svgGroup, common_1.AttributeNames.h, true);\n                const mw = merge_w == null ? 1 : (merge_w < 1 ? 1 : merge_w);\n                const mh = merge_h == null ? 1 : (merge_h < 1 ? 1 : merge_h);\n                if (mw > 1 || mh > 1) {\n                    if (cell.canMerge(mw, mh)) {\n                        cell.merge(mw, mh);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * LogicTableからTableを構築します。\n     * @param logicTable 入力LogicTable\n     */\n    buildFromLogicTable(logicTable) {\n        var _a, _b;\n        const option = Object.assign({}, logicTable.option);\n        option.rowCount = logicTable.rowCount;\n        option.columnCount = logicTable.columnCount;\n        const columnCount = (_a = option.columnCount) !== null && _a !== void 0 ? _a : 5;\n        const rowCount = (_b = option.rowCount) !== null && _b !== void 0 ? _b : 5;\n        this.setSize(columnCount, rowCount);\n        if (option.rowHeight !== undefined) {\n            this.rows.forEach((v) => v.height = option.rowHeight);\n        }\n        if (option.columnWidth !== undefined) {\n            this.columns.forEach((v) => v.width = option.columnWidth);\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                this.updateCellByLogicCell(logicTable, x, y);\n            }\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const cell = this.cells[y][x];\n                const logicCell = logicTable.cells[y][x];\n                if (logicCell.connectedColumnCount > 1 || logicCell.connectedRowCount > 1) {\n                    if (cell.canMerge(logicCell.connectedColumnCount, logicCell.connectedRowCount)) {\n                        cell.merge(logicCell.connectedColumnCount, logicCell.connectedRowCount);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * 二次元文字列配列から表を作成します。\n     * @param table 各セルの文字列\n     * @param option 表情報\n     * @param option.x 表のx座標\n     * @param option.y 表のy座標\n     * @param option.rowHeight 各行の縦幅(px)\n     * @param option.columnWidth 各列の横幅(px)\n     * @param option.tableClassName 表(svgGroup)のクラス属性\n     * @param option.isLatexMode Trueのときセルの文字列をLatex表記とみなして描画します。\n     *\n     */\n    construct(table, option = {}) {\n        if (option.isLatexMode == undefined)\n            option.isLatexMode = false;\n        if (option.x == undefined)\n            option.x = 0;\n        if (option.y == undefined)\n            option.y = 0;\n        [this.cx, this.cy] = [option.x, option.y];\n        this.clear();\n        let width = 0;\n        table.forEach((v) => { if (v.length > width)\n            width = v.length; });\n        let height = table.length;\n        this.setSize(width, height);\n        table.forEach((v, y) => {\n            v.forEach((str, x) => {\n                SVGTextExtension.setTextContent(this.cells[y][x].svgText, str, option.isLatexMode);\n            });\n        });\n        if (option.rowHeight != undefined) {\n            this.rows.forEach((v) => v.height = option.rowHeight);\n        }\n        if (option.columnWidth != undefined) {\n            this.columns.forEach((v) => v.width = option.columnWidth);\n        }\n    }\n    // #endregion\n    // #region vba\n    /**\n     * 表からVBAコードを作成します。\n     * @param id\n     * @param slide\n     */\n    createVBACode(id) {\n        const lines = new Array(0);\n        lines.push(`Sub create${id}(createdSlide As slide)`);\n        const [main, sub] = this.createVBAMainCode(\"createdSlide\", id);\n        lines.push(main);\n        lines.push(`End Sub`);\n        lines.push(sub);\n        return lines;\n    }\n    /**\n     * 現在のテーブルを表すVBAコードを返します。\n     */\n    createVBAMainCode(slideName, id) {\n        const fstLines = [];\n        const lines = new Array(0);\n        fstLines.push(` Dim tableS As shape`);\n        fstLines.push(` Dim table_ As table`);\n        //lines.push(` Set tableS = CreateTable(createdSlide, ${table.height}, ${table.width})`);\n        fstLines.push(` Set tableS = ${slideName}.Shapes.AddTable(${this.rowCount}, ${this.columnCount})`);\n        fstLines.push(` tableS.Left = ${SVGGExtension.getX(this.svgGroup)}`);\n        fstLines.push(` tableS.Top = ${SVGGExtension.getY(this.svgGroup)}`);\n        //const backColor = VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface!, \"fill\", \"gray\"));\n        //const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface!, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n        fstLines.push(` tableS.name = \"${this.objectID}\"`);\n        //page.Shapes.AddTable(row_, column_)\n        fstLines.push(` Set table_ = tableS.table`);\n        const tableName = \"table_\";\n        for (let y = 0; y < this.rowCount; y++) {\n            lines.push([` Call EditRow(${tableName}.Rows(${y + 1}), ${this.rows[y].height})`]);\n        }\n        for (let x = 0; x < this.columnCount; x++) {\n            lines.push([` Call EditColumn(${tableName}.Columns(${x + 1}), ${this.columns[x].width})`]);\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const cell = this.cells[y][x];\n                let color = Color.createRGBFromColorName(ElementExtension.getPropertyStyleValueWithDefault(cell.svgSurface, \"fill\", \"gray\"));\n                //const style = cell.svgBackground.style.fill != null ? VBATranslateFunctions.colorToVBA(cell.svgBackground.style.fill) : \"\";\n                vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement(lines, this.cells[y][x].svgText, `${tableName}.cell(${y + 1},${x + 1}).Shape.TextFrame.TextRange`);\n                lines.push([`${tableName}.cell(${y + 1},${x + 1}).Shape.Fill.ForeColor.RGB = RGB(CInt(${color.r}), CInt(${color.g}), CInt(${color.b}))`]);\n                //lines.push(` Call EditCell(${tableName}.cell(${y + 1},${x + 1}), \"${cell.svgText.textContent}\", ${color})`);\n            }\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const cell = this.cells[y][x];\n                const vAnchor = vba_functions_1.VBATranslateFunctions.ToVerticalAnchor(cell.verticalAnchor);\n                const hAnchor = vba_functions_1.VBATranslateFunctions.ToHorizontalAnchor(cell.horizontalAnchor);\n                lines.push([` Call EditCellTextFrame(${tableName}.cell(${y + 1},${x + 1}).Shape.TextFrame, ${cell.paddingTop}, ${cell.paddingBottom}, ${cell.paddingLeft}, ${cell.paddingRight}, ${vAnchor}, ${hAnchor})`]);\n            }\n        }\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const cell = this.cells[y][x];\n                const upLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgTopBorder, \"stroke\", \"gray\"));\n                const upLineStrokeWidth = cell.svgTopBorder.style.strokeWidth != null ? (0, vba_functions_1.parseInteger)(cell.svgTopBorder.style.strokeWidth) : \"\";\n                const upLineVisibility = cell.svgTopBorder.style.visibility != null ? (0, vba_functions_1.styleVisible)(cell.svgTopBorder.style) : \"\";\n                lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderTop), ${upLineStyle}, ${upLineStrokeWidth}, ${upLineVisibility})`]);\n                const leftLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgLeftBorder, \"stroke\", \"gray\"));\n                const leftLineStrokeWidth = cell.svgLeftBorder.style.strokeWidth != null ? (0, vba_functions_1.parseInteger)(cell.svgLeftBorder.style.strokeWidth) : \"\";\n                const leftLineVisibility = cell.svgLeftBorder.style.visibility != null ? (0, vba_functions_1.styleVisible)(cell.svgLeftBorder.style) : \"\";\n                lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderLeft), ${leftLineStyle}, ${leftLineStrokeWidth}, ${leftLineVisibility})`]);\n                if (x + 1 == this.columnCount) {\n                    const rightLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgRightBorder, \"stroke\", \"gray\"));\n                    const rightLineStrokeWidth = cell.svgRightBorder.style.strokeWidth != null ? (0, vba_functions_1.parseInteger)(cell.svgRightBorder.style.strokeWidth) : \"\";\n                    const rightLineVisibility = cell.svgRightBorder.style.visibility != null ? (0, vba_functions_1.styleVisible)(cell.svgRightBorder.style) : \"\";\n                    lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderRight), ${rightLineStyle}, ${rightLineStrokeWidth}, ${rightLineVisibility})`]);\n                }\n                if (y + 1 == this.rowCount) {\n                    const bottomLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgBottomBorder, \"stroke\", \"gray\"));\n                    const bottomLineStrokeWidth = cell.svgBottomBorder.style.strokeWidth != null ? (0, vba_functions_1.parseInteger)(cell.svgBottomBorder.style.strokeWidth) : \"\";\n                    const bottomLineVisibility = cell.svgBottomBorder.style.visibility != null ? (0, vba_functions_1.styleVisible)(cell.svgBottomBorder.style) : \"\";\n                    lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderBottom), ${bottomLineStyle}, ${bottomLineStrokeWidth}, ${bottomLineVisibility})`]);\n                }\n            }\n        }\n        this.createCellArray().forEach((v) => {\n            if (v.isMaster) {\n                const cells = v.cellsInGroup;\n                for (let y = 0; y < cells.length; y++) {\n                    for (let x = 1; x < cells[y].length; x++) {\n                        lines.push([` ${tableName}.Cell(${cells[y][0].cellY + 1}, ${cells[y][0].cellX + 1}).Merge MergeTo := ${tableName}.Cell(${cells[y][x].cellY + 1}, ${cells[y][x].cellX + 1})`]);\n                    }\n                }\n                for (let y = 1; y < cells.length; y++) {\n                    lines.push([` ${tableName}.Cell(${cells[0][0].cellY + 1}, ${cells[0][0].cellX + 1}).Merge MergeTo := ${tableName}.Cell(${cells[y][0].cellY + 1}, ${cells[y][0].cellX + 1})`]);\n                }\n            }\n        });\n        const x0 = vba_functions_1.VBATranslateFunctions.joinLines(fstLines);\n        const [x1, y1] = vba_functions_1.VBATranslateFunctions.splitCode(lines, `${tableName} as Table`, `${tableName}`, id);\n        return [vba_functions_1.VBATranslateFunctions.joinLines([x0, x1]), y1];\n    }\n    // #endregion\n    //private _updateCounter = 0;\n    // #region dynamic\n    /**\n     * 新しいセルを作成します。\n     */\n    /*\n    private createCell(cellX: number, cellY: number): Cell {\n        const cellClass = this.defaultCellClass == null ? undefined : this.defaultCellClass;\n        const borderClass = this.defaultBorderClass == null ? undefined : this.defaultBorderClass;\n\n        const option: CellOption = { cellClass: cellClass, borderClass: borderClass };\n        return new Cell(this, cellX, cellY, option);\n    }\n    */\n    /*\n    Dynamic Method\n    */\n    /**\n     * テーブルを削除します。\n     * @param svg 表が格納されているSVG要素\n     */\n    removeTable(svg) {\n        if (svg.contains(this.svgGroup)) {\n            svg.removeChild(this.svgGroup);\n        }\n    }\n    firstSetSize() {\n        this.createRowBorder(0, 1);\n        this.createRowBorder(1, 1);\n        this.createColumnBorder(0, 1);\n        this.createColumnBorder(1, 1);\n        this._rows.splice(0, 0, new row_1.CellRow(this, 0, undefined));\n        this._rows[0]._appendCell(this._cellMap);\n        this._columns.splice(0, 0, new column_1.CellColumn(this, 0));\n    }\n    borderSizeCheck(_w, _h) {\n        const w = this.borderRows[0].borders.length;\n        const h = this.borderColumns[0].borders.length;\n        if (w != _w)\n            throw Error(`error ${_w} ${_h} ${w} ${h}`);\n        if (h != _h)\n            throw Error(`error ${_w} ${_h} ${w} ${h}`);\n        this.borderRows.forEach((v, i) => {\n            if (w != v.borders.length)\n                throw Error(\"border rows error\");\n        });\n        this.borderColumns.forEach((v, i) => {\n            if (h != v.borders.length)\n                throw Error(`border column error ${h} ${v.borders.length} ${i}`);\n        });\n        //return [w, h];\n    }\n    /**\n     * 表の列数と行数を変更します。\n     * @param columnCount 列数\n     * @param rowCount 行数\n     */\n    setSize(columnCount, rowCount) {\n        this.clear();\n        this.isSetSize = true;\n        const borderRowCount = rowCount + 1;\n        const borderColumnCount = columnCount + 1;\n        if (this.rowCount == 0 || this.columnCount == 0)\n            throw Error(\"Table Empty Error\");\n        /*\n        while (this._borderRows.length < rowCount + 1) {\n            const i = this._borderRows.length;\n            this.createRowBorder(i);\n            this.insertLineIntoColumns(i)\n            //this.createRow(i-1);\n        }\n        */\n        while (this.rowCount < rowCount) {\n            this.primitiveInsertRow(this.rowCount, false);\n        }\n        while (this.columnCount < columnCount) {\n            this.primitiveInsertColumn(this.columnCount, false);\n        }\n        /*\n        this.borderSizeCheck(1, rowCount);\n        while (this._borderColumns.length < columnCount + 1) {\n            const i = this._borderColumns.length + 1;\n            this.createColumnBorder(i);\n            this.insertLineIntoRows(i);\n        }\n        this.borderSizeCheck(columnCount, rowCount);\n\n        while (this.columnCount < columnCount) {\n            this.createColumn(this.columnCount);\n        }\n        */\n        /*\n        while (this.rowCount < rowCount) {\n            this.createRow(this.rowCount);\n        }\n        */\n        this.updateNodeRelations();\n        this.isSetSize = false;\n        /*\n        this.renumbering();\n        this.update();\n        */\n    }\n    primitiveInsertRow(ithRow, insertTopBorders) {\n        let ithRowBorder = insertTopBorders ? ithRow : ithRow + 1;\n        if (ithRow < 0 || ithRow > this.rowCount)\n            throw new Error(\"primitive insert row error\");\n        if (ithRow == 0)\n            ithRowBorder = 0;\n        if (ithRow == this.rowCount)\n            ithRowBorder = this.borderRows.length;\n        this.createRowBorder(ithRowBorder);\n        this.insertYVerticalBorders(ithRow);\n        this.createRow(ithRow);\n    }\n    primitiveInsertColumn(ithColumn, insertLeftBorders) {\n        let ithColumnBorder = insertLeftBorders ? ithColumn : ithColumn + 1;\n        if (ithColumn < 0 || ithColumn > this.columnCount)\n            throw new Error(\"primitive insert column error\");\n        if (ithColumn == 0)\n            ithColumnBorder = 0;\n        if (ithColumn == this.columnCount)\n            ithColumnBorder = this.borderColumns.length;\n        this.createColumnBorder(ithColumnBorder);\n        this.insertXHorizontalBorders(ithColumn);\n        this.createColumn(ithColumn);\n    }\n    get borderColumnCount() {\n        return this.columnCount + 1;\n    }\n    get borderRowCount() {\n        return this.rowCount + 1;\n    }\n    /**\n     * rowCount = 0, columnCount = 0のテーブルを作成します。\n     */\n    clear() {\n        if (this.rowCount == 0 || this.columnCount == 0)\n            throw Error(\"Table Empty Error\");\n        if (this.columnCount != this.columns.length)\n            throw Error(\"clear error\");\n        while (this.rowCount > 1) {\n            this.primitiveRemoveRow(1, false);\n        }\n        while (this.columnCount > 1) {\n            this.primitiveRemoveColumn(1, false);\n        }\n        this.updateNodeRelations();\n    }\n    /*\n    public removeCell(i: number) {\n        this.cells[i].removeFromTable(false);\n        //this.cells.forEach((v) => v.removeFromTable(false));\n        this.cells.splice(i, 1);\n    }\n    */\n    removeCellRow(i) {\n        this.rows[i]._dispose();\n        this.rows.splice(i, 1);\n    }\n    removeCellColumn(i) {\n        this.columns[i]._dispose();\n        this.columns.splice(i, 1);\n    }\n    primitiveRemoveRow(ithRow, removeTopBorders) {\n        const ithBorderRow = removeTopBorders ? ithRow : ithRow + 1;\n        if (ithRow < 0 || ithRow >= this.rowCount)\n            throw new Error(\"error\");\n        //this.removeRow(rowi);\n        this.removeCellRow(ithRow);\n        ;\n        this.removeRowBorder(ithBorderRow);\n        this.deleteYVerticalBorders(ithRow);\n    }\n    primitiveRemoveColumn(ithColumn, removeLeftBorders) {\n        const ithborderColumn = removeLeftBorders ? ithColumn : ithColumn + 1;\n        if (ithColumn < 0 || ithColumn >= this.columnCount)\n            throw new Error(\"primitive insert column error\");\n        this.removeCellColumn(ithColumn);\n        //this.columns[ithColumn].remove(true);\n        //this.table.columns.splice(x, 1);\n        this.removeColumnBorder(ithborderColumn);\n        this.deleteXHorizontalBorders(ithColumn);\n    }\n    removeColumnBorder(i) {\n        //this._borderRows.forEach((v) => v.removeBorder(i));\n        this._borderColumns[i].remove();\n        this._borderColumns.splice(i, 1);\n    }\n    removeRowBorder(i) {\n        //this._borderColumns.forEach((v) => v.removeBorder(i));\n        this._borderRows[i].remove();\n        this._borderRows.splice(i, 1);\n    }\n    removeRow(ithRow) {\n        this.primitiveRemoveRow(ithRow, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n    }\n    removeColumn(ithColumn) {\n        this.primitiveRemoveColumn(ithColumn, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n    }\n    deleteXHorizontalBorders(i) {\n        this._borderRows.forEach((v) => {\n            v.removeBorder(i);\n        });\n    }\n    deleteYVerticalBorders(i) {\n        this._borderColumns.forEach((v) => {\n            v.removeBorder(i);\n        });\n    }\n    createColumnBorder(i, borderRowCount = this.borderRows.length - 1) {\n        const column = new border_column_1.BorderColumn(this, i, borderRowCount, undefined);\n        this._borderColumns.splice(i, 0, column);\n    }\n    createRowBorder(i, borderColumnCount = this.borderColumns.length - 1) {\n        const row = new border_row_1.BorderRow(this, i, borderColumnCount, undefined);\n        this._borderRows.splice(i, 0, row);\n    }\n    createRow(i) {\n        //const cell: Cell[] = [];\n        //this.cells.splice(i, 0, cell);\n        const columnCount = this.columnCount;\n        const row = new row_1.CellRow(this, i, undefined);\n        this._rows.splice(i, 0, row);\n        row._appendCell(this._cellMap, columnCount);\n        /*\n        for (let x = 0; x < this.columnCount; x++) {\n            cell[x] = this.createCell(x, i);\n            if (this._columns.length <= x) this._columns.push(new Column(this, 0));\n        }\n        */\n    }\n    createColumn(i) {\n        for (let y = 0; y < this.rowCount; y++) {\n            this.rows[y]._insertCell(i, this._cellMap);\n            //const cell = this.createCell(i, y);\n            //this.cells[y].splice(i, 0, cell);\n        }\n        this._columns.splice(i, 0, new column_1.CellColumn(this, i));\n    }\n    insertXHorizontalBorders(i) {\n        this._borderRows.forEach((v) => {\n            v.insertBorder(i, undefined);\n        });\n    }\n    insertYVerticalBorders(i) {\n        this._borderColumns.forEach((v) => {\n            v.insertBorder(i, undefined);\n        });\n    }\n    /**\n    * 新しい行をi番目の行に挿入します\n    * @param 挿入行の行番号\n    */\n    insertRow(ithRow) {\n        this.primitiveInsertRow(ithRow, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n    }\n    /**\n    * 新しい列をi番目の列に挿入します。\n    * @param ithColumn 挿入列の列番号\n    */\n    insertColumn(ithColumn) {\n        this.primitiveInsertColumn(ithColumn, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n    }\n    /**\n     * 新しい行を作って挿入します。\n     * @param i 挿入行の行番号\n     * @param columnCount 挿入行の列数\n     */\n    /*\n    private insertRowFunction(i: number, columnCount: number = this.columnCount) {\n        const cell: Cell[] = [];\n\n        this.cells.splice(i, 0, cell);\n        this._rows.splice(i, 0, new Row(this, i));\n        for (let x = 0; x < columnCount; x++) {\n            cell[x] = this.createCell(x, i);\n            if (this._columns.length <= x) this._columns.push(new Column(this, 0));\n        }\n\n    }\n    */\n    /**\n    新しい列を最後の列に追加します。\n    */\n    appendColumn() {\n        //this.insertColumn(this.columnCount);\n        this.primitiveInsertColumn(this.columnCount, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n    }\n    /**\n    新しい行を行の最後に追加します。\n    */\n    appendRow() {\n        //this.insertRow(this.rowCount);\n        this.primitiveInsertRow(this.rowCount, false);\n        this.updateNodeRelations();\n        //this.resetUnstableCounter();\n        //this.update();\n        //this.update();\n    }\n    // #endregion\n    // #region update\n    //private prevShow: boolean = false;\n    /*\n    private tryUpdateWithUpdateFlag(withUpdate : boolean) : boolean{\n        let b = super.getUpdateFlag();\n\n        this.hasConnectedObserverFunction = false;\n\n\n        const xb = HTMLFunctions.isShow(this.svgGroup);\n        if (!xb) {\n            return false;\n        }\n\n        this._isDrawing = true;\n\n\n        const cells = this.cellArray;\n        for(let i =0;i<cells.length;i++){\n            b = cells[i].tryUpdateWithUpdateFlag(withUpdate) || b;\n            if(!withUpdate && b){\n                \n                Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag,`${cells[i].tryUpdateWithUpdateFlag.name}`);\n                this._isDrawing = false;\n                this.hasConnectedObserverFunction = true;\n                return b;\n            }\n        }\n\n\n        b = this.fitSizeToOriginalCellsWithUpdateFlag(true, withUpdate) || b;\n        if(!withUpdate && b){\n            Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag,`${this.fitSizeToOriginalCellsWithUpdateFlag.name}`);\n\n            this._isDrawing = false;\n            this.hasConnectedObserverFunction = true;\n            return b;\n        }\n    \n        this.prevShow = false;\n\n\n        b = this.tryResizeWithUpdateFlag(withUpdate) || b;\n\n        if(!withUpdate && b){\n            Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag,this.tryResizeWithUpdateFlag.name);\n\n\n            this._isDrawing = false;\n            this.hasConnectedObserverFunction = true;\n            return b;\n        }\n\n\n        b = this.relocateWithUpdate(withUpdate) || b;\n\n        if(!withUpdate && b){\n            Debugger.updateFlagLog(this, this.tryUpdateWithUpdateFlag,this.relocateWithUpdate.name);\n\n        }\n\n        this._isDrawing = false;\n        this.hasConnectedObserverFunction = true;\n        return b;\n    }\n    /*\n\n    public getUpdateFlag(): boolean {\n        return this.tryUpdateWithUpdateFlag(false);\n        \n    }\n\n\n    /**\n    各セルのサイズを再計算します。\n    */\n    update() {\n        super.update();\n        //this.tryUpdateWithUpdateFlag(true);\n    }\n    connectObserverFunction() {\n        this._observer.observe(this.svgGroup, this.groupObserverOption);\n    }\n    /**\n     * セル番号を振り直します。\n     */\n    /*\n    private renumbering() {\n\n        this.rows.forEach((v, i) => v.cellY = i);\n        this.columns.forEach((v, i) => v.cellX = i);\n        //this.cellArray.forEach((v) => v.updateBorderAttributes());\n\n    }\n    */\n    updateNodeRelations() {\n        this.rows.forEach((v, i) => v.cellY = i);\n        this.columns.forEach((v, i) => v.cellX = i);\n        this.borderRows.forEach((v, i) => {\n            if (v.borders.length != this.columnCount) {\n                throw new Error(`error row ${i} ${v.borders.length} ${this.columnCount}`);\n            }\n        });\n        this.borderColumns.forEach((v, i) => {\n            if (v.borders.length != this.rowCount) {\n                throw new Error(`error column ${i} ${v.borders.length} ${this.rowCount}`);\n            }\n        });\n        this.createCellArray().forEach((v) => v.updateNodeRelations());\n    }\n    /*\n    private tryResizeWithUpdateFlag(withUpdate : boolean) : boolean {\n        let b = false;\n        for(let i = 0;i<this.rows.length;i++){\n            //b = this.rows[i].tryResizeWithUpdateFlag(withUpdate) || b;\n            b = this.rows[i].setHeightToCellsWithUpdateFlag(withUpdate) || b;\n\n            if(!withUpdate && b){\n                return b;\n            }\n        }\n\n        for(let i = 0;i<this.columns.length;i++){\n            b = this.columns[i].setWidthToCellsWithUpdateFlag(withUpdate) || b;\n            if(!withUpdate && b){\n                return b;\n            }\n        }\n        return b;\n\n    }\n    */\n    /*\n    private updateBorders() : boolean{\n        const withUpdate = true;\n        let b  = false;\n\n        const date1 = new Date();\n        (this.createCellArray()).forEach((v) =>{\n            if(v.isMaster){\n                b = UpdateBorder.tryUpdateBordersWithUpdateFlag(v, withUpdate) || b;\n            }\n        })\n        const date2 = new Date();\n        Debugger.showTime(date1, date2, `Table: ${this.objectID}`, \"updateBorders\")\n\n        return b;\n    }\n    */\n    /**\n     * サイズを再計算します。\n     */\n    /*\n    private resize() {\n        this.tryResizeWithUpdateFlag(true);\n\n    }\n    */\n    get childrenStableFlag() {\n        let b = true;\n        for (let i = 0; i < this.rows.length; i++) {\n            if (!this.rows[i].stableFlag) {\n                b = false;\n                break;\n            }\n        }\n        return b;\n    }\n    /*\n    private relocation() {\n        this.relocateWithUpdate(true);\n    }\n    */\n    // #endregion\n    /*\n    public deleteLastRow() {\n        this.rows[this.rowCount - 1].remove(true);\n    }\n    public deleteLastColumn() {\n        this.deleteColumn(this.columnCount - 1);\n    }\n    */\n    /*\n    public deleteColumn(i: number) {\n        const [b,e] = this.columns[i].groupColumnRange;\n        for (let x = e; x >= b; x--) {\n            this.columns[x].remove();\n        }\n    }\n    */\n    /*\n    public deleteRow(i: number) {\n        \n        const [b, e] = this.rows[i].groupRowRange;\n        for (let y = e; y >= b; y--) {\n            this.rows[y].remove();\n        }\n    }\n    */\n    /*\n    private splitCode(tableName: string, codes: string[], id: number): [string, string] {\n        const functions: string[] = [];\n\n        const p = VBATranslateFunctions.grouping80(codes);\n        p.forEach(function (x, i, arr) {\n            functions.push(`Call SubFunction${id}_${i}(${tableName})`);\n            const begin = `Sub SubFunction${id}_${i}(${tableName} As Table)`;\n            const end = `End Sub`;\n            p[i] = VBATranslateFunctions.joinLines([begin, x, end]);\n        });\n        return [VBATranslateFunctions.joinLines(functions), VBATranslateFunctions.joinLines(p)];\n    }\n    */\n    /*\n    public constructFromLogicCell(table: LogicCell[][], isLatexMode: boolean = false) {\n\n    }\n    */\n    /*\n    public get x() : number {\n        return this.svgGroup.getX();\n    }\n    public set x(value :number) {\n        this.svgGroup.setX(value);\n    }\n    public get y() : number {\n        return this.svgGroup.getY();\n    }\n    public set y(value :number) {\n        this.svgGroup.setY(value);\n    }\n    */\n    /**\n            * 接続部分の座標を返します。\n            * @param type\n            * @param x\n            * @param y\n            */\n    getContactPosition(type, x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        switch (type) {\n            case enums_1.ConnectorType.Top:\n                return [this.cx, this.cy - hr];\n            case enums_1.ConnectorType.TopRight:\n            case enums_1.ConnectorType.Right:\n            case enums_1.ConnectorType.BottomRight:\n                return [this.cx + wr, this.cy];\n            case enums_1.ConnectorType.Bottom:\n                return [this.cx, this.cy + hr];\n            case enums_1.ConnectorType.BottomLeft:\n            case enums_1.ConnectorType.Left:\n            case enums_1.ConnectorType.TopLeft:\n                return [this.cx - wr, this.cy];\n            default:\n                const autoType = this.getContactAutoPosition(x, y);\n                return this.getContactPosition(autoType, x, y);\n        }\n    }\n    getContactAutoPosition(x, y) {\n        const wr = this.width / 2;\n        const hr = this.height / 2;\n        const line1 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy + hr);\n        const line2 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy - hr);\n        const b1 = line1.contains(x, y);\n        const b2 = line2.contains(x, y);\n        if (b1) {\n            if (b2) {\n                return enums_1.ConnectorType.Top;\n            }\n            else {\n                return enums_1.ConnectorType.Right;\n            }\n        }\n        else {\n            if (b2) {\n                return enums_1.ConnectorType.Left;\n            }\n            else {\n                return enums_1.ConnectorType.Bottom;\n            }\n        }\n    }\n    getVirtualWidth() {\n        return this.columns.reduce((w, v) => w + v.getVirtualSize().width, 0);\n    }\n    getVirtualHeight() {\n        return this.rows.reduce((w, v) => w + v.getVirtualSize().height, 0);\n    }\n}\nexports.ZTable = ZTable;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_table.ts?");

/***/ }),

/***/ "./src/objects/z_textbox.ts":
/*!**********************************!*\
  !*** ./src/objects/z_textbox.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZTextBox = void 0;\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./src/common/vba_functions.ts\");\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./src/common/style_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\nconst z_vertex_1 = __webpack_require__(/*! ./z_vertex */ \"./src/objects/z_vertex.ts\");\nconst Extensions = __webpack_require__(/*! ../interfaces/extensions */ \"./src/interfaces/extensions.ts\");\nconst enums_2 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./src/html/enum_extension.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGElementExtension = __webpack_require__(/*! ../interfaces/svg_element_extension */ \"./src/interfaces/svg_element_extension.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nconst virtual_text_1 = __webpack_require__(/*! ../interfaces/virtual_text */ \"./src/interfaces/virtual_text.ts\");\nconst element_builder_1 = __webpack_require__(/*! ./element_builder */ \"./src/objects/element_builder.ts\");\nconst debugger_1 = __webpack_require__(/*! ../common/debugger */ \"./src/common/debugger.ts\");\n//namespace GraphTableSVG {\nclass ZTextBox extends z_vertex_1.ZVertex {\n    constructor(svgbox) {\n        super(svgbox);\n        //private isFixTextSize: boolean = false;\n        this.surfaceAttributes = [];\n        //protected _isSpecialTextBox: boolean = false;\n        this._minimumWidth = 10;\n        this._minimumHeight = 10;\n        this.textObserverFunc = (x) => {\n            if (!this.isLocated)\n                return;\n            let b = false;\n            for (let i = 0; i < x.length; i++) {\n                const p = x[i];\n                if (ZTextBox.updateTextAttributes.some((v) => v == p.attributeName)) {\n                    b = true;\n                }\n                if (p.attributeName == null) {\n                    b = true;\n                }\n            }\n            if (b) {\n                //this.resetUnstableCounter();\n                //this.update();\n            }\n        };\n        this.op = 0;\n        this._svgText = (0, element_builder_1.createSVGText)(undefined, undefined, enums_1.DataName.Text);\n        this.svgGroup.appendChild(this.svgText);\n        this._textObserver = new MutationObserver(this.textObserverFunc);\n        const option2 = { childList: true, attributes: true, subtree: true };\n        this._textObserver.observe(this.svgText, option2);\n        if (this.type == enums_1.ShapeObjectType.Object)\n            this.firstFunctionAfterInitialized();\n        /*\n        this.svgText!.onclick = (e) => {\n            const textRect = this.getVirtualRegion();\n\n            this.svgText!.style.border = \"black\"\n\n        }\n        */\n    }\n    /*\n    protected setBasicOption(option: GOptions.ZTextBoxAttributes) {\n        super.setBasicOption(option)\n        const textClass = CSS.createCSSClass(option.textClass);\n        const styleClass = CSS.createCSSClass(option.textStyle);\n        GOptions.setClassAndStyle(this.svgText, textClass, styleClass);\n\n        if (typeof option.text == \"string\") {\n            SVGTextExtension.setTextContent(this.svgText, option.text);\n        } else if (Array.isArray(option.text)) {\n            SVGTextBox.constructSVGTextByHTMLElements(this.svgText, option.text, false);\n            SVGTextBox.sortText(this.svgText, this.horizontalAnchor, false);\n\n\n        } else {\n\n        }\n\n        const b = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.autoSizeShapeToFitText);\n        if (b === undefined && typeof (option.style) == \"object\") {\n            const style: GOptions.ZTextBoxCSS = option.style;\n            if (style.autoSizeShapeToFitText !== undefined) {\n                this.isAutoSizeShapeToFitText = style.autoSizeShapeToFitText;\n            }\n        }\n\n    }\n\n    public setOption(option: GOptions.ZTextBoxAttributes) {\n        super.setOption(option);\n        //this.setBasicOption(option);\n    }\n    */\n    initializeSetBasicOption(source) {\n        super.initializeSetBasicOption(source);\n        ZTextBox.importTextFromSource(this.svgText, this.horizontalAnchor, source);\n        if (this.svgText != null) {\n            z_object_1.ZObject.setSubAttributes(this.svgText, source);\n        }\n    }\n    static importTextFromSource(svgText, horizontalAnchor, source) {\n        if (source.children.length > 0) {\n            const tNodes = HTMLFunctions.getTNodes(source);\n            if (tNodes != null) {\n                tNodes.forEach((v) => v.remove());\n                SVGTextBox.constructSVGTextByHTMLElements(svgText, tNodes, false);\n                if (horizontalAnchor != null && svgText instanceof SVGTextElement) {\n                    SVGTextBox.sortText(svgText, horizontalAnchor, false);\n                }\n            }\n        }\n        else if (source.innerHTML.length > 0) {\n            if (svgText instanceof SVGTextElement) {\n                SVGTextExtension.setTextContent(svgText, source.textContent);\n            }\n            else {\n                Extensions.setTextContent(svgText, source.textContent);\n            }\n            source.innerHTML = \"\";\n        }\n    }\n    /*\n    static constructAttributes(e: Element,\n        removeAttributes: boolean = false, output: GOptions.ZTextBoxAttributes = {}): GOptions.ZTextBoxAttributes {\n\n        ZObject.constructAttributes(e, removeAttributes, output, \"center\");\n        //output.isAutoSizeShapeToFitText = e.gtGetStyleBooleanWithUndefined(AttributeNames.Style.autoSizeShapeToFitText);\n        //const textChild = HTMLFunctions.getChildByNodeName(e, AttributeNames.text);\n        output.textClass = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.textClass);\n        output.textStyle = ElementExtension.gtGetInheritedAttributeString(e, AttributeNames.textStyle);\n\n        if (e.children.length > 0) {\n            const tNodes = HTMLFunctions.getTNodes(e);\n            if (tNodes != null) {\n                tNodes.forEach((v) => v.remove())\n                output.text = tNodes;\n            }\n        } else if (e.innerHTML.length > 0) {\n            output.text = e.innerHTML;\n        }\n\n\n        if (removeAttributes) {\n            //e.removeAttribute(AttributeNames.text);\n            e.removeAttribute(AttributeNames.className);\n            e.removeAttribute(AttributeNames.textStyle);\n\n            (<any>e).style.removeProperty(StyleNames.autoSizeShapeToFitText);\n        }\n        return output;\n    }\n    */\n    get svgText() {\n        return this._svgText;\n    }\n    get horizontalAnchor() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.horizontalAnchor, \"center\");\n        return enums_1.HorizontalAnchor.toHorizontalAnchor(b);\n    }\n    /**\n    テキストの水平方向の配置設定を設定します。\n    */\n    set horizontalAnchor(value) {\n        if (this.horizontalAnchor != value)\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.horizontalAnchor, value);\n    }\n    /**\n    テキストの垂直方向の配置設定を返します。\n    */\n    get verticalAnchor() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.verticalAnchor, \"middle\");\n        return enums_1.VerticalAnchor.toVerticalAnchor(b);\n    }\n    /**\n    テキストの垂直方向の配置設定を設定します。\n    */\n    set verticalAnchor(value) {\n        if (this.verticalAnchor != value)\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.verticalAnchor, value);\n    }\n    /**\n     * このVertexがテキストに合わせてサイズを変える場合Trueを返します。\n     */\n    get isAutoSizeShapeToFitText() {\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.autoSizeShapeToFitText, enums_1.ShapeToFitType.SemiAuto);\n        if (b == enums_1.ShapeToFitType.Auto) {\n            return enums_1.ShapeToFitType.Auto;\n        }\n        else if (b == enums_1.ShapeToFitType.SemiAuto) {\n            return enums_1.ShapeToFitType.SemiAuto;\n        }\n        else {\n            return enums_1.ShapeToFitType.None;\n        }\n        /*\n        if (b == undefined) {\n            return false;\n        } else {\n            return b;\n        }\n        */\n    }\n    set isAutoSizeShapeToFitText(value) {\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.autoSizeShapeToFitText, value);\n        //this.svgGroup.setPropertyStyleValue(AttributeNames.Style.autoSizeShapeToFitText, value ? \"true\" : \"false\");\n    }\n    updateStyleWithUpdateFlag(updateFlag) {\n        let b = false;\n        const dashStyle = this.msoDashStyle;\n        if (dashStyle != null && this.svgSurface != null) {\n            if (updateFlag) {\n                this.hasConnectedObserverFunction = false;\n                b = (0, enum_extension_1.updateAppropriateDashArray)(this.svgSurface);\n                this.hasConnectedObserverFunction = true;\n            }\n            else {\n                b = (0, enum_extension_1.getUpdateFlagAppropriateDashArray)(this.svgSurface);\n            }\n        }\n        return b;\n    }\n    /*\n    protected getUpdateFlagOfStyle(): boolean {\n        return this.updateStyleWithUpdateFlag(false);\n    }\n    protected updateStyle() : boolean {\n        return this.updateStyleWithUpdateFlag(true);\n    }\n    */\n    updateSurfaceSizeWithUpdateFlag(withUpdate) {\n        const region = this.getVirtualRegion();\n        let b = false;\n        const widthRound100 = (0, vline_1.round100)(region.width);\n        if (!(0, vline_1.nearlyEqual)(this.width, widthRound100)) {\n            if (withUpdate) {\n                this.width = widthRound100;\n            }\n            b = true;\n        }\n        const heightRound100 = (0, vline_1.round100)(region.height);\n        if (!(0, vline_1.nearlyEqual)(this.height, heightRound100)) {\n            if (withUpdate) {\n                this.height = heightRound100;\n            }\n            //this.height = region.height;        \n            b = true;\n        }\n        return b;\n    }\n    /*\n    protected updateTextLocationOrGetUpdateFlag(executeUpdate : boolean): boolean {\n        return SVGTextExtension.up(this.svgText, this.getVirtualTextLocationRegion(), this.verticalAnchor, this.horizontalAnchor, this.isAutoSizeShapeToFitText);\n    }\n    */\n    updateTextLocation() {\n        return SVGTextExtension.updateLocation(this.svgText, this.getVirtualTextLocationRegion(), this.verticalAnchor, this.horizontalAnchor, this.isAutoSizeShapeToFitText);\n    }\n    getUpdateFlagOfTextLocation() {\n        return SVGTextExtension.getUpdateFlagOfLocation(this.svgText, this.getVirtualTextLocationRegion(), this.verticalAnchor, this.horizontalAnchor, this.isAutoSizeShapeToFitText);\n    }\n    updateSurfaceLocation() {\n        return false;\n    }\n    getUpdateFlagOfSurfaceLocation() {\n        return false;\n    }\n    getUpdateFlag() {\n        const b1 = super.getUpdateFlag();\n        if (b1) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${super.getUpdateFlag.name}`);\n            return b1;\n        }\n        if (!this.isShown)\n            return b1;\n        if (this.svgText == null) {\n            throw new TypeError(\"svgText is null\");\n        }\n        const b2 = this.updateStyleWithUpdateFlag(false);\n        if (b2) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.updateStyleWithUpdateFlag.name}`);\n            return b2;\n        }\n        const b3 = this.getUpdateFlagOfTextLocation();\n        if (b3) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.getUpdateFlagOfTextLocation.name}`);\n            return b3;\n        }\n        const b4 = this.updateSurfaceSizeWithUpdateFlag(false);\n        if (b4) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.updateSurfaceSizeWithUpdateFlag.name}`);\n            return b3;\n        }\n        const b5 = this.getUpdateFlagOfSurfaceLocation();\n        if (b4) {\n            debugger_1.Debugger.updateFlagLog(this, this.getUpdateFlag, `${this.getUpdateFlagOfSurfaceLocation.name}`);\n            return b3;\n        }\n        const b = b1 || b2 || b3 || b4 || b5;\n        return b;\n    }\n    updateSub() {\n        super.update();\n        this._isUpdating = true;\n        if (!this.isShown)\n            return;\n        //this._observer.disconnect();\n        this.hasConnectedObserverFunction = false;\n        if (this.svgText == null) {\n            throw new TypeError(\"svgText is null\");\n        }\n        this.updateStyleWithUpdateFlag(true);\n        this.updateTextLocation();\n        this.updateSurfaceSizeWithUpdateFlag(true);\n        this.updateSurfaceLocation();\n        this.updateObjectLocation();\n        //this.joint();\n        this._isUpdating = false;\n        this.hasConnectedObserverFunction = true;\n    }\n    update() {\n        //let counter = 1;\n        this.updateSub();\n        /*\n        while(this.getUpdateFlag()){\n            if(counter > 10){\n                throw new Error(\"Update-Loop Error!\");\n            }\n            counter++;\n        }\n        */\n        //return counter > 1;\n    }\n    /*\n    protected updateToFitText(isWidth: boolean) {\n        //this.isFixTextSize = true;\n        //const box = this.svgText.getBBox();\n        const textRect = SVGTextExtension.getSize(this.svgText);\n\n        const textWidth = textRect.width < this._minimumWidth ? this._minimumWidth : textRect.width;\n        const textHeight = textRect.height < this._minimumHeight ? this._minimumHeight : textRect.height;\n\n        if (isWidth) {\n            this.width = textWidth + this.marginPaddingLeft + this.marginPaddingRight;\n        } else {\n            this.height = textHeight + this.marginPaddingTop + this.marginPaddingBottom;\n        }\n    }\n    */\n    get marginPaddingTop() {\n        return SVGTextExtension.getMarginTop(this.svgText) + SVGElementExtension.getPaddingTop(this.svgGroup);\n    }\n    get marginPaddingLeft() {\n        return SVGTextExtension.getMarginLeft(this.svgText) + SVGElementExtension.getPaddingLeft(this.svgGroup);\n    }\n    get marginPaddingRight() {\n        return SVGTextExtension.getMarginRight(this.svgText) + SVGElementExtension.getPaddingRight(this.svgGroup);\n    }\n    get marginPaddingBottom() {\n        return SVGTextExtension.getMarginBottom(this.svgText) + SVGElementExtension.getPaddingBottom(this.svgGroup);\n    }\n    get paddingTop() {\n        return SVGElementExtension.getPaddingTop(this.svgGroup);\n    }\n    set paddingTop(value) {\n        SVGElementExtension.setPaddingTop(this.svgGroup, value);\n    }\n    get paddingLeft() {\n        return SVGElementExtension.getPaddingLeft(this.svgGroup);\n    }\n    set paddingLeft(value) {\n        SVGElementExtension.setPaddingLeft(this.svgGroup, value);\n    }\n    get paddingRight() {\n        return SVGElementExtension.getPaddingRight(this.svgGroup);\n    }\n    set paddingRight(value) {\n        SVGElementExtension.setPaddingRight(this.svgGroup, value);\n    }\n    get paddingBottom() {\n        return SVGElementExtension.getPaddingBottom(this.svgGroup);\n    }\n    set paddingBottom(value) {\n        SVGElementExtension.setPaddingBottom(this.svgGroup, value);\n    }\n    get marginTop() {\n        return SVGTextExtension.getMarginTop(this.svgText);\n    }\n    set marginTop(value) {\n        SVGTextExtension.setMarginTop(this.svgText, value);\n    }\n    get marginLeft() {\n        return SVGTextExtension.getMarginLeft(this.svgText);\n    }\n    set marginLeft(value) {\n        SVGTextExtension.setMarginLeft(this.svgText, value);\n    }\n    get marginRight() {\n        return SVGTextExtension.getMarginRight(this.svgText);\n    }\n    set marginRight(value) {\n        SVGTextExtension.setMarginRight(this.svgText, value);\n    }\n    get marginBottom() {\n        return SVGTextExtension.getMarginBottom(this.svgText);\n    }\n    set marginBottom(value) {\n        SVGTextExtension.setMarginBottom(this.svgText, value);\n    }\n    /*\n    private get innerRectangleWithoutMargin(): Rectangle {\n        const rect = this.innerRectangle;\n        rect.width = rect.width - this.marginPaddingLeft - this.marginPaddingRight;\n        rect.height = rect.height - this.marginPaddingTop - this.marginPaddingBottom;\n        rect.x = rect.x + this.marginPaddingLeft;\n        rect.y = rect.y + this.marginPaddingTop;\n        return rect;\n    }\n    */\n    /*\n    get marginLeft(): number {\n        return this.svgText.getPropertyStyleNumberValue(\"--margin-left\", 0);\n    }\n    set marginLeft(value: number) {\n        this.svgText.setPropertyStyleValue(\"--margin-left\", value.toString());\n    }\n    get marginTop(): number {\n        return this.svgText.getPropertyStyleNumberValue(\"--margin-top\", 0);\n    }\n    set marginTop(value: number) {\n        this.svgText.setPropertyStyleValue(\"--margin-top\", value.toString());\n    }\n    */\n    get svgElements() {\n        const r = [];\n        r.push(this.svgGroup);\n        r.push(this.svgText);\n        return r;\n    }\n    hasDescendant(obj) {\n        const ids = this.svgElements.map((v) => v.getAttribute(AttributeNames.objectIDName)).filter((v) => v != null);\n        const id = obj.getAttribute(AttributeNames.objectIDName);\n        return ids.some((v) => v == id);\n    }\n    get hasSize() {\n        return true;\n    }\n    get msoDashStyle() {\n        if (this.svgSurface != null) {\n            const dashStyle = ElementExtension.getPropertyStyleValue(this.svgSurface, StyleNames.msoDashStyleName);\n            if (dashStyle != null) {\n                return enums_1.msoDashStyle.toMSODashStyle(dashStyle);\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n    set msoDashStyle(value) {\n        if (this.svgSurface != null) {\n            if (enums_1.msoDashStyle == null) {\n                this.svgSurface.style.removeProperty(StyleNames.msoDashStyleName);\n            }\n            else {\n                ElementExtension.setPropertyStyleValue(this.svgSurface, StyleNames.msoDashStyleName, value);\n            }\n        }\n    }\n    createVBACode(id) {\n        const lines = [];\n        const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"fill\", \"gray\"));\n        const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n        const vAnchor = vba_functions_1.VBATranslateFunctions.ToVerticalAnchor(this.verticalAnchor);\n        const hAnchor = vba_functions_1.VBATranslateFunctions.ToHorizontalAnchor(this.horizontalAnchor);\n        lines.push(`Sub create${id}(createdSlide As slide)`);\n        lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n        lines.push(` Dim obj As Shape`);\n        lines.push(` Set obj = shapes_.AddShape(${this.shape}, ${this.globalX}, ${this.globalY}, ${this.width}, ${this.height})`);\n        lines.push(` Call EditTextFrame(obj.TextFrame, ${this.marginPaddingTop}, ${this.marginPaddingBottom}, ${this.marginPaddingLeft}, ${this.marginPaddingRight}, false, ppAutoSizeNone)`);\n        lines.push(` Call EditAnchor(obj.TextFrame, ${vAnchor}, ${hAnchor})`);\n        vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement2(this.svgText, `obj.TextFrame.TextRange`).forEach((v) => lines.push(v));\n        lines.push(this.getVBAEditLine());\n        lines.push(` Call EditCallOut(obj, \"${this.objectID}\", ${visible}, ${backColor})`);\n        this.VBAAdjustments.forEach((v, i) => {\n            lines.push(` obj.Adjustments.Item(${i + 1}) = ${v}`);\n        });\n        lines.push(`End Sub`);\n        return lines;\n    }\n    getVirtualWidth() {\n        return this.getVirtualRegion().width;\n    }\n    getVirtualHeight() {\n        return this.getVirtualRegion().height;\n    }\n    getVirtualExtraRegion() {\n        const textRect = (0, virtual_text_1.getVirtualRegion)(this.svgText);\n        //const textRect = SVGTextExtension.getRegion(this.svgText);\n        const w = textRect.width + this.leftExtraLength + this.rightExtraLength;\n        const h = textRect.height + this.topExtraLength + this.bottomExtraLength;\n        const x = -w / 2;\n        const y = -h / 2;\n        return new vline_1.Rectangle(x, y, w, h);\n    }\n    getVirtualTextLocationRegion() {\n        const rect = this.getVirtualRegion();\n        rect.x += this.leftExtraLength;\n        rect.y += this.topExtraLength;\n        rect.width -= this.leftExtraLength + this.rightExtraLength;\n        rect.height -= this.topExtraLength + this.bottomExtraLength;\n        return rect;\n        /*\n        const rect = this.ExtraRegion;\n        const w = rect.width - this.leftExtraLength - this.rightExtraLength;\n        const h = rect.height - this.topExtraLength - this.bottomExtraLength;\n        const x =rect.x + this.leftExtraLength;\n        const y = rect.y + this.topExtraLength;\n        return new Rectangle(x, y, w, h);\n        */\n    }\n    getVirtualRegion() {\n        if (this.svgText === undefined) {\n            throw new exceptions_1.UndefinedError();\n            //return new Rectangle(this.cx, this.cy, 0, 0);\n        }\n        const marginRect = this.getVirtualExtraRegion();\n        if (this.isAutoSizeShapeToFitText == enums_2.AutoSizeShapeToFitText.Auto) {\n            return marginRect;\n        }\n        else if (this.isAutoSizeShapeToFitText == enums_2.AutoSizeShapeToFitText.SemiAuto) {\n            let [x, y] = [0, 0];\n            let [newWidth, newHeight] = [0, 0];\n            if (this.width < marginRect.width) {\n                newWidth = marginRect.width;\n                x = marginRect.x;\n            }\n            else {\n                //const surface_x = this.svgSurface != null ? SVGElementExtension.getX(this.svgSurface) : 0;\n                newWidth = this.width;\n                x = -this.width / 2;\n            }\n            if (this.height < marginRect.height) {\n                newHeight = marginRect.height;\n                y = marginRect.y;\n            }\n            else {\n                //const surface_y = this.svgSurface != null ? SVGElementExtension.getY(this.svgSurface) : 0;\n                newHeight = this.height;\n                y = -this.height / 2;\n            }\n            //const newWidth = this.width < width ? width : this.width;\n            //const newHeigth = this.height < height ? height : this.height;\n            return new vline_1.Rectangle((0, vline_1.round100)(x), (0, vline_1.round100)(y), (0, vline_1.round100)(newWidth), (0, vline_1.round100)(newHeight));\n        }\n        else {\n            return new vline_1.Rectangle(-(this.width / 2), -(this.height / 2), this.width, this.height);\n            //return new Rectangle(this.x, this.y, this.width, this.height);\n        }\n    }\n    get topExtraLength() {\n        return this.marginPaddingTop;\n    }\n    get leftExtraLength() {\n        return this.marginPaddingLeft;\n    }\n    get rightExtraLength() {\n        return this.marginPaddingRight;\n    }\n    get bottomExtraLength() {\n        return this.marginPaddingBottom;\n    }\n}\nexports.ZTextBox = ZTextBox;\nZTextBox.updateTextAttributes = [\"style\"];\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_textbox.ts?");

/***/ }),

/***/ "./src/objects/z_vertex.ts":
/*!*********************************!*\
  !*** ./src/objects/z_vertex.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZVertex = void 0;\n/// <reference path=\"z_textbox.ts\"/>\n//namespace GraphTableSVG {\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./src/common/vba_functions.ts\");\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst z_object_1 = __webpack_require__(/*! ./z_object */ \"./src/objects/z_object.ts\");\n//import { ZGraph } from \"./g_graph\"\nconst virtual_tree_1 = __webpack_require__(/*! ./graph_helpers/virtual_tree */ \"./src/objects/graph_helpers/virtual_tree.ts\");\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./src/html/enum_extension.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst common_functions_1 = __webpack_require__(/*! ./graph_helpers/common_functions */ \"./src/objects/graph_helpers/common_functions.ts\");\nconst html_1 = __webpack_require__(/*! ../html */ \"./src/html/index.ts\");\nclass ZVertex extends z_object_1.ZObject {\n    /*\n    protected setClassNameOfSVGGroup() {\n        const parent = this.svgGroup.parentElement;\n        if (parent instanceof SVGElement) {\n            const className = GraphTableSVG.AttributeNames.StyleValue.defaultVertexClass;\n            if (className != null && !this.svgGroup.hasAttribute(\"class\") ) {\n                this.svgGroup.setAttribute(\"class\", className);\n            }\n        }\n    }\n    */\n    get defaultClassName() {\n        return DefaultClassNames.defaultVertexClass;\n    }\n    /**\n    * 接続部分のXY座標を返します。\n    * @param type\n    * @param x\n    * @param y\n    */\n    getContactPosition(type, x, y) {\n        return [this.cx, this.cy];\n    }\n    /**\n     * 与えられた位置から伸びた辺に対応する接続位置を返します。\n     * @param type\n     * @param x\n     * @param y\n     */\n    getConnectorType(type, x, y) {\n        if (type == enums_1.ConnectorType.Auto) {\n            return this.getContactAutoPosition(x, y);\n        }\n        else {\n            return type;\n        }\n    }\n    /**\n     * 与えられた位置から伸びた辺に対応する接続位置がAutoだったときの実際の接続位置を返します。\n     * @param x\n     * @param y\n     */\n    getContactAutoPosition(x, y) {\n        return enums_1.ConnectorType.Top;\n    }\n    tryGetSVGText() {\n        return null;\n    }\n    update() {\n        /*\n        if(this.getUpdateFlag()){\n        }\n        */\n        /*\n         this.incomingEdges.forEach((v) =>{\n             v.resetUnstableCounter();\n         })\n         this.outcomingEdges.forEach((v) =>{\n             v.resetUnstableCounter();\n         })\n         */\n        super.update();\n    }\n    /**\n    入辺配列を返します。\n    */\n    get outgoingEdges() {\n        const svgsvg = html_1.HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvg != null) {\n            const manager = svgsvg._manager;\n            if (manager != undefined) {\n                const arr = manager.getOutgoingEdges(this);\n                if (arr == null) {\n                    return new Array(0);\n                }\n                else {\n                    return arr.map((v) => v);\n                }\n            }\n        }\n        return new Array(0);\n    }\n    /*\n    set outcomingEdges(edges : PPEdge[]) {\n        const mes = edges.map((v)=>v.objectID).join(\",\");\n        this.svgGroup.setAttribute(\"outcoming-edges\", mes);\n    }\n    */\n    /**\n    出辺配列を返します。\n    */\n    get incomingEdges() {\n        const svgsvg = html_1.HTMLFunctions.getSVGSVGAncestor(this.svgGroup);\n        if (svgsvg != null) {\n            const manager = svgsvg._manager;\n            if (manager != undefined) {\n                const arr = manager.getIncmoingEdges(this);\n                if (arr == null) {\n                    return new Array(0);\n                }\n                else {\n                    return arr.map((v) => v);\n                }\n            }\n        }\n        return new Array(0);\n    }\n    /*\n    set incomingEdges(edges : PPEdge[]) {\n        const mes = edges.map((v)=>v.objectID).join(\",\");\n        this.svgGroup.setAttribute(\"incoming-edges\", mes);\n    }\n    */\n    /**\n     * 出辺を挿入します。\n     * @param edge\n     * @param insertIndex\n     */\n    /*\n    public insertOutcomingEdge(edge: ZAbstractEdge, insertIndex: number = this.outgoingEdges.length) {\n        return new Array(0);\n    }\n    */\n    dispose() {\n        /*\n        while (this.incomingEdges.length > 0) {\n            this.removeIncomingEdge(this.incomingEdges[0]);\n        }\n\n        while (this.outgoingEdges.length > 0) {\n            this.removeOutcomingEdge(this.outgoingEdges[0]);\n        }\n        */\n    }\n    /**\n    * 親Vertex配列を返します。\n    */\n    getParents() {\n        return this.incomingEdges.filter((v) => v.beginVertex != null).map((v) => v.beginVertex);\n    }\n    /**\n    親との間の辺を返します。\n    */\n    get parentEdge() {\n        if (this.incomingEdges.length == 0) {\n            return null;\n        }\n        else {\n            return this.incomingEdges[0];\n        }\n    }\n    /**\n    このVertexの親を返します。\n    */\n    get parent() {\n        if (this.parentEdge == null) {\n            return null;\n        }\n        else {\n            return this.parentEdge.beginVertex;\n        }\n    }\n    /**\n    このVertexに親がいないときTrueを返します。\n    */\n    get isNoParent() {\n        return this.parent == null;\n    }\n    /**\n    出辺配列を返します。\n    */\n    get children() {\n        return this.outgoingEdges.filter((v) => v.endVertex != null).map((v) => v.endVertex);\n    }\n    /**\n    このVertexが葉のときTrueを返します。\n    */\n    get isLeaf() {\n        return this.outgoingEdges.length == 0;\n    }\n    /**\n     * このVertexを頂点とする仮想部分木を作成します。\n     */\n    //get tree(): VirtualTree {\n    //    return new VirtualTree(this);\n    //}\n    createVirtualTree(excludedEdgeDic) {\n        return new virtual_tree_1.VirtualTree(this, excludedEdgeDic);\n    }\n    /**\n    このVertexの領域を返します。\n    */\n    get region() {\n        const p = new vline_1.Rectangle();\n        p.x = this.cx - (this.width / 2);\n        p.y = this.cy - (this.height / 2);\n        p.width = this.width;\n        p.height = this.height;\n        return p;\n    }\n    get globalX() {\n        if (this.graph != null) {\n            return this.graph.x + this.x;\n        }\n        else {\n            return this.x;\n        }\n    }\n    get globalY() {\n        if (this.graph != null) {\n            return this.graph.y + this.y;\n        }\n        else {\n            return this.y;\n        }\n    }\n    get shape() {\n        return enums_1.VBAShapeType.None;\n    }\n    /**\n             *\n             * @param id\n             */\n    createVBACode(id) {\n        const lines = [];\n        const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"fill\", \"gray\"));\n        const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n        lines.push(`Sub create${id}(createdSlide As slide)`);\n        lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n        lines.push(` Dim obj As Shape`);\n        lines.push(` Set obj = shapes_.AddShape(${this.shape}, ${this.globalX}, ${this.globalY}, ${this.width}, ${this.height})`);\n        const svgText = this.tryGetSVGText();\n        if (svgText != null)\n            vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement2(svgText, `obj.TextFrame.TextRange`).forEach((v) => lines.push(v));\n        lines.push(this.getVBAEditLine());\n        lines.push(` Call EditCallOut(obj, \"${this.objectID}\", ${visible}, ${backColor})`);\n        this.VBAAdjustments.forEach((v, i) => {\n            lines.push(` obj.Adjustments.Item(${i + 1}) = ${v}`);\n        });\n        lines.push(`End Sub`);\n        return lines;\n    }\n    /**\n     * VBAコードでのこの図形を表すShape図形のVBAAdjustmentsプロパティを表します。\n     */\n    get VBAAdjustments() {\n        return [];\n    }\n    getVBAEditLine() {\n        const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"stroke\", \"gray\"));\n        const lineType = (0, enum_extension_1.getLineType)(this.svgSurface);\n        const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"stroke-width\", \"4\"));\n        const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n        return ` Call EditLine(obj.Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`;\n    }\n    get graph() {\n        return (0, common_functions_1.getGraph)(this);\n    }\n    updateSurfaceWithoutSVGText() {\n        super.updateSurfaceWithoutSVGText();\n        this.incomingEdges.forEach((e) => {\n            e.update();\n        });\n        this.outgoingEdges.forEach((e) => {\n            e.update();\n        });\n        return true;\n    }\n}\nexports.ZVertex = ZVertex;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/objects/z_vertex.ts?");

/***/ }),

/***/ "./src/options/console.ts":
/*!********************************!*\
  !*** ./src/options/console.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.view = exports.textarea = exports.log = exports.graph = exports.clear = exports.table = exports.ConsoleLineElement = void 0;\nconst table_dictionary_1 = __webpack_require__(/*! ./table_dictionary */ \"./src/options/table_dictionary.ts\");\nconst logic_tree_1 = __webpack_require__(/*! ../logics/logic_tree */ \"./src/logics/logic_tree.ts\");\nconst logic_graph_1 = __webpack_require__(/*! ../logics/logic_graph */ \"./src/logics/logic_graph.ts\");\nconst logic_table_1 = __webpack_require__(/*! ../logics/logic_table */ \"./src/logics/logic_table.ts\");\n//import { CommonFunctions } from \"../common/common_functions\";\nconst create_g_object_1 = __webpack_require__(/*! ./create_g_object */ \"./src/options/create_g_object.ts\");\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./src/interfaces/svg_textbox.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst CSS = __webpack_require__(/*! ../html/css */ \"./src/html/css.ts\");\nconst VBAMacroModal = __webpack_require__(/*! ./vba_macro_modal */ \"./src/options/vba_macro_modal.ts\");\nconst svg_to_vba_1 = __webpack_require__(/*! ./svg_to_vba */ \"./src/options/svg_to_vba.ts\");\nconst GUIObserver = __webpack_require__(/*! ../html/gui_observer */ \"./src/html/gui_observer.ts\");\nconst z_table_1 = __webpack_require__(/*! ../objects/z_table */ \"./src/objects/z_table.ts\");\nconst z_graph_1 = __webpack_require__(/*! ../objects/z_graph */ \"./src/objects/z_graph.ts\");\nconst ToJSON = __webpack_require__(/*! ./to_json */ \"./src/options/to_json.ts\");\nconst logics_1 = __webpack_require__(/*! ../logics */ \"./src/logics/index.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\n//export namespace Console {\nclass ConsoleLineElement {\n    constructor(parent, type, title = \"\", option = {}) {\n        this.canvas = null;\n        this.vbaObjects = new Array();\n        this.mainObject = null;\n        this.canvasContainer = document.createElement(\"div\");\n        if (parent.firstChild == null) {\n            parent.appendChild(this.canvasContainer);\n        }\n        else {\n            parent.insertBefore(this.canvasContainer, parent.firstChild);\n        }\n        this.fieldSetElement = document.createElement(\"fieldset\");\n        this.canvasContainer.appendChild(this.fieldSetElement);\n        this.legendElement = document.createElement(\"legend\");\n        this.fieldSetElement.appendChild(this.legendElement);\n        this.title = title;\n        const createCanvas = type == \"table\" || type == \"graph\" || type == \"log\" || type == \"group\";\n        const createVBAButton = type == \"table\" || type == \"graph\" || type == \"log\" || type == \"group\";\n        if (createCanvas) {\n            this.canvas = ConsoleLineElement.addSVGSVGElement(this.fieldSetElement);\n            GUIObserver.observeSVGSVG(this.canvas);\n        }\n        if (option.mainElement !== undefined) {\n            if (option.mainElement instanceof HTMLElement) {\n                this.fieldSetElement.appendChild(option.mainElement);\n            }\n        }\n        /*\n        this.pngButton = document.createElement(\"button\");\n        this.pngButton.textContent = \"PNG\";\n        const pngFunc = () =>{\n            const _canvas = PNG.createPNGFromSVGSVGElement(this.canvas);\n            this.canvasContainer.appendChild(_canvas);\n\n        }\n        this.pngButton.onclick = pngFunc;\n        */\n        //this.canvasContainer.appendChild(this.pngButton);\n        //this.pngButton.setAttribute(\"hidden\", \"1\");\n        this.removeButton = document.createElement(\"button\");\n        this.removeButton.textContent = \"remove\";\n        this.fieldSetElement.appendChild(this.removeButton);\n        const removeFunc = () => {\n            this.fieldSetElement.remove();\n        };\n        this.removeButton.onclick = removeFunc;\n        this.macroButton = document.createElement(\"button\");\n        this.macroButton.textContent = \"VBA\";\n        if (createVBAButton) {\n            this.fieldSetElement.appendChild(this.macroButton);\n        }\n        const vbaFunc = () => {\n            VBAMacroModal.createMacroModal(svg_to_vba_1.SVGToVBA.create(this.vbaObjects));\n        };\n        this.macroButton.onclick = vbaFunc;\n        const createCSVButton = type == \"table\";\n        this.csvButton = document.createElement(\"button\");\n        this.csvButton.textContent = \"csv\";\n        if (createCSVButton) {\n            this.fieldSetElement.appendChild(this.csvButton);\n        }\n        const csvFunc = () => {\n            if (this.mainObject instanceof z_table_1.ZTable) {\n                const str = this.mainObject.rows.map((v) => {\n                    return v.cells.map((w) => w.svgText.textContent).join(\",\");\n                }).join(\"\\n\");\n                textarea(str, this.title);\n            }\n        };\n        this.csvButton.onclick = csvFunc;\n    }\n    get title() {\n        return this.legendElement.textContent;\n    }\n    set title(value) {\n        this.legendElement.textContent = value;\n        this.legendElement.style.fontWeight = \"bold\";\n    }\n    addVBAObject(obj) {\n        this.vbaObjects.push(obj);\n        if (obj instanceof z_table_1.ZTable || obj instanceof z_graph_1.ZGraph) {\n            this.mainObject = obj;\n        }\n    }\n    static addSVGSVGElement(code) {\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        //const p = document.createElement(\"p\");\n        //code.appendChild(p);\n        //p.appendChild(svg);\n        code.appendChild(svg);\n        svg.setAttribute(\"style\", \"background:#e9e9e9;border:solid 1pt;padding:10px\");\n        //svg.setAttribute(\"style\", \"background:#e9e9e9;\");\n        //svg.setAttribute(\"width\", \"600px\");\n        //svg.setAttribute(\"height\", \"600px\");\n        svg.setAttribute(enums_1.OriginalSVGSVGAttributes.ShrinkAttributeName, \"true\");\n        if (svg instanceof SVGSVGElement) {\n            return svg;\n        }\n        else {\n            throw \"error\";\n        }\n    }\n}\nexports.ConsoleLineElement = ConsoleLineElement;\nconst defaultCodeBoxID = \"GraphTableSVG-CodeBox\";\n/*\nfunction getCodeTag(containerID : string = defaultCodeBoxID ): HTMLElement | null {\n    const box = document.getElementById(containerID);\n    return box;\n}\n*/\nfunction getOrCreateCodeElement(containerID = defaultCodeBoxID) {\n    CSS.setGraphTableCSS();\n    const code = document.getElementById(containerID);\n    //const code = getCodeTag(containerID);\n    if (code != null) {\n        return code;\n    }\n    else {\n        const element = document.createElement(\"code\");\n        document.body.appendChild(element);\n        element.setAttribute(\"id\", defaultCodeBoxID);\n        //document.body.appendChild(element);\n        //element.setAttribute(\"name\", codeTagName);\n        return element;\n    }\n}\n/*\nfunction initialize(): void {\n    const code = getCodeTag();\n    if (code == null) {\n        createCodeTag();\n    }\n}\n*/\nfunction table(item, title = \"\", canvasID_or_ContainerID = null) {\n    if (item instanceof logic_table_1.LogicTable) {\n        return view(item, title, canvasID_or_ContainerID);\n    }\n    else if (item instanceof Array && item.every((v) => v instanceof logics_1.LogicCell)) {\n        const tableItem = (0, logics_1.buildLogicTable)([item], { isRowLines: false });\n        return table(tableItem, title, canvasID_or_ContainerID);\n    }\n    else {\n        const tableDic = new table_dictionary_1.TableDictionary();\n        tableDic.construct(item);\n        const logicTable = tableDic.toLogicTable();\n        return table(logicTable, title, canvasID_or_ContainerID);\n    }\n}\nexports.table = table;\nfunction clear(containerID = defaultCodeBoxID) {\n    const code = getOrCreateCodeElement(containerID);\n    code.innerHTML = \"\";\n}\nexports.clear = clear;\nfunction graph(item, title = \"\", canvasID_or_ContainerID = null) {\n    if (item instanceof logic_tree_1.LogicTree || item instanceof logic_graph_1.LogicGraph) {\n        if (item instanceof logic_tree_1.LogicTree) {\n            return view(item, title, canvasID_or_ContainerID);\n        }\n        else {\n            return view(item, title, canvasID_or_ContainerID);\n        }\n    }\n    else {\n        const tableDic = new table_dictionary_1.TableDictionary();\n        tableDic.construct(item);\n        const logicGraph = tableDic.toLogicGraph();\n        return graph(logicGraph, title, canvasID_or_ContainerID);\n    }\n}\nexports.graph = graph;\nfunction log(message, title = \"\") {\n    const code = getOrCreateCodeElement();\n    const consoleLine = new ConsoleLineElement(code, \"log\", title);\n    const textClass = DefaultClassNames.defaultTextClass;\n    const textElement = SVG.createText(textClass);\n    //const text = document.createElementNS('http://www.w3.org/2000/svg', \"text\");\n    //text.textContent = message;\n    consoleLine.canvas.appendChild(textElement);\n    SVGTextBox.setTextToSVGText(textElement, message, false);\n    textElement.setAttribute(\"x\", \"0\");\n    const b2 = SVGTextExtension.getSize(textElement, true);\n    textElement.setAttribute(\"y\", b2.height.toString());\n    consoleLine.addVBAObject(textElement);\n    //table(message);\n    return consoleLine;\n}\nexports.log = log;\nfunction getRowCount(line, cols) {\n    return Math.ceil(line.length / cols);\n}\nfunction textarea(message, title = \"\", option) {\n    if (typeof (message) != \"string\") {\n        return textarea(ToJSON.stringify(message), title, option);\n    }\n    else {\n        const newOption = option === undefined ? {} : option;\n        const code = getOrCreateCodeElement(newOption.container === undefined ? defaultCodeBoxID : newOption.container);\n        const textArea = document.createElement(\"textarea\");\n        textArea.textContent = message;\n        const lines = message.split(\"\\n\");\n        let maxCols = 0;\n        lines.forEach((v) => {\n            if (v.length > maxCols) {\n                maxCols = v.length;\n            }\n        });\n        const defaultCols = maxCols < 240 ? maxCols + 5 : 245;\n        textArea.cols = newOption.cols === undefined ? defaultCols : newOption.cols;\n        let rowCount = 0;\n        lines.forEach((v) => rowCount += getRowCount(v, textArea.cols));\n        textArea.rows = newOption.rows === undefined ? rowCount : newOption.rows;\n        const consoleLine = new ConsoleLineElement(code, \"textarea\", title, { mainElement: textArea });\n        consoleLine.title = title;\n        //const canvasContainer = document.createElement(\"div\");\n        //code.appendChild(canvasContainer);                \n        //consoleLine.canvasContainer.appendChild(textArea);\n        return consoleLine;\n    }\n}\nexports.textarea = textarea;\nfunction view(item, title, canvasID = null) {\n    let isCanvasID = false;\n    if (canvasID != null) {\n        if (typeof (canvasID) == \"string\") {\n            isCanvasID = (document.getElementById(canvasID) instanceof SVGSVGElement);\n        }\n        else {\n            isCanvasID = canvasID instanceof SVGSVGElement;\n        }\n    }\n    if (item instanceof logic_table_1.LogicTable) {\n        if (isCanvasID) {\n            const canvasItem = canvasID;\n            const gtable = (0, create_g_object_1.createGObject)(canvasItem, enums_1.ShapeObjectType.Table);\n            gtable.buildFromLogicTable(item);\n            return [gtable, gtable.svgGroup.parentNode];\n        }\n        else {\n            const containerID = canvasID == null ? null : canvasID;\n            const code = containerID == null ? getOrCreateCodeElement() : getOrCreateCodeElement(containerID);\n            const consoleLine = new ConsoleLineElement(code, \"table\", title);\n            const gtable = (0, create_g_object_1.createGObject)(consoleLine.canvas, enums_1.ShapeObjectType.Table);\n            gtable.buildFromLogicTable(item);\n            gtable.x = 0;\n            gtable.y = 0;\n            consoleLine.addVBAObject(gtable);\n            return [gtable, consoleLine];\n        }\n    }\n    else if (item instanceof logic_tree_1.LogicTree || item instanceof logic_graph_1.LogicGraph) {\n        throw new Error(\"Error\");\n        /*\n        if(isCanvasID){\n            const canvasItem = <string | SVGElement>canvasID;\n            const ggraph = <ZGraph>createGObject(canvasItem, ShapeObjectType.Graph);\n            ggraph.build(item);\n            if (item.option.drawingFunction !== undefined) {\n                const drawingFunction = new Function(\"obj\", `${item.option.drawingFunction.functionName}(obj)`);\n                drawingFunction(ggraph);\n            }\n            return [ggraph, <SVGElement>ggraph.svgGroup.parentNode];\n        }\n        else {\n            const containerID : string | null = canvasID == null ? null : <string>canvasID;\n            const code = containerID == null ? getOrCreateCodeElement() : getOrCreateCodeElement(containerID);\n\n            //const code = getOrCreateCodeElement();\n            const consoleLine = new ConsoleLineElement(code, \"graph\", title);\n            //const svg = addSVGSVGElement(code);\n            const ggraph = <ZGraph>createGObject(consoleLine.canvas!, ShapeObjectType.Graph);\n            if(item.option ===undefined){\n                throw new Exceptions.UndefinedError();\n            }\n    \n            ggraph.build(item);\n            consoleLine.addVBAObject(ggraph);\n            if (item.option.drawingFunction !== undefined) {\n                const drawingFunction = new Function(\"obj\", `${item.option.drawingFunction.functionName}(obj)`);\n                drawingFunction(ggraph);\n            }\n\n            return [ggraph, consoleLine];\n        }\n        */\n        //graph(item);\n    }\n    else {\n        let gobject;\n        let svg;\n        if (canvasID != null) {\n            gobject = (0, create_g_object_1.createGObject)(canvasID, enums_1.ShapeObjectType.Object);\n            svg = gobject.svgGroup.parentNode;\n        }\n        else {\n            const code = getOrCreateCodeElement();\n            const consoleLine = new ConsoleLineElement(code, \"group\", title);\n            gobject = (0, create_g_object_1.createGObject)(consoleLine.canvas, enums_1.ShapeObjectType.Object);\n            svg = consoleLine;\n        }\n        let prevItem = null;\n        item.items.forEach((v) => {\n            if (item.itemOrder == \"row\") {\n                if (prevItem != null) {\n                    if (v instanceof logic_table_1.LogicTable) {\n                        v.option.x = 0;\n                        v.option.y = prevItem.getRegion().bottom + item.itemInterval;\n                        v.option.positionType = \"upper-left\";\n                    }\n                    else if (v instanceof logic_tree_1.LogicTree) {\n                        v.option.position = { x: 0, y: prevItem.getRegion().bottom + item.itemInterval, type: \"upper-left\" };\n                    }\n                }\n            }\n            const [tmp1, tmp2] = view(v, title, gobject.svgGroup);\n            prevItem = tmp1;\n        });\n        return [gobject, svg];\n    }\n}\nexports.view = view;\n/*\nexport function viewUsingObject(obj: any, title: string, canvasID: string | SVGElement | null = null) : [GObject, ConsoleLineElement | SVGElement] {\n    const item = LogicGroup.buildLogicObjectFromObject(obj);\n    return view(<any>item, title, canvasID);\n}\n*/\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/console.ts?");

/***/ }),

/***/ "./src/options/create_g_object.ts":
/*!****************************************!*\
  !*** ./src/options/create_g_object.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createGObject = void 0;\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nfunction createGObject(parent, type, option = {}) {\n    /*\n    let _parent: SVGElement;\n    if (parent instanceof ZObject) {\n        _parent = parent.svgGroup;\n    } else if (parent instanceof SVGElement) {\n        _parent = parent;\n    } else {\n        _parent = <any>document.getElementById(parent);\n    }\n\n    switch (type) {\n        case ShapeObjectType.Callout:\n            const call = new ZCallout(_parent);\n            call.setOption(option);\n            return call;\n        case ShapeObjectType.ArrowCallout:\n            const arr = new ZArrowCallout(_parent);\n            arr.setOption(option);\n        case ShapeObjectType.Ellipse:\n            const ell = new ZEllipse(_parent);\n            ell.setOption(option);\n            return ell;\n        case ShapeObjectType.Rect:\n            const rect = new ZRect(_parent);\n            rect.setOption(option);\n            return rect;\n        case ShapeObjectType.Edge:\n            const edge = new ZEdge(_parent);\n            edge.setOption(option);\n            return edge;\n        case ShapeObjectType.Graph:\n            const graph = new ZGraph(_parent);\n            graph.setOption(option);\n            return graph;\n        case ShapeObjectType.Table:\n            const table = new ZTable(_parent);\n            table.setOption(option);\n            return table;\n        case ShapeObjectType.RectButton:\n            const rectb = new ZRectButton(_parent);\n            rectb.setOption(option);\n            return rectb;\n        case ShapeObjectType.Circle:\n            const circle = new ZCircle(_parent);\n            circle.setOption(option);\n            return circle;\n        case ShapeObjectType.ForeignButton:\n            const button = new ZForeignButton(_parent);\n            button.setOption(option);\n            return button;\n\n        case ShapeObjectType.Object:\n            const obj = new ZObject(_parent);\n            obj.setOption(option);\n            return obj;\n    }\n    */\n    throw new exceptions_1.ArgumentOutOfRangeError();\n}\nexports.createGObject = createGObject;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/create_g_object.ts?");

/***/ }),

/***/ "./src/options/custom_tag_processors/intermediate_g_tag_preprocessor.ts":
/*!******************************************************************************!*\
  !*** ./src/options/custom_tag_processors/intermediate_g_tag_preprocessor.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.processIntermediateSVGGElements = exports.convertFromZTagToIntermediateSVGGTag = void 0;\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../../common/enums */ \"./src/common/enums.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../../html/html_functions */ \"./src/html/html_functions.ts\");\nconst z_callout_1 = __webpack_require__(/*! ../../objects/z_callout */ \"./src/objects/z_callout.ts\");\nconst z_arrow_callout_1 = __webpack_require__(/*! ../../objects/z_arrow_callout */ \"./src/objects/z_arrow_callout.ts\");\nconst z_ellipse_1 = __webpack_require__(/*! ../../objects/z_ellipse */ \"./src/objects/z_ellipse.ts\");\nconst z_rect_1 = __webpack_require__(/*! ../../objects/z_rect */ \"./src/objects/z_rect.ts\");\nconst z_edge_1 = __webpack_require__(/*! ../../objects/z_edge */ \"./src/objects/z_edge.ts\");\nconst z_table_1 = __webpack_require__(/*! ../../objects/z_table */ \"./src/objects/z_table.ts\");\nconst z_graph_1 = __webpack_require__(/*! ../../objects/z_graph */ \"./src/objects/z_graph.ts\");\nconst z_rect_button_1 = __webpack_require__(/*! ../../objects/z_rect_button */ \"./src/objects/z_rect_button.ts\");\nconst z_circle_1 = __webpack_require__(/*! ../../objects/z_circle */ \"./src/objects/z_circle.ts\");\nconst z_foreign_button_1 = __webpack_require__(/*! ../../objects/z_foreign_button */ \"./src/objects/z_foreign_button.ts\");\n/**\n * ZObjectタグをCustomGElementに変換します。\n * @param element\n * @returns\n */\nfunction convertFromZTagToIntermediateSVGGTagSub(e) {\n    const type = enums_1.ShapeObjectType.toShapeObjectTypeOrCustomTag(e.nodeName.toLowerCase());\n    if (type == null) {\n    }\n    else {\n        const ns = document.createElementNS('http://www.w3.org/2000/svg', \"g\");\n        ns.setAttribute(AttributeNames.customElement, e.nodeName.toLowerCase());\n        HTMLFunctions.copyAttributes(e, ns);\n        ns.innerHTML = e.innerHTML;\n        //HTMLFunctions.getChildren(e).forEach((v)=>ns.appendChild(v));\n        const p = e.parentElement;\n        if (p != null) {\n            p.insertBefore(ns, e);\n            e.remove();\n        }\n        const children = HTMLFunctions.getChildren(ns);\n        children.forEach((v) => convertFromZTagToIntermediateSVGGTagSub(v));\n    }\n}\nfunction convertFromZTagToIntermediateSVGGTag(svgsvg) {\n    HTMLFunctions.getDescendants(svgsvg).forEach(v => {\n        const shapeType = enums_1.ShapeObjectType.toShapeObjectType(v.nodeName.toLowerCase());\n        if (shapeType != null) {\n            convertFromZTagToIntermediateSVGGTagSub(v);\n        }\n    });\n}\nexports.convertFromZTagToIntermediateSVGGTag = convertFromZTagToIntermediateSVGGTag;\n/**\n * CustomGElementかどうか判定します。\n * @param element\n * @returns\n */\nfunction isIntermediateSVGGElement(element) {\n    const gObjectTypeAttr = element.getAttribute(AttributeNames.customElement);\n    if (gObjectTypeAttr != null) {\n        const gObjectType = enums_1.ShapeObjectType.toShapeObjectType(gObjectTypeAttr);\n        return gObjectType != null;\n    }\n    else {\n        return false;\n    }\n}\n/**\n * g-rectなどのカスタムタグをGObjectに変換します。\n * @param intermediateSVGGElement カスタムタグのElement\n * @param type\n * @returns\n */\nfunction convertFromIntermediateGElementToZObject(intermediateSVGGElement, type) {\n    const parent = intermediateSVGGElement.parentElement;\n    if (parent instanceof SVGElement) {\n        let r;\n        //intermediateSVGGElement.removeAttribute(AttributeNames.customElement);\n        if (type == enums_1.ShapeObjectType.Callout) {\n            //const option = ZCallout.constructAttributes(intermediateSVGGElement, true);\n            r = new z_callout_1.ZCallout(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.ArrowCallout) {\n            //const option = ZArrowCallout.constructAttributes(intermediateSVGGElement, true);\n            r = new z_arrow_callout_1.ZArrowCallout(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.Ellipse) {\n            //const option = ZEllipse.constructAttributes(intermediateSVGGElement, true);\n            r = new z_ellipse_1.ZEllipse(parent);\n            r.initialize(intermediateSVGGElement);\n            // r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.Circle) {\n            //const option = ZCircle.constructAttributes(intermediateSVGGElement, true);\n            r = new z_circle_1.ZCircle(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.Rect) {\n            //const option = ZRect.constructAttributes(intermediateSVGGElement, true);\n            r = new z_rect_1.ZRect(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.Edge) {\n            //const option = ZEdge.constructAttributes(intermediateSVGGElement, true);\n            r = new z_edge_1.ZEdge(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.Graph) {\n            //const option = ZGraph.constructAttributes(intermediateSVGGElement, true, {}, \"center\");\n            r = new z_graph_1.ZGraph(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n            //(<ZGraph>r).relocate();\n        }\n        else if (type == enums_1.ShapeObjectType.Table) {\n            //const logicTable = LogicTable.constructLogicTable(intermediateSVGGElement);\n            const table = new z_table_1.ZTable(parent);\n            table.initialize(intermediateSVGGElement);\n            /*\n            if(logicTable != null){\n                //logicTable.option = convertAttributesIntoTableOption(node);\n                table.buildFromLogicTable(logicTable);\n            }else{\n                const option = convertAttributesIntoTableOption(intermediateSVGGElement);\n                table.assignOption(option);\n            }\n            */\n            r = table;\n        }\n        else if (type == enums_1.ShapeObjectType.RectButton) {\n            //const option = ZRectButton.constructAttributes(intermediateSVGGElement, true);\n            r = new z_rect_button_1.ZRectButton(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else if (type == enums_1.ShapeObjectType.ForeignButton) {\n            //const option = ZRectButton.constructAttributes(intermediateSVGGElement, true);\n            r = new z_foreign_button_1.ZForeignButton(parent);\n            r.initialize(intermediateSVGGElement);\n            //r.setOption(option);\n        }\n        else {\n            return null;\n        }\n        //属性の移動と元オブジェクトの削除\n        /*\n        const attrs = ElementExtension.gtGetAttributes(intermediateSVGGElement);\n        HTMLFunctions.getChildren(intermediateSVGGElement).forEach((v) => r.svgGroup.appendChild(v));\n        intermediateSVGGElement.remove();\n        attrs.forEach((v) => {\n            var items = v.name.split(\":\");\n            if (items.length == 2 && items[0] == \"surface\") {\n                if (r.svgSurface != null) {\n                    r.svgSurface.setAttribute(items[1], v.value);\n                }\n            } else {\n                r.svgGroup.setAttribute(v.name, v.value)\n            }\n        }\n        );\n        */\n        if (r instanceof z_graph_1.ZGraph) {\n            r.relocate();\n        }\n        return r;\n    }\n    else {\n        throw Error(\"error!\");\n    }\n}\nfunction processIntermediateSVGGElements(svgsvg, output) {\n    HTMLFunctions.getDescendantsByPostorder(svgsvg).forEach((v) => {\n        if (v instanceof SVGElement) {\n            if (isIntermediateSVGGElement(v)) {\n                const p = convertFromIntermediateSVGGElementToZObject(v);\n                if (p != null && output != null) {\n                    output.push(p);\n                }\n            }\n        }\n    });\n}\nexports.processIntermediateSVGGElements = processIntermediateSVGGElements;\nfunction convertFromIntermediateSVGGElementToZObject(id) {\n    if (typeof id == \"string\") {\n        const item = document.getElementById(id);\n        if (item instanceof SVGElement) {\n            return convertFromIntermediateSVGGElementToZObject(item);\n        }\n        else {\n            return null;\n        }\n    }\n    else {\n        const element = id;\n        //const shapeType = GraphTableSVG.ShapeObjectType.toShapeObjectType(element.nodeName);\n        const gObjectTypeAttr = element.getAttribute(AttributeNames.customElement);\n        if (gObjectTypeAttr != null) {\n            const gObjectType = enums_1.ShapeObjectType.toShapeObjectType(gObjectTypeAttr);\n            if (gObjectType != null) {\n                return convertFromIntermediateGElementToZObject(element, gObjectType);\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            const type = enums_1.ShapeObjectType.toShapeObjectType(element.nodeName.toLowerCase());\n            if (type != null) {\n                return convertFromIntermediateGElementToZObject(element, type);\n            }\n            else {\n                return null;\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/custom_tag_processors/intermediate_g_tag_preprocessor.ts?");

/***/ }),

/***/ "./src/options/custom_tag_processors/macro_tag_preprocessor.ts":
/*!*********************************************************************!*\
  !*** ./src/options/custom_tag_processors/macro_tag_preprocessor.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.processMacroTag = void 0;\nconst common_1 = __webpack_require__(/*! ../../common */ \"./src/common/index.ts\");\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../../common/enums */ \"./src/common/enums.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../../html/html_functions */ \"./src/html/html_functions.ts\");\n/**\n * CustomGElementかどうか判定します。\n * @param element\n * @returns\n */\n/*\n export function isMacroTag(element: Element): MacroTagNames | null {\n    const gObjectTypeAttr = element.getAttribute(AttributeNames.customElement);\n\n    if (gObjectTypeAttr != null) {\n        const gObjectType = ShapeObjectType.toShapeObjectType(gObjectTypeAttr);\n        return gObjectType != null;\n    } else {\n        return false;\n    }\n\n}\n*/\nlet _id_count = 1;\nfunction getNewID(e) {\n    while (true) {\n        const id = `__${e.nodeName.toLowerCase()}_${_id_count++}`;\n        if (document.getElementById(id) == null) {\n            return id;\n        }\n    }\n}\nfunction isMacroVertex(e) {\n    if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Circle) {\n        return enums_1.MacroTagNames.Circle;\n    }\n    else if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Ellipse) {\n        return enums_1.MacroTagNames.Ellipse;\n    }\n    else if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Rect) {\n        return enums_1.MacroTagNames.Rect;\n    }\n    else {\n        return null;\n    }\n}\nfunction createUnknownElement(e) {\n    if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Circle) {\n        return document.createElement(enums_1.ShapeObjectType.Circle);\n    }\n    else if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Ellipse) {\n        return document.createElement(enums_1.ShapeObjectType.Ellipse);\n    }\n    else if (e.nodeName.toLowerCase() == enums_1.MacroTagNames.Rect) {\n        return document.createElement(enums_1.ShapeObjectType.Rect);\n    }\n    else {\n        return null;\n    }\n}\nfunction processMacroNodeTag(e, parent, depth, outputVertexes, outputEdges) {\n    const newNode = createUnknownElement(e);\n    //newNode.setAttribute(AttributeNames.customElement, ShapeObjectType.Ellipse);\n    HTMLFunctions.copyAttributes(e, newNode);\n    outputVertexes.push(newNode);\n    newNode.setAttribute(\"data-depth\", depth.toString());\n    newNode.setAttribute(\"data-x\", outputVertexes.length.toString());\n    newNode.setAttribute(\"cy\", ((depth + 1) * 50).toString());\n    newNode.setAttribute(\"id\", getNewID(newNode));\n    if (parent != null) {\n        const newEdge = document.createElement(enums_1.ShapeObjectType.Edge);\n        outputEdges.push(newEdge);\n        newEdge.setAttribute(\"id\", getNewID(newEdge));\n        newEdge.setAttribute(AttributeNames.beginVertex, parent.getAttribute(\"id\"));\n        newEdge.setAttribute(AttributeNames.endVertex, newNode.getAttribute(\"id\"));\n    }\n    while (e.children.length > 0) {\n        const child = e.children.item(0);\n        if (child != null) {\n            if (isMacroVertex(child) != null) {\n                processMacroNodeTag(child, newNode, depth + 1, outputVertexes, outputEdges);\n            }\n            else {\n                newNode.appendChild(child);\n            }\n        }\n    }\n    e.remove();\n}\nfunction processMacroTreeTag(e) {\n    const graphTag = document.createElement(enums_1.ShapeObjectType.Graph);\n    graphTag.setAttribute(AttributeNames.customElement, enums_1.ShapeObjectType.Graph);\n    HTMLFunctions.copyAttributes(e, graphTag);\n    if (graphTag.getAttribute(\"class\") == null) {\n        graphTag.setAttribute(\"class\", common_1.DefaultClassNames.defaultTreeClass);\n    }\n    const outputVertexes = new Array();\n    const outputEdges = new Array();\n    while (e.children.length > 0) {\n        const child = e.children.item(0);\n        if (child != null) {\n            if (isMacroVertex(child)) {\n                processMacroNodeTag(child, null, 0, outputVertexes, outputEdges);\n            }\n            else {\n                child.remove();\n            }\n        }\n    }\n    outputVertexes.forEach((v) => {\n        graphTag.appendChild(v);\n    });\n    outputEdges.forEach((v) => {\n        graphTag.appendChild(v);\n    });\n    return graphTag;\n}\nfunction processMacroTag(svgsvg) {\n    while (true) {\n        const trees = svgsvg.getElementsByTagName(enums_1.MacroTagNames.Tree);\n        if (trees.length > 0) {\n            const mtreeTag = trees.item(0);\n            if (mtreeTag != null) {\n                const intermediateGElement = processMacroTreeTag(mtreeTag);\n                svgsvg.insertBefore(intermediateGElement, mtreeTag);\n                mtreeTag.remove();\n            }\n        }\n        else {\n            break;\n        }\n    }\n}\nexports.processMacroTag = processMacroTag;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/custom_tag_processors/macro_tag_preprocessor.ts?");

/***/ }),

/***/ "./src/options/editor_helper.ts":
/*!**************************************!*\
  !*** ./src/options/editor_helper.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDisplayVertexObjectTypes = exports.DisplayObject = void 0;\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nvar DisplayObject;\n(function (DisplayObject) {\n    function create(key, displayName) {\n        return { key: key, displayName: displayName };\n    }\n    DisplayObject.create = create;\n})(DisplayObject || (exports.DisplayObject = DisplayObject = {}));\n//export function getObjects() : VertexObjectType[] {\n//    return [ \"g-callout\", \"g-arrow-callout\", \"g-ellipse\", \"g-circle\", \"g-rect\", \"g-path-textbox\", \"g-rect-button\", \"g-table\"];\n//}\nfunction getDisplayVertexObjectTypes() {\n    return [DisplayObject.create(enums_1.ShapeObjectType.Callout, \"ZCallout\"),\n        DisplayObject.create(enums_1.ShapeObjectType.ArrowCallout, \"ZArrowCallout\"),\n        DisplayObject.create(enums_1.ShapeObjectType.Ellipse, \"GEllipse\"),\n        DisplayObject.create(enums_1.ShapeObjectType.Circle, \"GCircle\"),\n        DisplayObject.create(enums_1.ShapeObjectType.Rect, \"GRect\"),\n        DisplayObject.create(enums_1.ShapeObjectType.PathTextBox, \"GPathTextbox\"),\n        DisplayObject.create(enums_1.ShapeObjectType.RectButton, \"GRectButton\"),\n        DisplayObject.create(enums_1.ShapeObjectType.Table, \"GTable\")];\n}\nexports.getDisplayVertexObjectTypes = getDisplayVertexObjectTypes;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/editor_helper.ts?");

/***/ }),

/***/ "./src/options/html_table.ts":
/*!***********************************!*\
  !*** ./src/options/html_table.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createHTMLTable = void 0;\nconst logic_table_1 = __webpack_require__(/*! ../logics/logic_table */ \"./src/logics/logic_table.ts\");\n//export namespace HTMLFunctions {\nfunction createHTMLTable(e) {\n    const table = logic_table_1.LogicTable.constructHTMLLogicTable(e);\n    const tableTag = document.createElement(\"table\");\n    tableTag.setAttribute(\"border\", \"1\");\n    tableTag.setAttribute(\"cellspacing\", \"0\");\n    tableTag.setAttribute(\"bordercolor\", \"black\");\n    if (table != null) {\n        const cellConnectChecker = new Array();\n        for (let y = 0; y < table.rowCount; y++) {\n            cellConnectChecker.push(new Array(table.columnCount));\n            for (let x = 0; x < table.columnCount; x++) {\n                cellConnectChecker[y][x] = true;\n            }\n        }\n        for (let y = 0; y < table.rowCount; y++) {\n            const tr = document.createElement(\"tr\");\n            tableTag.appendChild(tr);\n            for (let x = 0; x < table.columnCount; x++) {\n                if (cellConnectChecker[y][x]) {\n                    const td = document.createElement(\"td\");\n                    const cell = table.cells[y][x];\n                    if (cell.option.h != undefined && cell.option.h > 1) {\n                        td.setAttribute(\"rowspan\", cell.option.h.toString());\n                    }\n                    if (cell.option.w != undefined && cell.option.w > 1) {\n                        td.setAttribute(\"columnspan\", cell.option.w.toString());\n                    }\n                    for (let ty = 0; ty < cell.connectedRowCount; ty++) {\n                        for (let tx = 0; tx < cell.connectedColumnCount; tx++) {\n                            if (tx != 0 || ty != 0) {\n                                cellConnectChecker[ty + y][tx + x] = false;\n                            }\n                        }\n                    }\n                    const tTexts = cell.tTexts;\n                    //td.style.borderTopStyle = \"3px solid red\";\n                    if (tTexts != null) {\n                        tTexts.forEach((v) => {\n                            td.appendChild(v);\n                        });\n                    }\n                    else {\n                        const text = cell.text;\n                        if (typeof text == \"string\")\n                            td.innerHTML = text;\n                    }\n                    tr.appendChild(td);\n                }\n            }\n        }\n    }\n    return tableTag;\n}\nexports.createHTMLTable = createHTMLTable;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/html_table.ts?");

/***/ }),

/***/ "./src/options/index.ts":
/*!******************************!*\
  !*** ./src/options/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VBAObject = exports.processVBAButtonClickEvent = exports.stringify = exports.EditorHelper = exports.createMacroModalFromID = exports.SVGToVBA = exports.equalityCheck = exports.clearSVG = exports.createShape = exports.lazyOpenSVG = exports.openHTML = exports.openSVG = void 0;\nconst open_svg_1 = __webpack_require__(/*! ./open_svg */ \"./src/options/open_svg.ts\");\nObject.defineProperty(exports, \"openSVG\", ({ enumerable: true, get: function () { return open_svg_1.openSVG; } }));\nObject.defineProperty(exports, \"openHTML\", ({ enumerable: true, get: function () { return open_svg_1.openHTML; } }));\nObject.defineProperty(exports, \"lazyOpenSVG\", ({ enumerable: true, get: function () { return open_svg_1.lazyOpenSVG; } }));\nObject.defineProperty(exports, \"clearSVG\", ({ enumerable: true, get: function () { return open_svg_1.clearSVG; } }));\nconst create_g_object_1 = __webpack_require__(/*! ./create_g_object */ \"./src/options/create_g_object.ts\");\nObject.defineProperty(exports, \"createShape\", ({ enumerable: true, get: function () { return create_g_object_1.createGObject; } }));\nconst svg_equal_1 = __webpack_require__(/*! ./svg_equal */ \"./src/options/svg_equal.ts\");\nObject.defineProperty(exports, \"equalityCheck\", ({ enumerable: true, get: function () { return svg_equal_1.equalityCheck; } }));\nconst to_json_1 = __webpack_require__(/*! ./to_json */ \"./src/options/to_json.ts\");\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return to_json_1.stringify; } }));\n//import {convertFromIntermediateSVGGElementToZObject} from \"./custom_tag_processors/intermediate_g_tag_preprocessor\"\nconst svg_to_vba_1 = __webpack_require__(/*! ./svg_to_vba */ \"./src/options/svg_to_vba.ts\");\nObject.defineProperty(exports, \"SVGToVBA\", ({ enumerable: true, get: function () { return svg_to_vba_1.SVGToVBA; } }));\nconst VBAObject = __webpack_require__(/*! ./vba_object */ \"./src/options/vba_object.ts\");\nexports.VBAObject = VBAObject;\nconst vba_macro_modal_1 = __webpack_require__(/*! ./vba_macro_modal */ \"./src/options/vba_macro_modal.ts\");\nObject.defineProperty(exports, \"createMacroModalFromID\", ({ enumerable: true, get: function () { return vba_macro_modal_1.createMacroModalFromID; } }));\nObject.defineProperty(exports, \"processVBAButtonClickEvent\", ({ enumerable: true, get: function () { return vba_macro_modal_1.processVBAButtonClickEvent; } }));\nconst EditorHelper = __webpack_require__(/*! ./editor_helper */ \"./src/options/editor_helper.ts\");\nexports.EditorHelper = EditorHelper;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/index.ts?");

/***/ }),

/***/ "./src/options/open_svg.ts":
/*!*********************************!*\
  !*** ./src/options/open_svg.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.openHTML = exports.openSVG = exports.clearSVG = exports.lazyOpenSVG = exports.getGObjects = void 0;\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./src/common/attribute_names.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./src/html/html_functions.ts\");\nconst HTMLTable = __webpack_require__(/*! ./html_table */ \"./src/options/html_table.ts\");\nconst GUIObserver = __webpack_require__(/*! ../html/gui_observer */ \"./src/html/gui_observer.ts\");\nconst z_object_1 = __webpack_require__(/*! ../objects/z_object */ \"./src/objects/z_object.ts\");\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nconst vba_macro_modal_1 = __webpack_require__(/*! ./vba_macro_modal */ \"./src/options/vba_macro_modal.ts\");\nconst intermediate_g_tag_preprocessor_1 = __webpack_require__(/*! ./custom_tag_processors/intermediate_g_tag_preprocessor */ \"./src/options/custom_tag_processors/intermediate_g_tag_preprocessor.ts\");\nconst macro_tag_preprocessor_1 = __webpack_require__(/*! ./custom_tag_processors/macro_tag_preprocessor */ \"./src/options/custom_tag_processors/macro_tag_preprocessor.ts\");\n//export namespace openSVGFunctions {\n//}\nlet timerInterval = 100;\nfunction getGObjectsSub(item) {\n    const arr = new Array();\n    const opr = item.operator;\n    if (opr != undefined && opr instanceof z_object_1.ZObject) {\n        arr.push(opr);\n    }\n    else {\n        for (let i = 0; i < item.children.length; i++) {\n            const child = item.children.item(i);\n            if (child != null) {\n                getGObjectsSub(child).forEach((v) => { arr.push(v); });\n            }\n        }\n    }\n    return arr;\n}\nfunction getGObjects(elementID) {\n    const svg = document.getElementById(elementID);\n    if (svg == null) {\n        throw new exceptions_1.NullError();\n    }\n    else {\n        return getGObjectsSub(svg);\n    }\n}\nexports.getGObjects = getGObjects;\nfunction lazyOpenSVG() {\n    const p = document.getElementsByTagName(\"svg\");\n    const svgElements = [];\n    for (let i = 0; i < p.length; i++) {\n        const svgNode = p.item(i);\n        if (svgNode instanceof SVGSVGElement)\n            svgElements.push(svgNode);\n    }\n    svgElements.forEach((svgsvg) => lazyElementDic.push(svgsvg));\n    if (lazyElementDic.length > 0)\n        setTimeout(observelazyElementTimer, timerInterval);\n}\nexports.lazyOpenSVG = lazyOpenSVG;\nlet lazyElementDic = [];\nfunction observelazyElementTimer() {\n    for (let i = 0; i < lazyElementDic.length; i++) {\n        const element = lazyElementDic[i];\n        if (HTMLFunctions.isInsideElement(element)) {\n            openSVG(element);\n            lazyElementDic.splice(i, 1);\n            i = -1;\n        }\n    }\n    if (lazyElementDic.length > 0)\n        setTimeout(observelazyElementTimer, timerInterval);\n}\nfunction clearSVG(id) {\n    const box = document.getElementById(id);\n    box.innerHTML = \"\";\n}\nexports.clearSVG = clearSVG;\nfunction openSVG(inputItem = null, output = []) {\n    if (typeof inputItem == \"string\") {\n        const item = document.getElementById(inputItem);\n        if (item != null && item instanceof SVGSVGElement) {\n            return openSVG(item, output);\n        }\n        else {\n            return [];\n        }\n    }\n    else if (inputItem === null) {\n        const p = document.getElementsByTagName(\"svg\");\n        const svgElements = [];\n        for (let i = 0; i < p.length; i++) {\n            const svgNode = p.item(i);\n            if (svgNode instanceof SVGSVGElement)\n                svgElements.push(svgNode);\n        }\n        svgElements.forEach((svgsvg) => openSVG(svgsvg, output));\n        return output;\n    }\n    else if (inputItem instanceof SVGSVGElement) {\n        const svgsvg = inputItem;\n        (0, macro_tag_preprocessor_1.processMacroTag)(svgsvg);\n        const vbaAttr = svgsvg.getAttribute(enums_1.OriginalSVGSVGAttributes.VBAAttributeName);\n        if (vbaAttr != null && vbaAttr == \"true\") {\n            (0, vba_macro_modal_1.appendVBAButton)(svgsvg);\n        }\n        (0, intermediate_g_tag_preprocessor_1.convertFromZTagToIntermediateSVGGTag)(svgsvg);\n        const startTime = performance.now();\n        (0, intermediate_g_tag_preprocessor_1.processIntermediateSVGGElements)(svgsvg, output);\n        const endTime = performance.now();\n        const time = endTime - startTime;\n        GUIObserver.observeSVGSVG(svgsvg);\n    }\n    else {\n        throw Error(\"errror\");\n    }\n    return output;\n}\nexports.openSVG = openSVG;\nfunction toDivElement(e) {\n    //const type = e.nodeName == \"G-TABLE\" ? \"g-table\" : e.nodeName == \"ROW\" ? \"row\" : e.nodeName == \"CELL\" ? \"cell\" : e.nodeName == \"T\" ? \"t\" : null;\n    const type = e.nodeName.toLowerCase() == enums_1.ShapeObjectType.Table ? enums_1.ShapeObjectType.Table : e.nodeName.toLowerCase() == \"row\" ? \"row\" : e.nodeName.toLowerCase() == \"cell\" ? \"cell\" : null;\n    if (type == null) {\n        return null;\n    }\n    else {\n        const ns = document.createElement(\"div\");\n        ns.setAttribute(AttributeNames.customElement, type);\n        for (let i = 0; i < e.attributes.length; i++) {\n            const attr = e.attributes.item(i);\n            ns.setAttribute(attr.name, attr.value);\n        }\n        ns.innerHTML = e.innerHTML;\n        //HTMLFunctions.getChildren(e).forEach((v)=>ns.appendChild(v));\n        const p = e.parentElement;\n        if (p != null) {\n            p.insertBefore(ns, e);\n            e.remove();\n        }\n        const children = HTMLFunctions.getChildren(ns);\n        children.forEach((v) => toDivElement(v));\n        return ns;\n    }\n}\nfunction isSVGElement(e) {\n    if (e.parentElement == null) {\n        return false;\n    }\n    else {\n        if (e.parentElement instanceof SVGSVGElement) {\n            return true;\n        }\n        else {\n            return isSVGElement(e.parentElement);\n        }\n    }\n}\nfunction openHTML(id = null) {\n    if (id == null) {\n        const p = document.getElementsByTagName(enums_1.ShapeObjectType.Table);\n        const svgElements = [];\n        for (let i = 0; i < p.length; i++) {\n            const svgNode = p.item(i);\n            if (svgNode != null) {\n                if (!isSVGElement(svgNode) && svgNode instanceof HTMLElement)\n                    svgElements.push(svgNode);\n            }\n        }\n        svgElements.forEach((e) => openHTML(e));\n    }\n    else if (typeof (id) == \"string\") {\n        const e = document.getElementById(id);\n        if (e instanceof HTMLElement) {\n            openHTML(e);\n        }\n    }\n    else {\n        const newE = toDivElement(id);\n        if (newE != null) {\n            const table = HTMLTable.createHTMLTable(newE);\n            newE.insertAdjacentElement('beforebegin', table);\n            newE.remove();\n        }\n    }\n}\nexports.openHTML = openHTML;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/open_svg.ts?");

/***/ }),

/***/ "./src/options/svg_equal.ts":
/*!**********************************!*\
  !*** ./src/options/svg_equal.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.equalityCheck = void 0;\nconst exceptions_1 = __webpack_require__(/*! ../common/exceptions */ \"./src/common/exceptions.ts\");\nfunction attributesToSet(obj1, obj2) {\n    const set = new Set();\n    for (let i = 0; i < obj1.attributes.length; i++) {\n        const attr = obj1.attributes.item(i);\n        if (attr != null) {\n            set.add(attr.name);\n        }\n    }\n    for (let i = 0; i < obj2.attributes.length; i++) {\n        const attr = obj2.attributes.item(i);\n        if (attr != null) {\n            set.add(attr.name);\n        }\n    }\n    return set;\n}\nfunction equal_attributes(obj1, obj2, attributeSet) {\n    Array.from(attributeSet.values()).forEach((v) => {\n        const value1 = obj1.getAttribute(v);\n        const value2 = obj2.getAttribute(v);\n        if (v == \"href\" || v == \"xlink:href\") {\n        }\n        else {\n            if (value1 != value2) {\n                throw new Error(`${v}/${value1}/${value2}`);\n            }\n        }\n    });\n    return true;\n}\nfunction equal_html(obj1, obj2, checkAttributes) {\n    if (checkAttributes) {\n        const attrNames = attributesToSet(obj1, obj2);\n        equal_attributes(obj1, obj2, attrNames);\n    }\n    const childsize1 = obj1.children.length;\n    const childsize2 = obj2.children.length;\n    if (childsize1 == childsize2) {\n        for (let i = 0; i < childsize1; i++) {\n            const node1 = obj1.children.item(i);\n            const node2 = obj2.children.item(i);\n            const b = equal_html(node1, node2, true);\n        }\n    }\n    else {\n        throw new Error(\"Children Size Error\");\n    }\n    return true;\n}\n/*\nfunction equal_svgsvg(obj1: HTMLElement, obj2: HTMLElement) {\n    const childsize1 = obj1.children.length;\n    const childsize2 = obj2.children.length;\n    if(childsize1 == childsize2){\n        for(let i=0;i<childsize1;i++){\n            const node1 = obj1.children.item(i)!;\n            const node2 = obj1.children.item(i)!;\n            if(node1 instanceof HTMLElement && node2 instanceof HTMLElement){\n                const b = equal_html(node1, node2);\n            }else{\n                throw new Error();\n            }\n        }\n    }else{\n        throw new Error();\n    }\n}\n*/\nfunction equal(obj1_id, obj2_id) {\n    const obj1 = document.getElementById(obj1_id);\n    const obj2 = document.getElementById(obj2_id);\n    if (obj1 != null && obj2 != null) {\n        let errorFlag = false;\n        try {\n            equal_html(obj1, obj2, false);\n        }\n        catch (e) {\n            errorFlag = true;\n            obj2.style.backgroundColor = \"red\";\n            throw e;\n        }\n        if (!errorFlag) {\n            obj2.style.backgroundColor = \"yellow\";\n        }\n        return true;\n    }\n    else {\n        throw new exceptions_1.NullError(`${obj1_id} / ${obj2_id}`);\n    }\n}\nfunction equalityCheck(test_id, correct_id_firefox, correct_id_edge, correct_id_chrome) {\n    const userAgent = window.navigator.userAgent.toLowerCase();\n    let correct_id = null;\n    let browser = window.navigator.userAgent;\n    if (userAgent.indexOf('edge') != -1) {\n        correct_id = correct_id_edge;\n    }\n    else if (userAgent.indexOf('firefox') != -1) {\n        correct_id = correct_id_firefox;\n    }\n    else if (userAgent.indexOf('chrome') != -1) {\n        correct_id = correct_id_chrome;\n    }\n    else {\n    }\n    //console.log(`Browser: ${browser}`)\n    if (correct_id != null) {\n        equal(test_id, correct_id);\n        //console.log(`Check OK!: ${test_id} / ${correct_id}`)\n    }\n    else {\n        //console.log(`NULL`);\n    }\n}\nexports.equalityCheck = equalityCheck;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/svg_equal.ts?");

/***/ }),

/***/ "./src/options/svg_to_vba.ts":
/*!***********************************!*\
  !*** ./src/options/svg_to_vba.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SVGToVBA = void 0;\n//namespace GraphTableSVG {\nconst z_object_1 = __webpack_require__(/*! ../objects/z_object */ \"./src/objects/z_object.ts\");\nconst z_table_1 = __webpack_require__(/*! ../objects/z_table */ \"./src/objects/z_table.ts\");\nconst z_graph_1 = __webpack_require__(/*! ../objects/z_graph */ \"./src/objects/z_graph.ts\");\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./src/common/vba_functions.ts\");\nconst vba_object_1 = __webpack_require__(/*! ./vba_object */ \"./src/options/vba_object.ts\");\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./src/interfaces/element_extension.ts\");\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./src/interfaces/svg_text_extension.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nconst svg_element_extension_1 = __webpack_require__(/*! ../interfaces/svg_element_extension */ \"./src/interfaces/svg_element_extension.ts\");\nconst Parser = __webpack_require__(/*! svg-path-parser */ \"./node_modules/svg-path-parser/index.js\");\nclass SVGToVBA {\n    static convert(svgsvgID) {\n        if (svgsvgID instanceof SVGSVGElement) {\n            const types = (0, vba_object_1.collectVBAObjectTypes)(svgsvgID);\n            return this.create(types);\n        }\n        else {\n            const obj = document.getElementById(svgsvgID);\n            if (obj instanceof SVGSVGElement) {\n                return this.convert(obj);\n            }\n            else {\n                throw new ReferenceError(`${svgsvgID} is not the ID of an SVGSVGElement.`);\n            }\n        }\n    }\n    /**\n     * 入力要素をPowerpoint上で作成するVBAコードを作成します。\n     * @param items\n     */\n    static create(items) {\n        //const id = 0;\n        if (items instanceof Array) {\n            const count = (0, vba_object_1.countVBSObjectNum)(items);\n            const s = new Array(0);\n            s.push(`Sub create()`);\n            s.push(` Dim createdSlide As slide`);\n            s.push(` Set createdSlide = ActivePresentation.Slides.Add(1, ppLayoutBlank)`);\n            for (let i = 0; i < count; i++) {\n                s.push(`Call create${i}(createdSlide)`);\n            }\n            s.push(`MsgBox \"created\"`);\n            s.push(`End Sub`);\n            let id = 0;\n            for (let i = 0; i < items.length; i++) {\n                const item = items[i];\n                if (item instanceof z_table_1.ZTable) {\n                    //const lines = item.createVBACode2(id++, \"createdSlide\");\n                    const lines = item.createVBACode(id);\n                    lines.forEach((v) => s.push(v));\n                    id++;\n                }\n                else if (item instanceof z_graph_1.ZGraph) {\n                    const lines = item.createVBACode(id);\n                    lines.forEach((v) => s.push(v));\n                    id += item.VBAObjectNum;\n                }\n                else if (item instanceof z_object_1.ZObject) {\n                    const lines = item.createVBACode(id);\n                    lines.forEach((v) => s.push(v));\n                    id += item.VBAObjectNum;\n                }\n                else if ((0, vba_object_1.isVBACodableSVG)(item)) {\n                    //const lines = SVGToVBA.createVBACodeOfSVGPath(item, id++);\n                    const lines = SVGToVBA.createVBACodeOfSVGElement(item, id);\n                    lines.forEach((v) => s.push(v));\n                    id++;\n                }\n            }\n            s.push(SVGToVBA.cellFunctionCode);\n            const r = vba_functions_1.VBATranslateFunctions.joinLines(s);\n            return r;\n        }\n        else if (typeof (items) == \"string\") {\n            const id = items;\n            const obj = document.getElementById(id);\n            if (obj != null && obj.operator instanceof z_object_1.ZObject) {\n                return SVGToVBA.create([obj.operator]);\n            }\n            else {\n                throw new Error();\n            }\n        }\n        else {\n            return SVGToVBA.create([items]);\n        }\n    }\n    static createVBACodeOfSVGElement(obj, id) {\n        const lines = new Array(0);\n        const backGroundvisible = (0, svg_element_extension_1.getBackgroundVisible)(obj) ? \"msoTrue\" : \"msoFalse\";\n        lines.push(`Sub create${id}(createdSlide As slide)`);\n        lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n        if (obj instanceof SVGTextElement) {\n            const sub = [];\n            lines.push(` Dim txt As Shape`);\n            lines.push(` Set txt = shapes_.AddTextbox(msoTextOrientationHorizontal, ${SVGTextExtension.getX(obj)}, ${SVGTextExtension.getY(obj)}, 0, 0)`);\n            const fontSize = parseInt(ElementExtension.getPropertyStyleValueWithDefault(obj, \"font-size\", \"24\"));\n            const fontFamily = vba_functions_1.VBATranslateFunctions.ToVBAFont(ElementExtension.getPropertyStyleValueWithDefault(obj, \"font-family\", \"MS PGothic\"));\n            const fontBold = vba_functions_1.VBATranslateFunctions.ToFontBold(ElementExtension.getPropertyStyleValueWithDefault(obj, \"font-weight\", \"none\"));\n            lines.push([` Call EditTextFrame(txt.TextFrame, ${0}, ${0}, ${0}, ${0}, false, ppAutoSizeShapeToFitText)`]);\n            vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement(sub, obj, `txt.TextFrame.TextRange`);\n            sub.forEach((v) => lines.push(v[0]));\n            lines.push([` Call EditTextEffect(txt.TextEffect, ${fontSize}, \"${fontFamily}\")`]);\n        }\n        else {\n            const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA((0, svg_element_extension_1.getStrokeColor)(obj));\n            const strokeWidth = (0, svg_element_extension_1.getStrokeWidth)(obj);\n            const lineColorValue = (0, svg_element_extension_1.getStrokeColor)(obj);\n            const lineVisible = lineColorValue != \"none\" ? \"msoTrue\" : \"msoFalse\";\n            if (obj instanceof SVGPathElement || obj instanceof SVGLineElement || obj instanceof SVGPolylineElement || obj instanceof SVGPolygonElement) {\n                if (obj instanceof SVGPathElement) {\n                    const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA((0, svg_element_extension_1.getBackgroundColor)(obj));\n                    lines.push(` Dim builder As FreeformBuilder`);\n                    const length = obj.getTotalLength();\n                    let d = 0;\n                    let p = obj.getPointAtLength(d);\n                    lines.push(` Set builder = shapes_.BuildFreeform(msoEditingCorner, ${p.x}, ${p.y}) `);\n                    d += 10;\n                    while (d < length) {\n                        p = obj.getPointAtLength(d);\n                        lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                        d += 10;\n                    }\n                    d = length;\n                    p = obj.getPointAtLength(d);\n                    lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                    const commandAttr = obj.getAttribute(\"d\");\n                    let hasClosePath = false;\n                    if (commandAttr != null) {\n                        const commandList = Parser.parseSVG(commandAttr);\n                        commandList.forEach((v) => {\n                            if (v.code == \"Z\" || v.code == \"z\") {\n                                hasClosePath = true;\n                            }\n                        });\n                    }\n                    if (hasClosePath) {\n                        p = obj.getPointAtLength(0);\n                        lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                    }\n                    lines.push(` Dim obj As Shape`);\n                    lines.push(`Set obj = builder.ConvertToShape`);\n                    lines.push(` Call EditLine(obj.Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${lineVisible})`);\n                    lines.push(` Call EditCallOut(obj, \"${id}\", ${backGroundvisible}, ${backColor})`);\n                    /*\n                    const pos = Extensions.getPathLocations(obj);\n                    lines.push(` Dim edges${id}(${pos.length - 1}) As Shape`);\n    \n                    for (let i = 0; i < pos.length - 1; i++) {\n                        lines.push(` Set edges${id}(${i}) = shapes_.AddConnector(msoConnectorStraight, ${pos[i][0]}, ${pos[i][1]}, ${pos[i + 1][0]}, ${pos[i + 1][1]})`);\n                        lines.push(` Call EditLine(edges${id}(${i}).Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${visible})`);\n                    }\n                    */\n                }\n                else if (obj instanceof SVGPolylineElement) {\n                    lines.push(` Dim builder As FreeformBuilder`);\n                    const list = obj.points;\n                    let p = list.getItem(0);\n                    lines.push(` Set builder = shapes_.BuildFreeform(msoEditingCorner, ${p.x}, ${p.y}) `);\n                    for (let i = 0; i < list.length; i++) {\n                        p = list.getItem(i);\n                        lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                    }\n                    lines.push(` Dim obj As Shape`);\n                    lines.push(`Set obj = builder.ConvertToShape`);\n                    lines.push(` Call EditLine(obj.Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${lineVisible})`);\n                }\n                else if (obj instanceof SVGPolygonElement) {\n                    const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA((0, svg_element_extension_1.getBackgroundColor)(obj));\n                    lines.push(` Dim builder As FreeformBuilder`);\n                    const list = obj.points;\n                    let p = list.getItem(0);\n                    lines.push(` Set builder = shapes_.BuildFreeform(msoEditingCorner, ${p.x}, ${p.y}) `);\n                    for (let i = 0; i < list.length; i++) {\n                        p = list.getItem(i);\n                        lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                    }\n                    p = list.getItem(0);\n                    lines.push(`builder.AddNodes msoSegmentLine, msoEditingAuto, ${p.x}, ${p.y}`);\n                    lines.push(` Dim obj As Shape`);\n                    lines.push(`Set obj = builder.ConvertToShape`);\n                    lines.push(` Call EditLine(obj.Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${lineVisible})`);\n                    lines.push(` Call EditCallOut(obj, \"${id}\", ${backGroundvisible}, ${backColor})`);\n                }\n                else {\n                    const x1 = obj.x1.baseVal.value;\n                    const y1 = obj.y1.baseVal.value;\n                    const x2 = obj.x2.baseVal.value;\n                    const y2 = obj.y2.baseVal.value;\n                    lines.push(` Dim obj As Shape`);\n                    lines.push(` Set obj = shapes_.AddConnector(msoConnectorStraight, ${x1}, ${y1}, ${x2}, ${y2})`);\n                    lines.push(` Call EditLine(obj.Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${lineVisible})`);\n                }\n            }\n            else {\n                const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA((0, svg_element_extension_1.getBackgroundColor)(obj));\n                lines.push(` Dim obj As Shape`);\n                if (obj instanceof SVGRectElement) {\n                    const rx = obj.getAttribute(\"rx\") == null ? 0 : parseInt(obj.getAttribute(\"rx\"));\n                    const ry = obj.getAttribute(\"ry\") == null ? 0 : parseInt(obj.getAttribute(\"ry\"));\n                    const maxr = Math.max(rx, ry);\n                    const shape = maxr == 0 ? \"msoShapeRectangle\" : \"msoShapeRoundedRectangle\";\n                    const width = obj.width.baseVal.value;\n                    const height = obj.height.baseVal.value;\n                    const x = obj.x.baseVal.value;\n                    const y = obj.y.baseVal.value;\n                    lines.push(` Set obj = shapes_.AddShape(${shape}, ${x}, ${y}, ${width}, ${height})`);\n                    if (maxr > 0) {\n                        const ratio = maxr / width;\n                        lines.push(` obj.Adjustments.Item(1) = ${ratio}`);\n                    }\n                }\n                else if (obj instanceof SVGEllipseElement) {\n                    const shape = \"msoShapeOval\";\n                    const width = obj.rx.baseVal.value * 2;\n                    const height = obj.ry.baseVal.value * 2;\n                    const x = obj.cx.baseVal.value - obj.rx.baseVal.value;\n                    const y = obj.cy.baseVal.value - obj.ry.baseVal.value;\n                    lines.push(` Set obj = shapes_.AddShape(${shape}, ${x}, ${y}, ${width}, ${height})`);\n                }\n                else {\n                    const shape = \"msoShapeOval\";\n                    const width = obj.r.baseVal.value * 2;\n                    const height = obj.r.baseVal.value * 2;\n                    const x = obj.cx.baseVal.value - obj.r.baseVal.value;\n                    const y = obj.cy.baseVal.value - obj.r.baseVal.value;\n                    lines.push(` Set obj = shapes_.AddShape(${shape}, ${x}, ${y}, ${width}, ${height})`);\n                }\n                lines.push(` Call EditLine(obj.Line, ${lineColor}, ${enums_1.msoDashStyle.msoLineSolid}, ${0}, ${strokeWidth}, ${lineVisible})`);\n                lines.push(` Call EditCallOut(obj, \"${id}\", ${backGroundvisible}, ${backColor})`);\n            }\n        }\n        lines.push(`End Sub`);\n        return lines;\n    }\n}\nexports.SVGToVBA = SVGToVBA;\n/*\nprivate static createVBACodeOfSVGPath(path: SVGPathElement, id: number): string[] {\n    const lines = new Array(0);\n    const pos = Extensions.getPathLocations(path);\n    lines.push(`Sub create${id}(createdSlide As slide)`);\n    lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n    lines.push(` Dim edges${id}(${pos.length - 1}) As Shape`);\n\n\n    for (let i = 0; i < pos.length - 1; i++) {\n        lines.push(` Set edges${id}(${i}) = shapes_.AddConnector(msoConnectorStraight, ${pos[i][0]}, ${pos[i][1]}, ${pos[i + 1][0]}, ${pos[i + 1][1]})`);\n        const lineColor = VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(path, \"stroke\", \"gray\"));\n        const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(path,\"stroke-width\", \"4\"));\n        const visible = ElementExtension.getPropertyStyleValueWithDefault(path, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\n        lines.push(` Call EditLine(edges${id}(${i}).Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${visible})`);\n    }\n\n    lines.push(`End Sub`);\n    return lines;\n}\n*/\n/*\n private static createVBACodeOfTextElement(element: SVGTextElement, id: number): string[] {\n     const lines = new Array(0);\n     const sub: string[][] = [];\n     lines.push(`Sub create${id}(createdSlide As slide)`);\n     lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\n     lines.push(` Dim txt As Shape`);\n     lines.push(` Set txt = shapes_.AddTextbox(msoTextOrientationHorizontal, ${SVGTextExtension.getX(element)}, ${SVGTextExtension.getY(element)}, 0, 0)`);\n     const fontSize = parseInt(ElementExtension.getPropertyStyleValueWithDefault(element, \"font-size\", \"24\"));\n     const fontFamily = VBATranslateFunctions.ToVBAFont(ElementExtension.getPropertyStyleValueWithDefault(element,\"font-family\", \"MS PGothic\"));\n     const fontBold = VBATranslateFunctions.ToFontBold(ElementExtension.getPropertyStyleValueWithDefault(element, \"font-weight\", \"none\"));\n     lines.push([` Call EditTextFrame(txt.TextFrame, ${0}, ${0}, ${0}, ${0}, false, ppAutoSizeShapeToFitText)`]);\n     VBATranslateFunctions.TranslateSVGTextElement(sub, element, `txt.TextFrame.TextRange`);\n     sub.forEach((v) => lines.push(v[0]));\n     lines.push([` Call EditTextEffect(txt.TextEffect, ${fontSize}, \"${fontFamily}\")`]);\n\n\n     lines.push(`End Sub`);\n     return lines;\n }\n */\nSVGToVBA.cellFunctionCode = `\r\nSub EditTable(table_ As table, cellInfo_() As Variant)\r\n    Dim x As Integer\r\n    Dim y As Integer\r\n    \r\n    For x = 1 To UBound(cellInfo_, 1)\r\n        For y = 1 To UBound(cellInfo_, 2)\r\n         Call EditCell(table_.cell(x, y), CStr(cellInfo_(x, y)(0)))\r\n        Next\r\n    Next\r\nEnd Sub\r\n\r\nSub EditCell(cell_ As cell, text_ As String, backColor As Variant)\r\n    cell_.Shape.TextFrame.TextRange.text = text_\r\n    cell_.Shape.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\nSub EditCellFont(frame_ As TextFrame, fontSize As Double, fontName As String, color As Variant, fontBold As Integer)\r\n    frame_.TextRange.Font.Size = fontSize\r\n    frame_.TextRange.Font.name = fontName\r\n    frame_.TextRange.Font.color.RGB = RGB(CInt(color(0)), CInt(color(1)), CInt(color(2)))\r\n    frame_.TextRange.Font.Bold = fontBold\r\nEnd Sub\r\n\r\n\r\n\r\n\r\nSub EditRow(row_ As Row, height As Integer)\r\n    row_.height = height\r\nEnd Sub\r\nSub EditColumn(column_ As Column, width As Integer)\r\n    column_.width = width\r\nEnd Sub\r\n\r\nSub EditCellTextFrame(frame_ As TextFrame, marginTop As Double, marginBottom As Double, marginLeft As Double, marginRight As Double, vAnchor As Integer, hAnchor As Integer)\r\n    frame_.marginLeft = marginLeft\r\n    frame_.marginRight = marginRight\r\n    frame_.marginTop = marginTop\r\n    frame_.marginBottom = marginBottom\r\n    frame_.VerticalAnchor = vAnchor\r\n    frame_.TextRange.ParagraphFormat.Alignment = hAnchor\r\nEnd Sub\r\n\r\nSub EditTextRange(range_ As TextRange, text As String)\r\n    range_.text = text\r\nEnd Sub\r\nSub EditTextRangeSub(range_ As TextRange, subBeg As Integer, subLen As Integer, script As String, color As Variant, fontName As String, fontSize As Double, fontBold As Integer)\r\n    range_.Characters(subBeg, subLen).Font.color.RGB = RGB(CInt(color(0)), CInt(color(1)), CInt(color(2)))\r\n    range_.Characters(subBeg, subLen).Font.Size = fontSize\r\n    range_.Characters(subBeg, subLen).Font.name = fontName\r\n    range_.Characters(subBeg, subLen).Font.Bold = fontBold\r\n    If script = \"subscript\" Then\r\n    range_.Characters(subBeg, subLen).Font.Subscript = True\r\n    End If\r\n    If script = \"superscript\" Then\r\n    range_.Characters(subBeg, subLen).Font.Superscript = True\r\n    End If\r\nEnd Sub\r\n\r\n\r\n\r\nSub EditShape(shape_ As Shape, name As String, visible As Integer, backColor As Variant)\r\n    shape_.name = name\r\n    shape_.Fill.visible = visible\r\n    shape_.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\nSub EditCellBorder(line_ As LineFormat, foreColor As Variant, weight As Integer, transparent As Double)\r\n    line_.foreColor.RGB = RGB(CInt(foreColor(0)), CInt(foreColor(1)), CInt(foreColor(2)))\r\n    line_.weight = weight\r\n    line_.Transparency = transparent\r\nEnd Sub\r\n\r\nSub EditConnector(connector_ As ConnectorFormat, begShape As Shape, endShape As Shape, begPos As Integer, endPos As Integer)\r\n    Call connector_.BeginConnect(begShape, begPos)\r\n    Call connector_.EndConnect(endShape, endPos)\r\nEnd Sub\r\n\r\nSub EditTextFrame(frame_ As TextFrame, marginTop As Double, marginBottom As Double, marginLeft As Double, marginRight As Double, wordWrap As Boolean, autoSize As Integer)\r\n    frame_.autoSize = autoSize\r\n    frame_.wordWrap = wordWrap\r\n    frame_.marginLeft = marginLeft\r\n    frame_.marginRight = marginRight\r\n    frame_.marginTop = marginTop\r\n    frame_.marginBottom = marginBottom\r\nEnd Sub\r\nSub EditAnchor(frame_ As TextFrame, vAnchor As Integer, hAnchor As Integer)\r\n    frame_.VerticalAnchor = vAnchor\r\n    frame_.TextRange.ParagraphFormat.Alignment = hAnchor\r\nEnd Sub\r\n\r\nSub EditTextEffect(effect_ As TextEffectFormat, fontSize As Double, fontName As String)\r\n effect_.fontSize = fontSize\r\n effect_.fontName = fontName\r\nEnd Sub\r\n\r\nSub EditVertexShape(shape_ As Shape, name As String, visible As Integer, backColor As Variant)\r\n    shape_.name = name\r\n    shape_.Fill.visible = visible\r\n    shape_.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\n\r\nSub EditLine(line_ As LineFormat, foreColor As Variant, dashStyle As Integer, transparent As Double, weight As Integer, visible As Integer)\r\n    line_.foreColor.RGB = RGB(CInt(foreColor(0)), CInt(foreColor(1)), CInt(foreColor(2)))\r\n    line_.dashStyle = dashStyle\r\n    line_.Transparency = transparent\r\n    line_.weight = weight\r\n    line_.visible = visible\r\nEnd Sub\r\n\r\nSub EditCallOut(shape_ As Shape, name As String, visible As Integer, backColor As Variant)\r\n    shape_.name = name\r\n    shape_.Fill.visible = visible\r\n    shape_.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\n\r\n`;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/svg_to_vba.ts?");

/***/ }),

/***/ "./src/options/table_dictionary.ts":
/*!*****************************************!*\
  !*** ./src/options/table_dictionary.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TableDictionary = void 0;\n// tslint:disable-next-line: no-namespace\nconst logic_graph_1 = __webpack_require__(/*! ../logics/logic_graph */ \"./src/logics/logic_graph.ts\");\nconst logic_table_1 = __webpack_require__(/*! ../logics/logic_table */ \"./src/logics/logic_table.ts\");\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./src/common/default_class_names.ts\");\nconst logic_text_1 = __webpack_require__(/*! ../logics/logic_text */ \"./src/logics/logic_text.ts\");\nclass TableDictionary {\n    // columnValues: Map<string, (string|undefined)[]>= new Map();\n    // itemCount : number = 0;\n    constructor() {\n        this.columnMapper = new Map();\n        this.rows = new Array();\n        this.objects = new Array();\n        this.columnMapper.set(TableDictionary.IndexName, 0);\n        // this.columnValues.set(\"index\", []);\n    }\n    construct(item) {\n        if (item instanceof Array) {\n            item.forEach((v) => {\n                this.add(v);\n            });\n        }\n        else {\n            this.add(item);\n        }\n    }\n    addValue(i, key, value) {\n        const column = this.columnMapper.get(key);\n        if (column === undefined) {\n            this.columnMapper.set(key, this.columnMapper.size);\n        }\n        this.rows[i].set(key, value);\n    }\n    add(item) {\n        this.rows.push(new Map());\n        this.objects.push(item);\n        const x = this.rows.length - 1;\n        this.addValue(x, TableDictionary.IndexName, x.toString());\n        if (item instanceof Array) {\n            for (let i = 0; i < item.length; i++) {\n                const cell = item[i];\n                if (cell != undefined) {\n                    this.addValue(x, i.toString(), cell);\n                }\n            }\n        }\n        else {\n            if (typeof item === \"string\" || typeof item === \"number\" || typeof item === \"boolean\") {\n                this.addValue(x, TableDictionary.ValueName, item.toString());\n            }\n            else if (typeof item === \"object\") {\n                Object.keys(item).forEach((key) => {\n                    const value = item[key];\n                    this.addValue(x, key.toString(), value);\n                });\n            }\n        }\n    }\n    toLogicTable() {\n        const table = new logic_table_1.LogicTable({ columnCount: this.columnMapper.size, rowCount: this.rows.length + 1 });\n        this.columnMapper.forEach((value, key) => {\n            const logicText = new logic_text_1.LogicText();\n            logicText.class = DefaultClassNames.defaultConsoleColumnTitleCellTextClass;\n            //table.cells[0][value].textClass = DefaultClassNames.defaultConsoleColumnTitleCellTextClass;\n            table.cells[0][value].backgroundOption.class = DefaultClassNames.defaultConsoleColumnTitleCellBackgroundClass;\n            if (key == TableDictionary.IndexName) {\n                logicText.textContent = \"(index)\";\n            }\n            else if (key == TableDictionary.ValueName) {\n                logicText.textContent = \"(value)\";\n            }\n            else {\n                logicText.textContent = key;\n            }\n            table.cells[0][value].text = logicText;\n        });\n        this.rows.forEach((map, index) => {\n            const tableIndex = index + 1;\n            for (let i = 0; i < this.columnMapper.size; i++) {\n                table.cells[tableIndex][i].text.textContent = \"undefined\";\n                table.cells[tableIndex][i].text.textContent = DefaultClassNames.defaultConsoleColumnTitleCellUndefinedTextClass;\n            }\n            map.forEach((value, key) => {\n                const columnIndex = this.columnMapper.get(key);\n                if (columnIndex != undefined) {\n                    const cell = this.rows[index].get(key);\n                    if (cell == null) {\n                        table.cells[tableIndex][columnIndex].text.textContent = \"null\";\n                    }\n                    else if (cell != undefined) {\n                        table.cells[tableIndex][columnIndex].text.textContent = cell.toString();\n                        table.cells[tableIndex][columnIndex].text.class = DefaultClassNames.defaultTextClass;\n                    }\n                }\n            });\n        });\n        return table;\n    }\n    createNode(item, graph, dic) {\n        if (typeof item === \"object\") {\n            let node = dic.get(item);\n            if (node !== undefined) {\n                return node;\n            }\n            else {\n                node = graph.addNode();\n                if (item !== undefined && item != null) {\n                    dic.set(item, node);\n                    Object.keys(item).forEach((key) => {\n                        const value = item[key];\n                        const child = this.createNode(value, graph, dic);\n                        const edge = graph.createEdge();\n                        edge.endNodeIndex = graph.getIndex(child);\n                        edge.text = key.toString();\n                        node.addEdge(edge);\n                    });\n                }\n                else {\n                    node.text = \"null\";\n                }\n                return node;\n            }\n        }\n        else {\n            const node = graph.addNode();\n            if (typeof item === \"undefined\") {\n                node.text = \"undefined\";\n            }\n            else {\n                node.text = item.toString();\n            }\n            return node;\n        }\n    }\n    toLogicGraph() {\n        const dic = new Map();\n        const graph = new logic_graph_1.LogicGraph();\n        this.rows.forEach((v, i) => {\n            const obj = this.objects[i];\n            this.createNode(obj, graph, dic);\n        });\n        return graph;\n    }\n}\nexports.TableDictionary = TableDictionary;\nTableDictionary.IndexName = \"___GraphTableSVG_Console_Index\";\nTableDictionary.ValueName = \"___GraphTableSVG_Console_Value\";\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/table_dictionary.ts?");

/***/ }),

/***/ "./src/options/to_json.ts":
/*!********************************!*\
  !*** ./src/options/to_json.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringify = exports.isPrimitiveObject = exports.spacePadding = void 0;\nfunction spacePadding(len) {\n    let s = \"\";\n    for (let i = 0; i < len; i++) {\n        s += \" \";\n    }\n    return s;\n}\nexports.spacePadding = spacePadding;\nfunction isPrimitiveObject(item) {\n    if (item == null) {\n        return true;\n    }\n    else if (item instanceof Array) {\n        return item.every((v) => (typeof v === \"string\" || typeof v === \"number\" || typeof v === \"boolean\"));\n    }\n    else {\n        return Object.keys(item).every((key) => {\n            const value = item[key];\n            return (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\");\n        });\n    }\n}\nexports.isPrimitiveObject = isPrimitiveObject;\nfunction toStringLineArray(item, name, padding) {\n    const r = new Array();\n    if (item instanceof Array) {\n        if (isPrimitiveObject(item)) {\n            const center = item.map((v) => v.toString()).join(\", \");\n            const s = name == null ? `[ ${center} ]` : `${name} = [ ${center} ]`;\n            r.push(spacePadding(padding) + s);\n        }\n        else {\n            let left = name == null ? (spacePadding(padding) + \"[\") : (spacePadding(padding) + `${name} = [`);\n            r.push(left);\n            for (let i = 0; i < item.length; i++) {\n                const center = toStringLineArray(item[i], null, padding + 1);\n                center.forEach((v) => r.push(v));\n            }\n            let right = spacePadding(padding) + \"[\";\n            r.push(right);\n        }\n    }\n    else {\n        if (typeof item === \"string\" || typeof item === \"number\" || typeof item === \"boolean\") {\n            if (name == null) {\n                const s = spacePadding(padding) + item.toString();\n                r.push(s);\n            }\n            else {\n                const s = `${spacePadding(padding)}${name} = ${item.toString()}`;\n                r.push(s);\n            }\n        }\n        else if (item instanceof Map) {\n            const arr = [];\n            item.forEach((value, key) => {\n                arr.push({ \"key\": key, \"value\": value });\n            });\n            const center = toStringLineArray(arr, name, padding);\n            center.forEach((v) => r.push(v));\n        }\n        else if (typeof item === \"object\") {\n            if (isPrimitiveObject(item)) {\n                if (item == null) {\n                    const s = name == null ? `null` : `${name} = null`;\n                    r.push(spacePadding(padding) + s);\n                }\n                else {\n                    const center = Object.keys(item).map((key) => `${key} = ${(item[key]).toString()}`).join(\", \");\n                    const s = name == null ? `{ ${center} }` : `${name} = { ${center} }`;\n                    r.push(spacePadding(padding) + s);\n                }\n            }\n            else {\n                let left = name == null ? (spacePadding(padding) + \"{\") : (spacePadding(padding) + `${name} = {`);\n                r.push(left);\n                Object.keys(item).forEach((key) => {\n                    const value = item[key];\n                    const center = toStringLineArray(value, key.toString(), padding + 1);\n                    center.forEach((v) => r.push(v));\n                });\n                let right = spacePadding(padding) + \"}\";\n                r.push(right);\n            }\n        }\n    }\n    return r;\n}\nfunction stringify(item) {\n    const r = toStringLineArray(item, null, 0);\n    return r.join(\"\\n\");\n}\nexports.stringify = stringify;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/to_json.ts?");

/***/ }),

/***/ "./src/options/vba_macro_modal.ts":
/*!****************************************!*\
  !*** ./src/options/vba_macro_modal.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.copyAndCloseMacroModal = exports.removeMacroModal = exports.createMacroModal = exports.createMacroModalFromID = exports.showMacroModal = exports.appendVBAButton = exports.processVBAButtonClickEvent = void 0;\n//namespace GraphTableSVG {\n//import { Padding, Rectangle } from \"../common/vline\";\nconst svg_to_vba_1 = __webpack_require__(/*! ./svg_to_vba */ \"./src/options/svg_to_vba.ts\");\nconst z_object_1 = __webpack_require__(/*! ../objects/z_object */ \"./src/objects/z_object.ts\");\nconst open_svg_1 = __webpack_require__(/*! ./open_svg */ \"./src/options/open_svg.ts\");\nconst vba_object_1 = __webpack_require__(/*! ./vba_object */ \"./src/options/vba_object.ts\");\nconst svg_1 = __webpack_require__(/*! ../interfaces/svg */ \"./src/interfaces/svg.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\n//export namespace VBAMacroModal {\nfunction processVBAButtonClickEvent(e) {\n    const target = e.target;\n    if (target instanceof SVGElement) {\n        const svgsvg = (0, svg_1.getSVGSVG)(target);\n        const types = (0, vba_object_1.collectVBAObjectTypes)(svgsvg);\n        const vbaCode = svg_to_vba_1.SVGToVBA.create(types);\n        createMacroModal(vbaCode);\n    }\n    else {\n        alert(\"Error!\");\n    }\n}\nexports.processVBAButtonClickEvent = processVBAButtonClickEvent;\nfunction appendVBAButton(svgsvg) {\n    const p = document.createElementNS('http://www.w3.org/2000/svg', enums_1.ShapeObjectType.RectButton);\n    p.textContent = \"VBA\";\n    const rect = svgsvg.getBoundingClientRect();\n    p.setAttribute(\"x\", (rect.width - 100).toString());\n    p.setAttribute(\"y\", (rect.height - 50).toString());\n    p.setAttribute(\"data-vba\", \"false\");\n    p.setAttribute(\"onclick\", `GraphTableSVG.Options.processVBAButtonClickEvent(event)`);\n    svgsvg.appendChild(p);\n}\nexports.appendVBAButton = appendVBAButton;\nfunction showMacroModal(id) {\n    if (id instanceof z_object_1.ZObject) {\n        const p = svg_to_vba_1.SVGToVBA.create(id);\n        createMacroModal(p);\n    }\n    else {\n    }\n}\nexports.showMacroModal = showMacroModal;\nfunction createMacroModalFromID(id) {\n    const objects = (0, open_svg_1.getGObjects)(id);\n    const code = svg_to_vba_1.SVGToVBA.create(objects);\n    return createMacroModal(code);\n}\nexports.createMacroModalFromID = createMacroModalFromID;\n/**\n * マクロ用のモーダルを画面に生成します。\n * @param vbaCode モーダルに表示する貼り付けるVBAマクロ\n */\nfunction createMacroModal(vbaCode) {\n    if (vbaCode instanceof z_object_1.ZObject) {\n        const p = svg_to_vba_1.SVGToVBA.create(vbaCode);\n        createMacroModal(p);\n    }\n    else {\n        const mainDiv = document.createElement(\"div\");\n        mainDiv.id = \"macro-modal\";\n        mainDiv.innerHTML = `\r\n使い方（Powerpoint 2013）<br>\r\n    新規ファイル<br>\r\n    →表示→マクロ→作成<br>\r\n    →生成したコードをユーザーフォームに貼り付ける<br>\r\n    →F5 or ユーザーフォームを実行<br>\r\n    →木が貼られたスライドが１ページ目に挿入される<br>\r\n    ※サイズの大きすぎるSVGはマクロ実行時にエラーが出ます。\r\n    <br>\r\n    <textarea id=\"codeBox\" rows=\"8\" cols=\"100\" style=\"overflow:auto;\"></textarea>\r\n`;\n        const button = document.createElement(\"button\");\n        button.setAttribute(\"class\", \"btn\");\n        button.textContent = \"クリップボードにコピー\";\n        button.onclick = () => {\n            copyAndCloseMacroModal();\n        };\n        mainDiv.appendChild(button);\n        mainDiv.style.position = \"fixed\";\n        mainDiv.style.zIndex = \"16\";\n        mainDiv.style.width = \"900px\";\n        mainDiv.style.height = \"400px\";\n        mainDiv.style.left = `${((window.outerWidth - parseInt(mainDiv.style.width)) / 2)}px`;\n        //mainDiv.style.top = `${((window.outerHeight - parseInt(mainDiv.style.height)) / 2)}px`;\n        mainDiv.style.top = `${((window.outerHeight - parseInt(mainDiv.style.height)) / 16)}px`;\n        mainDiv.style.display = \"inline\";\n        mainDiv.style.backgroundColor = \"#ffffff\";\n        document.body.appendChild(mainDiv);\n        const cnt = document.getElementById(\"codeBox\");\n        cnt.value = vbaCode;\n        const bgDiv = document.createElement(\"div\");\n        document.body.appendChild(bgDiv);\n        bgDiv.style.width = \"100%\";\n        bgDiv.style.height = \"100%\";\n        bgDiv.style.backgroundColor = \"rgba(0,0,0,0.5)\";\n        bgDiv.style.position = \"fixed\";\n        bgDiv.style.top = \"0\";\n        bgDiv.style.left = \"0\";\n        bgDiv.id = \"modal-bg\";\n        bgDiv.style.zIndex = \"5\";\n        bgDiv.style.display = \"inline\";\n        bgDiv.onclick = removeMacroModal;\n        //$(\"body\").append('<div id=\"modal-bg\" style=\"z-index:5\"></div>');\n    }\n}\nexports.createMacroModal = createMacroModal;\n/**\n * マクロ用モーダルを取り除きます。\n */\nfunction removeMacroModal() {\n    const div1 = document.getElementById(\"macro-modal\");\n    const div2 = document.getElementById(\"modal-bg\");\n    if (div1 != null)\n        document.body.removeChild(div1);\n    if (div2 != null)\n        document.body.removeChild(div2);\n}\nexports.removeMacroModal = removeMacroModal;\n/**\n * マクロ用モーダルのテキストをクリップボードにコピーしてマクロ用モーダルを取り除きます。\n */\nfunction copyAndCloseMacroModal() {\n    const cnt = document.getElementById(\"codeBox\");\n    cnt.select();\n    window.document.execCommand('copy');\n    alert('クリップボードにコピーしました。');\n    removeMacroModal();\n}\nexports.copyAndCloseMacroModal = copyAndCloseMacroModal;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/vba_macro_modal.ts?");

/***/ }),

/***/ "./src/options/vba_object.ts":
/*!***********************************!*\
  !*** ./src/options/vba_object.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clearGraphTables = exports.getRegion = exports.isVBAObject = exports.isVBACodableSVG = exports.collectVBAObjectTypes = exports.countVBSObjectNum = void 0;\n//namespace GraphTableSVG {\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./src/common/vline.ts\");\nconst z_graph_1 = __webpack_require__(/*! ../objects/z_graph */ \"./src/objects/z_graph.ts\");\nconst z_table_1 = __webpack_require__(/*! ../objects/z_table */ \"./src/objects/z_table.ts\");\nconst z_object_1 = __webpack_require__(/*! ../objects/z_object */ \"./src/objects/z_object.ts\");\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./src/common/enums.ts\");\nfunction collectVBAObjectTypesSub(svg, output) {\n    const dataVBA = svg.getAttribute(\"data-vba\");\n    if (dataVBA == \"false\") {\n        return;\n    }\n    if (svg instanceof SVGGElement) {\n        const dataType = svg.getAttribute(\"data-type\");\n        if (dataType == null) {\n            for (let i = 0; i < svg.children.length; i++) {\n                const item = svg.children.item(i);\n                if (item != null && item instanceof SVGElement) {\n                    collectVBAObjectTypesSub(item, output);\n                }\n            }\n        }\n        else {\n            const type = enums_1.ShapeObjectType.toShapeObjectType(dataType);\n            if (type != null) {\n                const gObject = svg.operator;\n                output.push(gObject);\n            }\n        }\n    }\n    else if (isVBAObject(svg)) {\n        output.push(svg);\n    }\n    else {\n    }\n}\nfunction countVBSObjectNum(items) {\n    //const id = 0;\n    if (items instanceof Array) {\n        let c = 0;\n        for (let i = 0; i < items.length; i++) {\n            const item = items[i];\n            if (item instanceof z_table_1.ZTable) {\n                c++;\n            }\n            else if (item instanceof z_graph_1.ZGraph) {\n                c += item.VBAObjectNum;\n            }\n            else if (item instanceof z_object_1.ZObject) {\n                c += item.VBAObjectNum;\n            }\n            else {\n                c++;\n            }\n        }\n        return c;\n    }\n    else {\n        return countVBSObjectNum([items]);\n    }\n}\nexports.countVBSObjectNum = countVBSObjectNum;\nfunction collectVBAObjectTypes(svgsvg) {\n    const r = new Array();\n    for (let i = 0; i < svgsvg.children.length; i++) {\n        const item = svgsvg.children.item(i);\n        if (item != null && item instanceof SVGElement) {\n            collectVBAObjectTypesSub(item, r);\n        }\n    }\n    return r;\n}\nexports.collectVBAObjectTypes = collectVBAObjectTypes;\nfunction isVBACodableSVG(svg) {\n    if (svg instanceof SVGPathElement || svg instanceof SVGTextElement ||\n        svg instanceof SVGRectElement || svg instanceof SVGCircleElement || svg instanceof SVGEllipseElement ||\n        svg instanceof SVGLineElement || svg instanceof SVGPolylineElement || svg instanceof SVGPolygonElement) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexports.isVBACodableSVG = isVBACodableSVG;\nfunction isVBAObject(svg) {\n    if (svg instanceof SVGGElement) {\n        const dataType = svg.getAttribute(\"data-type\");\n        if (dataType == null) {\n            return false;\n        }\n        else {\n            const type = enums_1.ShapeObjectType.toShapeObjectType(dataType);\n            if (type != null) {\n                return true;\n            }\n        }\n    }\n    else if (isVBACodableSVG(svg)) {\n        return true;\n    }\n    return false;\n}\nexports.isVBAObject = isVBAObject;\n//export namespace VBAObject{\n/**\n * 領域を取得します。\n * @param items\n */\nfunction getRegion(items) {\n    const rects = items.map((v) => {\n        if (v instanceof z_object_1.ZObject) {\n            return v.getRegion();\n        }\n        else if (v instanceof SVGPathElement || v instanceof SVGTextElement) {\n            const rect = v.getBBox();\n            return new vline_1.Rectangle(rect.x, rect.y, rect.width, rect.height);\n        }\n        else {\n            return new vline_1.Rectangle();\n        }\n    });\n    if (rects.length > 0) {\n        return vline_1.Rectangle.merge(rects);\n    }\n    else {\n        return new vline_1.Rectangle();\n    }\n}\nexports.getRegion = getRegion;\n/**\n * グラフや表を消去します。\n * @param svg\n * @param items\n */\nfunction clearGraphTables(svg, items) {\n    for (let i = 0; i < items.length; i++) {\n        var item = items[i];\n        if (item instanceof z_graph_1.ZGraph) {\n            item.removeGraph(svg);\n        }\n        else if (item instanceof z_table_1.ZTable) {\n            item.removeTable(svg);\n        }\n    }\n}\nexports.clearGraphTables = clearGraphTables;\n//}\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/options/vba_object.ts?");

/***/ }),

/***/ "./src/typedoc/index.ts":
/*!******************************!*\
  !*** ./src/typedoc/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hello = void 0;\nfunction hello() {\n    console.log(\"hello\");\n}\nexports.hello = hello;\n\n\n//# sourceURL=webpack://GraphTableSVG/./src/typedoc/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	GraphTableSVG = __webpack_exports__;
/******/ 	
/******/ })()
;